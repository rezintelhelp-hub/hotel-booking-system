// Force rebuild - Jan 14 2026
// GAS - Guest Accommodation System Server
// Multi-tenant SaaS for property management
// 
// SYNC SYSTEM v2.1:
// - Property-level sync controls (Prices, Images, Content)
// - 12+ month availability window (365-540 days)
// - Rate limited to 1 sync per hour per property per type
// - Background tiered sync for automatic updates
require('dotenv').config();
const express = require('express');
const axios = require('axios');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { Pool } = require('pg');

// Image processing dependencies
const multer = require('multer');
const sharp = require('sharp');
const { S3Client, PutObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const { v4: uuidv4 } = require('uuid');

// Stripe for payment processing
const Stripe = require('stripe');
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// Google APIs for Analytics & Search Console
const { google } = require('googleapis');
let googleAuth = null;
let searchConsole = null;
let analyticsAdmin = null;
let analyticsData = null;

// Helper: extract plain string from a value that might be a multilingual object {"en":"..."} or a plain string
// Used whenever frontend sends multilingual data to a VARCHAR column
function mlStr(value) {
  if (!value) return value;
  if (typeof value === 'string') return value;
  if (typeof value === 'object' && value !== null) {
    return value.en || value.fr || value.es || value.de || value.nl || value.ja || Object.values(value)[0] || '';
  }
  return String(value);
}

// Initialize Google Auth from service account
function initGoogleAuth() {
  try {
    const serviceAccountJson = process.env.GOOGLE_SERVICE_ACCOUNT;
    if (!serviceAccountJson) {
      console.log('‚ÑπÔ∏è  GOOGLE_SERVICE_ACCOUNT not configured - Google APIs disabled');
      return false;
    }
    
    const credentials = JSON.parse(serviceAccountJson);
    googleAuth = new google.auth.GoogleAuth({
      credentials,
      scopes: [
        'https://www.googleapis.com/auth/webmasters',
        'https://www.googleapis.com/auth/analytics.readonly',
        'https://www.googleapis.com/auth/analytics.edit'
      ]
    });
    
    searchConsole = google.searchconsole({ version: 'v1', auth: googleAuth });
    analyticsAdmin = google.analyticsadmin({ version: 'v1beta', auth: googleAuth });
    analyticsData = google.analyticsdata({ version: 'v1beta', auth: googleAuth });
    
    console.log('‚úÖ Google APIs initialized successfully');
    return true;
  } catch (error) {
    console.error('‚ùå Failed to initialize Google APIs:', error.message);
    return false;
  }
}

// Initialize on startup
initGoogleAuth();

// GasSync - Channel Manager Integration Layer
let getAdapter, getAvailableAdapters, getAdapterInfo, getAdapterGroups, SyncManager;
try {
  const gasSyncModule = require('./gas-sync/adapters');
  getAdapter = gasSyncModule.getAdapter;
  getAvailableAdapters = gasSyncModule.getAvailableAdapters;
  getAdapterInfo = gasSyncModule.getAdapterInfo;
  getAdapterGroups = gasSyncModule.getAdapterGroups;
  SyncManager = gasSyncModule.SyncManager;
  console.log('‚úÖ GasSync adapters loaded successfully');
} catch (gasSyncError) {
  console.error('‚ùå Failed to load GasSync adapters:', gasSyncError.message);
  // Provide fallback implementations
  getAdapter = () => { throw new Error('GasSync not loaded'); };
  getAvailableAdapters = () => ['beds24', 'calry', 'hostaway', 'smoobu'];
  getAdapterInfo = (code) => ({
    code,
    name: code.charAt(0).toUpperCase() + code.slice(1),
    capabilities: ['properties', 'reservations', 'availability']
  });
  getAdapterGroups = () => ({
    direct: [
      { code: 'beds24', name: 'Beds24', description: 'PMS + Channel Manager' },
      { code: 'calry', name: 'Calry', description: 'Unified API' },
      { code: 'hostaway', name: 'Hostaway', description: 'Vacation Rental Software' },
      { code: 'smoobu', name: 'Smoobu', description: 'Channel Manager' },
      { code: 'hostfully', name: 'Hostfully', description: 'Property Management Platform' },
      { code: 'lodgify', name: 'Lodgify', description: 'Vacation Rental Software' },
      { code: 'other', name: 'Other / Not Listed', description: 'Request integration' }
    ],
    viaCalry: []
  });
  SyncManager = class { constructor() {} };
}

// Email configuration - Mailgun
const MAILGUN_API_KEY = process.env.MAILGUN_API_KEY;
const MAILGUN_DOMAIN = process.env.MAILGUN_DOMAIN || 'mg.gas.travel';
const EMAIL_FROM = process.env.EMAIL_FROM || 'bookings@mg.gas.travel';

// Calry API configuration
const CALRY_API_TOKEN = process.env.CALRY_API_TOKEN;
const CALRY_WORKSPACE_ID = process.env.CALRY_WORKSPACE_ID;
const CALRY_API_BASE = 'https://prod.calry.app/api/v2/vrs';

// Calry Integration Account IDs - maps PMS name to their Calry integration ID
const CALRY_INTEGRATION_IDS = {
  'fantastic_stay': 'c475f29c-cbb0-4266-a9f0-d65b41e186ab',
  'apaleo': '520e2d7a-ae33-4d29-8ede-6521579cdc27',
  'avaibook': 'a8d5719c-9317-4b38-8771-6bcf4a829827',
  'avantio': '89d0d70d-1ba7-489e-bb93-5249eaf165cb',
  'beds24': 'b4010939-f85c-4a7e-ae01-a21a516878d8',
  'bookingsync': 'f2d800c7-269c-41a8-b520-f255b6a127d6',
  'cloudbeds': '8c438104-f636-40a9-b49f-af2810b64aae',
  'direct': '8bc944e7-cddd-4806-8b38-112355c59a58',
  'elina': '0f1236ba-6f5c-407c-87a5-94082392a2d4',
  'escapia': '61458422-9599-4061-8ecb-a794c6dae62b',
  'guestwisely': 'ee775ed1-3e34-4029-b9fd-858144c97464',
  'guesty': 'd403dcaa-a50e-411b-8aac-6137b22d81c5',
  'hospitable': '19cc30f0-f245-412c-aca5-f6d8e0da7088',
  'hosttools': '76abdaee-cadf-497d-9885-e507afa06fed',
  'hostaway': '1b523646-ca1d-4ecc-a942-90a3e667dad8',
  'hostex': '67498bb1-2d63-4c28-b972-b56ee1dc8ec2',
  'hostfully': 'c01768cb-26b4-4817-99ca-99f9bc53117a',
  'hostify': '502e5eea-ebc5-4d73-b434-3d8b5b14b24e',
  'lodgify': '5f9f15ae-ae8f-4cd3-8822-993ca59bf142',
  'mews': 'f34f1e78-7f18-4b2a-9ef2-20a6505d14d7',
  'ownerrez': 'd8c7cf66-e299-4bee-b2cb-773a73b0dbe5',
  'rentalwise': 'b34aa1c6-6423-4a05-aa08-1b84ce248841',
  'resly': '5c75a17d-ca5d-4c56-839a-b2ae5fa47b21',
  'rms': 'ccb540e8-385f-41c0-a95e-08c148deac58',
  'smoobu': '468a377c-ba36-4534-95a3-ca4d21890c80',
  'streamline': 'ed4b9227-03b2-4a3f-81f4-5971187c2d90',
  'tokeet': 'a189a99e-9ae1-4393-8852-41de62770a95',
  'track': 'b280a5fe-6a84-4db7-8947-e4ada72b79b3',
  'uplisting': '8fec689e-5590-43cc-b193-74c3b2bb25c6',
  'your_rentals': '15227a83-01f2-4e83-9ffd-0e402f6211e6',
  'zeevou': '0b414fc5-7bf5-4438-a6d9-3d655fa2189f'
};

// Send email via Mailgun API
async function sendEmail({ to, subject, html, from = EMAIL_FROM }) {
  if (!MAILGUN_API_KEY) {
    console.log('‚ö†Ô∏è Email not sent - MAILGUN_API_KEY not configured');
    return { success: false, error: 'Email not configured' };
  }
  
  try {
    const formData = new URLSearchParams();
    formData.append('from', from);
    formData.append('to', Array.isArray(to) ? to.join(',') : to);
    formData.append('subject', subject);
    formData.append('html', html);
    
    const response = await axios.post(
      `https://api.mailgun.net/v3/${MAILGUN_DOMAIN}/messages`,
      formData.toString(),
      {
        auth: {
          username: 'api',
          password: MAILGUN_API_KEY
        },
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );
    
    console.log('‚úÖ Email sent to:', to);
    return { success: true, id: response.data?.id };
  } catch (error) {
    console.error('‚ùå Email error:', error.response?.data || error.message);
    return { success: false, error: error.message };
  }
}

// Generate booking confirmation email HTML
function generateBookingConfirmationEmail(booking, property, room) {
  const formatDate = (dateStr) => {
    const d = new Date(dateStr);
    return d.toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
  };
  
  const depositPaid = booking.deposit_amount && parseFloat(booking.deposit_amount) > 0;
  const balanceDue = booking.balance_amount && parseFloat(booking.balance_amount) > 0;
  
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Booking Confirmation</title>
</head>
<body style="margin: 0; padding: 0; background-color: #f4f4f5; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f4f4f5; padding: 40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td style="background: linear-gradient(135deg, #10b981, #059669); padding: 40px; text-align: center;">
              <div style="width: 60px; height: 60px; background: white; border-radius: 50%; margin: 0 auto 16px; line-height: 60px; font-size: 30px;">‚úì</div>
              <h1 style="color: white; margin: 0; font-size: 28px; font-weight: 700;">Booking Confirmed!</h1>
              <p style="color: rgba(255,255,255,0.9); margin: 8px 0 0; font-size: 16px;">Thank you for your reservation</p>
            </td>
          </tr>
          
          <!-- Booking Reference -->
          <tr>
            <td style="padding: 32px 40px 0;">
              <table width="100%" style="background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; padding: 20px; text-align: center;">
                <tr>
                  <td>
                    <span style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #059669;">Booking Reference</span>
                    <div style="font-size: 28px; font-weight: 700; color: #047857; margin-top: 4px;">${booking.id}</div>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
          
          <!-- Property Details -->
          <tr>
            <td style="padding: 32px 40px 0; text-align: center;">
              <h2 style="margin: 0 0 4px; font-size: 20px; color: #1e293b;">${property?.name || 'Property'}</h2>
              <p style="margin: 0; color: #64748b; font-size: 14px;">${room?.name || 'Room'}</p>
            </td>
          </tr>
          
          <!-- Dates -->
          <tr>
            <td style="padding: 32px 40px;">
              <table width="100%" cellpadding="0" cellspacing="0">
                <tr>
                  <td width="45%" style="text-align: center; padding: 16px; background: #f8fafc; border-radius: 8px;">
                    <span style="font-size: 11px; text-transform: uppercase; color: #94a3b8; display: block;">Check-in</span>
                    <strong style="font-size: 14px; color: #1e293b; display: block; margin: 4px 0;">${formatDate(booking.arrival_date)}</strong>
                    <span style="font-size: 12px; color: #64748b;">From 3:00 PM</span>
                  </td>
                  <td width="10%" style="text-align: center; color: #cbd5e1; font-size: 20px;">‚Üí</td>
                  <td width="45%" style="text-align: center; padding: 16px; background: #f8fafc; border-radius: 8px;">
                    <span style="font-size: 11px; text-transform: uppercase; color: #94a3b8; display: block;">Check-out</span>
                    <strong style="font-size: 14px; color: #1e293b; display: block; margin: 4px 0;">${formatDate(booking.departure_date)}</strong>
                    <span style="font-size: 12px; color: #64748b;">By 11:00 AM</span>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
          
          <!-- Guest Info -->
          <tr>
            <td style="padding: 0 40px 24px; text-align: center;">
              <span style="font-size: 14px; color: #475569;">üë§ ${booking.num_adults} ${booking.num_adults === 1 ? 'Guest' : 'Guests'}</span>
            </td>
          </tr>
          
          <!-- Divider -->
          <tr>
            <td style="padding: 0 40px;">
              <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 0;">
            </td>
          </tr>
          
          <!-- Pricing -->
          <tr>
            <td style="padding: 24px 40px;">
              <table width="100%" cellpadding="0" cellspacing="0">
                <tr>
                  <td style="padding: 8px 0; font-size: 16px; font-weight: 600; color: #1e293b;">Total</td>
                  <td style="padding: 8px 0; font-size: 16px; font-weight: 600; color: #1e293b; text-align: right;">${booking.currency || '$'}${parseFloat(booking.grand_total || 0).toFixed(2)}</td>
                </tr>
                ${depositPaid ? `
                <tr>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569;">Deposit Paid</td>
                  <td style="padding: 8px 0; font-size: 14px; color: #10b981; text-align: right; font-weight: 500;">‚úì ${booking.currency || '$'}${parseFloat(booking.deposit_amount).toFixed(2)}</td>
                </tr>
                ` : ''}
                ${balanceDue ? `
                <tr>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569;">Balance Due at Check-in</td>
                  <td style="padding: 8px 0; font-size: 14px; color: #f59e0b; text-align: right; font-weight: 500;">${booking.currency || '$'}${parseFloat(booking.balance_amount).toFixed(2)}</td>
                </tr>
                ` : ''}
                ${!depositPaid ? `
                <tr>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569;">Payment</td>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569; text-align: right;">Pay at Property</td>
                </tr>
                ` : ''}
              </table>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="background: #f8fafc; padding: 24px 40px; text-align: center; border-top: 1px solid #e2e8f0;">
              <p style="margin: 0 0 8px; font-size: 14px; color: #64748b;">Questions about your booking?</p>
              <p style="margin: 0; font-size: 14px; color: #64748b;">Contact us at <a href="mailto:${property?.email || EMAIL_FROM}" style="color: #10b981;">${property?.email || EMAIL_FROM}</a></p>
            </td>
          </tr>
        </table>
        
        <!-- Unsubscribe -->
        <p style="text-align: center; margin-top: 24px; font-size: 12px; color: #94a3b8;">
          This is a transactional email regarding your booking.
        </p>
      </td>
    </tr>
  </table>
</body>
</html>
  `;
}

// Generate group booking confirmation email
function generateGroupBookingConfirmationEmail(groupBookingId, bookings, rooms, property, guestInfo, totals) {
  const formatDate = (dateStr) => {
    const d = new Date(dateStr);
    return d.toLocaleDateString('en-GB', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' });
  };
  
  const depositPaid = totals.depositAmount && parseFloat(totals.depositAmount) > 0;
  const balanceDue = totals.balanceAmount && parseFloat(totals.balanceAmount) > 0;
  const currency = totals.currency || '$';
  
  // Build rooms HTML
  let roomsHtml = '';
  rooms.forEach((room, index) => {
    const booking = bookings[index];
    const roomPrice = booking?.accommodation_price || room.price || 0;
    roomsHtml += `
      <tr>
        <td style="padding: 12px 16px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; margin-bottom: 8px;">
          <table width="100%" cellpadding="0" cellspacing="0">
            <tr>
              <td>
                <strong style="font-size: 14px; color: #1e293b;">${room.name || 'Room'}</strong>
                <div style="font-size: 13px; color: #64748b;">${room.guests || 1} guest${(room.guests || 1) > 1 ? 's' : ''}</div>
              </td>
              <td style="text-align: right;">
                <strong style="font-size: 14px; color: #047857;">${currency}${parseFloat(roomPrice).toFixed(2)}</strong>
              </td>
            </tr>
          </table>
        </td>
      </tr>
      <tr><td style="height: 8px;"></td></tr>
    `;
  });
  
  // Build extras HTML if any
  let extrasHtml = '';
  if (totals.upsells && totals.upsells.length > 0) {
    extrasHtml = `
      <tr>
        <td style="padding: 16px 0 8px; font-size: 14px; font-weight: 600; color: #1e293b; text-align: center;">Extras</td>
      </tr>
    `;
    totals.upsells.forEach(upsell => {
      extrasHtml += `
        <tr>
          <td style="padding: 10px 16px; background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px;">
            <table width="100%" cellpadding="0" cellspacing="0">
              <tr>
                <td style="font-size: 14px; color: #92400e;">${upsell.name}</td>
                <td style="text-align: right; font-size: 14px; font-weight: 600; color: #b45309;">${currency}${parseFloat(upsell.price).toFixed(2)}</td>
              </tr>
            </table>
          </td>
        </tr>
        <tr><td style="height: 8px;"></td></tr>
      `;
    });
  }
  
  const totalGuests = rooms.reduce((sum, r) => sum + (parseInt(r.guests) || 1), 0);
  
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Group Booking Confirmation</title>
</head>
<body style="margin: 0; padding: 0; background-color: #f4f4f5; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f4f4f5; padding: 40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td style="background: linear-gradient(135deg, #10b981, #059669); padding: 40px; text-align: center;">
              <div style="width: 60px; height: 60px; background: white; border-radius: 50%; margin: 0 auto 16px; line-height: 60px; font-size: 30px;">‚úì</div>
              <h1 style="color: white; margin: 0; font-size: 28px; font-weight: 700;">Booking Confirmed!</h1>
              <p style="color: rgba(255,255,255,0.9); margin: 8px 0 0; font-size: 16px;">Thank you for your reservation</p>
            </td>
          </tr>
          
          <!-- Booking Reference -->
          <tr>
            <td style="padding: 32px 40px 0;">
              <table width="100%" style="background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; padding: 20px; text-align: center;">
                <tr>
                  <td>
                    <span style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #059669;">Booking Reference</span>
                    <div style="font-size: 18px; font-weight: 700; color: #047857; margin-top: 4px; word-break: break-all;">${groupBookingId}</div>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
          
          <!-- Property Details -->
          <tr>
            <td style="padding: 32px 40px 0; text-align: center;">
              <h2 style="margin: 0 0 8px; font-size: 20px; color: #1e293b;">Group Booking - ${rooms.length} room${rooms.length > 1 ? 's' : ''}</h2>
              <p style="margin: 0; color: #64748b; font-size: 14px;">${property?.name || 'Property'}</p>
            </td>
          </tr>
          
          <!-- Rooms List -->
          <tr>
            <td style="padding: 24px 40px 0;">
              <table width="100%" cellpadding="0" cellspacing="0">
                ${roomsHtml}
              </table>
            </td>
          </tr>
          
          <!-- Extras if any -->
          ${extrasHtml ? `
          <tr>
            <td style="padding: 0 40px;">
              <table width="100%" cellpadding="0" cellspacing="0">
                ${extrasHtml}
              </table>
            </td>
          </tr>
          ` : ''}
          
          <!-- Dates -->
          <tr>
            <td style="padding: 24px 40px;">
              <table width="100%" cellpadding="0" cellspacing="0">
                <tr>
                  <td width="45%" style="text-align: center; padding: 16px; background: #f8fafc; border-radius: 8px;">
                    <span style="font-size: 11px; text-transform: uppercase; color: #94a3b8; display: block;">Check-in</span>
                    <strong style="font-size: 14px; color: #1e293b; display: block; margin: 4px 0;">${formatDate(totals.checkin)}</strong>
                    <span style="font-size: 12px; color: #64748b;">From 3:00 PM</span>
                  </td>
                  <td width="10%" style="text-align: center; color: #cbd5e1; font-size: 20px;">‚Üí</td>
                  <td width="45%" style="text-align: center; padding: 16px; background: #f8fafc; border-radius: 8px;">
                    <span style="font-size: 11px; text-transform: uppercase; color: #94a3b8; display: block;">Check-out</span>
                    <strong style="font-size: 14px; color: #1e293b; display: block; margin: 4px 0;">${formatDate(totals.checkout)}</strong>
                    <span style="font-size: 12px; color: #64748b;">By 11:00 AM</span>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
          
          <!-- Guest Info -->
          <tr>
            <td style="padding: 0 40px 24px; text-align: center;">
              <span style="font-size: 14px; color: #475569;">üë§ ${totalGuests} ${totalGuests === 1 ? 'Guest' : 'Guests'}</span>
            </td>
          </tr>
          
          <!-- Divider -->
          <tr>
            <td style="padding: 0 40px;">
              <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 0;">
            </td>
          </tr>
          
          <!-- Pricing -->
          <tr>
            <td style="padding: 24px 40px;">
              <table width="100%" cellpadding="0" cellspacing="0">
                <tr>
                  <td style="padding: 8px 0; font-size: 16px; font-weight: 600; color: #1e293b;">Total</td>
                  <td style="padding: 8px 0; font-size: 16px; font-weight: 600; color: #1e293b; text-align: right;">${currency}${parseFloat(totals.total || 0).toFixed(2)}</td>
                </tr>
                ${depositPaid ? `
                <tr>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569;">Deposit Paid</td>
                  <td style="padding: 8px 0; font-size: 14px; color: #10b981; text-align: right; font-weight: 500;">‚úì ${currency}${parseFloat(totals.depositAmount).toFixed(2)}</td>
                </tr>
                ` : ''}
                ${balanceDue ? `
                <tr>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569;">Balance Due at Check-in</td>
                  <td style="padding: 8px 0; font-size: 14px; color: #f59e0b; text-align: right; font-weight: 500;">${currency}${parseFloat(totals.balanceAmount).toFixed(2)}</td>
                </tr>
                ` : ''}
                ${!depositPaid ? `
                <tr>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569;">Payment</td>
                  <td style="padding: 8px 0; font-size: 14px; color: #475569; text-align: right;">Pay at Property</td>
                </tr>
                ` : ''}
              </table>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="background: #f8fafc; padding: 24px 40px; text-align: center; border-top: 1px solid #e2e8f0;">
              <p style="margin: 0 0 8px; font-size: 14px; color: #64748b;">Questions about your booking?</p>
              <p style="margin: 0; font-size: 14px; color: #64748b;">Contact us at <a href="mailto:${property?.email || EMAIL_FROM}" style="color: #10b981;">${property?.email || EMAIL_FROM}</a></p>
            </td>
          </tr>
        </table>
        
        <!-- Unsubscribe -->
        <p style="text-align: center; margin-top: 24px; font-size: 12px; color: #94a3b8;">
          This is a transactional email regarding your booking.
        </p>
      </td>
    </tr>
  </table>
</body>
</html>
  `;
}

const app = express();
const PORT = process.env.PORT || 3000;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
  // Connection pool settings for stability
  max: 20,                          // Maximum number of clients
  idleTimeoutMillis: 30000,         // Close idle clients after 30s
  connectionTimeoutMillis: 10000,   // Return an error after 10s if can't connect
  allowExitOnIdle: false            // Keep pool alive even when idle
});

// Handle pool errors gracefully to prevent crashes
pool.on('error', (err, client) => {
  console.error('‚ö†Ô∏è Unexpected PostgreSQL pool error:', err.message);
  // Don't crash - the pool will create new connections as needed
});

// Handle individual client errors
pool.on('connect', (client) => {
  client.on('error', (err) => {
    console.error('‚ö†Ô∏è PostgreSQL client error:', err.message);
  });
});

// Initialize GasSync Manager
const syncManager = new SyncManager(pool);

// Run database migrations on startup
async function runMigrations() {
  try {
    // Create migrations tracking table if it doesn't exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS _migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL UNIQUE,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Get list of migration files
    const migrationsDir = path.join(__dirname, 'migrations');
    
    // Check if migrations directory exists
    if (!fs.existsSync(migrationsDir)) {
      console.log('üìÅ No migrations directory found, skipping migrations');
      return;
    }
    
    const files = fs.readdirSync(migrationsDir)
      .filter(f => f.endsWith('.sql'))
      .sort();

    if (files.length === 0) {
      console.log('üìÅ No migration files found');
      return;
    }

    console.log(`üìÅ Found ${files.length} migration files`);

    for (const file of files) {
      // Check if already executed
      const executed = await pool.query(
        'SELECT id FROM _migrations WHERE name = $1',
        [file]
      );

      if (executed.rows.length > 0) {
        console.log(`‚è≠Ô∏è  Skipping ${file} (already executed)`);
        continue;
      }

      // Read and execute migration
      console.log(`üîÑ Running migration: ${file}`);
      const sql = fs.readFileSync(path.join(migrationsDir, file), 'utf8');
      
      try {
        await pool.query(sql);
        
        // Record successful migration
        await pool.query(
          'INSERT INTO _migrations (name) VALUES ($1)',
          [file]
        );
        
        console.log(`‚úÖ Completed: ${file}`);
      } catch (err) {
        console.error(`‚ùå Migration failed: ${file}`);
        console.error(err.message);
        // Don't throw - let server continue even if migration fails
      }
    }

    console.log('üéâ Migrations check complete!');
    
    // ===== INLINE MIGRATIONS (no SQL files needed) =====
    
    // Fix: Add unique constraint to website_settings if missing
    try {
      const constraintCheck = await pool.query(`
        SELECT constraint_name FROM information_schema.table_constraints 
        WHERE table_name = 'website_settings' 
        AND constraint_type = 'UNIQUE'
        AND constraint_name = 'website_settings_website_id_section_unique'
      `);
      
      if (constraintCheck.rows.length === 0) {
        console.log('üîß Adding missing unique constraint to website_settings...');
        
        // First remove any duplicates that would block the constraint
        await pool.query(`
          DELETE FROM website_settings a USING website_settings b
          WHERE a.id < b.id 
          AND a.website_id = b.website_id 
          AND a.section = b.section
        `);
        
        await pool.query(`
          ALTER TABLE website_settings 
          ADD CONSTRAINT website_settings_website_id_section_unique 
          UNIQUE (website_id, section)
        `);
        console.log('‚úÖ website_settings unique constraint added');
      }
    } catch (constraintError) {
      console.log('‚ÑπÔ∏è  Constraint check:', constraintError.message);
    }
    
    // Fix: Ensure gas_sync_logs table exists (required by SyncManager)
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS gas_sync_logs (
          id SERIAL PRIMARY KEY,
          connection_id INTEGER,
          sync_type VARCHAR(50),
          status VARCHAR(50),
          records_synced INTEGER DEFAULT 0,
          error_message TEXT,
          started_at TIMESTAMP DEFAULT NOW(),
          completed_at TIMESTAMP,
          duration_seconds NUMERIC
        )
      `);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_gas_sync_logs_connection ON gas_sync_logs(connection_id)`);
      // Fix: Drop FK constraint if it exists without CASCADE, then recreate with CASCADE
      await pool.query(`ALTER TABLE gas_sync_logs DROP CONSTRAINT IF EXISTS gas_sync_logs_connection_id_fkey`);
      console.log('‚úÖ gas_sync_logs table ensured');
    } catch (logsTableError) {
      console.log('‚ÑπÔ∏è  gas_sync_logs:', logsTableError.message);
    }
    
    // Fix: Ensure gas_sync_properties has prop_key column
    try {
      await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS prop_key TEXT`);
      console.log('‚úÖ gas_sync_properties.prop_key ensured');
    } catch (propKeyError) {
      console.log('‚ÑπÔ∏è  prop_key column:', propKeyError.message);
    }
    
    // Fix: Extend room_availability.source column to VARCHAR(50) if it's VARCHAR(20)
    try {
      await pool.query(`ALTER TABLE room_availability ALTER COLUMN source TYPE VARCHAR(50)`);
      console.log('‚úÖ room_availability.source extended to VARCHAR(50)');
    } catch (sourceError) {
      console.log('‚ÑπÔ∏è  source column:', sourceError.message);
    }
    
    // Add property-level Stripe keys (legacy - will migrate to payment_configurations)
    try {
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS stripe_account_id TEXT`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS stripe_name VARCHAR(255)`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS stripe_publishable_key TEXT`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS stripe_secret_key TEXT`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS stripe_enabled BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS child_max_age INTEGER DEFAULT 12`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS website_url VARCHAR(500)`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS district VARCHAR(255)`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS zip_code VARCHAR(50)`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS cm_property_id VARCHAR(100)`);
      await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS cm_source VARCHAR(50)`);
      console.log('‚úÖ Property Stripe keys columns ensured');
    } catch (stripeError) {
      console.log('‚ÑπÔ∏è  Stripe columns:', stripeError.message);
    }
    
    // Add occupancy pricing columns to bookable_units
    try {
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS pricing_mode VARCHAR(20) DEFAULT 'per_room'`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS base_occupancy INTEGER DEFAULT 2`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS extra_adult_type VARCHAR(10) DEFAULT 'fixed'`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS extra_adult_charge DECIMAL(10,2) DEFAULT 0`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS single_discount_type VARCHAR(10) DEFAULT 'fixed'`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS single_discount_value DECIMAL(10,2) DEFAULT 0`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS child_charge_type VARCHAR(10) DEFAULT 'fixed'`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS child_charge DECIMAL(10,2) DEFAULT 0`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS children_allowed BOOLEAN DEFAULT true`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS is_hidden BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS num_bedrooms INTEGER DEFAULT 1`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS num_bathrooms DECIMAL(3,1) DEFAULT 1`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS currency VARCHAR(3) DEFAULT 'CHF'`);
      await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS cm_source VARCHAR(50)`);
      console.log('‚úÖ Occupancy pricing columns ensured on bookable_units');
    } catch (occError) {
      console.log('‚ÑπÔ∏è  Occupancy columns:', occError.message);
    }
    
    // Add min_stay columns to room_availability
    try {
      await pool.query(`ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS cm_min_stay INTEGER`);
      await pool.query(`ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS min_stay_override INTEGER`);
      console.log('‚úÖ Min stay columns ensured on room_availability');
    } catch (minStayError) {
      console.log('‚ÑπÔ∏è  Min stay columns:', minStayError.message);
    }
    
    // Create payment_configurations table for flexible multi-provider support
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS payment_configurations (
          id SERIAL PRIMARY KEY,
          account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
          property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
          provider VARCHAR(50) NOT NULL,
          name VARCHAR(100),
          is_enabled BOOLEAN DEFAULT false,
          credentials JSONB DEFAULT '{}',
          settings JSONB DEFAULT '{}',
          is_default BOOLEAN DEFAULT false,
          test_mode BOOLEAN DEFAULT false,
          last_tested_at TIMESTAMP,
          test_result JSONB,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          CONSTRAINT unique_provider_per_scope UNIQUE (account_id, property_id, provider)
        )
      `);
      console.log('‚úÖ payment_configurations table ensured');
    } catch (payConfigError) {
      console.log('‚ÑπÔ∏è  payment_configurations:', payConfigError.message);
    }
    
    // Add payment_account_id for grouping payments (allows multi-unit checkout when same account)
    try {
      await pool.query(`
        ALTER TABLE payment_configurations 
        ADD COLUMN IF NOT EXISTS payment_account_id VARCHAR(32) UNIQUE
      `);
      console.log('‚úÖ payment_account_id column ensured');
      
      // Backfill existing configs without payment_account_id
      const backfillResult = await pool.query(`
        UPDATE payment_configurations 
        SET payment_account_id = 'pa_' || SUBSTRING(REPLACE(gen_random_uuid()::text, '-', ''), 1, 16)
        WHERE payment_account_id IS NULL
        RETURNING id
      `);
      if (backfillResult.rows.length > 0) {
        console.log(`‚úÖ Backfilled ${backfillResult.rows.length} payment configs with payment_account_id`);
      }
    } catch (payAccountIdError) {
      console.log('‚ÑπÔ∏è  payment_account_id:', payAccountIdError.message);
    }
    
    // Create payment_setup_tokens for secure setup links
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS payment_setup_tokens (
          id SERIAL PRIMARY KEY,
          token VARCHAR(100) UNIQUE NOT NULL,
          account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
          property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
          provider VARCHAR(50),
          expires_at TIMESTAMP NOT NULL,
          used_at TIMESTAMP,
          created_by INTEGER,
          created_at TIMESTAMP DEFAULT NOW()
        )
      `);
      console.log('‚úÖ payment_setup_tokens table ensured');
    } catch (setupTokenError) {
      console.log('‚ÑπÔ∏è  payment_setup_tokens:', setupTokenError.message);
    }
    
    // Add property_id to blog_posts and attractions for multi-property support
    try {
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS property_id INTEGER REFERENCES properties(id)`);
      console.log('‚úÖ blog_posts.property_id column ensured');
    } catch (blogPropertyError) {
      console.log('‚ÑπÔ∏è  blog_posts.property_id:', blogPropertyError.message);
    }
    
    // Fix blog_posts.client_id FK - should reference accounts, not clients
    try {
      // Drop the old FK constraint if it exists (referencing clients table)
      await pool.query(`ALTER TABLE blog_posts DROP CONSTRAINT IF EXISTS blog_posts_client_id_fkey`);
      // Make client_id nullable (no FK) since we filter via properties.account_id
      await pool.query(`ALTER TABLE blog_posts ALTER COLUMN client_id DROP NOT NULL`);
      console.log('‚úÖ blog_posts.client_id FK constraint fixed');
    } catch (blogFkError) {
      console.log('‚ÑπÔ∏è  blog_posts.client_id FK fix:', blogFkError.message);
    }
    
    // Fix attractions.client_id FK - same issue
    try {
      await pool.query(`ALTER TABLE attractions DROP CONSTRAINT IF EXISTS attractions_client_id_fkey`);
      await pool.query(`ALTER TABLE attractions ALTER COLUMN client_id DROP NOT NULL`);
      console.log('‚úÖ attractions.client_id FK constraint fixed');
    } catch (attrFkError) {
      console.log('‚ÑπÔ∏è  attractions.client_id FK fix:', attrFkError.message);
    }
    
    try {
      await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS property_id INTEGER REFERENCES properties(id)`);
      console.log('‚úÖ attractions.property_id column ensured');
    } catch (attractionsPropertyError) {
      console.log('‚ÑπÔ∏è  attractions.property_id:', attractionsPropertyError.message);
    }
    
    try {
      await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS ga4_measurement_id VARCHAR(50)`);
      await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS ga4_property_id VARCHAR(100)`);
      console.log('‚úÖ deployed_sites GA4 columns ensured');
    } catch (ga4ColError) {
      console.log('‚ÑπÔ∏è  deployed_sites GA4 columns:', ga4ColError.message);
    }
    
    // Enhanced blog_posts columns
    try {
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS scheduled_at TIMESTAMP`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS ai_generated BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS source_keyword VARCHAR(255)`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS language VARCHAR(10) DEFAULT 'en'`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS featured_image TEXT`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS event_date TIMESTAMP`);
      console.log('‚úÖ blog_posts enhanced columns ensured');
    } catch (blogEnhanceError) {
      console.log('‚ÑπÔ∏è  blog_posts enhanced columns:', blogEnhanceError.message);
    }
    
    // Multilingual columns for blog_posts
    try {
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS title_ml JSONB`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS excerpt_ml JSONB`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS content_ml JSONB`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS meta_title_ml JSONB`);
      await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS meta_description_ml JSONB`);
      console.log('‚úÖ blog_posts multilingual columns ensured');
    } catch (blogMlError) {
      console.log('‚ÑπÔ∏è  blog_posts multilingual columns:', blogMlError.message);
    }
    
    // Property images table and columns
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS property_images (
          id SERIAL PRIMARY KEY,
          property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
          room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
          url TEXT NOT NULL,
          caption VARCHAR(500),
          sort_order INTEGER DEFAULT 0,
          is_primary BOOLEAN DEFAULT false,
          external_id VARCHAR(255),
          created_at TIMESTAMP DEFAULT NOW()
        )
      `);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS url TEXT`);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS external_id VARCHAR(255)`);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE`);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS is_primary BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS sort_order INTEGER DEFAULT 0`);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS caption VARCHAR(500)`);
      await pool.query(`ALTER TABLE property_images ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT NOW()`);
      console.log('‚úÖ property_images table and columns ensured');
    } catch (propImgError) {
      console.log('‚ÑπÔ∏è  property_images:', propImgError.message);
    }
    
    // Blog schedules table for recurring auto-generation
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS blog_schedules (
          id SERIAL PRIMARY KEY,
          client_id INTEGER REFERENCES clients(id),
          property_id INTEGER REFERENCES properties(id),
          topic VARCHAR(255) NOT NULL,
          language VARCHAR(10) DEFAULT 'en',
          frequency VARCHAR(20) DEFAULT 'weekly',
          day_of_week INTEGER,
          day_of_month INTEGER,
          next_run_at TIMESTAMP,
          last_run_at TIMESTAMP,
          is_active BOOLEAN DEFAULT true,
          auto_publish BOOLEAN DEFAULT false,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        )
      `);
      console.log('‚úÖ blog_schedules table ensured');
    } catch (blogScheduleError) {
      console.log('‚ÑπÔ∏è  blog_schedules table:', blogScheduleError.message);
    }
    
    // Blog topic templates for suggestions
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS blog_topic_templates (
          id SERIAL PRIMARY KEY,
          category VARCHAR(50),
          template VARCHAR(255),
          description TEXT,
          variables JSONB,
          is_active BOOLEAN DEFAULT true,
          sort_order INTEGER DEFAULT 0
        )
      `);
      
      // Seed default templates if empty
      const templateCheck = await pool.query('SELECT COUNT(*) FROM blog_topic_templates');
      if (parseInt(templateCheck.rows[0].count) === 0) {
        await pool.query(`
          INSERT INTO blog_topic_templates (category, template, description, variables, sort_order) VALUES
          -- Location-based
          ('location', 'Accommodation in {city}', 'Generic accommodation search', '["city"]', 1),
          ('location', 'Hotels in {city}', 'Hotel searches', '["city"]', 2),
          ('location', 'Places to stay in {city}', 'General lodging', '["city"]', 3),
          ('location', 'Holiday rentals {city}', 'Vacation rental searches', '["city"]', 4),
          ('location', '{city} vacation rentals', 'US-style search', '["city"]', 5),
          ('location', 'Best {city} accommodation', 'Quality focused', '["city"]', 6),
          ('location', 'Where to stay in {city}', 'Decision help', '["city"]', 7),
          
          -- Regional
          ('regional', 'Holidays in {region}', 'Regional tourism', '["region"]', 10),
          ('regional', '{region} getaways', 'Short breaks', '["region"]', 11),
          ('regional', 'Weekend breaks {region}', 'Weekend trips', '["region"]', 12),
          
          -- Seasonal
          ('seasonal', 'Christmas in {city}', 'Winter holidays', '["city"]', 20),
          ('seasonal', 'Summer holidays {city}', 'Peak season', '["city"]', 21),
          ('seasonal', 'Easter breaks {city}', 'Spring holidays', '["city"]', 22),
          ('seasonal', 'New Year in {city}', 'NYE celebrations', '["city"]', 23),
          ('seasonal', 'Autumn breaks in {city}', 'Fall season', '["city"]', 24),
          
          -- Amenity-based
          ('amenity', 'Pet-friendly holidays in {city}', 'Pet owners', '["city"]', 30),
          ('amenity', 'Family accommodation {city}', 'Family travel', '["city"]', 31),
          ('amenity', 'Accessible hotels in {city}', 'Accessibility', '["city"]', 32),
          ('amenity', 'Self-catering accommodation {city}', 'Self-catering', '["city"]', 33),
          
          -- Intent-based
          ('intent', 'Cheap accommodation {city}', 'Budget travelers', '["city"]', 40),
          ('intent', 'Luxury stays in {city}', 'High-end market', '["city"]', 41),
          ('intent', 'Budget hotels {city}', 'Cost-conscious', '["city"]', 42),
          ('intent', 'Romantic getaways {city}', 'Couples', '["city"]', 43),
          
          -- Activities/Things to do
          ('activities', 'Things to do in {city}', 'Activity guide', '["city"]', 50),
          ('activities', 'Best restaurants in {city}', 'Food guide', '["city"]', 51),
          ('activities', 'Day trips from {city}', 'Excursions', '["city"]', 52),
          ('activities', 'Hidden gems in {city}', 'Local secrets', '["city"]', 53),
          ('activities', 'Nightlife in {city}', 'Entertainment', '["city"]', 54),
          ('activities', 'Shopping in {city}', 'Retail guide', '["city"]', 55),
          ('activities', 'Free things to do in {city}', 'Budget activities', '["city"]', 56),
          
          -- Events
          ('events', 'Events in {city} this month', 'Current events', '["city"]', 60),
          ('events', 'Festivals in {city}', 'Festival guide', '["city"]', 61),
          ('events', 'Concerts and shows in {city}', 'Entertainment', '["city"]', 62),
          ('events', 'Sports events in {city}', 'Sports', '["city"]', 63)
        `);
        console.log('‚úÖ blog_topic_templates seeded with defaults');
      }
      console.log('‚úÖ blog_topic_templates table ensured');
    } catch (blogTemplateError) {
      console.log('‚ÑπÔ∏è  blog_topic_templates table:', blogTemplateError.message);
    }
    
    // =========================================================
    // VENDOR MANAGEMENT TABLES
    // =========================================================
    
    // Vendors table - external service providers (taxis, tours, restaurants, etc.)
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS vendors (
          id SERIAL PRIMARY KEY,
          account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
          name VARCHAR(255) NOT NULL,
          email VARCHAR(255),
          phone VARCHAR(50),
          address TEXT,
          website VARCHAR(255),
          contact_name VARCHAR(255),
          notes TEXT,
          login_email VARCHAR(255) UNIQUE,
          login_password_hash VARCHAR(255),
          login_token VARCHAR(255),
          token_expires_at TIMESTAMP,
          is_active BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        )
      `);
      console.log('‚úÖ vendors table ensured');
    } catch (vendorError) {
      console.log('‚ÑπÔ∏è  vendors table:', vendorError.message);
    }
    
    // Vendor permissions - what data each vendor can see
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS vendor_permissions (
          id SERIAL PRIMARY KEY,
          vendor_id INTEGER REFERENCES vendors(id) ON DELETE CASCADE,
          can_see_guest_name BOOLEAN DEFAULT true,
          can_see_guest_email BOOLEAN DEFAULT false,
          can_see_guest_phone BOOLEAN DEFAULT true,
          can_see_booking_dates BOOLEAN DEFAULT true,
          can_see_room_details BOOLEAN DEFAULT false,
          can_see_booking_notes BOOLEAN DEFAULT false,
          can_see_price_paid BOOLEAN DEFAULT false,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          UNIQUE(vendor_id)
        )
      `);
      console.log('‚úÖ vendor_permissions table ensured');
    } catch (vendorPermError) {
      console.log('‚ÑπÔ∏è  vendor_permissions table:', vendorPermError.message);
    }
    
    // Ensure vendors table has all columns (for existing tables)
    try {
      await pool.query(`ALTER TABLE vendors ADD COLUMN IF NOT EXISTS website VARCHAR(255)`);
      await pool.query(`ALTER TABLE vendors ADD COLUMN IF NOT EXISTS contact_name VARCHAR(255)`);
      await pool.query(`ALTER TABLE vendors ADD COLUMN IF NOT EXISTS login_email VARCHAR(255)`);
      await pool.query(`ALTER TABLE vendors ADD COLUMN IF NOT EXISTS login_password_hash VARCHAR(255)`);
      await pool.query(`ALTER TABLE vendors ADD COLUMN IF NOT EXISTS login_token VARCHAR(255)`);
      await pool.query(`ALTER TABLE vendors ADD COLUMN IF NOT EXISTS token_expires_at TIMESTAMP`);
      console.log('‚úÖ vendors columns ensured');
    } catch (vendorColError) {
      console.log('‚ÑπÔ∏è  vendors columns:', vendorColError.message);
    }
    
    // Ensure property_features has room_id column
    try {
      await pool.query(`ALTER TABLE property_features ADD COLUMN IF NOT EXISTS room_id INTEGER`);
      console.log('‚úÖ property_features.room_id ensured');
    } catch (featRoomError) {
      console.log('‚ÑπÔ∏è  property_features.room_id:', featRoomError.message);
    }
    
    // Add vendor_id to upsells table
    try {
      await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS is_external BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS vendor_id INTEGER REFERENCES vendors(id) ON DELETE SET NULL`);
      console.log('‚úÖ upsells vendor columns ensured');
    } catch (upsellVendorError) {
      console.log('‚ÑπÔ∏è  upsells vendor columns:', upsellVendorError.message);
    }
    
    // Add vendor_id to vouchers table (if it exists)
    try {
      await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS is_external BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS vendor_id INTEGER REFERENCES vendors(id) ON DELETE SET NULL`);
      console.log('‚úÖ vouchers vendor columns ensured');
    } catch (voucherVendorError) {
      console.log('‚ÑπÔ∏è  vouchers vendor columns:', voucherVendorError.message);
    }
    
    // Vendor service requests - when a booking includes external upsell/voucher
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS vendor_service_requests (
          id SERIAL PRIMARY KEY,
          vendor_id INTEGER REFERENCES vendors(id) ON DELETE CASCADE,
          booking_id INTEGER REFERENCES bookings(id) ON DELETE CASCADE,
          upsell_id INTEGER REFERENCES upsells(id) ON DELETE SET NULL,
          voucher_id INTEGER,
          property_id INTEGER REFERENCES properties(id),
          service_name VARCHAR(255),
          service_date DATE,
          service_time TIME,
          guest_name VARCHAR(255),
          guest_email VARCHAR(255),
          guest_phone VARCHAR(255),
          special_instructions TEXT,
          quantity INTEGER DEFAULT 1,
          status VARCHAR(50) DEFAULT 'pending',
          confirmed_at TIMESTAMP,
          completed_at TIMESTAMP,
          notes TEXT,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        )
      `);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_vendor_requests_vendor ON vendor_service_requests(vendor_id)`);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_vendor_requests_status ON vendor_service_requests(status)`);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_vendor_requests_booking ON vendor_service_requests(booking_id)`);
      console.log('‚úÖ vendor_service_requests table ensured');
    } catch (vendorRequestError) {
      console.log('‚ÑπÔ∏è  vendor_service_requests table:', vendorRequestError.message);
    }
    
    // Detailed bedroom configuration table
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS property_bedrooms (
          id SERIAL PRIMARY KEY,
          property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
          room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
          name VARCHAR(100) NOT NULL,
          bed_config JSONB,
          has_ensuite BOOLEAN DEFAULT false,
          ensuite_bathroom_id INTEGER,
          description TEXT,
          display_order INTEGER DEFAULT 0,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
      `);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_property_bedrooms_property ON property_bedrooms(property_id)`);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_property_bedrooms_room ON property_bedrooms(room_id)`);
      console.log('‚úÖ property_bedrooms table ensured');
    } catch (bedroomsTableError) {
      console.log('‚ÑπÔ∏è  property_bedrooms table:', bedroomsTableError.message);
    }

    // Bedroom amenities (applies to all bedrooms) - stored in property_terms or separate
    try {
      await pool.query(`ALTER TABLE property_terms ADD COLUMN IF NOT EXISTS bedroom_amenities JSONB`);
      console.log('‚úÖ property_terms.bedroom_amenities column ensured');
    } catch (bedroomAmenitiesError) {
      console.log('‚ÑπÔ∏è  property_terms.bedroom_amenities:', bedroomAmenitiesError.message);
    }

    // Enhance property_bathrooms table with more detail
    try {
      await pool.query(`ALTER TABLE property_bathrooms ADD COLUMN IF NOT EXISTS name VARCHAR(100)`);
      await pool.query(`ALTER TABLE property_bathrooms ADD COLUMN IF NOT EXISTS location VARCHAR(100)`);
      await pool.query(`ALTER TABLE property_bathrooms ADD COLUMN IF NOT EXISTS is_ensuite BOOLEAN DEFAULT false`);
      await pool.query(`ALTER TABLE property_bathrooms ADD COLUMN IF NOT EXISTS linked_bedroom_id INTEGER`);
      await pool.query(`ALTER TABLE property_bathrooms ADD COLUMN IF NOT EXISTS features JSONB`);
      await pool.query(`ALTER TABLE property_bathrooms ADD COLUMN IF NOT EXISTS description TEXT`);
      console.log('‚úÖ property_bathrooms enhanced columns ensured');
    } catch (bathroomEnhanceError) {
      console.log('‚ÑπÔ∏è  property_bathrooms enhance:', bathroomEnhanceError.message);
    }

    // Property bathrooms table (like property_beds but for bathrooms)
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS property_bathrooms (
          id SERIAL PRIMARY KEY,
          property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
          room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
          bathroom_type VARCHAR(50) NOT NULL,
          quantity INTEGER DEFAULT 1,
          display_order INTEGER DEFAULT 0,
          created_at TIMESTAMP DEFAULT NOW()
        )
      `);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_property_bathrooms_property ON property_bathrooms(property_id)`);
      await pool.query(`CREATE INDEX IF NOT EXISTS idx_property_bathrooms_room ON property_bathrooms(room_id)`);
      console.log('‚úÖ property_bathrooms table ensured');
    } catch (bathroomsTableError) {
      console.log('‚ÑπÔ∏è  property_bathrooms table:', bathroomsTableError.message);
    }
    
    // Add bathroom_features JSONB column to property_terms
    try {
      await pool.query(`ALTER TABLE property_terms ADD COLUMN IF NOT EXISTS bathroom_features JSONB`);
      console.log('‚úÖ property_terms.bathroom_features column ensured');
    } catch (bathroomFeaturesError) {
      console.log('‚ÑπÔ∏è  property_terms.bathroom_features:', bathroomFeaturesError.message);
    }
    
    // Add cancellation_policy column to property_terms for Beds24 sync
    try {
      await pool.query(`ALTER TABLE property_terms ADD COLUMN IF NOT EXISTS cancellation_policy TEXT`);
      console.log('‚úÖ property_terms.cancellation_policy column ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  property_terms.cancellation_policy:', e.message);
    }
    
    // Multilingual support for property_terms
    try {
      await pool.query(`ALTER TABLE property_terms ADD COLUMN IF NOT EXISTS additional_rules_ml JSONB`);
      await pool.query(`ALTER TABLE property_terms ADD COLUMN IF NOT EXISTS cancellation_policy_ml JSONB`);
      console.log('‚úÖ property_terms multilingual columns ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  property_terms multilingual:', e.message);
    }
    
    // Add price_linking JSONB column to gas_sync_room_types for linked pricing
    try {
      await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS price_linking JSONB`);
      console.log('‚úÖ gas_sync_room_types.price_linking column ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  gas_sync_room_types.price_linking:', e.message);
    }
    
    // Add subdomain column to custom_site_requests
    try {
      await pool.query(`ALTER TABLE custom_site_requests ADD COLUMN IF NOT EXISTS subdomain VARCHAR(100)`);
      console.log('‚úÖ custom_site_requests.subdomain column ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  custom_site_requests.subdomain:', e.message);
    }
    
  } catch (error) {
    console.error('Migration runner error:', error.message);
  }
}

// Initialize database connection and run migrations
pool.query('SELECT NOW()', async (err, res) => {
  if (err) {
    console.error('‚ùå Database connection failed:', err);
  } else {
    console.log('‚úÖ Database connected:', res.rows[0].now);
    // Run migrations after successful connection
    await runMigrations();
  }
});

// =========================================================
// R2/S3 CLIENT CONFIGURATION
// =========================================================
const r2Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_ENDPOINT || `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY,
  },
});

const R2_BUCKET = process.env.R2_BUCKET_NAME || 'gas-property-images';
const R2_PUBLIC_URL = process.env.R2_PUBLIC_URL || `https://pub-${process.env.R2_ACCOUNT_ID}.r2.dev`;

// =========================================================
// MULTER CONFIGURATION (Memory storage for processing)
// =========================================================
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max
  },
  fileFilter: (req, file, cb) => {
    // Accept images only
    if (!file.mimetype.startsWith('image/')) {
      return cb(new Error('Only image files are allowed!'), false);
    }
    cb(null, true);
  },
});

app.use(cors());
app.use(express.json({ limit: '50mb' }));

// Handle JSON parse errors gracefully
app.use((err, req, res, next) => {
  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
    console.error('JSON Parse Error:', err.message);
    console.error('Request URL:', req.url);
    console.error('Content-Type:', req.headers['content-type']);
    return res.status(400).json({ 
      success: false, 
      error: 'Invalid JSON in request body',
      details: err.message 
    });
  }
  next(err);
});

// Root URL routing based on domain - MUST be before static middleware
app.get('/', (req, res) => {
  const host = req.hostname;
  if (host === 'admin.gas.travel') {
    res.redirect('/gas-admin.html');
  } else {
    res.redirect('/home.html');
  }
});

app.use(express.static('public'));

const BEDS24_TOKEN = process.env.BEDS24_TOKEN;
const BEDS24_API = 'https://beds24.com/api/v2';

async function beds24Request(endpoint, method = 'GET', data = null) {
  try {
    const config = {
      method,
      url: `${BEDS24_API}${endpoint}`,
      headers: { 'token': BEDS24_TOKEN, 'Content-Type': 'application/json' }
    };
    if (data) config.data = data;
    const response = await axios(config);
    return { success: true, data: response.data };
  } catch (error) {
    return { success: false, error: error.response?.data?.error || error.message };
  }
}

// =====================================================
// DATABASE MIGRATION ROUTES (NEW)
// =====================================================

// Admin page for database migration
app.get('/admin/deploy-database', (req, res) => {
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>üöÄ Deploy GAS Database</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
          padding: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .container {
          max-width: 900px;
          width: 100%;
          background: white;
          border-radius: 20px;
          padding: 40px;
          box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
          color: #333;
          font-size: 36px;
          margin-bottom: 10px;
          display: flex;
          align-items: center;
          gap: 15px;
        }
        .subtitle {
          color: #666;
          margin-bottom: 30px;
          font-size: 16px;
        }
        .card {
          background: #f8f9fa;
          border-radius: 12px;
          padding: 25px;
          margin: 20px 0;
          border-left: 5px solid #667eea;
        }
        .card.warning {
          background: #fff3cd;
          border-left-color: #ffc107;
        }
        .card.info {
          background: #e7f3ff;
          border-left-color: #0dcaf0;
        }
        .card.success {
          background: #d4edda;
          border-left-color: #28a745;
        }
        .card.error {
          background: #f8d7da;
          border-left-color: #dc3545;
        }
        .card strong {
          display: block;
          margin-bottom: 12px;
          font-size: 18px;
          color: #333;
        }
        .card ul {
          margin-left: 25px;
          margin-top: 12px;
          line-height: 1.8;
        }
        .button-group {
          display: flex;
          gap: 15px;
          justify-content: center;
          margin: 35px 0;
          flex-wrap: wrap;
        }
        button {
          background: #667eea;
          color: white;
          border: none;
          padding: 18px 35px;
          font-size: 16px;
          font-weight: 600;
          border-radius: 12px;
          cursor: pointer;
          transition: all 0.3s;
          box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
          display: flex;
          align-items: center;
          gap: 10px;
        }
        button:hover:not(:disabled) {
          transform: translateY(-3px);
          box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        button:active {
          transform: translateY(0);
        }
        button.danger {
          background: #dc3545;
          box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }
        button.danger:hover:not(:disabled) {
          box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
        }
        button:disabled {
          background: #ccc;
          cursor: not-allowed;
          box-shadow: none;
        }
        #result {
          margin-top: 25px;
          display: none;
          animation: slideIn 0.3s ease;
        }
        #result.show {
          display: block;
        }
        @keyframes slideIn {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .spinner {
          border: 4px solid #f3f3f3;
          border-top: 4px solid #667eea;
          border-radius: 50%;
          width: 50px;
          height: 50px;
          animation: spin 1s linear infinite;
          margin: 25px auto;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .stats {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 20px;
          margin-top: 25px;
        }
        .stat-box {
          background: white;
          padding: 20px;
          border-radius: 10px;
          text-align: center;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .stat-number {
          font-size: 42px;
          font-weight: bold;
          color: #667eea;
          margin-bottom: 8px;
        }
        .stat-label {
          font-size: 14px;
          color: #666;
          text-transform: uppercase;
          letter-spacing: 1px;
        }
        .table-list {
          max-height: 350px;
          overflow-y: auto;
          background: white;
          padding: 20px;
          border-radius: 8px;
          margin-top: 15px;
          font-family: 'Courier New', monospace;
          font-size: 13px;
          line-height: 2;
          box-shadow: inset 0 2px 8px rgba(0,0,0,0.1);
        }
        .table-list div {
          padding: 5px 10px;
          border-radius: 4px;
          transition: background 0.2s;
        }
        .table-list div:hover {
          background: #f0f0f0;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>
          <span>üöÄ</span>
          <span>GAS Database Deployment</span>
        </h1>
        <div class="subtitle">Deploy the complete 43-table schema to your Railway database</div>
        
        <div class="card info">
          <strong>üìä What Will Be Deployed:</strong>
          <ul>
            <li><strong>43 tables</strong> across 7 major systems</li>
            <li><strong>500+ fields</strong> with complete relationships</li>
            <li><strong>Users, Properties, Bookable Units, Bookings, Channel Managers, Rate Plans, Upsells</strong></li>
            <li><strong>All indexes, triggers, and functions</strong></li>
          </ul>
        </div>

        <div class="card warning">
          <strong>‚ö†Ô∏è Important Warning:</strong>
          This will <strong>DELETE ALL</strong> existing tables and data. Your current database will be completely replaced with the new schema. This action cannot be undone without a backup.
        </div>

        <div class="button-group">
          <button onclick="checkStatus()" id="checkBtn">
            <span>üìã</span>
            <span>Check Current Database</span>
          </button>
          <button onclick="deployDatabase()" class="danger" id="deployBtn">
            <span>üöÄ</span>
            <span>Deploy New Schema</span>
          </button>
        </div>

        <div id="result"></div>
      </div>

      <script>
        async function checkStatus() {
          const btn = document.getElementById('checkBtn');
          const result = document.getElementById('result');
          
          btn.disabled = true;
          result.className = 'card info show';
          result.innerHTML = '<div class="spinner"></div><p style="text-align:center; margin-top:10px; font-size:16px;">Checking database...</p>';

          try {
            const res = await fetch('/api/migration/status');
            const data = await res.json();
            
            if (data.success) {
              result.className = 'card success show';
              result.innerHTML = \`
                <strong>‚úì Current Database Status</strong>
                <div class="stats">
                  <div class="stat-box">
                    <div class="stat-number">\${data.tableCount}</div>
                    <div class="stat-label">Tables</div>
                  </div>
                </div>
                <div class="table-list">
                  \${data.tables.map(t => '<div>‚Ä¢ ' + t + '</div>').join('')}
                </div>
              \`;
            } else {
              throw new Error(data.error);
            }
          } catch (error) {
            result.className = 'card error show';
            result.innerHTML = '<strong>‚úó Error:</strong> ' + error.message;
          } finally {
            btn.disabled = false;
          }
        }

        async function deployDatabase() {
          if (!confirm('‚ö†Ô∏è FINAL WARNING\\n\\nThis will DELETE ALL existing data and create a fresh database with 43 new tables.\\n\\nThis action CANNOT be undone!\\n\\nAre you absolutely sure you want to proceed?')) {
            return;
          }

          const btn = document.getElementById('deployBtn');
          const checkBtn = document.getElementById('checkBtn');
          const result = document.getElementById('result');
          
          btn.disabled = true;
          checkBtn.disabled = true;
          result.className = 'card info show';
          result.innerHTML = '<div class="spinner"></div><p style="text-align:center; margin-top:10px; font-size:16px;"><strong>Deploying database...</strong><br>This may take 30-60 seconds. Please wait...</p>';

          const startTime = Date.now();

          try {
            const res = await fetch('/api/migration/deploy', { method: 'POST' });
            const data = await res.json();
            
            const timeTaken = ((Date.now() - startTime) / 1000).toFixed(1);
            
            if (data.success) {
              result.className = 'card success show';
              result.innerHTML = \`
                <strong>üéâ DEPLOYMENT SUCCESSFUL!</strong>
                <p style="margin: 15px 0; font-size: 16px;">Your database has been successfully deployed with the complete schema.</p>
                <div class="stats">
                  <div class="stat-box">
                    <div class="stat-number">\${data.tableCount}</div>
                    <div class="stat-label">Tables Created</div>
                  </div>
                  <div class="stat-box">
                    <div class="stat-number">\${timeTaken}s</div>
                    <div class="stat-label">Time Taken</div>
                  </div>
                </div>
                <strong style="margin-top: 25px; display: block;">‚úì New Tables:</strong>
                <div class="table-list">
                  \${data.tables.map(t => '<div>‚úì ' + t + '</div>').join('')}
                </div>
                <div style="margin-top: 25px; padding: 20px; background: #e7f3ff; border-radius: 8px; border-left: 5px solid #0dcaf0;">
                  <strong style="color: #0c5460;">üéØ Next Steps:</strong>
                  <ul style="margin-top: 10px; line-height: 2;">
                    <li>Your database is now ready to use!</li>
                    <li>Update your API endpoints to use new table names</li>
                    <li>Test Beds24 integration with new schema</li>
                    <li>Update admin panel for new features</li>
                  </ul>
                </div>
              \`;
            } else {
              throw new Error(data.error);
            }
          } catch (error) {
            result.className = 'card error show';
            result.innerHTML = \`
              <strong>‚úó Deployment Failed</strong>
              <p style="margin: 15px 0; font-size: 16px; color: #721c24;">\${error.message}</p>
              <div style="padding: 15px; background: white; border-radius: 8px; margin-top: 15px;">
                <strong>‚ÑπÔ∏è Good News:</strong> The database has been automatically rolled back. No changes were made to your existing database.
              </div>
            \`;
          } finally {
            btn.disabled = false;
            checkBtn.disabled = false;
          }
        }
      </script>
    </body>
    </html>
  `);
});

// API: Check current database status
app.get('/api/migration/status', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
      ORDER BY table_name
    `);
    
    res.json({
      success: true,
      tableCount: result.rows.length,
      tables: result.rows.map(row => row.table_name)
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// API: Deploy new database schema
app.post('/api/migration/deploy', async (req, res) => {
  const client = await pool.connect();
  
  try {
    console.log('üöÄ Starting database migration...');
    
    // Read the migration SQL file
    const migrationPath = path.join(__dirname, 'master-migration.sql');
    
    if (!fs.existsSync(migrationPath)) {
      throw new Error('Migration file not found! Please ensure master-migration.sql is in the project root.');
    }
    
    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    console.log('üìÑ Migration file loaded (' + migrationSQL.length + ' characters)');
    
    // Execute the migration
    console.log('‚öôÔ∏è  Executing migration...');
    await client.query(migrationSQL);
    
    // Verify deployment
    const result = await client.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public'
      ORDER BY table_name
    `);
    
    console.log('‚úÖ Migration complete! Created ' + result.rows.length + ' tables.');
    
    res.json({
      success: true,
      tableCount: result.rows.length,
      tables: result.rows.map(row => row.table_name)
    });
    
  } catch (error) {
    console.error('‚ùå Migration failed:', error.message);
    res.json({ 
      success: false, 
      error: error.message 
    });
  } finally {
    client.release();
  }
});

// =====================================================
// EXISTING ROUTES (UNCHANGED)
// =====================================================

app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', database: !!process.env.DATABASE_URL, beds24: !!BEDS24_TOKEN });
});

// Fix gas_sync_reservations table - add missing columns
app.get('/api/fix-gas-sync-tables', async (req, res) => {
  try {
    const migrations = [
      // Reservations table fixes
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS channel_reservation_id TEXT",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS infants INTEGER DEFAULT 0",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS subtotal DECIMAL(10,2)",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS cleaning_fee DECIMAL(10,2)",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS taxes DECIMAL(10,2)",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS fees DECIMAL(10,2)",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS discount DECIMAL(10,2)",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS currency TEXT DEFAULT 'GBP'",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS special_requests TEXT",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS arrival_time TEXT",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS property_external_id TEXT",
      "ALTER TABLE gas_sync_reservations ADD COLUMN IF NOT EXISTS room_type_external_id TEXT",
      // Images table fixes
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS sync_property_id INTEGER",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS room_type_external_id TEXT",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS image_type TEXT DEFAULT 'property'",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS caption TEXT",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS sort_order INTEGER DEFAULT 0",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS width INTEGER",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS height INTEGER",
      "ALTER TABLE gas_sync_images ADD COLUMN IF NOT EXISTS metadata JSONB",
      // Properties table - add prop_key column
      "ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS prop_key TEXT",
      // Add unique constraint for images (ignore if exists)
      "CREATE UNIQUE INDEX IF NOT EXISTS gas_sync_images_conn_ext_idx ON gas_sync_images(connection_id, external_id)"
    ];
    
    const results = [];
    for (const sql of migrations) {
      try {
        await pool.query(sql);
        results.push({ sql: sql.substring(0, 60) + '...', success: true });
      } catch (err) {
        results.push({ sql: sql.substring(0, 60) + '...', success: false, error: err.message });
      }
    }
    
    res.json({ success: true, message: 'Gas sync tables fixed', results });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// GAS SYNC FIELD MAPPINGS
// =====================================================

// Create field mappings table
app.get('/api/gas-sync/setup-mappings', async (req, res) => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS gas_sync_field_mappings (
        id SERIAL PRIMARY KEY,
        connection_id INTEGER REFERENCES gas_sync_connections(id) ON DELETE CASCADE,
        adapter_code VARCHAR(50),
        source_entity VARCHAR(50) NOT NULL,
        source_field VARCHAR(200) NOT NULL,
        target_entity VARCHAR(50) NOT NULL,
        target_field VARCHAR(100),
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(connection_id, source_entity, source_field)
      )
    `);
    
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_field_mappings_connection ON gas_sync_field_mappings(connection_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_field_mappings_adapter ON gas_sync_field_mappings(adapter_code)`);
    
    res.json({ success: true, message: 'Field mappings table created' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Discover available fields from synced data
app.get('/api/gas-sync/connections/:id/discover-fields', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get a sample property with raw_data
    const propResult = await pool.query(`
      SELECT raw_data FROM gas_sync_properties WHERE connection_id = $1 LIMIT 1
    `, [id]);
    
    // Get a sample room with raw_data
    const roomResult = await pool.query(`
      SELECT rt.raw_data FROM gas_sync_room_types rt
      JOIN gas_sync_properties p ON rt.sync_property_id = p.id
      WHERE p.connection_id = $1 LIMIT 1
    `, [id]);
    
    // Get a sample reservation with raw_data
    const resResult = await pool.query(`
      SELECT raw_data FROM gas_sync_reservations WHERE connection_id = $1 LIMIT 1
    `, [id]);
    
    // Helper to flatten nested object keys
    const flattenKeys = (obj, prefix = '') => {
      const keys = [];
      if (!obj || typeof obj !== 'object') return keys;
      
      for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}.${key}` : key;
        keys.push({ 
          field: fullKey, 
          type: Array.isArray(value) ? 'array' : typeof value,
          sample: typeof value === 'object' ? '[object]' : String(value).substring(0, 100)
        });
        
        // Recurse into objects (but not arrays)
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          keys.push(...flattenKeys(value, fullKey));
        }
      }
      return keys;
    };
    
    const propertyFields = propResult.rows[0] 
      ? flattenKeys(typeof propResult.rows[0].raw_data === 'string' 
          ? JSON.parse(propResult.rows[0].raw_data) 
          : propResult.rows[0].raw_data)
      : [];
    
    const roomFields = roomResult.rows[0]
      ? flattenKeys(typeof roomResult.rows[0].raw_data === 'string'
          ? JSON.parse(roomResult.rows[0].raw_data)
          : roomResult.rows[0].raw_data)
      : [];
    
    const reservationFields = resResult.rows[0]
      ? flattenKeys(typeof resResult.rows[0].raw_data === 'string'
          ? JSON.parse(resResult.rows[0].raw_data)
          : resResult.rows[0].raw_data)
      : [];
    
    res.json({
      success: true,
      fields: {
        property: propertyFields,
        room: roomFields,
        reservation: reservationFields
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get available GAS target fields
app.get('/api/gas-sync/gas-fields', async (req, res) => {
  try {
    // These are the GAS fields we support mapping to
    const gasFields = {
      property: [
        { field: 'name', type: 'string', required: true },
        { field: 'address', type: 'string' },
        { field: 'city', type: 'string' },
        { field: 'state', type: 'string' },
        { field: 'country', type: 'string' },
        { field: 'postal_code', type: 'string' },
        { field: 'property_type', type: 'string' },
        { field: 'short_description', type: 'text' },
        { field: 'full_description', type: 'text' },
        { field: 'policies', type: 'text' },
        { field: 'directions', type: 'text' },
        { field: 'check_in_time', type: 'string' },
        { field: 'check_out_time', type: 'string' },
        { field: 'contact_email', type: 'string' },
        { field: 'contact_phone', type: 'string' },
        { field: 'website', type: 'string' },
        { field: 'latitude', type: 'number' },
        { field: 'longitude', type: 'number' }
      ],
      room: [
        { field: 'name', type: 'string', required: true },
        { field: 'display_name', type: 'string' },
        { field: 'short_description', type: 'text' },
        { field: 'full_description', type: 'text' },
        { field: 'max_guests', type: 'number' },
        { field: 'base_price', type: 'number' },
        { field: 'bedrooms', type: 'number' },
        { field: 'beds', type: 'number' },
        { field: 'bathrooms', type: 'number' },
        { field: 'size_sqm', type: 'number' },
        { field: 'amenities', type: 'json' },
        { field: 'room_type', type: 'string' },
        { field: 'cleaning_fee', type: 'number' },
        { field: 'security_deposit', type: 'number' }
      ],
      reservation: [
        { field: 'guest_first_name', type: 'string' },
        { field: 'guest_last_name', type: 'string' },
        { field: 'guest_email', type: 'string' },
        { field: 'guest_phone', type: 'string' },
        { field: 'check_in', type: 'date' },
        { field: 'check_out', type: 'date' },
        { field: 'adults', type: 'number' },
        { field: 'children', type: 'number' },
        { field: 'total_price', type: 'number' },
        { field: 'status', type: 'string' },
        { field: 'notes', type: 'text' },
        { field: 'special_requests', type: 'text' }
      ]
    };
    
    res.json({ success: true, fields: gasFields });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get current mappings for a connection (or defaults)
app.get('/api/gas-sync/connections/:id/mappings', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS gas_sync_field_mappings (
        id SERIAL PRIMARY KEY,
        connection_id INTEGER,
        adapter_code VARCHAR(50),
        source_entity VARCHAR(50) NOT NULL,
        source_field VARCHAR(200) NOT NULL,
        target_entity VARCHAR(50) NOT NULL,
        target_field VARCHAR(100),
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Get connection's adapter code
    const connResult = await pool.query('SELECT adapter_code FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    const adapterCode = connResult.rows[0].adapter_code;
    
    // Check for custom mappings first
    const customMappings = await pool.query(`
      SELECT * FROM gas_sync_field_mappings 
      WHERE connection_id = $1 AND is_active = true
      ORDER BY source_entity, source_field
    `, [id]);
    
    if (customMappings.rows.length > 0) {
      return res.json({ 
        success: true, 
        source: 'custom',
        mappings: customMappings.rows 
      });
    }
    
    // Return defaults based on adapter
    const defaults = getDefaultMappings(adapterCode);
    
    res.json({ 
      success: true, 
      source: 'defaults',
      adapterCode,
      mappings: defaults 
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Save mappings for a connection
app.post('/api/gas-sync/connections/:id/mappings', async (req, res) => {
  try {
    const { id } = req.params;
    const { mappings } = req.body;
    
    if (!mappings || !Array.isArray(mappings)) {
      return res.status(400).json({ success: false, error: 'mappings array required' });
    }
    
    // Get adapter code
    const connResult = await pool.query('SELECT adapter_code FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    const adapterCode = connResult.rows[0].adapter_code;
    
    // Clear existing mappings for this connection
    await pool.query('DELETE FROM gas_sync_field_mappings WHERE connection_id = $1', [id]);
    
    // Insert new mappings
    for (const mapping of mappings) {
      if (mapping.source_field && mapping.target_field) {
        await pool.query(`
          INSERT INTO gas_sync_field_mappings 
          (connection_id, adapter_code, source_entity, source_field, target_entity, target_field, is_active)
          VALUES ($1, $2, $3, $4, $5, $6, $7)
        `, [
          id,
          adapterCode,
          mapping.source_entity,
          mapping.source_field,
          mapping.target_entity,
          mapping.target_field,
          mapping.is_active !== false
        ]);
      }
    }
    
    res.json({ success: true, message: `Saved ${mappings.length} mappings` });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Reset to default mappings
app.post('/api/gas-sync/connections/:id/mappings/reset', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Delete custom mappings - will fall back to defaults
    await pool.query('DELETE FROM gas_sync_field_mappings WHERE connection_id = $1', [id]);
    
    res.json({ success: true, message: 'Mappings reset to defaults' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Helper function to get currency symbol from currency code
function getCurrencySymbol(currencyCode) {
  const symbols = {
    'GBP': '¬£',
    'USD': '$',
    'EUR': '‚Ç¨',
    'CHF': 'CHF ',
    'AUD': 'A$',
    'CAD': 'C$',
    'NZD': 'NZ$',
    'JPY': '¬•',
    'CNY': '¬•',
    'INR': '‚Çπ',
    'ZAR': 'R',
    'BRL': 'R$',
    'MXN': 'MX$',
    'SEK': 'kr',
    'NOK': 'kr',
    'DKK': 'kr',
    'PLN': 'z≈Ç',
    'CZK': 'Kƒç',
    'HUF': 'Ft',
    'THB': '‡∏ø',
    'SGD': 'S$',
    'HKD': 'HK$',
    'MYR': 'RM',
    'AED': 'AED ',
    'SAR': 'SAR ',
    'ILS': '‚Ç™',
    'TRY': '‚Ç∫',
    'RUB': '‚ÇΩ',
    'KRW': '‚Ç©'
  };
  return symbols[currencyCode?.toUpperCase()] || currencyCode + ' ' || '$';
}

// Helper function for default mappings
function getDefaultMappings(adapterCode) {
  const beds24Defaults = [
    // Property mappings
    { source_entity: 'property', source_field: 'name', target_entity: 'properties', target_field: 'name' },
    { source_entity: 'property', source_field: 'address', target_entity: 'properties', target_field: 'address' },
    { source_entity: 'property', source_field: 'city', target_entity: 'properties', target_field: 'city' },
    { source_entity: 'property', source_field: 'state', target_entity: 'properties', target_field: 'state' },
    { source_entity: 'property', source_field: 'country', target_entity: 'properties', target_field: 'country' },
    { source_entity: 'property', source_field: 'postcode', target_entity: 'properties', target_field: 'postal_code' },
    { source_entity: 'property', source_field: 'propertyType', target_entity: 'properties', target_field: 'property_type' },
    { source_entity: 'property', source_field: 'checkInStart', target_entity: 'properties', target_field: 'check_in_time' },
    { source_entity: 'property', source_field: 'checkOutEnd', target_entity: 'properties', target_field: 'check_out_time' },
    { source_entity: 'property', source_field: 'email', target_entity: 'properties', target_field: 'contact_email' },
    { source_entity: 'property', source_field: 'phone', target_entity: 'properties', target_field: 'contact_phone' },
    { source_entity: 'property', source_field: 'web', target_entity: 'properties', target_field: 'website' },
    { source_entity: 'property', source_field: 'latitude', target_entity: 'properties', target_field: 'latitude' },
    { source_entity: 'property', source_field: 'longitude', target_entity: 'properties', target_field: 'longitude' },
    { source_entity: 'property', source_field: 'currency', target_entity: 'properties', target_field: 'currency' },
    // Room mappings - based on actual Beds24 V1 API response
    { source_entity: 'room', source_field: 'name', target_entity: 'bookable_units', target_field: 'name' },
    { source_entity: 'room', source_field: 'texts.displayName.EN', target_entity: 'bookable_units', target_field: 'display_name' },
    { source_entity: 'room', source_field: 'texts.roomDescription1.EN', target_entity: 'bookable_units', target_field: 'full_description' },
    { source_entity: 'room', source_field: 'description', target_entity: 'bookable_units', target_field: 'short_description' },
    { source_entity: 'room', source_field: 'rackRate', target_entity: 'bookable_units', target_field: 'base_price' },
    { source_entity: 'room', source_field: 'texts.accommodationType.EN', target_entity: 'bookable_units', target_field: 'room_type' },
    { source_entity: 'room', source_field: 'featureCodes', target_entity: 'bookable_units', target_field: 'amenities' },
    { source_entity: 'room', source_field: 'cleaningFee', target_entity: 'bookable_units', target_field: 'cleaning_fee' },
    { source_entity: 'room', source_field: 'securityDeposit', target_entity: 'bookable_units', target_field: 'security_deposit' }
  ];
  
  // Add more adapters as needed
  const mappings = {
    beds24: beds24Defaults,
    smoobu: beds24Defaults, // Similar structure
    hostaway: beds24Defaults,
    calry: beds24Defaults
  };
  
  return mappings[adapterCode] || beds24Defaults;
}

// Reset gas sync connection data (clear rooms, images, reservations but keep connection)
app.post('/api/gas-sync/connections/:id/reset', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Delete synced data but keep the connection
    await pool.query('DELETE FROM gas_sync_logs WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_images WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_room_types WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_reservations WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_properties WHERE connection_id = $1', [id]);
    
    // Reset connection status
    await pool.query(`
      UPDATE gas_sync_connections SET 
        last_sync_at = NULL, 
        last_error = NULL, 
        last_error_at = NULL,
        status = 'connected'
      WHERE id = $1
    `, [id]);
    
    res.json({ success: true, message: 'Connection data reset. Ready for fresh sync.' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Set property key for a synced property (Beds24 V1 API)
app.post('/api/gas-sync/properties/:propertyId/set-prop-key', async (req, res) => {
  try {
    const { propertyId } = req.params;
    const { propKey } = req.body;
    
    if (!propKey) {
      return res.status(400).json({ success: false, error: 'propKey is required' });
    }
    
    // Add prop_key column if it doesn't exist
    await pool.query(`
      ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS prop_key TEXT
    `);
    
    // Update the property with the prop key
    const result = await pool.query(`
      UPDATE gas_sync_properties SET prop_key = $1, updated_at = NOW() 
      WHERE id = $2 
      RETURNING id, external_id, name, prop_key
    `, [propKey, propertyId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    res.json({ success: true, property: result.rows[0] });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete/clear prop key for a synced property
app.delete('/api/gas-sync/properties/:id/prop-key', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.query(`
      UPDATE gas_sync_properties 
      SET prop_key = NULL, prop_key_tested = FALSE, webhook_tested = FALSE, updated_at = NOW() 
      WHERE id = $1
    `, [id]);
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Unlink property from GAS (removes gas_property_id link but keeps data)
app.post('/api/gas-sync/properties/:id/unlink', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.query(`
      UPDATE gas_sync_properties 
      SET gas_property_id = NULL, updated_at = NOW() 
      WHERE id = $1
    `, [id]);
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Test prop key for a synced property (Beds24 V1 API)
// Test prop key - verifies GAS can fetch data from Beds24 V1 API
app.post('/api/gas-sync/test-prop-key', async (req, res) => {
  try {
    const { syncPropertyId, externalPropertyId, propKey } = req.body;
    
    if (!syncPropertyId || !propKey) {
      return res.json({ success: false, error: 'syncPropertyId and propKey are required' });
    }
    
    // Get connection info for this property
    const propResult = await pool.query(`
      SELECT sp.*, c.credentials, c.adapter_code 
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [syncPropertyId]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    let credentials = prop.credentials || {};
    if (typeof credentials === 'string') {
      credentials = JSON.parse(credentials);
    }
    
    console.log('Test prop key - credentials found:', !!credentials, 'v1ApiKey:', !!credentials.v1ApiKey);
    
    // For Beds24, test by fetching property data using the propKey
    if (prop.adapter_code === 'beds24') {
      const v1ApiKey = credentials.v1ApiKey;
      
      if (!v1ApiKey) {
        return res.json({ success: false, error: 'V1 API key not configured for this connection. Add it in the connection settings.' });
      }
      
      // Test the V1 API with this propKey
      try {
        console.log('Testing Beds24 V1 API with propKey:', propKey.substring(0, 4) + '...');
        
        // V1 API requires POST with JSON body
        const testResponse = await axios.post('https://api.beds24.com/json/getProperty', {
          authentication: {
            apiKey: v1ApiKey,
            propKey: propKey
          }
        }, {
          headers: { 'Content-Type': 'application/json' },
          timeout: 15000
        });
        
        console.log('Beds24 V1 API response:', JSON.stringify(testResponse.data).substring(0, 200));
        
        // Beds24 returns { getProperty: [ { propId, name, ... } ] }
        const propertyData = testResponse.data?.getProperty?.[0] || testResponse.data;
        
        console.log('Parsed propertyData:', propertyData ? 'found' : 'null', 'propId:', propertyData?.propId);
        
        // Check if we got valid property data back
        if (propertyData && propertyData.propId) {
          // Verify the propId matches
          if (String(propertyData.propId) === String(externalPropertyId)) {
            // Success! Mark as tested
            await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS prop_key_tested BOOLEAN DEFAULT FALSE`);
            await pool.query(`
              UPDATE gas_sync_properties SET prop_key_tested = TRUE, updated_at = NOW() WHERE id = $1
            `, [syncPropertyId]);
            
            return res.json({ 
              success: true, 
              message: 'Prop Key validated successfully',
              propertyName: propertyData.name || prop.name
            });
          } else {
            return res.json({ 
              success: false, 
              error: `Property ID mismatch. Expected ${externalPropertyId}, got ${propertyData.propId}. Check your propKey.`
            });
          }
        } else if (testResponse.data && testResponse.data.error) {
          return res.json({ success: false, error: testResponse.data.error });
        } else {
          console.log('Invalid response structure:', JSON.stringify(testResponse.data));
          return res.json({ success: false, error: 'Invalid response from Beds24. Check your propKey.' });
        }
      } catch (apiError) {
        console.error('Beds24 API test error:', apiError.message);
        return res.json({ success: false, error: 'Failed to connect to Beds24: ' + apiError.message });
      }
    }
    
    // For other adapters, just mark as tested for now
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS prop_key_tested BOOLEAN DEFAULT FALSE`);
    await pool.query(`
      UPDATE gas_sync_properties SET prop_key_tested = TRUE, updated_at = NOW() WHERE id = $1
    `, [syncPropertyId]);
    
    res.json({ success: true, message: 'Prop Key test passed' });
    
  } catch (error) {
    console.error('Prop Key test error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Test webhook URL for a synced property
app.post('/api/gas-sync/test-webhook-url', async (req, res) => {
  try {
    const { syncPropertyId, externalPropertyId } = req.body;
    
    if (!syncPropertyId) {
      return res.json({ success: false, error: 'syncPropertyId is required' });
    }
    
    // For now, just verify the webhook endpoint exists and mark as tested
    // In production, this could actually trigger a test from Beds24
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS webhook_tested BOOLEAN DEFAULT FALSE`);
    
    await pool.query(`
      UPDATE gas_sync_properties SET webhook_tested = TRUE, updated_at = NOW() WHERE id = $1
    `, [syncPropertyId]);
    
    res.json({ 
      success: true, 
      message: 'Webhook URL verified. Make sure to configure this URL in Beds24 webhook settings.'
    });
    
  } catch (error) {
    console.error('Webhook URL test error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get property test status
app.get('/api/gas-sync/property/:propertyId/status', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    const result = await pool.query(`
      SELECT webhook_tested, prop_key_tested, prop_key, gas_property_id 
      FROM gas_sync_properties WHERE id = $1
    `, [propertyId]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    res.json({ 
      success: true, 
      webhook_tested: result.rows[0].webhook_tested || false,
      prop_key_tested: result.rows[0].prop_key_tested || false,
      has_prop_key: !!result.rows[0].prop_key,
      imported: !!result.rows[0].gas_property_id
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get sync property by GAS property ID
app.get('/api/gas-sync/property-by-gas-id/:gasPropertyId', async (req, res) => {
  try {
    const { gasPropertyId } = req.params;
    
    // Try gas_sync_properties first (if table exists)
    try {
      const result = await pool.query(`
        SELECT id, connection_id, cm_property_id, gas_property_id, name
        FROM gas_sync_properties 
        WHERE gas_property_id = $1
      `, [gasPropertyId]);
      
      if (result.rows.length > 0) {
        return res.json({ 
          success: true, 
          syncPropertyId: result.rows[0].id,
          connectionId: result.rows[0].connection_id,
          cmPropertyId: result.rows[0].cm_property_id,
          name: result.rows[0].name
        });
      }
    } catch (e) {
      // gas_sync_properties table or column doesn't exist, continue to fallback
      console.log('gas_sync_properties lookup failed:', e.message);
    }
    
    // Fallback: get cm_property_id from properties table, and room info from bookable_units
    const result = await pool.query(`
      SELECT p.id, p.name, p.account_id, p.cm_property_id, p.cm_source,
             bu.cm_room_id,
             c.id as connection_id, c.adapter_code, c.external_account_id
      FROM properties p
      LEFT JOIN bookable_units bu ON bu.property_id = p.id
      LEFT JOIN gas_sync_connections c ON c.account_id = p.account_id
      WHERE p.id = $1
      LIMIT 1
    `, [gasPropertyId]);
    
    if (result.rows.length > 0) {
      const row = result.rows[0];
      // Use cm_property_id from properties if available, otherwise fall back to cm_room_id
      const cmPropertyId = row.cm_property_id || row.cm_room_id;
      
      if (cmPropertyId) {
        return res.json({
          success: true,
          syncPropertyId: gasPropertyId,
          connectionId: row.connection_id,
          cmPropertyId: cmPropertyId,
          cmRoomId: row.cm_room_id,
          adapterCode: row.adapter_code || row.cm_source,
          integrationAccountId: row.external_account_id,
          name: row.name
        });
      }
    }
    
    res.json({ success: false, error: 'No sync property found for this GAS property' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Sync prices for a property (works with both gas_sync_properties ID and GAS property ID)
app.post('/api/gas-sync/properties/:syncPropertyId/sync-prices', async (req, res) => {
  try {
    const { syncPropertyId } = req.params;
    const { days = 90, force = false } = req.body;
    
    let propResult = { rows: [] };
    
    // First try to find in gas_sync_properties by id OR gas_property_id (for Beds24)
    try {
      propResult = await pool.query(`
        SELECT sp.id, sp.gas_property_id, sp.external_id as cm_property_id, sp.name,
               c.id as connection_id, c.adapter_code, c.external_account_id,
               c.access_token, c.refresh_token, c.credentials
        FROM gas_sync_properties sp
        JOIN gas_sync_connections c ON c.id = sp.connection_id
        WHERE sp.id = $1 OR sp.gas_property_id = $1
      `, [syncPropertyId]);
    } catch (e) {
      console.log('gas_sync_properties lookup failed:', e.message);
    }
    
    // If not found, try as a GAS property ID - get cm_property_id from properties or bookable_units
    if (propResult.rows.length === 0) {
      propResult = await pool.query(`
        SELECT p.id as gas_property_id, 
               COALESCE(p.cm_property_id, bu.beds24_room_id::text, bu.cm_room_id) as cm_property_id, 
               p.name, 
               COALESCE(p.cm_source, 
                 CASE WHEN bu.beds24_room_id IS NOT NULL THEN 'beds24' ELSE NULL END
               ) as cm_source,
               c.id as connection_id,
               c.adapter_code, 
               c.external_account_id
        FROM properties p
        LEFT JOIN bookable_units bu ON bu.property_id = p.id
        LEFT JOIN gas_sync_connections c ON c.account_id = p.account_id
        WHERE p.id = $1
        LIMIT 1
      `, [syncPropertyId]);
    }
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    const gasPropertyId = prop.gas_property_id || syncPropertyId;
    const cmPropertyId = prop.cm_property_id;
    const adapterCode = prop.adapter_code || prop.cm_source;
    const integrationAccountId = prop.external_account_id;
    
    // For Beds24, we don't need cm_property_id - they use their own sync
    if (!cmPropertyId && adapterCode !== 'beds24') {
      return res.json({ success: false, error: 'Property not linked to channel manager' });
    }
    
    // Route to appropriate sync based on adapter
    if (adapterCode === 'calry') {
      // Calry v2 pricing sync - 2-step process:
      // Step 1: Get room types from property ID
      // Step 2: Get availability for each room type
      const startDate = new Date().toISOString().split('T')[0];
      const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      
      let totalDaysUpdated = 0;
      let roomTypesProcessed = 0;
      
      try {
        // Step 1: Get room types for this property
        console.log(`[Calry Sync] Step 1: Getting room types for property ${cmPropertyId}`);
        const roomTypesResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/room-types/${cmPropertyId}`, {
          headers: {
            'Authorization': `Bearer ${CALRY_API_TOKEN}`,
            'workspaceId': CALRY_WORKSPACE_ID,
            'integrationAccountId': integrationAccountId,
            'Content-Type': 'application/json'
          },
          timeout: 30000
        });
        
        const roomTypes = roomTypesResponse.data?.data || [];
        console.log(`[Calry Sync] Found ${roomTypes.length} room types`);
        
        if (roomTypes.length === 0) {
          return res.json({ success: false, error: 'No room types found in Calry for this property' });
        }
        
        // Step 2: For each room type, get availability
        for (const roomType of roomTypes) {
          const roomTypeId = String(roomType.id);
          console.log(`[Calry Sync] Step 2: Getting availability for room type ${roomTypeId}`);
          
          try {
            // FIXED: URL uses propertyId, query param uses roomTypeId
            const availResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${cmPropertyId}`, {
              headers: {
                'Authorization': `Bearer ${CALRY_API_TOKEN}`,
                'workspaceId': CALRY_WORKSPACE_ID,
                'integrationAccountId': integrationAccountId,
                'Content-Type': 'application/json'
              },
              params: { startDate, endDate, roomTypeId: roomTypeId, rates: 'true' },
              timeout: 30000
            });
            
            // Response structure: { success: true, data: { propertyId, roomTypeId, dateWiseAvailability: [...] } }
            console.log(`[Calry Sync] Raw response type:`, typeof availResponse.data);
            console.log(`[Calry Sync] Raw response keys:`, availResponse.data ? Object.keys(availResponse.data) : 'null');
            
            // Extract the availability array from the correct path
            const responseData = availResponse.data?.data || availResponse.data || {};
            const availData = responseData.dateWiseAvailability || responseData.data || responseData || [];
            
            console.log(`[Calry Sync] Room type ${roomTypeId}: ${Array.isArray(availData) ? availData.length : 'non-array'} availability records`);
            
            if (Array.isArray(availData) && availData.length > 0) {
              console.log(`[Calry Sync] Sample record:`, JSON.stringify(availData[0]));
            }
            
            // Find the GAS room by cm_room_id
            const roomResult = await pool.query(`
              SELECT id FROM bookable_units WHERE property_id = $1 AND cm_room_id = $2
            `, [gasPropertyId, String(roomTypeId)]);
            
            let gasRoomId = roomResult.rows[0]?.id;
            if (!gasRoomId) {
              // Fall back to first room for property
              const anyRoom = await pool.query(`SELECT id FROM bookable_units WHERE property_id = $1 LIMIT 1`, [gasPropertyId]);
              gasRoomId = anyRoom.rows[0]?.id;
            }
            
            if (gasRoomId && Array.isArray(availData)) {
              let availCount = 0;
              let blockedCount = 0;
              
              for (const day of availData) {
                const date = day.date || day.startDate;
                if (!date) continue;
                
                // Handle price in different formats - Calry returns { price: { amount: 857 } }
                let price = null;
                if (day.price) {
                  if (typeof day.price === 'object' && day.price.amount !== undefined) {
                    price = parseFloat(day.price.amount);
                  } else if (typeof day.price === 'number' || typeof day.price === 'string') {
                    price = parseFloat(day.price);
                  }
                } else if (day.rate) {
                  price = parseFloat(day.rate);
                } else if (day.amount) {
                  price = parseFloat(day.amount);
                }
                
                // Handle availability status - check multiple indicators
                // Calry returns: status: "AVAILABLE"/"BLOCKED", unitsAvailable: 0/1, reservationIds: []
                const hasReservation = day.reservationIds && day.reservationIds.length > 0;
                const noUnitsAvailable = day.unitsAvailable === 0 || day.unitsAvailable === '0';
                const statusBlocked = day.status === 'BLOCKED' || day.status === 'blocked';
                
                const isAvailable = !hasReservation && !noUnitsAvailable && !statusBlocked && 
                                   (day.status === 'AVAILABLE' || day.available !== false);
                
                if (isAvailable) availCount++; else blockedCount++;
                
                const minStay = day.minimumNights || day.minStay || day.minimumStay || day.minNights || 1;
                const maxStay = day.maximumNights || day.maxStay || day.maximumStay || day.maxNights || null;
                
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, min_stay, source, updated_at)
                  VALUES ($1, $2, $3, $4, $5, $6, 'calry', NOW())
                  ON CONFLICT (room_id, date) DO UPDATE SET
                    cm_price = COALESCE(EXCLUDED.cm_price, room_availability.cm_price),
                    is_available = EXCLUDED.is_available,
                    is_blocked = NOT EXCLUDED.is_available,
                    min_stay = COALESCE(EXCLUDED.min_stay, room_availability.min_stay),
                    source = 'calry',
                    updated_at = NOW()
                `, [gasRoomId, date, price, isAvailable, !isAvailable, minStay]);
                
                totalDaysUpdated++;
              }
              
              console.log(`[Calry Sync] Room type ${roomTypeId}: ${availCount} available, ${blockedCount} blocked`);
            }
            
            roomTypesProcessed++;
            
          } catch (roomErr) {
            console.error(`[Calry Sync] Error fetching availability for room type ${roomTypeId}:`, roomErr.response?.status, roomErr.response?.data || roomErr.message);
          }
        }
        
        return res.json({ success: true, daysUpdated: totalDaysUpdated, roomTypes: roomTypesProcessed });
        
      } catch (calryErr) {
        console.error('Calry sync error:', calryErr.response?.data || calryErr.message);
        return res.json({ success: false, error: calryErr.response?.data?.message || calryErr.message });
      }
      
    } else if (adapterCode === 'beds24') {
      // Beds24 manual sync - fetch calendar data from Beds24 API
      const connectionId = prop.connection_id;
      
      if (!connectionId) {
        return res.json({ success: false, error: 'No Beds24 connection found for this property' });
      }
      
      // Get connection with token
      const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [connectionId]);
      if (connResult.rows.length === 0) {
        return res.json({ success: false, error: 'Connection not found' });
      }
      
      const conn = connResult.rows[0];
      let accessToken = conn.access_token;
      
      // Refresh token if needed
      if (!accessToken && conn.refresh_token) {
        try {
          const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
            headers: { 'refreshToken': conn.refresh_token }
          });
          accessToken = tokenResponse.data.token;
          await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [accessToken, connectionId]);
        } catch (e) {
          return res.json({ success: false, error: 'Token expired. Please reconnect to Beds24.' });
        }
      }
      
      if (!accessToken) {
        return res.json({ success: false, error: 'No access token. Please reconnect to Beds24.' });
      }
      
      // Get rooms for this property
      const roomsResult = await pool.query(`
        SELECT bu.id as gas_room_id, bu.beds24_room_id, bu.name
        FROM bookable_units bu
        WHERE bu.property_id = $1 AND bu.beds24_room_id IS NOT NULL
      `, [gasPropertyId]);
      
      if (roomsResult.rows.length === 0) {
        return res.json({ success: false, error: 'No Beds24-linked rooms found' });
      }
      
      // Load price linking for this connection
      const priceLinkingMap = {};
      const linkingResult = await pool.query(`
        SELECT rt.external_id, rt.price_linking
        FROM gas_sync_room_types rt
        JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
        WHERE sp.connection_id = $1 AND rt.price_linking IS NOT NULL
      `, [connectionId]);
      for (const row of linkingResult.rows) {
        if (row.price_linking) {
          priceLinkingMap[row.external_id] = typeof row.price_linking === 'string' 
            ? JSON.parse(row.price_linking) 
            : row.price_linking;
        }
      }
      
      const startDate = new Date().toISOString().split('T')[0];
      const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      
      console.log(`[Beds24 Sync] Price linking map has ${Object.keys(priceLinkingMap).length} entries`);
      console.log(`[Beds24 Sync] Date range: ${startDate} to ${endDate}`);
      
      let totalDaysUpdated = 0;
      
      for (const room of roomsResult.rows) {
        try {
          console.log(`[Beds24 Sync] Processing room ${room.name}, beds24_room_id: ${room.beds24_room_id}`);
          
          // Fetch calendar from Beds24 V2
          const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
            headers: { 'token': accessToken },
            params: {
              roomId: parseInt(room.beds24_room_id),
              startDate: startDate,
              endDate: endDate,
              includeNumAvail: true,
              includePrices: true,
              includeMinStay: true
            }
          });
          
          const calendarData = calResponse.data.data?.[0]?.calendar || [];
          const hasAnyPrices = calendarData.some(entry => entry.price1);
          
          console.log(`[Beds24 Sync] ${room.name}: V2 returned ${calendarData.length} entries, hasAnyPrices: ${hasAnyPrices}`);
          
          // DEBUG: Log raw fields from first 10 entries to see all price columns
          if (calendarData.length > 0) {
            const sampleEntries = calendarData.slice(0, 10).map(entry => {
              const fields = {};
              for (const key of Object.keys(entry)) {
                fields[key] = entry[key];
              }
              return fields;
            });
            console.log(`[Beds24 Debug] ${room.name} RAW first 10 entries: ${JSON.stringify(sampleEntries)}`);
          }
          
          // Check if this room has price linking
          const linking = priceLinkingMap[String(room.beds24_room_id)];
          console.log(`[Beds24 Sync] ${room.name}: linking found: ${!!linking}, key used: ${String(room.beds24_room_id)}`);
          
          // If no prices but has linking, get from BASE in database
          if (!hasAnyPrices && linking) {
            const sourceRoomResult = await pool.query(`
              SELECT rt.gas_room_id 
              FROM gas_sync_room_types rt
              JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
              WHERE sp.connection_id = $1 AND rt.external_id = $2
            `, [connectionId, String(linking.sourceRoomId)]);
            
            const sourceGasRoomId = sourceRoomResult.rows[0]?.gas_room_id;
            
            if (sourceGasRoomId) {
              const sourcePricesResult = await pool.query(`
                SELECT date, cm_price, min_stay
                FROM room_availability
                WHERE room_id = $1 AND date >= $2 AND date <= $3 AND cm_price IS NOT NULL
                ORDER BY date
              `, [sourceGasRoomId, startDate, endDate]);
              
              if (sourcePricesResult.rows.length > 0) {
                const multiplier = linking.offsetMultiplier || 1;
                const offset = linking.offsetAmount || 0;
                
                console.log(`[Beds24 Sync] Applying ${sourcePricesResult.rows.length} BASE prices to ${room.name} (x${multiplier})`);
                
                for (const row of sourcePricesResult.rows) {
                  const dateStr = row.date.toISOString().split('T')[0];
                  const basePrice = parseFloat(row.cm_price);
                  const linkedPrice = (basePrice * multiplier) + offset;
                  const minStay = row.min_stay || 1;
                  
                  await pool.query(`
                    INSERT INTO room_availability (room_id, date, cm_price, direct_price, min_stay, cm_min_stay, source, updated_at)
                    VALUES ($1, $2, $3, $3, $4, $4, 'beds24-linked', NOW())
                    ON CONFLICT (room_id, date) 
                    DO UPDATE SET 
                      cm_price = $3,
                      direct_price = $3,
                      min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $4 END,
                      cm_min_stay = $4,
                      source = 'beds24-linked',
                      updated_at = NOW()
                  `, [room.gas_room_id, dateStr, linkedPrice, minStay]);
                  
                  totalDaysUpdated++;
                }
              }
            }
          } else {
            // Process V2 calendar data normally
            for (const entry of calendarData) {
              const fromDate = new Date(entry.from);
              const toDate = new Date(entry.to);
              
              for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];
                const numAvail = entry.numAvail || 0;
                const price = entry.price1 || null;
                const minStay = entry.minStay || 1;
                
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                  VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24', NOW())
                  ON CONFLICT (room_id, date) 
                  DO UPDATE SET 
                    cm_price = COALESCE($3, room_availability.cm_price),
                    is_available = $4,
                    is_blocked = $5,
                    min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                    cm_min_stay = $6,
                    source = 'beds24',
                    updated_at = NOW()
                `, [room.gas_room_id, dateStr, price, numAvail > 0, numAvail === 0, minStay]);
                
                totalDaysUpdated++;
              }
            }
          }
        } catch (roomErr) {
          console.error(`Beds24 sync error for room ${room.beds24_room_id}:`, roomErr.message);
        }
      }
      
      return res.json({ success: true, daysUpdated: totalDaysUpdated });
    } else if (adapterCode === 'elevate') {
      // Elevate properties are synced via the Elevate partner API pushing data to us
      // We don't pull from Elevate - they push pricing via PUT /api/elevate/:apiKey/room/:roomId/calendar
      return res.json({ 
        success: true, 
        message: 'Elevate properties receive pricing updates via push from Elevate partner API',
        note: 'No pull sync needed - Elevate pushes data to GAS'
      });
    } else if (adapterCode === 'hostaway') {
      // Hostaway pricing sync - to be implemented
      return res.json({ success: false, error: 'Hostaway pricing sync not yet implemented via this endpoint' });
    } else if (adapterCode === 'smoobu') {
      // Smoobu pricing/availability sync
      const connectionId = prop.connection_id;
      
      // Get connection to find API key
      let smoobuApiKey = null;
      if (connectionId) {
        const connResult = await pool.query('SELECT api_key, access_token FROM gas_sync_connections WHERE id = $1', [connectionId]);
        smoobuApiKey = connResult.rows[0]?.api_key || connResult.rows[0]?.access_token;
      }
      
      // If no API key from connection, try client_settings
      if (!smoobuApiKey) {
        const propResult = await pool.query('SELECT account_id FROM properties WHERE id = $1', [gasPropertyId]);
        const accountId = propResult.rows[0]?.account_id;
        if (accountId) {
          const keyResult = await pool.query(`
            SELECT setting_value FROM client_settings 
            WHERE client_id = (SELECT client_id FROM accounts WHERE id = $1) AND setting_key = 'smoobu_api_key'
          `, [accountId]);
          smoobuApiKey = keyResult.rows[0]?.setting_value;
        }
      }
      
      if (!smoobuApiKey) {
        return res.json({ success: false, error: 'No Smoobu API key found' });
      }
      
      // Get smoobu_id for this property
      const smoobuIdResult = await pool.query(`
        SELECT smoobu_id FROM properties WHERE id = $1
        UNION
        SELECT smoobu_id FROM bookable_units WHERE property_id = $1 AND smoobu_id IS NOT NULL
        LIMIT 1
      `, [gasPropertyId]);
      
      const smoobuApartmentId = smoobuIdResult.rows[0]?.smoobu_id || cmPropertyId;
      
      if (!smoobuApartmentId) {
        return res.json({ success: false, error: 'No Smoobu apartment ID found for this property' });
      }
      
      console.log(`[Smoobu Sync] Fetching rates for apartment ${smoobuApartmentId}`);
      
      const startDate = new Date().toISOString().split('T')[0];
      const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      
      try {
        const ratesResponse = await axios.get(
          `https://login.smoobu.com/api/rates?apartments[]=${smoobuApartmentId}&start_date=${startDate}&end_date=${endDate}`,
          {
            headers: {
              'Api-Key': smoobuApiKey,
              'Cache-Control': 'no-cache'
            },
            timeout: 30000
          }
        );
        
        const ratesData = ratesResponse.data?.data || ratesResponse.data || {};
        const apartmentRates = ratesData[smoobuApartmentId];
        
        console.log(`[Smoobu Sync] Raw response keys:`, Object.keys(ratesData));
        console.log(`[Smoobu Sync] Apartment ${smoobuApartmentId} has ${apartmentRates ? Object.keys(apartmentRates).length : 0} rate entries`);
        
        if (!apartmentRates) {
          return res.json({ success: false, error: 'No rates data returned from Smoobu' });
        }
        
        // Find GAS room
        const roomResult = await pool.query(`
          SELECT id FROM bookable_units WHERE property_id = $1 ORDER BY id LIMIT 1
        `, [gasPropertyId]);
        
        const gasRoomId = roomResult.rows[0]?.id;
        if (!gasRoomId) {
          return res.json({ success: false, error: 'No GAS room found for this property' });
        }
        
        let totalDaysUpdated = 0;
        let availCount = 0;
        let blockedCount = 0;
        
        for (const [date, info] of Object.entries(apartmentRates)) {
          const isAvailable = info.available > 0;
          const price = parseFloat(info.price) || null;
          const minStay = info.min_length_of_stay || 1;
          
          if (isAvailable) availCount++; else blockedCount++;
          
          await pool.query(`
            INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, min_stay, source, updated_at)
            VALUES ($1, $2, $3, $4, $5, $6, 'smoobu', NOW())
            ON CONFLICT (room_id, date) DO UPDATE SET
              cm_price = COALESCE(EXCLUDED.cm_price, room_availability.cm_price),
              is_available = EXCLUDED.is_available,
              is_blocked = NOT EXCLUDED.is_available,
              min_stay = COALESCE(EXCLUDED.min_stay, room_availability.min_stay),
              source = 'smoobu',
              updated_at = NOW()
          `, [gasRoomId, date, price, isAvailable, !isAvailable, minStay]);
          
          totalDaysUpdated++;
        }
        
        console.log(`[Smoobu Sync] Apartment ${smoobuApartmentId}: ${availCount} available, ${blockedCount} blocked`);
        
        return res.json({ success: true, daysUpdated: totalDaysUpdated, available: availCount, blocked: blockedCount });
        
      } catch (smoobuErr) {
        console.error('Smoobu sync error:', smoobuErr.response?.data || smoobuErr.message);
        return res.json({ success: false, error: smoobuErr.response?.data?.message || smoobuErr.message });
      }
      
    } else {
      return res.json({ success: false, error: `Unknown adapter: ${adapterCode}` });
    }
    
  } catch (error) {
    console.error('Sync prices error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Copy images from gas_sync_images to room_images for a property
app.post('/api/gas-sync/properties/:syncPropertyId/copy-images', async (req, res) => {
  try {
    const { syncPropertyId } = req.params;
    
    // Get sync property info
    const propResult = await pool.query(`
      SELECT sp.*, sp.gas_property_id 
      FROM gas_sync_properties sp 
      WHERE sp.id = $1
    `, [syncPropertyId]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Sync property not found' });
    }
    
    const syncProp = propResult.rows[0];
    const gasPropertyId = syncProp.gas_property_id;
    
    if (!gasPropertyId) {
      return res.json({ success: false, error: 'Property not linked to GAS yet' });
    }
    
    // Get sync room mappings - external_id (Beds24 room ID) -> GAS room ID
    const roomMappings = await pool.query(`
      SELECT sr.external_id as beds24_room_id, bu.id as gas_room_id
      FROM gas_sync_room_types sr
      JOIN bookable_units bu ON bu.beds24_room_id = CAST(sr.external_id AS INTEGER)
      WHERE sr.sync_property_id = $1
    `, [syncPropertyId]);
    
    const roomIdMap = {};
    for (const row of roomMappings.rows) {
      roomIdMap[row.beds24_room_id] = row.gas_room_id;
    }
    
    console.log('Room ID map:', roomIdMap);
    
    // Get images from gas_sync_images
    const syncImages = await pool.query(`
      SELECT * FROM gas_sync_images WHERE sync_property_id = $1
    `, [syncPropertyId]);
    
    console.log('Found', syncImages.rows.length, 'sync images');
    
    // Ensure room_images table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_images (
        id SERIAL PRIMARY KEY,
        room_id INTEGER,
        image_key VARCHAR(500),
        image_url TEXT,
        thumbnail_url TEXT,
        caption TEXT,
        display_order INTEGER DEFAULT 0,
        upload_source VARCHAR(50),
        is_active BOOLEAN DEFAULT true,
        is_primary BOOLEAN DEFAULT false,
        alt_text TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    let copied = 0;
    let skipped = 0;
    
    for (const img of syncImages.rows) {
      // Extract Beds24 room ID from external_id (format: "138605-img-25-309239")
      const parts = img.external_id?.split('-') || [];
      const beds24RoomId = parts[parts.length - 1];
      
      // Find GAS room ID
      let gasRoomId = roomIdMap[beds24RoomId];
      
      // If no mapping found, try to find by beds24_room_id directly
      if (!gasRoomId && beds24RoomId) {
        const directMatch = await pool.query(`
          SELECT id FROM bookable_units WHERE beds24_room_id = $1
        `, [parseInt(beds24RoomId)]);
        if (directMatch.rows.length > 0) {
          gasRoomId = directMatch.rows[0].id;
        }
      }
      
      if (!gasRoomId) {
        console.log('No GAS room found for Beds24 room:', beds24RoomId);
        skipped++;
        continue;
      }
      
      // Check if image already exists
      const existing = await pool.query(`
        SELECT id FROM room_images WHERE room_id = $1 AND image_url = $2
      `, [gasRoomId, img.original_url]);
      
      if (existing.rows.length > 0) {
        skipped++;
        continue;
      }
      
      // Insert image
      await pool.query(`
        INSERT INTO room_images (room_id, image_key, image_url, thumbnail_url, caption, display_order, upload_source, is_active, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, 'gas_sync', true, NOW())
      `, [
        gasRoomId,
        img.external_id,
        img.original_url,
        img.thumbnail_url || img.original_url,
        img.caption || '',
        img.sort_order || 0
      ]);
      copied++;
    }
    
    res.json({
      success: true,
      message: `Copied ${copied} images, skipped ${skipped}`,
      copied,
      skipped
    });
    
  } catch (error) {
    console.error('Copy images error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Set V1 API key for a connection (for Fixed Prices fallback)
app.post('/api/gas-sync/connections/:id/set-v1-api-key', async (req, res) => {
  try {
    const { id } = req.params;
    const { v1ApiKey } = req.body;
    
    if (!v1ApiKey) {
      return res.status(400).json({ success: false, error: 'v1ApiKey is required' });
    }
    
    // Get current credentials
    const connResult = await pool.query('SELECT credentials FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    let credentials = connResult.rows[0].credentials || {};
    if (typeof credentials === 'string') {
      credentials = JSON.parse(credentials);
    }
    
    // Add V1 API key to credentials
    credentials.v1ApiKey = v1ApiKey;
    
    // Save updated credentials
    await pool.query(`
      UPDATE gas_sync_connections 
      SET credentials = $1, updated_at = NOW()
      WHERE id = $2
    `, [JSON.stringify(credentials), id]);
    
    console.log(`‚úÖ V1 API key set for connection ${id}`);
    res.json({ success: true, message: 'V1 API key saved. Fixed Prices fallback now enabled.' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get synced properties with their prop keys
app.get('/api/gas-sync/connections/:id/properties-with-keys', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Add columns if not exist
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS gas_property_id INTEGER');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS prop_key_tested BOOLEAN DEFAULT FALSE');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS webhook_tested BOOLEAN DEFAULT FALSE');
    // Add columns required by Calry adapter
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS address TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS city TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS country TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS postal_code TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS latitude DECIMAL(10,7)');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS longitude DECIMAL(10,7)');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS currency VARCHAR(3)');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS description TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS raw_data JSONB');
    
    const result = await pool.query(`
      SELECT p.id, p.external_id, p.name, p.prop_key, p.gas_property_id, p.city, p.country,
             p.prop_key_tested, p.webhook_tested,
             (SELECT COUNT(*) FROM gas_sync_room_types WHERE sync_property_id = p.id) as room_count,
             (SELECT COUNT(*) FROM gas_sync_room_types WHERE sync_property_id = p.id) as room_type_count,
             (SELECT COUNT(*) FROM gas_sync_images WHERE sync_property_id = p.id) as image_count,
             gp.name as gas_property_name,
             a.name as account_name
      FROM gas_sync_properties p
      LEFT JOIN properties gp ON p.gas_property_id = gp.id
      LEFT JOIN accounts a ON gp.account_id = a.id
      WHERE p.connection_id = $1
      ORDER BY p.name
    `, [id]);
    
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Helper function to format amenities as JSON
function formatAmenities(amenities) {
  if (!amenities) return null;
  if (typeof amenities === 'string') {
    // Already a string - try to parse it to validate it's JSON, then return as-is
    try {
      JSON.parse(amenities);
      return amenities;
    } catch (e) {
      // Not valid JSON string, wrap it as array
      return JSON.stringify([amenities]);
    }
  }
  if (Array.isArray(amenities)) {
    return JSON.stringify(amenities);
  }
  if (typeof amenities === 'object') {
    return JSON.stringify(amenities);
  }
  return null;
}

// Helper to extract text from nested Beds24 structures like texts.roomDescription1.EN
function extractText(...args) {
  try {
    for (const val of args) {
      if (!val) continue;
      if (typeof val === 'string' && val.trim()) return val;
      if (typeof val === 'object' && !Array.isArray(val)) {
        // Try common language keys
        const text = val.EN || val.en || val.DE || val.de || val.FR || val.fr || Object.values(val).find(v => typeof v === 'string' && v);
        if (text && typeof text === 'string') return text;
      }
    }
  } catch (e) {
    console.log('extractText error:', e);
  }
  return '';
}

// Debug endpoint to see room raw_data from Beds24
app.get('/api/gas-sync/debug/room-raw-data', async (req, res) => {
  try {
    const { propertyId } = req.query;
    
    const result = await pool.query(`
      SELECT rt.id, rt.external_id, rt.name, rt.raw_data 
      FROM gas_sync_room_types rt
      WHERE rt.sync_property_id = $1
      LIMIT 3
    `, [propertyId]);
    
    const rooms = result.rows.map(r => {
      const rawData = typeof r.raw_data === 'string' ? JSON.parse(r.raw_data) : r.raw_data;
      return {
        id: r.id,
        external_id: r.external_id,
        name: r.name,
        raw_data_keys: Object.keys(rawData || {}),
        texts: rawData?.texts,
        displayName: rawData?.displayName,
        description: rawData?.description,
        auxiliaryText: rawData?.auxiliaryText
      };
    });
    
    res.json({ success: true, rooms });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Debug endpoint to check GAS room data after sync
app.get('/api/gas-sync/debug/gas-room-data', async (req, res) => {
  try {
    const { propertyId } = req.query;
    
    const result = await pool.query(`
      SELECT id, name, display_name, short_description, full_description, cm_room_id, beds24_room_id
      FROM bookable_units
      WHERE property_id = $1
      LIMIT 5
    `, [propertyId]);
    
    res.json({ success: true, rooms: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Debug endpoint to see relationship between individual rooms and room types
app.get('/api/gas-sync/debug/room-mapping', async (req, res) => {
  try {
    const { propertyId } = req.query;
    
    // Get GAS rooms (individual)
    const gasRooms = await pool.query(`
      SELECT id, name, cm_room_id, beds24_room_id 
      FROM bookable_units 
      WHERE property_id = $1
    `, [propertyId]);
    
    // Get sync room types
    const syncRoomTypes = await pool.query(`
      SELECT rt.id, rt.external_id, rt.name, 
             rt.raw_data->>'texts' as texts_json
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
      WHERE sp.gas_property_id = $1
    `, [propertyId]);
    
    res.json({ 
      success: true, 
      gasRooms: gasRooms.rows,
      syncRoomTypes: syncRoomTypes.rows.map(r => ({
        id: r.id,
        external_id: r.external_id,
        name: r.name
      }))
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Link synced property to GAS system - creates property, rooms, and images
app.post('/api/gas-sync/properties/:syncPropertyId/link-to-gas', async (req, res) => {
  try {
    const { syncPropertyId } = req.params;
    let { accountId } = req.body;
    
    // 1. Get synced property data AND connection's account_id
    const syncProp = await pool.query(`
      SELECT sp.*, c.adapter_code, c.account_id as connection_account_id
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [syncPropertyId]);
    
    if (syncProp.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Synced property not found' });
    }
    
    const prop = syncProp.rows[0];
    
    // Use connection's account_id if not provided in request
    if (!accountId) {
      accountId = prop.connection_account_id;
    }
    
    console.log('link-to-gas: Starting for syncPropertyId:', syncPropertyId, 'accountId:', accountId);
    
    if (!accountId) {
      return res.status(400).json({ success: false, error: 'accountId is required' });
    }
    
    console.log('link-to-gas: Property found:', prop.name, 'adapter:', prop.adapter_code);
    
    const rawData = typeof prop.raw_data === 'string' ? JSON.parse(prop.raw_data) : (prop.raw_data || {});
    
    // Log raw data keys for debugging
    console.log('link-to-gas: rawData keys:', Object.keys(rawData).join(', '));
    
    // Initialize variables for extracted data
    let propDescription = '';
    let propShortDesc = '';
    let propHouseRules = '';
    let propCancellation = '';
    let propTerms = '';
    let propDirections = '';
    let propCheckInInstr = '';
    let propCheckOutInstr = '';
    let propAreaInfo = '';
    let propDamagePolicy = '';
    let propDescription1 = '';
    let propDescription2 = '';
    let propDisplayName = '';
    let propAmenities = [];
    let propImages = [];
    let propCheckInTime = '';
    let propCheckOutTime = '';
    let propTimezone = '';
    
    // Handle different adapters
    if (prop.adapter_code === 'calry') {
      // CALRY: Fetch fresh data from Calry API
      console.log('link-to-gas: Processing Calry data - fetching fresh from API');
      
      // Get connection to find integrationAccountId
      const connResult = await pool.query(
        'SELECT credentials, external_account_id FROM gas_sync_connections WHERE id = $1',
        [prop.connection_id]
      );
      
      if (connResult.rows.length > 0 && CALRY_API_TOKEN && CALRY_WORKSPACE_ID) {
        const integrationAccountId = connResult.rows[0].external_account_id;
        console.log('link-to-gas: Fetching from Calry integrationAccountId:', integrationAccountId);
        
        try {
          // Fetch properties from Calry
          const propResponse = await axios.get(`${CALRY_API_BASE}/properties`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId,
              'Content-Type': 'application/json'
            }
          });
          
          const calryProperties = propResponse.data?.data || [];
          const calryProp = calryProperties.find(p => String(p.id) === String(prop.external_id));
          
          if (calryProp) {
            console.log('link-to-gas: Found Calry property:', calryProp.name);
            console.log('link-to-gas: Calry property keys:', Object.keys(calryProp).join(', '));
            
            // Extract data from fresh Calry response
            propDescription = calryProp.description || calryProp.summary || '';
            propShortDesc = calryProp.shortDescription || calryProp.summary || '';
            propHouseRules = calryProp.houseRules || calryProp.rules || '';
            propCancellation = calryProp.cancellationPolicy || '';
            propCheckInTime = calryProp.checkInTime || calryProp.checkinTime || '';
            propCheckOutTime = calryProp.checkOutTime || calryProp.checkoutTime || '';
            propTimezone = calryProp.timezone || '';
            propDisplayName = calryProp.name || prop.name || '';
            
            // Calry amenities
            if (calryProp.amenities && Array.isArray(calryProp.amenities)) {
              calryProp.amenities.forEach(a => {
                if (typeof a === 'string') propAmenities.push(a);
                else if (a.name) propAmenities.push(a.name);
                else if (a.amenity) propAmenities.push(a.amenity);
              });
            }
            
            // Calry images
            propImages = calryProp.pictures || calryProp.images || calryProp.photos || [];
            if (calryProp.thumbnailUrl && propImages.length === 0) {
              propImages = [{ url: calryProp.thumbnailUrl }];
            }
            
            // Also fetch room types
            try {
              const roomResponse = await axios.get(`${CALRY_API_BASE}/room-types/${prop.external_id}`, {
                headers: {
                  'Authorization': `Bearer ${CALRY_API_TOKEN}`,
                  'workspaceId': CALRY_WORKSPACE_ID,
                  'integrationAccountId': integrationAccountId,
                  'Content-Type': 'application/json'
                }
              });
              const calryRooms = roomResponse.data?.data || [];
              console.log('link-to-gas: Fetched', calryRooms.length, 'rooms from Calry');
              
              // Store rooms for later processing
              rawData._calryRooms = calryRooms;
              rawData._calryProperty = calryProp;
            } catch (roomErr) {
              console.log('link-to-gas: Could not fetch Calry rooms:', roomErr.message);
            }
            
            console.log('link-to-gas: Calry extracted - desc:', propDescription?.substring(0, 50), 'amenities:', propAmenities.length, 'images:', propImages.length);
          } else {
            console.log('link-to-gas: Property not found in Calry response');
          }
        } catch (calryErr) {
          console.log('link-to-gas: Calry API error:', calryErr.message);
        }
      } else {
        // Fallback to raw_data if no API access
        propDescription = rawData.description || rawData.summary || '';
        propShortDesc = rawData.shortDescription || rawData.summary || '';
        propHouseRules = rawData.houseRules || rawData.rules || '';
        propCancellation = rawData.cancellationPolicy || '';
        propDisplayName = rawData.name || prop.name || '';
        
        if (rawData.amenities && Array.isArray(rawData.amenities)) {
          rawData.amenities.forEach(a => {
            if (typeof a === 'string') propAmenities.push(a);
            else if (a.name) propAmenities.push(a.name);
          });
        }
        
        propImages = rawData.pictures || rawData.images || rawData.photos || [];
      }
      
    } else {
      // BEDS24 / HOSTAWAY data structure
      // Extract nested data - Beds24 uses texts array with language objects
      let texts = {};
      if (rawData.texts && Array.isArray(rawData.texts) && rawData.texts.length > 0) {
        texts = rawData.texts[0]; // First = default language (usually EN)
      } else if (rawData.texts && typeof rawData.texts === 'object') {
        texts = rawData.texts;
      }
      
      // Extract all text fields from Beds24
      propDescription = extractText(texts.propertyDescription, texts.description, rawData.description);
      propShortDesc = extractText(texts.propertyShortDescription, texts.shortDescription, rawData.shortDescription);
      propHouseRules = extractText(texts.houseRules, texts.propertyHouseRules, rawData.houseRules);
      propCancellation = extractText(texts.cancellationPolicy, texts.cancellation, rawData.cancellationPolicy);
      propTerms = extractText(texts.termsConditions, texts.terms, rawData.termsConditions);
      propDirections = extractText(texts.directions, texts.howToGetThere, rawData.directions);
      propCheckInInstr = extractText(texts.checkInInstructions, rawData.checkInInstructions);
      propCheckOutInstr = extractText(texts.checkOutInstructions, rawData.checkOutInstructions);
      propAreaInfo = extractText(texts.areaInfo, texts.areaDescription, rawData.areaInfo);
      propDamagePolicy = extractText(texts.damagePolicy, rawData.damagePolicy);
      
      // Extract propertyDescription1 and propertyDescription2 for room-level fallbacks
      console.log('link-to-gas: texts.propertyDescription1 type:', typeof texts.propertyDescription1, 'value:', JSON.stringify(texts.propertyDescription1)?.substring(0, 100));
      console.log('link-to-gas: texts.propertyDescription2 type:', typeof texts.propertyDescription2, 'value:', JSON.stringify(texts.propertyDescription2)?.substring(0, 100));
      propDescription1 = extractText(texts.propertyDescription1, rawData.propertyDescription1);
      propDescription2 = extractText(texts.propertyDescription2, rawData.propertyDescription2);
      console.log('link-to-gas: Property fallback texts - propDesc1:', propDescription1?.substring(0,50) || '(empty)', 'propDesc2:', propDescription2?.substring(0,50) || '(empty)');
      
      // Extract property-level display name (Hostaway uses externalListingName)
      propDisplayName = prop.adapter_code === 'hostaway' 
        ? (rawData.externalListingName || '') 
        : '';
    }
    
    console.log('link-to-gas: Extracted texts - desc:', propDescription?.substring(0,50), 'houseRules:', propHouseRules?.substring(0,30));
    console.log('link-to-gas: propDisplayName:', propDisplayName || '(empty)');
    
    // 2. Check if already linked
    let gasPropertyId = null;
    
    // Add all necessary columns
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS gas_property_id INTEGER');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS currency VARCHAR(3) DEFAULT \'GBP\'');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS display_name VARCHAR(500)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS short_description TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS full_description TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS house_rules TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS cancellation_policy TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS terms_conditions TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS directions TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS check_in_instructions TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS check_out_instructions TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS area_info TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS damage_policy TEXT');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS check_in_time VARCHAR(10)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS check_out_time VARCHAR(10)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS contact_email VARCHAR(255)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS contact_phone VARCHAR(50)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS website VARCHAR(255)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS latitude DECIMAL(10,7)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS longitude DECIMAL(10,7)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS postal_code VARCHAR(20)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS state VARCHAR(100)');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS show_on_portfolio BOOLEAN DEFAULT true');
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS portfolio_display JSONB DEFAULT \'{}\'::jsonb');
    
    // Fix: Ensure country column is wide enough for full country names
    await pool.query('ALTER TABLE properties ALTER COLUMN country TYPE VARCHAR(100)').catch(() => {});
    
    if (prop.gas_property_id) {
      gasPropertyId = prop.gas_property_id;
      // Update existing property - only update text fields, skip JSONB columns to avoid type mismatch
      console.log('link-to-gas: Updating existing property', gasPropertyId);
      
      // Parse address - Calry sends it as an object like {"city":"Iiyama-shi","line1":"Toyoda 5480","state":"Nagano-ken","country":"JP","postal_code":"389-2411"}
      let parsedAddr = {};
      if (rawData.address && typeof rawData.address === 'object') {
        parsedAddr = rawData.address;
      } else if (rawData.address && typeof rawData.address === 'string') {
        try { parsedAddr = JSON.parse(rawData.address); } catch(e) { parsedAddr = { line1: rawData.address }; }
      }
      
      // Parse geoLocation - Calry sends as {"lat": x, "lng": y} or {"latitude": x, "longitude": y}
      let geo = {};
      if (rawData.geoLocation && typeof rawData.geoLocation === 'object') {
        geo = rawData.geoLocation;
      } else if (rawData.geoLocation && typeof rawData.geoLocation === 'string') {
        try { geo = JSON.parse(rawData.geoLocation); } catch(e) {}
      }
      
      const addressStr = parsedAddr.line1 || parsedAddr.street || parsedAddr.address1 || (typeof rawData.address === 'string' ? rawData.address : '') || '';
      const cityStr = parsedAddr.city || rawData.city || '';
      const stateStr = parsedAddr.state || rawData.state || rawData.region || '';
      const countryStr = parsedAddr.country || parsedAddr.countryCode || rawData.country || '';
      const postalStr = parsedAddr.postal_code || parsedAddr.postalCode || rawData.postcode || rawData.postalCode || '';
      const latVal = geo.lat || geo.latitude || rawData.latitude ? parseFloat(geo.lat || geo.latitude || rawData.latitude) : null;
      const lngVal = geo.lng || geo.lon || geo.longitude || rawData.longitude ? parseFloat(geo.lng || geo.lon || geo.longitude || rawData.longitude) : null;
      
      console.log('link-to-gas: Parsed address:', addressStr, '|', cityStr, '|', stateStr, '|', countryStr, '|', postalStr);
      console.log('link-to-gas: Parsed coords:', latVal, lngVal);
      
      await pool.query(`
        UPDATE properties SET
          name = $1,
          address = COALESCE(NULLIF($2, ''), address),
          city = COALESCE(NULLIF($3, ''), city),
          state = COALESCE(NULLIF($4, ''), state),
          country = COALESCE(NULLIF($5, ''), country),
          postal_code = COALESCE(NULLIF($6, ''), postal_code),
          property_type = COALESCE(NULLIF($7, ''), property_type),
          check_in_time = COALESCE(NULLIF($8, ''), check_in_time),
          check_out_time = COALESCE(NULLIF($9, ''), check_out_time),
          contact_email = COALESCE(NULLIF($10, ''), contact_email),
          contact_phone = COALESCE(NULLIF($11, ''), contact_phone),
          website = COALESCE(NULLIF($12, ''), website),
          latitude = COALESCE($13, latitude),
          longitude = COALESCE($14, longitude),
          account_id = $15,
          updated_at = NOW()
        WHERE id = $16
      `, [
        prop.name || 'Unnamed Property',
        addressStr,
        cityStr,
        stateStr,
        countryStr,
        postalStr,
        rawData.propertyType || rawData.type || '',
        rawData.checkInStart || rawData.checkInTime || propCheckInTime || '',
        rawData.checkOutEnd || rawData.checkOutTime || propCheckOutTime || '',
        rawData.email || '',
        rawData.phone || '',
        rawData.web || rawData.website || '',
        latVal,
        lngVal,
        accountId,
        gasPropertyId
      ]);
      
      // Property descriptions NOT updated on sync - these are manually curated / AI-generated
      // Only sync structural data: check-in/out times, house rules from PMS, cancellation policy
      
      if (propDisplayName) {
        await pool.query('UPDATE properties SET display_name = $1 WHERE id = $2', [propDisplayName, gasPropertyId]).catch(() => {});
      }
      
      // Sync property_terms with Beds24 data (check-in/out, house rules, cancellation)
      const checkInTime = rawData.checkInStart || rawData.checkInTime || '15:00';
      const checkOutTime = rawData.checkOutEnd || rawData.checkOutTime || '11:00';
      
      await pool.query(`
        INSERT INTO property_terms (property_id, checkin_from, checkout_by, additional_rules, cancellation_policy)
        VALUES ($1, $2, $3, $4, $5)
        ON CONFLICT (property_id) DO UPDATE SET
          checkin_from = COALESCE(NULLIF($2, ''), property_terms.checkin_from),
          checkout_by = COALESCE(NULLIF($3, ''), property_terms.checkout_by),
          additional_rules = COALESCE(NULLIF($4, ''), property_terms.additional_rules),
          cancellation_policy = COALESCE(NULLIF($5, ''), property_terms.cancellation_policy),
          updated_at = NOW()
      `, [
        gasPropertyId,
        checkInTime,
        checkOutTime,
        propHouseRules || '',
        propCancellation || ''
      ]).catch(e => console.log('link-to-gas: property_terms sync:', e.message));
      
      console.log('link-to-gas: Updated property', gasPropertyId);
    } else {
      // Check if property exists by external ID (only check columns that exist for this adapter)
      let existingQuery;
      if (prop.adapter_code === 'beds24') {
        existingQuery = await pool.query(`SELECT id FROM properties WHERE beds24_property_id::text = $1`, [String(prop.external_id)]);
      } else if (prop.adapter_code === 'smoobu') {
        existingQuery = await pool.query(`SELECT id FROM properties WHERE smoobu_id::text = $1`, [String(prop.external_id)]);
      } else {
        // Calry / generic - check cm_property_id
        existingQuery = await pool.query(`SELECT id FROM properties WHERE cm_property_id = $1 AND account_id = $2`, [String(prop.external_id), accountId]);
      }
      const existing = existingQuery;
      
      if (existing.rows.length > 0) {
        gasPropertyId = existing.rows[0].id;
        await pool.query('UPDATE properties SET account_id = $1, updated_at = NOW() WHERE id = $2', [accountId, gasPropertyId]);
        console.log('link-to-gas: Updated existing property', gasPropertyId);
      } else {
        // Create new property with all fields
        console.log('link-to-gas: Creating new property');
        // Ensure the adapter-specific column exists
        if (prop.adapter_code === 'beds24') {
          await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS beds24_property_id VARCHAR(50)');
        } else if (prop.adapter_code === 'smoobu') {
          await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS smoobu_id VARCHAR(50)');
        }
        await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS cm_source VARCHAR(50)');
        
        const adapterColumn = prop.adapter_code === 'beds24' ? 'beds24_property_id' :
                              prop.adapter_code === 'smoobu' ? 'smoobu_id' :
                              prop.adapter_code === 'calry' ? 'cm_property_id' : 'cm_property_id';
        
        console.log('link-to-gas: Creating property with full data');
        
        // Country to currency mapping
        const countryCurrencyMap = {
          'GB': 'GBP', 'UK': 'GBP', 'United Kingdom': 'GBP', 'England': 'GBP', 'Scotland': 'GBP', 'Wales': 'GBP',
          'US': 'USD', 'USA': 'USD', 'United States': 'USD',
          'FR': 'EUR', 'France': 'EUR', 'DE': 'EUR', 'Germany': 'EUR', 'IT': 'EUR', 'Italy': 'EUR', 
          'ES': 'EUR', 'Spain': 'EUR', 'PT': 'EUR', 'Portugal': 'EUR', 'NL': 'EUR', 'Netherlands': 'EUR',
          'BE': 'EUR', 'Belgium': 'EUR', 'AT': 'EUR', 'Austria': 'EUR', 'IE': 'EUR', 'Ireland': 'EUR',
          'GR': 'EUR', 'Greece': 'EUR', 'FI': 'EUR', 'Finland': 'EUR',
          'CH': 'CHF', 'Switzerland': 'CHF',
          'AU': 'AUD', 'Australia': 'AUD',
          'NZ': 'NZD', 'New Zealand': 'NZD',
          'CA': 'CAD', 'Canada': 'CAD',
          'JP': 'JPY', 'Japan': 'JPY',
          'TH': 'THB', 'Thailand': 'THB',
          'MX': 'MXN', 'Mexico': 'MXN',
          'ZA': 'ZAR', 'South Africa': 'ZAR',
          'AE': 'AED', 'UAE': 'AED', 'United Arab Emirates': 'AED',
          'IN': 'INR', 'India': 'INR',
          'SG': 'SGD', 'Singapore': 'SGD',
          'HK': 'HKD', 'Hong Kong': 'HKD',
          'MY': 'MYR', 'Malaysia': 'MYR',
          'ID': 'IDR', 'Indonesia': 'IDR',
          'PH': 'PHP', 'Philippines': 'PHP',
          'VN': 'VND', 'Vietnam': 'VND',
          'KR': 'KRW', 'South Korea': 'KRW',
          'TW': 'TWD', 'Taiwan': 'TWD',
          'BR': 'BRL', 'Brazil': 'BRL',
          'AR': 'ARS', 'Argentina': 'ARS',
          'CL': 'CLP', 'Chile': 'CLP',
          'CO': 'COP', 'Colombia': 'COP',
          'PE': 'PEN', 'Peru': 'PEN',
          'SE': 'SEK', 'Sweden': 'SEK',
          'NO': 'NOK', 'Norway': 'NOK',
          'DK': 'DKK', 'Denmark': 'DKK',
          'PL': 'PLN', 'Poland': 'PLN',
          'CZ': 'CZK', 'Czech Republic': 'CZK', 'Czechia': 'CZK',
          'HU': 'HUF', 'Hungary': 'HUF',
          'RO': 'RON', 'Romania': 'RON',
          'BG': 'BGN', 'Bulgaria': 'BGN',
          'HR': 'HRK', 'Croatia': 'HRK',
          'RU': 'RUB', 'Russia': 'RUB',
          'TR': 'TRY', 'Turkey': 'TRY', 'T√ºrkiye': 'TRY',
          'IL': 'ILS', 'Israel': 'ILS',
          'EG': 'EGP', 'Egypt': 'EGP',
          'MA': 'MAD', 'Morocco': 'MAD',
          'KE': 'KES', 'Kenya': 'KES',
          'NG': 'NGN', 'Nigeria': 'NGN'
        };
        
        // Get currency: first from Beds24/sync, then from country, then default to GBP
        const propCountry = parsedAddr.country || rawData.country || '';
        let propCurrency = prop.currency || rawData.currency;
        if (!propCurrency) {
          propCurrency = countryCurrencyMap[propCountry] || countryCurrencyMap[propCountry.toUpperCase()] || 'GBP';
        }
        
        // Parse address for INSERT (same logic as UPDATE above)
        let insertAddr = {};
        if (rawData.address && typeof rawData.address === 'object') {
          insertAddr = rawData.address;
        } else if (rawData.address && typeof rawData.address === 'string') {
          try { insertAddr = JSON.parse(rawData.address); } catch(e) { insertAddr = { line1: rawData.address }; }
        }
        let insertGeo = {};
        if (rawData.geoLocation && typeof rawData.geoLocation === 'object') {
          insertGeo = rawData.geoLocation;
        } else if (rawData.geoLocation && typeof rawData.geoLocation === 'string') {
          try { insertGeo = JSON.parse(rawData.geoLocation); } catch(e) {}
        }
        
        // INSERT with basic fields only (avoid JSONB columns)
        const propResult = await pool.query(`
          INSERT INTO properties (
            account_id, user_id, ${adapterColumn}, name, 
            address, city, state, country, postal_code, currency,
            property_type, check_in_time, check_out_time,
            contact_email, contact_phone, website, latitude, longitude,
            cm_source, status, created_at
          ) VALUES ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, 'active', NOW())
          RETURNING id
        `, [
          accountId,
          String(prop.external_id),
          prop.name || 'Unnamed Property',
          insertAddr.line1 || insertAddr.street || insertAddr.address1 || (typeof rawData.address === 'string' ? rawData.address : '') || '',
          insertAddr.city || rawData.city || '',
          insertAddr.state || rawData.state || rawData.region || '',
          insertAddr.country || insertAddr.countryCode || rawData.country || '',
          insertAddr.postal_code || insertAddr.postalCode || rawData.postcode || rawData.postalCode || '',
          propCurrency,
          rawData.propertyType || rawData.type || 'vacation_rental',
          rawData.checkInStart || rawData.checkInTime || propCheckInTime || '15:00',
          rawData.checkOutEnd || rawData.checkOutTime || propCheckOutTime || '11:00',
          rawData.email || '',
          rawData.phone || '',
          rawData.web || rawData.website || '',
          insertGeo.lat || insertGeo.latitude || rawData.latitude ? parseFloat(insertGeo.lat || insertGeo.latitude || rawData.latitude) : null,
          insertGeo.lng || insertGeo.lon || insertGeo.longitude || rawData.longitude ? parseFloat(insertGeo.lng || insertGeo.lon || insertGeo.longitude || rawData.longitude) : null,
          prop.adapter_code
        ]);
        gasPropertyId = propResult.rows[0].id;
        console.log('link-to-gas: Created property with ID:', gasPropertyId);
        
        // Update text description fields separately (handle JSONB/TEXT type differences)
        if (propShortDesc) {
          await pool.query('UPDATE properties SET short_description = $1 WHERE id = $2', [propShortDesc, gasPropertyId]).catch(() => {});
        }
        if (propDescription) {
          await pool.query('UPDATE properties SET full_description = $1 WHERE id = $2', [propDescription, gasPropertyId]).catch(() => {});
        }
        if (propHouseRules) {
          await pool.query('UPDATE properties SET house_rules = $1 WHERE id = $2', [propHouseRules, gasPropertyId]).catch(() => {});
        }
        if (propCancellation) {
          await pool.query('UPDATE properties SET cancellation_policy = $1 WHERE id = $2', [propCancellation, gasPropertyId]).catch(() => {});
        }
        if (propTerms) {
          await pool.query('UPDATE properties SET terms_conditions = $1 WHERE id = $2', [propTerms, gasPropertyId]).catch(() => {});
        }
        if (propDirections) {
          await pool.query('UPDATE properties SET directions = $1 WHERE id = $2', [propDirections, gasPropertyId]).catch(() => {});
        }
        if (propCheckInInstr) {
          await pool.query('UPDATE properties SET check_in_instructions = $1 WHERE id = $2', [propCheckInInstr, gasPropertyId]).catch(() => {});
        }
        if (propCheckOutInstr) {
          await pool.query('UPDATE properties SET check_out_instructions = $1 WHERE id = $2', [propCheckOutInstr, gasPropertyId]).catch(() => {});
        }
        if (propAreaInfo) {
          await pool.query('UPDATE properties SET area_info = $1 WHERE id = $2', [propAreaInfo, gasPropertyId]).catch(() => {});
        }
        if (propDamagePolicy) {
          await pool.query('UPDATE properties SET damage_policy = $1 WHERE id = $2', [propDamagePolicy, gasPropertyId]).catch(() => {});
        }
      }
      
      // Link the synced property to GAS property
      await pool.query('UPDATE gas_sync_properties SET gas_property_id = $1 WHERE id = $2', [gasPropertyId, syncPropertyId]);
      console.log('link-to-gas: Linked sync property to GAS property');
    }
    
    // 3. Sync room types to bookable_units
    console.log('link-to-gas: Starting room sync');
    let syncRooms = await pool.query(`
      SELECT * FROM gas_sync_room_types WHERE sync_property_id = $1
    `, [syncPropertyId]);
    
    // Auto-repair: if no gas_sync_room_types exist but bookable_units do, create them
    if (syncRooms.rows.length === 0 && prop.gas_property_id) {
      console.log('link-to-gas: No gas_sync_room_types found, checking bookable_units for auto-repair...');
      const existingUnits = await pool.query(`
        SELECT id, cm_room_id, beds24_room_id, name, max_guests, quantity
        FROM bookable_units WHERE property_id = $1 AND (cm_room_id IS NOT NULL OR beds24_room_id IS NOT NULL)
      `, [prop.gas_property_id]);
      
      if (existingUnits.rows.length > 0) {
        console.log('link-to-gas: Found', existingUnits.rows.length, 'bookable_units to create sync mappings for');
        for (const unit of existingUnits.rows) {
          const extId = String(unit.cm_room_id || unit.beds24_room_id);
          try {
            await pool.query(`
              INSERT INTO gas_sync_room_types (sync_property_id, connection_id, external_id, gas_room_id, name, max_guests, unit_count, synced_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
              ON CONFLICT DO NOTHING
            `, [syncPropertyId, prop.connection_id, extId, unit.id, unit.name, unit.max_guests || 2, unit.quantity || 1]);
          } catch (e) {
            console.log('link-to-gas: auto-repair insert error:', e.message);
          }
        }
        // Re-fetch after repair
        syncRooms = await pool.query(`
          SELECT * FROM gas_sync_room_types WHERE sync_property_id = $1
        `, [syncPropertyId]);
        console.log('link-to-gas: After auto-repair, found', syncRooms.rows.length, 'rooms');
      }
    }
    
    console.log('link-to-gas: Found', syncRooms.rows.length, 'rooms to sync');
    
    // Ensure bookable_units table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS bookable_units (
        id SERIAL PRIMARY KEY,
        property_id INTEGER,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Add more columns to bookable_units
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS cm_room_id VARCHAR(50)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS name VARCHAR(255)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS display_name TEXT');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS max_guests INTEGER');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS base_price DECIMAL(10,2)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS currency VARCHAR(3)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS short_description TEXT');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS full_description TEXT');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS bedrooms INTEGER');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS beds INTEGER');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS bathrooms DECIMAL(3,1)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS size_sqm INTEGER');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS amenities JSONB');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS room_type VARCHAR(100)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS cleaning_fee DECIMAL(10,2)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS security_deposit DECIMAL(10,2)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS status VARCHAR(50)');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS feature_codes TEXT');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS quantity INTEGER DEFAULT 1');
    
    // Add unique constraint to prevent duplicate rooms from channel managers
    try {
      await pool.query('CREATE UNIQUE INDEX IF NOT EXISTS idx_bookable_units_property_cm_room ON bookable_units(property_id, cm_room_id) WHERE cm_room_id IS NOT NULL');
      console.log('‚úÖ bookable_units unique constraint ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  bookable_units unique constraint:', e.message);
    }
    
    // Add unique constraints for image tables (needed for ON CONFLICT)
    try {
      await pool.query('ALTER TABLE room_images ADD COLUMN IF NOT EXISTS image_key VARCHAR(100)');
      await pool.query('CREATE UNIQUE INDEX IF NOT EXISTS idx_room_images_room_key ON room_images(room_id, image_key) WHERE image_key IS NOT NULL');
      console.log('‚úÖ room_images unique constraint ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  room_images unique constraint:', e.message);
    }
    
    try {
      await pool.query('ALTER TABLE property_images ADD COLUMN IF NOT EXISTS image_key VARCHAR(100)');
      await pool.query('CREATE UNIQUE INDEX IF NOT EXISTS idx_property_images_prop_key ON property_images(property_id, image_key) WHERE image_key IS NOT NULL');
      console.log('‚úÖ property_images unique constraint ensured');
    } catch (e) {
      console.log('‚ÑπÔ∏è  property_images unique constraint:', e.message);
    }
    
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS max_adults INTEGER');
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS max_children INTEGER DEFAULT 0');
    
    // Drop FK constraint on gas_room_id if it exists (we'll manage this ourselves)
    await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS gas_room_id INTEGER');
    try {
      await pool.query('ALTER TABLE gas_sync_room_types DROP CONSTRAINT IF EXISTS gas_sync_room_types_gas_room_id_fkey');
    } catch (e) {
      console.log('link-to-gas: FK constraint drop skipped:', e.message);
    }
    
    let roomsCreated = 0;
    let roomsUpdated = 0;
    const roomIdMap = {}; // Map sync room external_id to GAS room id
    
    for (const room of syncRooms.rows) {
      const roomRawData = typeof room.raw_data === 'string' ? JSON.parse(room.raw_data) : (room.raw_data || {});
      
      // Debug: log all raw_data keys
      console.log('link-to-gas: raw_data keys:', Object.keys(roomRawData).join(', '));
      
      // Beds24 texts is an OBJECT with nested language keys: texts.displayName.EN
      const texts = roomRawData.texts || {};
      
      // Debug: log texts keys
      console.log('link-to-gas: texts keys:', Object.keys(texts).filter(k => k !== 'offers').join(', '));
      console.log('link-to-gas: texts.displayName:', JSON.stringify(texts.displayName));
      console.log('link-to-gas: texts.roomDescription1:', JSON.stringify(texts.roomDescription1));
      console.log('link-to-gas: texts.auxiliaryText:', JSON.stringify(texts.auxiliaryText));
      
      // Helper to extract text from Beds24 format: {EN: "...", DE: "...", NL: "..."}
      function getText(val) {
        if (!val) return '';
        if (typeof val === 'string') return val;
        if (typeof val === 'object') {
          return val.EN || val.en || val.DE || val.de || val.FR || val.fr || Object.values(val).find(v => typeof v === 'string' && v.trim()) || '';
        }
        return '';
      }
      
      // Display Name: Hostaway uses externalListingName, Beds24 uses texts.displayName
      let displayName = '';
      if (prop.adapter_code === 'hostaway') {
        // Hostaway: externalListingName is the promotional name for channels
        displayName = roomRawData.externalListingName || rawData.externalListingName || '';
        console.log('link-to-gas: Hostaway externalListingName:', displayName);
      } else {
        // Beds24 Display Name ‚Üí GAS display_name
        displayName = getText(texts.displayName) || '';
      }
      
      // Helper to strip HTML tags, script tags, and decode entities
      function stripHtml(html) {
        if (!html) return '';
        return html
          .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '') // Remove script tags and content
          .replace(/var\s+script\s*=\s*document\.createElement[^;]*;[^}]*appendChild\([^)]*\);?/gi, '') // Remove inline script injection
          .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '') // Remove style tags and content
          .replace(/<[^>]*>/g, '') // Remove remaining HTML tags
          .replace(/&nbsp;/g, ' ')
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&apos;/g, "'")
          // Accented characters
          .replace(/&iuml;/g, '√Ø')
          .replace(/&Iuml;/g, '√è')
          .replace(/&eacute;/g, '√©')
          .replace(/&Eacute;/g, '√â')
          .replace(/&egrave;/g, '√®')
          .replace(/&Egrave;/g, '√à')
          .replace(/&agrave;/g, '√†')
          .replace(/&Agrave;/g, '√Ä')
          .replace(/&acirc;/g, '√¢')
          .replace(/&Acirc;/g, '√Ç')
          .replace(/&ecirc;/g, '√™')
          .replace(/&Ecirc;/g, '√ä')
          .replace(/&ocirc;/g, '√¥')
          .replace(/&Ocirc;/g, '√î')
          .replace(/&ucirc;/g, '√ª')
          .replace(/&Ucirc;/g, '√õ')
          .replace(/&icirc;/g, '√Æ')
          .replace(/&Icirc;/g, '√é')
          .replace(/&ccedil;/g, '√ß')
          .replace(/&Ccedil;/g, '√á')
          .replace(/&ntilde;/g, '√±')
          .replace(/&Ntilde;/g, '√ë')
          .replace(/&ouml;/g, '√∂')
          .replace(/&Ouml;/g, '√ñ')
          .replace(/&uuml;/g, '√º')
          .replace(/&Uuml;/g, '√ú')
          .replace(/&auml;/g, '√§')
          .replace(/&Auml;/g, '√Ñ')
          .replace(/&szlig;/g, '√ü')
          .replace(/&euro;/g, '‚Ç¨')
          .replace(/&pound;/g, '¬£')
          // Numeric entities (&#xxx;)
          .replace(/&#(\d+);/g, (match, dec) => String.fromCharCode(dec))
          .replace(/\s+/g, ' ') // Normalize whitespace
          .trim();
      }
      
      // Beds24 roomDescription1 (Room Description) ‚Üí GAS short_description (for listings)
      // Fallback to propertyDescription1 if room description is empty
      // Check if we have multilingual data from V1 sync-content first
      let shortDescMultilang = roomRawData.short_description || null;
      let fullDescMultilang = roomRawData.full_description || null;
      let displayNameMultilang = roomRawData.displayName || null;
      
      // Helper to safely strip HTML - handles strings and objects
      const safeStripHtml = (val) => {
        if (!val) return '';
        if (typeof val === 'string') return stripHtml(val);
        if (typeof val === 'object') {
          // If it's an object with language keys, return first value
          const firstVal = Object.values(val).find(v => typeof v === 'string');
          return firstVal ? stripHtml(firstVal) : '';
        }
        return String(val);
      };
      
      // If multilingual displayName exists (from V1 sync), use it
      if (displayNameMultilang && typeof displayNameMultilang === 'object' && Object.keys(displayNameMultilang).length > 0) {
        console.log('link-to-gas: Using multilingual displayName from V1 sync, langs:', Object.keys(displayNameMultilang).join(','));
        // Strip HTML from each language
        for (const lang of Object.keys(displayNameMultilang)) {
          if (displayNameMultilang[lang]) {
            displayNameMultilang[lang] = safeStripHtml(displayNameMultilang[lang]);
          }
        }
      } else if (displayName) {
        // Fall back to single language from V2/direct extraction
        displayNameMultilang = { en: safeStripHtml(displayName) };
      } else {
        displayNameMultilang = null;
      }
      
      // If multilingual data exists (from V1 sync), use it directly
      if (shortDescMultilang && typeof shortDescMultilang === 'object' && Object.keys(shortDescMultilang).length > 0) {
        console.log('link-to-gas: Using multilingual short_description from V1 sync, langs:', Object.keys(shortDescMultilang).join(','));
        // Strip HTML from each language
        for (const lang of Object.keys(shortDescMultilang)) {
          if (shortDescMultilang[lang]) {
            shortDescMultilang[lang] = safeStripHtml(shortDescMultilang[lang]);
          }
        }
      } else {
        // Fall back to V2 data (single language)
        let roomShortDescRaw = getText(texts.roomDescription1) || getText(roomRawData.description) || '';
        if (!roomShortDescRaw && propDescription1) {
          roomShortDescRaw = propDescription1;
          console.log('link-to-gas: Using propertyDescription1 as short_description fallback');
        }
        const roomShortDesc = safeStripHtml(roomShortDescRaw);
        shortDescMultilang = roomShortDesc ? { en: roomShortDesc } : null;
      }
      
      if (fullDescMultilang && typeof fullDescMultilang === 'object' && Object.keys(fullDescMultilang).length > 0) {
        console.log('link-to-gas: Using multilingual full_description from V1 sync, langs:', Object.keys(fullDescMultilang).join(','));
        // Strip HTML from each language
        for (const lang of Object.keys(fullDescMultilang)) {
          if (fullDescMultilang[lang]) {
            fullDescMultilang[lang] = safeStripHtml(fullDescMultilang[lang]);
          }
        }
      } else {
        // Fall back to V2 data (single language)
        let roomFullDescRaw = getText(texts.auxiliaryText) || getText(roomRawData.fullDescription) || '';
        if (!roomFullDescRaw && propDescription2) {
          roomFullDescRaw = propDescription2;
          console.log('link-to-gas: Using propertyDescription2 as full_description fallback');
        }
        const roomFullDesc = safeStripHtml(roomFullDescRaw);
        fullDescMultilang = roomFullDesc ? { en: roomFullDesc } : null;
      }
      
      // For backwards compat, extract single-lang versions
      const roomShortDesc = shortDescMultilang ? (shortDescMultilang.en || shortDescMultilang.fr || Object.values(shortDescMultilang)[0] || '') : '';
      const roomFullDesc = fullDescMultilang ? (fullDescMultilang.en || fullDescMultilang.fr || Object.values(fullDescMultilang)[0] || '') : '';
      
      // Also strip HTML from displayName just in case
      displayName = safeStripHtml(displayName);
      
      // Log what we found
      console.log('link-to-gas: Room', room.name);
      console.log('  - displayName:', displayName || '(empty)');
      console.log('  - shortDesc langs:', shortDescMultilang ? Object.keys(shortDescMultilang).join(',') : '(empty)');
      console.log('  - fullDesc langs:', fullDescMultilang ? Object.keys(fullDescMultilang).join(',') : '(empty)');
      
      const roomType = getText(texts.accommodationType) || getText(roomRawData.accommodationType) || '';
      
      // Extract numeric values
      const maxGuests = room.max_guests || roomRawData.maxPeople || roomRawData.maxAdults || 2;
      const basePrice = parseFloat(room.base_price || roomRawData.rackRate) || null;
      const cleaningFee = parseFloat(roomRawData.cleaningFee) || null;
      const securityDeposit = parseFloat(roomRawData.securityDeposit) || null;
      let bedrooms = roomRawData.bedrooms || roomRawData.numBedrooms || null;
      const beds = roomRawData.beds || roomRawData.numBeds || null;
      let bathrooms = roomRawData.bathrooms || roomRawData.numBathrooms || null;
      const sizeSqm = roomRawData.size || roomRawData.sqm || null;
      
      // Extract feature codes for amenities
      // Beds24 sends featureCodes as array where each element is a space-separated group
      // e.g. ["BEDROOM_ENSUITE BED_KING BED_SOFA", "BEDROOM BED_QUEEN", "BATHROOM BATH_TUB"]
      let featureCodes = null;
      let featureCodesArray = null; // Keep original array for structured parsing
      if (roomRawData.featureCodes) {
        if (typeof roomRawData.featureCodes === 'string') {
          featureCodes = roomRawData.featureCodes;
        } else if (Array.isArray(roomRawData.featureCodes)) {
          featureCodesArray = roomRawData.featureCodes; // Preserve array structure
          featureCodes = roomRawData.featureCodes.join(',');
        }
      }
      
      // Log featureCodes for debugging
      console.log('link-to-gas: featureCodes:', featureCodes ? featureCodes.substring(0, 100) : '(none)');
      if (featureCodesArray) {
        console.log('link-to-gas: featureCodesArray (first 5):', JSON.stringify(featureCodesArray.slice(0, 5)));
      }
      
      // Count bedrooms and bathrooms from feature codes if not already set
      // IMPORTANT: Only count actual BEDROOM codes, not BED_ types (those are bed types within bedrooms)
      // Only count actual BATHROOM codes, not BATH_ features (those are bathroom features)
      if (featureCodes) {
        const codes = featureCodes.split(',').map(c => c.trim().toUpperCase());
        if (!bedrooms) {
          // Count only codes that START with BEDROOM (e.g., BEDROOM, BEDROOM_ENSUITE, BEDROOM_MASTER)
          // Do NOT count BED_KING, BED_QUEEN etc - those are bed types, not bedrooms
          const bedroomCodes = codes.filter(c => c.startsWith('BEDROOM'));
          bedrooms = bedroomCodes.length || null;
        }
        if (!bathrooms) {
          // Count only codes that START with BATHROOM (e.g., BATHROOM, BATHROOM_FULL, BATHROOM_HALF)
          // Do NOT count BATH_TUB, BATH_SHOWER etc - those are bathroom features, not bathrooms
          const bathroomCodes = codes.filter(c => c.startsWith('BATHROOM') || c === 'FULLBATH' || c === 'HALFBATH');
          bathrooms = bathroomCodes.length || null;
        }
      }
      
      // Check if room exists (check both cm_room_id and beds24_room_id)
      const beds24RoomIdValue = prop.adapter_code === 'beds24' ? parseInt(room.external_id) : null;
      let existingRoom = await pool.query(`
        SELECT id FROM bookable_units 
        WHERE property_id = $1 AND (cm_room_id::text = $2 OR beds24_room_id = $3)
      `, [gasPropertyId, String(room.external_id), beds24RoomIdValue]);
      
      // If not found by property, check globally by beds24_room_id (unique constraint)
      // This handles rooms that might have been created under wrong property
      if (existingRoom.rows.length === 0 && beds24RoomIdValue) {
        const globalCheck = await pool.query(
          'SELECT id, property_id FROM bookable_units WHERE beds24_room_id = $1',
          [beds24RoomIdValue]
        );
        if (globalCheck.rows.length > 0) {
          console.log(`link-to-gas: Found room ${beds24RoomIdValue} under different property ${globalCheck.rows[0].property_id}, updating to property ${gasPropertyId}`);
          // Move room to correct property and use it
          await pool.query('UPDATE bookable_units SET property_id = $1 WHERE id = $2', [gasPropertyId, globalCheck.rows[0].id]);
          existingRoom = globalCheck;
        }
      }
      
      let gasRoomId;
      
      if (existingRoom.rows.length > 0) {
        gasRoomId = existingRoom.rows[0].id;
        // Update existing room - basic fields first
        console.log('link-to-gas: Updating existing room', gasRoomId, room.name);
        await pool.query(`
          UPDATE bookable_units SET
            name = $1,
            max_guests = COALESCE($2, max_guests),
            base_price = COALESCE($3, base_price),
            room_type = COALESCE(NULLIF($4, ''), room_type),
            bedrooms = COALESCE($5, bedrooms),
            beds = COALESCE($6, beds),
            bathrooms = COALESCE($7, bathrooms),
            size_sqm = COALESCE($8, size_sqm),
            cleaning_fee = COALESCE($9, cleaning_fee),
            security_deposit = COALESCE($10, security_deposit),
            feature_codes = COALESCE(NULLIF($11, ''), feature_codes),
            beds24_room_id = COALESCE($13, beds24_room_id),
            num_bedrooms = COALESCE($5, num_bedrooms),
            num_bathrooms = COALESCE($7, num_bathrooms),
            updated_at = NOW()
          WHERE id = $12
        `, [
          room.name || 'Unnamed Room',
          maxGuests,
          basePrice,
          roomType || '',
          bedrooms,
          beds,
          bathrooms,
          sizeSqm,
          cleaningFee,
          securityDeposit,
          featureCodes,
          gasRoomId,
          prop.adapter_code === 'beds24' ? parseInt(room.external_id) : null
        ]);
        
        // Descriptions NOT updated on sync - these are manually curated / AI-generated
        
        roomsUpdated++;
      } else {
        // Create new room - basic fields first
        console.log('link-to-gas: Creating room', room.name);
        
        // Ensure feature_codes column exists
        await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS feature_codes TEXT').catch(() => {});
        
        const roomResult = await pool.query(`
          INSERT INTO bookable_units (
            property_id, cm_room_id, beds24_room_id, name,
            max_guests, base_price,
            room_type, bedrooms, beds, bathrooms, size_sqm,
            cleaning_fee, security_deposit, feature_codes,
            status, created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, 'available', NOW())
          RETURNING id
        `, [
          gasPropertyId,
          String(room.external_id),
          prop.adapter_code === 'beds24' ? parseInt(room.external_id) : null,  // Set beds24_room_id for Beds24 (as integer)
          room.name || 'Unnamed Room',
          maxGuests,
          basePrice,
          roomType || '',
          bedrooms,
          beds,
          bathrooms,
          sizeSqm,
          cleaningFee,
          securityDeposit,
          featureCodes
        ]);
        gasRoomId = roomResult.rows[0].id;
        
        // Update text fields separately - columns are JSONB, need {"en": "...", "fr": "..."} format (multilingual)
        if (displayNameMultilang && Object.keys(displayNameMultilang).length > 0) {
          const jsonVal = JSON.stringify(displayNameMultilang);
          await pool.query('UPDATE bookable_units SET display_name = $1::jsonb WHERE id = $2', [jsonVal, gasRoomId])
            .catch(e => console.log('link-to-gas: display_name update failed:', e.message));
        }
        if (shortDescMultilang && Object.keys(shortDescMultilang).length > 0) {
          const jsonVal = JSON.stringify(shortDescMultilang);
          await pool.query('UPDATE bookable_units SET short_description = $1::jsonb WHERE id = $2', [jsonVal, gasRoomId])
            .catch(e => console.log('link-to-gas: short_description update failed:', e.message));
        }
        if (fullDescMultilang && Object.keys(fullDescMultilang).length > 0) {
          const jsonVal = JSON.stringify(fullDescMultilang);
          await pool.query('UPDATE bookable_units SET full_description = $1::jsonb WHERE id = $2', [jsonVal, gasRoomId])
            .catch(e => console.log('link-to-gas: full_description update failed:', e.message));
        }
        
        roomsCreated++;
      }
      
      roomIdMap[String(room.external_id)] = gasRoomId;
      
      // Save gas_room_id back to gas_sync_room_types for the fix-room-ids endpoint
      await pool.query('UPDATE gas_sync_room_types SET gas_room_id = $1 WHERE id = $2', [gasRoomId, room.id]);
      
      // Map feature codes to amenities
      if (featureCodes && gasRoomId) {
        const codes = featureCodes.split(',').map(c => c.trim()).filter(c => c);
        
        if (codes.length > 0) {
          // Ensure beds24_code column exists on master_amenities
          await pool.query('ALTER TABLE master_amenities ADD COLUMN IF NOT EXISTS beds24_code VARCHAR(100)').catch(() => {});
          
          // Ensure bookable_unit_amenities table exists
          await pool.query(`
            CREATE TABLE IF NOT EXISTS bookable_unit_amenities (
              id SERIAL PRIMARY KEY,
              bookable_unit_id INTEGER,
              amenity_id INTEGER,
              amenity_code VARCHAR(100),
              amenity_name VARCHAR(255),
              category VARCHAR(100),
              display_order INTEGER DEFAULT 0,
              created_at TIMESTAMP DEFAULT NOW()
            )
          `).catch(() => {});
          
          for (const code of codes) {
            // Try to find matching master amenity by beds24_code or amenity_code
            const masterMatch = await pool.query(`
              SELECT id, amenity_code, amenity_name, category 
              FROM master_amenities 
              WHERE beds24_code = $1 OR amenity_code = $1 OR UPPER(amenity_code) = UPPER($1)
              LIMIT 1
            `, [code]);
            
            if (masterMatch.rows.length > 0) {
              const ma = masterMatch.rows[0];
              // Check if already linked - UI reads from room_amenity_selections
              const existing = await pool.query(
                'SELECT id FROM room_amenity_selections WHERE room_id = $1 AND amenity_id = $2',
                [gasRoomId, ma.id]
              );
              
              if (existing.rows.length === 0) {
                await pool.query(`
                  INSERT INTO room_amenity_selections (room_id, amenity_id, display_order)
                  VALUES ($1, $2, $3)
                  ON CONFLICT (room_id, amenity_id) DO NOTHING
                `, [gasRoomId, ma.id, 0]);
                console.log(`link-to-gas: Mapped amenity ${code} -> ${ma.amenity_name}`);
              }
            }
            // If no match, the feature code is stored in feature_codes column for manual mapping later
          }
        }
      }
      
      // =========================================================
      // AUTO-CREATE BEDROOMS AND BATHROOMS FROM FEATURE CODES
      // =========================================================
      // Beds24 sends featureCodes as array where each element is space-separated:
      // ["BEDROOM_ENSUITE BED_KING BED_SOFA", "BEDROOM BED_QUEEN", "BATHROOM BATH_TUB BATH_SHOWER"]
      // Each BEDROOM line defines one bedroom with its beds
      
      if (gasRoomId && gasPropertyId && (featureCodesArray || featureCodes)) {
        // Map bed codes to friendly names
        const bedNames = {
          'BED_KING': 'King Bed', 'BED_QUEEN': 'Queen Bed', 'BED_DOUBLE': 'Double Bed',
          'BED_SINGLE': 'Single Bed', 'BED_TWIN': 'Twin Bed', 'BED_SOFA': 'Sofa Bed',
          'BED_BUNK': 'Bunk Bed', 'BED_MURPHY': 'Murphy Bed', 'BED_FUTON': 'Futon',
          'BED_CHILD': 'Child Bed', 'BED_CRIB': 'Crib', 'BED_TODDLER': 'Toddler Bed',
          'BED_AIRMATTRESS': 'Air Mattress', 'BED_FLOORMATTRESS': 'Floor Mattress',
          'BED_COUCH': 'Couch', 'BED_HAMMOCK': 'Hammock'
        };
        
        // Parse structured bedroom definitions from array
        const bedroomDefinitions = [];
        const bathroomDefinitions = [];
        
        if (featureCodesArray && featureCodesArray.length > 0) {
          // Use structured array - each element is a space-separated group
          for (const line of featureCodesArray) {
            // Skip if line is not a string
            if (typeof line !== 'string') continue;
            const parts = line.trim().toUpperCase().split(/\s+/);
            
            // Check if this line defines a bedroom
            if (parts.some(p => p.startsWith('BEDROOM'))) {
              const bedroomType = parts.find(p => p.startsWith('BEDROOM')) || 'BEDROOM';
              const isEnsuite = bedroomType.includes('ENSUITE');
              const beds = parts.filter(p => p.startsWith('BED_'));
              
              // Normalize bed codes (handle single/twin combos)
              const normalizedBeds = [];
              for (const bed of beds) {
                if (bed.toLowerCase().includes('/')) {
                  const subParts = bed.split('/');
                  for (const sp of subParts) {
                    const norm = sp.toUpperCase().trim();
                    normalizedBeds.push(norm.startsWith('BED_') ? norm : `BED_${norm}`);
                  }
                } else {
                  normalizedBeds.push(bed);
                }
              }
              
              bedroomDefinitions.push({
                type: bedroomType,
                isEnsuite,
                beds: normalizedBeds
              });
            }
            
            // Check if this line defines a bathroom
            if (parts.some(p => p.startsWith('BATHROOM') || p === 'FULLBATH' || p === 'HALFBATH')) {
              const bathroomType = parts.find(p => p.startsWith('BATHROOM')) || 'BATHROOM';
              const features = parts.filter(p => p.startsWith('BATH_') && !p.startsWith('BATHROOM'));
              
              bathroomDefinitions.push({
                type: bathroomType,
                features
              });
            }
          }
          
          console.log(`link-to-gas: Parsed ${bedroomDefinitions.length} bedroom(s) and ${bathroomDefinitions.length} bathroom(s) from structured featureCodes`);
        }
        
        // Fallback: if no structured array or no bedrooms found, use flat parsing
        if (bedroomDefinitions.length === 0 && featureCodes) {
          const codes = featureCodes.split(',').map(c => c.trim().toUpperCase()).filter(c => c);
          const bedroomCodes = codes.filter(c => c === 'BEDROOM' || c.startsWith('BEDROOM'));
          const bedCodes = codes.filter(c => c.startsWith('BED_'));
          
          // Create one definition per BEDROOM code, distribute beds
          const numBedrooms = bedroomCodes.length || (bedCodes.length > 0 ? 1 : 0);
          
          if (numBedrooms > 0) {
            // Normalize bed codes
            const normalizedBeds = [];
            for (const code of bedCodes) {
              if (code.toLowerCase().includes('/')) {
                const parts = code.split('/');
                for (const part of parts) {
                  const normalized = part.toUpperCase().trim();
                  normalizedBeds.push(normalized.startsWith('BED_') ? normalized : `BED_${normalized}`);
                }
              } else {
                normalizedBeds.push(code);
              }
            }
            
            // Distribute beds across bedrooms
            for (let i = 0; i < numBedrooms; i++) {
              bedroomDefinitions.push({
                type: bedroomCodes[i] || 'BEDROOM',
                isEnsuite: (bedroomCodes[i] || '').includes('ENSUITE'),
                beds: [] // Will be filled below
              });
            }
            
            // Distribute beds round-robin
            normalizedBeds.forEach((bed, idx) => {
              bedroomDefinitions[idx % numBedrooms].beds.push(bed);
            });
          }
          
          // Parse bathrooms from flat codes
          const bathroomCodes = codes.filter(c => c.startsWith('BATHROOM'));
          
          for (const bc of bathroomCodes) {
            bathroomDefinitions.push({
              type: bc,
              features: []
            });
          }
          
          console.log(`link-to-gas: Parsed ${bedroomDefinitions.length} bedroom(s) from flat featureCodes (fallback)`);
        }
        
        // Create bedrooms if we have definitions and none exist
        if (bedroomDefinitions.length > 0) {
          const existingBedrooms = await pool.query(
            'SELECT COUNT(*) as count FROM property_bedrooms WHERE property_id = $1 AND room_id = $2',
            [gasPropertyId, gasRoomId]
          );
          
          if (parseInt(existingBedrooms.rows[0].count) === 0) {
            console.log(`link-to-gas: Auto-creating ${bedroomDefinitions.length} bedroom(s) with their specific beds`);
            
            for (let i = 0; i < bedroomDefinitions.length; i++) {
              const def = bedroomDefinitions[i];
              const bedroomName = bedroomDefinitions.length === 1 ? 'Bedroom' : `Bedroom ${i + 1}`;
              
              // Count bed types for this bedroom
              const bedCounts = {};
              for (const bed of def.beds) {
                bedCounts[bed] = (bedCounts[bed] || 0) + 1;
              }
              
              // Create bed_config array
              const bedConfig = Object.entries(bedCounts).map(([type, qty]) => ({
                type,
                name: bedNames[type] || type.replace('BED_', '').replace(/_/g, ' '),
                quantity: qty
              }));
              
              console.log(`link-to-gas: ${bedroomName}${def.isEnsuite ? ' (ensuite)' : ''}: ${bedConfig.map(b => `${b.quantity}x ${b.name}`).join(', ') || 'no beds'}`);
              
              await pool.query(`
                INSERT INTO property_bedrooms (property_id, room_id, name, bed_config, has_ensuite, display_order)
                VALUES ($1, $2, $3, $4, $5, $6)
              `, [
                gasPropertyId,
                gasRoomId,
                bedroomName,
                JSON.stringify(bedConfig),
                def.isEnsuite,
                i
              ]).catch(e => console.log('link-to-gas: bedroom create failed:', e.message));
            }
            
            // Update num_bedrooms count on bookable_unit
            await pool.query(
              'UPDATE bookable_units SET num_bedrooms = $1 WHERE id = $2',
              [bedroomDefinitions.length, gasRoomId]
            ).catch(e => console.log('link-to-gas: num_bedrooms update failed:', e.message));
            console.log(`link-to-gas: Updated num_bedrooms = ${bedroomDefinitions.length} on room ${gasRoomId}`);
          }
        }
        
        // Parse bathroom codes for bathroom creation
        const codes = featureCodes ? featureCodes.split(',').map(c => c.trim().toUpperCase()).filter(c => c) : [];
        const bathroomTypeCodes = codes.filter(c => c.startsWith('BATHROOM_'));
        const bathFeatureCodes = codes.filter(c => c.startsWith('BATH_') && !c.startsWith('BATHROOM_'));
        
        // Parse bathroom types and features
        const bathroomTypes = {
          'BATHROOM_FULL': 'full',
          'BATHROOM_HALF': 'half',
          'BATHROOM_PRIVATE': 'full',
          'BATHROOM_SHARED': 'shared',
          'BATHROOM_ENSUITE': 'ensuite'
        };
        
        const bathroomFeatureMap = {
          'BATH_TUB': 'tub',
          'BATH_SHOWER': 'shower',
          'BATH_COMBO_TUB_SHOWER': 'combo_tub_shower',
          'BATH_TOILET': 'toilet',
          'BATH_BIDET': 'bidet',
          'BATH_JACUZZI': 'jacuzzi',
          'BATH_OUTDOOR_SHOWER': 'outdoor_shower'
        };
        
        // Count bathroom types
        const bathroomCounts = {};
        for (const code of bathroomTypeCodes) {
          const type = bathroomTypes[code] || 'full';
          bathroomCounts[type] = (bathroomCounts[type] || 0) + 1;
        }
        
        // Build features object
        const features = {};
        for (const code of bathFeatureCodes) {
          const feature = bathroomFeatureMap[code];
          if (feature) {
            features[feature] = true;
          }
        }
        
        // Only create bathrooms if we have bathroom codes and no existing bathrooms
        const numBathrooms = Object.values(bathroomCounts).reduce((a, b) => a + b, 0);
        if (numBathrooms > 0 || Object.keys(features).length > 0) {
          const existingBathrooms = await pool.query(
            'SELECT COUNT(*) as count FROM property_bathrooms WHERE property_id = $1 AND room_id = $2',
            [gasPropertyId, gasRoomId]
          );
          
          if (parseInt(existingBathrooms.rows[0].count) === 0) {
            console.log(`link-to-gas: Auto-creating ${numBathrooms || 1} bathroom(s) with features:`, Object.keys(features).join(', ') || 'none');
            
            // Create bathrooms based on type codes
            let displayOrder = 0;
            if (numBathrooms > 0) {
              for (const [type, count] of Object.entries(bathroomCounts)) {
                for (let i = 0; i < count; i++) {
                  const bathroomName = count === 1 && numBathrooms === 1 ? 'Bathroom' : 
                    `${type.charAt(0).toUpperCase() + type.slice(1)} Bathroom ${displayOrder + 1}`;
                  
                  await pool.query(`
                    INSERT INTO property_bathrooms (property_id, room_id, name, bathroom_type, features, quantity, display_order)
                    VALUES ($1, $2, $3, $4, $5, $6, $7)
                  `, [
                    gasPropertyId,
                    gasRoomId,
                    bathroomName,
                    type,
                    JSON.stringify(features),
                    1,
                    displayOrder++
                  ]).catch(e => console.log('link-to-gas: bathroom create failed:', e.message));
                }
              }
            } else if (Object.keys(features).length > 0) {
              // We have features but no explicit bathroom type - create one full bathroom
              await pool.query(`
                INSERT INTO property_bathrooms (property_id, room_id, name, bathroom_type, features, quantity, display_order)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
              `, [
                gasPropertyId,
                gasRoomId,
                'Bathroom',
                'full',
                JSON.stringify(features),
                1,
                0
              ]).catch(e => console.log('link-to-gas: bathroom create failed:', e.message));
              
              // Update num_bathrooms
              await pool.query(
                'UPDATE bookable_units SET num_bathrooms = 1 WHERE id = $1',
                [gasRoomId]
              ).catch(e => console.log('link-to-gas: num_bathrooms update failed:', e.message));
            }
            
            // Update num_bathrooms count based on total created
            if (numBathrooms > 0) {
              await pool.query(
                'UPDATE bookable_units SET num_bathrooms = $1 WHERE id = $2',
                [numBathrooms, gasRoomId]
              ).catch(e => console.log('link-to-gas: num_bathrooms update failed:', e.message));
              console.log(`link-to-gas: Updated num_bathrooms = ${numBathrooms} on room ${gasRoomId}`);
            }
          }
        }
      }
    }
    
    // 4. Sync images to room_images
    // Ensure room_images table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_images (
        id SERIAL PRIMARY KEY,
        room_id INTEGER,
        image_key VARCHAR(500),
        image_url TEXT,
        thumbnail_url TEXT,
        caption TEXT,
        display_order INTEGER DEFAULT 0,
        upload_source VARCHAR(50),
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Skip images if requested (for quick re-syncs)
    const { skipImages } = req.body;
    let imagesCreated = 0;
    let syncImages = { rows: [] };
    
    // Handle Calry rooms and images directly (not from gas_sync_room_types/gas_sync_images)
    if (prop.adapter_code === 'calry' && rawData._calryRooms && rawData._calryRooms.length > 0) {
      console.log('link-to-gas: Processing Calry rooms directly:', rawData._calryRooms.length);
      
      for (const room of rawData._calryRooms) {
        const roomExternalId = String(room.id);
        
        // Log raw room data for debugging
        console.log('link-to-gas: Calry room raw keys:', Object.keys(room).join(', '));
        
        // Extract room data - comprehensive mapping
        const roomName = room.name || rawData._calryProperty?.name || 'Room';
        const roomDesc = room.description || room.longDescription || room.summary || '';
        const shortDesc = room.shortDescription || room.summary || '';
        const maxGuests = room.maxOccupancy || room.maxGuests || room.capacity || 2;
        const maxAdults = room.maxAdults || room.maxOccupancy || maxGuests;
        const maxChildren = room.maxChildren || 0;
        const bedrooms = room.bedRoom?.count || room.bedrooms || room.numberOfBedrooms || room.bedroomCount || 1;
        const bathrooms = room.bathRoom?.count || room.bathrooms || room.numberOfBathrooms || room.bathroomCount || 1;
        const basePrice = parseFloat(room.startPrice || room.basePrice || room.price || 0);
        const roomType = room.roomType || room.type || room.accommodationType || 'entire_place';
        const sizeSqm = room.size || room.area || room.squareMeters || null;
        const currency = room.currency || rawData._calryProperty?.currency || 'EUR';
        
        // Room amenities - extract as array
        const roomAmenities = [];
        if (room.amenities && Array.isArray(room.amenities)) {
          room.amenities.forEach(a => {
            if (typeof a === 'string') roomAmenities.push(a);
            else if (a.name) roomAmenities.push(a.name);
            else if (a.amenity) roomAmenities.push(a.amenity);
          });
        }
        console.log('link-to-gas: Room amenities extracted:', roomAmenities.length);
        
        // Bedroom configuration - Lodgify stores in rooms[0].beds
        let bedroomConfig = room.bedRoom?.beds || room.bedTypes || room.beds || room.bedConfiguration || [];
        // Also check rooms array (Lodgify format)
        if ((!bedroomConfig || bedroomConfig.length === 0) && room.rooms && Array.isArray(room.rooms) && room.rooms[0]?.beds) {
          bedroomConfig = room.rooms[0].beds;
          console.log('link-to-gas: Found beds in rooms[0].beds:', JSON.stringify(bedroomConfig));
        }
        console.log('link-to-gas: Bedroom config:', JSON.stringify(bedroomConfig).substring(0, 200));
        
        // Bathroom configuration  
        const bathroomConfig = room.bathRoom?.types || room.bathroomTypes || room.bathrooms || [];
        console.log('link-to-gas: Bathroom config:', JSON.stringify(bathroomConfig).substring(0, 200));
        
        // Check if room exists
        const existingRoom = await pool.query(
          'SELECT id FROM bookable_units WHERE property_id = $1 AND cm_room_id = $2',
          [gasPropertyId, roomExternalId]
        );
        
        let gasRoomId;
        
        // Prepare descriptions as JSONB
        const fullDescJson = roomDesc ? JSON.stringify({ en: roomDesc }) : null;
        const shortDescJson = shortDesc ? JSON.stringify({ en: shortDesc }) : null;
        
        if (existingRoom.rows.length > 0) {
          gasRoomId = existingRoom.rows[0].id;
          console.log('link-to-gas: Updating Calry room', gasRoomId, roomName);
          
          await pool.query(`
            UPDATE bookable_units SET
              name = $1,
              max_guests = $2,
              max_adults = $3,
              max_children = $4,
              num_bedrooms = $5,
              num_bathrooms = $6,
              base_price = $7,
              currency = $8,
              room_type = $9,
              size_sqm = $10,
              amenities = $11,
              updated_at = NOW()
            WHERE id = $12
          `, [
            roomName,
            maxGuests,
            maxAdults,
            maxChildren,
            bedrooms,
            bathrooms,
            basePrice,
            currency,
            roomType,
            sizeSqm,
            JSON.stringify({ amenities: roomAmenities, calry_id: room.id, raw_amenities: room.amenities }),
            gasRoomId
          ]);
          
          // Descriptions NOT updated on sync - these are manually curated / AI-generated
          
          roomsUpdated++;
        } else {
          console.log('link-to-gas: Creating Calry room', roomName);
          
          const roomResult = await pool.query(`
            INSERT INTO bookable_units (
              property_id, cm_room_id, cm_source, name,
              max_guests, max_adults, max_children,
              num_bedrooms, num_bathrooms, base_price, currency,
              room_type, size_sqm, amenities, status, created_at
            ) VALUES ($1, $2, 'calry', $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'active', NOW())
            RETURNING id
          `, [
            gasPropertyId,
            roomExternalId,
            roomName,
            maxGuests,
            maxAdults,
            maxChildren,
            bedrooms,
            bathrooms,
            basePrice,
            currency,
            roomType,
            sizeSqm,
            JSON.stringify({ amenities: roomAmenities, calry_id: room.id, raw_amenities: room.amenities })
          ]);
          gasRoomId = roomResult.rows[0].id;
          
          // Update descriptions separately (JSONB columns)
          if (fullDescJson) {
            await pool.query('UPDATE bookable_units SET full_description = $1::jsonb WHERE id = $2', [fullDescJson, gasRoomId])
              .catch(e => console.log('link-to-gas: full_description update skipped:', e.message));
          }
          if (shortDescJson) {
            await pool.query('UPDATE bookable_units SET short_description = $1::jsonb WHERE id = $2', [shortDescJson, gasRoomId])
              .catch(e => console.log('link-to-gas: short_description update skipped:', e.message));
          }
          
          roomsCreated++;
        }
        
        roomIdMap[roomExternalId] = gasRoomId;
        
        // ===== SYNC AMENITIES TO room_amenities TABLE =====
        if (roomAmenities.length > 0) {
          try {
            for (const amenityName of roomAmenities) {
              // Find or create amenity
              let amenityResult = await pool.query(
                "SELECT id FROM amenities WHERE LOWER(name) = LOWER($1)",
                [amenityName]
              );
              
              let amenityId;
              if (amenityResult.rows.length > 0) {
                amenityId = amenityResult.rows[0].id;
              } else {
                const newAmenity = await pool.query(
                  "INSERT INTO amenities (name, created_at) VALUES ($1, NOW()) RETURNING id",
                  [amenityName]
                );
                amenityId = newAmenity.rows[0].id;
              }
              
              // Link amenity to room
              await pool.query(`
                INSERT INTO room_amenities (room_id, amenity_id)
                VALUES ($1, $2)
                ON CONFLICT DO NOTHING
              `, [gasRoomId, amenityId]);
            }
            console.log('link-to-gas: Synced', roomAmenities.length, 'amenities for room', gasRoomId);
          } catch (amenErr) {
            console.log('link-to-gas: Amenity sync skipped:', amenErr.message);
          }
        }
        
        // ===== SYNC BEDROOM CONFIGURATION =====
        if (bedroomConfig && (Array.isArray(bedroomConfig) ? bedroomConfig.length > 0 : typeof bedroomConfig === 'object')) {
          try {
            // Clear existing bedrooms for this room
            await pool.query('DELETE FROM property_bedrooms WHERE room_id = $1', [gasRoomId]);
            
            const bedsArray = Array.isArray(bedroomConfig) ? bedroomConfig : [bedroomConfig];
            let bedroomOrder = 1;
            
            // Group beds by bedroom (each bed entry becomes a bedroom with that bed type)
            for (const bed of bedsArray) {
              // Handle different bed config formats
              let bedType = 'bed_double';
              let bedCount = 1;
              let bedroomName = `Bedroom ${bedroomOrder}`;
              
              if (typeof bed === 'string') {
                bedType = bed.toLowerCase().replace(/\s+/g, '_');
              } else if (bed.type || bed.bedType) {
                bedType = (bed.type || bed.bedType).toLowerCase().replace(/\s+/g, '_');
                bedCount = bed.count || bed.quantity || 1;
                bedroomName = bed.name || bed.roomName || `Bedroom ${bedroomOrder}`;
              } else if (bed.name) {
                // bed.name might be "King Bed", "Queen Bed", etc.
                bedType = bed.name.toLowerCase().replace(/\s+/g, '_');
                bedCount = bed.count || 1;
              }
              
              // Skip beds with count 0 (e.g., SleepingBedLinen)
              if (bedCount === 0) {
                console.log('link-to-gas: Skipping bed with count 0:', bedType);
                continue;
              }
              
              // Normalize bed type to our standard codes (handle Lodgify's Sleeping* format)
              const bedTypeLower = bedType.toLowerCase();
              if (bedTypeLower.includes('king')) bedType = 'bed_king';
              else if (bedTypeLower.includes('queen')) bedType = 'bed_queen';
              else if (bedTypeLower.includes('double')) bedType = 'bed_double';
              else if (bedTypeLower.includes('single') || bedTypeLower.includes('twin')) bedType = 'bed_single';
              else if (bedTypeLower.includes('sofa')) bedType = 'bed_sofa_double';
              else if (bedTypeLower.includes('bunk')) bedType = 'bed_bunk';
              else if (bedTypeLower.includes('cot') || bedTypeLower.includes('crib')) bedType = 'bed_cot';
              else if (bedTypeLower.includes('futon')) bedType = 'bed_futon';
              else bedType = 'bed_double'; // Default
              
              console.log('link-to-gas: Adding bed:', bedType, 'x', bedCount);
              
              // Use bed_config JSONB column
              const bedConfig = JSON.stringify({ beds: [{ type: bedType, count: bedCount }] });
              
              await pool.query(`
                INSERT INTO property_bedrooms (property_id, room_id, name, bed_config, has_ensuite, display_order, created_at, updated_at)
                VALUES ((SELECT property_id FROM bookable_units WHERE id = $1), $1, $2, $3::jsonb, false, $4, NOW(), NOW())
              `, [gasRoomId, bedroomName, bedConfig, bedroomOrder]);
              
              bedroomOrder++;
            }
            console.log('link-to-gas: Synced', bedroomOrder - 1, 'bedroom configs for room', gasRoomId);
          } catch (bedErr) {
            console.log('link-to-gas: Bedroom config sync skipped:', bedErr.message);
          }
        }
        
        // ===== SYNC BATHROOM CONFIGURATION =====
        // Lodgify returns bathRoom: {count: 2} so we need to handle that
        const bathroomCount = room.bathRoom?.count || bathrooms || 1;
        if (bathroomCount > 0) {
          try {
            // Clear existing bathrooms for this room
            await pool.query('DELETE FROM property_bathrooms WHERE room_id = $1', [gasRoomId]);
            
            // If we have detailed config, use it; otherwise create based on count
            let bathsArray = [];
            if (bathroomConfig && Array.isArray(bathroomConfig) && bathroomConfig.length > 0) {
              bathsArray = bathroomConfig;
            } else {
              // Create bathrooms based on count
              for (let i = 0; i < bathroomCount; i++) {
                bathsArray.push({ type: i === 0 ? 'bathroom_private_ensuite' : 'bathroom_full' });
              }
            }
            
            let bathroomOrder = 1;
            
            for (const bath of bathsArray) {
              let bathType = 'bathroom_full';
              
              if (typeof bath === 'string') {
                bathType = bath.toLowerCase().replace(/\s+/g, '_');
              } else if (bath.type || bath.bathType) {
                bathType = (bath.type || bath.bathType).toLowerCase().replace(/\s+/g, '_');
              }
              
              // Normalize bathroom type
              if (bathType.includes('ensuite') || bathType.includes('private')) bathType = 'bathroom_private_ensuite';
              else if (bathType.includes('shared')) bathType = 'bathroom_shared';
              else if (bathType.includes('half')) bathType = 'bathroom_half';
              else bathType = 'bathroom_full';
              
              await pool.query(`
                INSERT INTO property_bathrooms (property_id, room_id, bathroom_type, quantity, display_order, created_at)
                VALUES ((SELECT property_id FROM bookable_units WHERE id = $1), $1, $2, 1, $3, NOW())
              `, [gasRoomId, bathType, bathroomOrder]);
              
              bathroomOrder++;
            }
            console.log('link-to-gas: Synced', bathroomOrder - 1, 'bathroom configs for room', gasRoomId);
          } catch (bathErr) {
            console.log('link-to-gas: Bathroom config sync skipped:', bathErr.message);
          }
        }
        
        // Import room images
        const roomPictures = room.pictures || room.images || room.photos || [];
        for (let i = 0; i < roomPictures.length; i++) {
          const pic = roomPictures[i];
          const imageUrl = typeof pic === 'string' ? pic : (pic.url || pic.original || pic.large);
          if (!imageUrl) continue;
          
          const imageKey = `calry_room_${gasRoomId}_${i}`;
          const caption = typeof pic === 'object' ? (pic.caption || pic.description || '') : '';
          
          try {
            // Check if image exists first
            const existingImg = await pool.query(
              'SELECT id FROM property_images WHERE property_id = $1 AND image_key = $2',
              [gasPropertyId, imageKey]
            );
            if (existingImg.rows.length > 0) {
              await pool.query(
                'UPDATE property_images SET room_id = $1, image_url = $2, url = $2, caption = $3, display_order = $4, updated_at = NOW() WHERE id = $5',
                [gasRoomId, imageUrl, caption, i, existingImg.rows[0].id]
              );
            } else {
              await pool.query(`
                INSERT INTO property_images (property_id, room_id, image_key, image_url, url, caption, display_order, is_primary, is_active, created_at)
                VALUES ($1, $2, $3, $4, $4, $5, $6, $7, true, NOW())
              `, [gasPropertyId, gasRoomId, imageKey, imageUrl, caption, i, i === 0]);
            }
            imagesCreated++;
          } catch (e) {
            console.log('link-to-gas: Room image insert error:', e.message);
          }
        }
      }
      
      // Also import property-level images
      if (propImages.length > 0) {
        console.log('link-to-gas: Importing', propImages.length, 'Calry property images');
        for (let i = 0; i < propImages.length; i++) {
          const pic = propImages[i];
          const imageUrl = typeof pic === 'string' ? pic : (pic.url || pic.original || pic.large || pic.medium);
          if (!imageUrl) continue;
          
          const imageKey = `calry_prop_${gasPropertyId}_${i}`;
          const caption = typeof pic === 'object' ? (pic.caption || pic.description || '') : '';
          
          try {
            // Check if image exists first
            const existingImg = await pool.query(
              'SELECT id FROM property_images WHERE property_id = $1 AND image_key = $2',
              [gasPropertyId, imageKey]
            );
            if (existingImg.rows.length > 0) {
              await pool.query(
                'UPDATE property_images SET image_url = $1, url = $1, caption = $2, display_order = $3, updated_at = NOW() WHERE id = $4',
                [imageUrl, caption, i, existingImg.rows[0].id]
              );
            } else {
              await pool.query(`
                INSERT INTO property_images (property_id, image_key, image_url, url, caption, display_order, is_primary, is_active, created_at)
                VALUES ($1, $2, $3, $3, $4, $5, $6, true, NOW())
              `, [gasPropertyId, imageKey, imageUrl, caption, i, i === 0]);
            }
            imagesCreated++;
          } catch (e) {
            console.log('link-to-gas: Property image insert error:', e.message);
          }
        }
      }
    }
    
    if (!skipImages && prop.adapter_code !== 'calry') {
      console.log('link-to-gas: Starting image sync');
      syncImages = await pool.query(`
        SELECT * FROM gas_sync_images WHERE sync_property_id = $1
      `, [syncPropertyId]);
      console.log('link-to-gas: Found', syncImages.rows.length, 'images to check');
      
      for (const img of syncImages.rows) {
        // Find the GAS room ID for this image
        const gasRoomId = roomIdMap[String(img.room_type_external_id)];
        
        if (!gasRoomId) {
          continue; // Skip quietly - room might not exist
        }
        
        // Check if image already exists (by URL to avoid duplicates)
        const existingImg = await pool.query(`
          SELECT id FROM room_images WHERE room_id = $1 AND image_url = $2
        `, [gasRoomId, img.original_url]);
        
        if (existingImg.rows.length === 0) {
          await pool.query(`
            INSERT INTO room_images (
              room_id, image_key, image_url, thumbnail_url,
              caption, display_order, upload_source, is_active, created_at
            ) VALUES ($1, $2, $3, $4, $5, $6, 'gas_sync', true, NOW())
          `, [
            gasRoomId,
            img.external_id,
            img.original_url,
            img.thumbnail_url || img.original_url,
            img.caption || '',
            img.sort_order || 0
          ]);
          imagesCreated++;
        }
      }
    } else if (prop.adapter_code !== 'calry') {
      console.log('link-to-gas: Skipping image sync (skipImages=true)');
    }
    
    // Count images for response
    const imageCount = skipImages ? 'skipped' : (syncImages?.rows?.length || 0);
    
    // Auto-translate room content if account has languages configured
    let translatedRooms = 0;
    try {
      // Get account's configured languages
      const accountResult = await pool.query(
        'SELECT settings FROM accounts WHERE id = $1',
        [prop.account_id]
      );
      const accountSettings = accountResult.rows[0]?.settings || {};
      const supportedLangs = accountSettings.languages?.supported || [];
      
      if (supportedLangs.length > 1 && DEEPL_API_KEY) {
        console.log('link-to-gas: Auto-translating to languages:', supportedLangs.join(', '));
        
        // Get all rooms we just synced that need translation
        const roomsToTranslate = await pool.query(`
          SELECT id, display_name, short_description, full_description
          FROM bookable_units
          WHERE property_id = $1
        `, [gasPropertyId]);
        
        for (const room of roomsToTranslate.rows) {
          try {
            // Determine source language from content
            let sourceLang = 'en';
            const shortDesc = room.short_description;
            if (typeof shortDesc === 'object' && shortDesc) {
              sourceLang = shortDesc._source || (shortDesc.en ? 'en' : shortDesc.fr ? 'fr' : Object.keys(shortDesc).find(k => !k.startsWith('_')) || 'en');
            }
            
            // Check if any supported language is missing
            const needsTranslation = supportedLangs.some(lang => {
              if (lang === sourceLang) return false;
              const hasDisplayName = room.display_name?.[lang];
              const hasShortDesc = room.short_description?.[lang];
              return !hasDisplayName || !hasShortDesc;
            });
            
            if (!needsTranslation) continue;
            
            // Translate each field
            const updates = [];
            const params = [];
            let paramIndex = 1;
            
            // Translate display_name
            if (room.display_name) {
              let displayNameObj = room.display_name;
              if (typeof displayNameObj === 'string') {
                try { displayNameObj = JSON.parse(displayNameObj); } catch(e) { displayNameObj = { [sourceLang]: displayNameObj }; }
              }
              const translated = await translateFieldToLanguages(displayNameObj, sourceLang, supportedLangs);
              if (translated && Object.keys(translated).length > 0) {
                updates.push(`display_name = $${paramIndex}::jsonb`);
                params.push(JSON.stringify(translated));
                paramIndex++;
              }
            }
            
            // Translate short_description
            if (room.short_description) {
              let shortDescObj = room.short_description;
              if (typeof shortDescObj === 'string') {
                try { shortDescObj = JSON.parse(shortDescObj); } catch(e) { shortDescObj = { [sourceLang]: shortDescObj }; }
              }
              const translated = await translateFieldToLanguages(shortDescObj, sourceLang, supportedLangs);
              if (translated && Object.keys(translated).length > 0) {
                updates.push(`short_description = $${paramIndex}::jsonb`);
                params.push(JSON.stringify(translated));
                paramIndex++;
              }
            }
            
            // Translate full_description
            if (room.full_description) {
              let fullDescObj = room.full_description;
              if (typeof fullDescObj === 'string') {
                try { fullDescObj = JSON.parse(fullDescObj); } catch(e) { fullDescObj = { [sourceLang]: fullDescObj }; }
              }
              const translated = await translateFieldToLanguages(fullDescObj, sourceLang, supportedLangs);
              if (translated && Object.keys(translated).length > 0) {
                updates.push(`full_description = $${paramIndex}::jsonb`);
                params.push(JSON.stringify(translated));
                paramIndex++;
              }
            }
            
            if (updates.length > 0) {
              params.push(room.id);
              await pool.query(`UPDATE bookable_units SET ${updates.join(', ')}, updated_at = NOW() WHERE id = $${paramIndex}`, params);
              translatedRooms++;
            }
          } catch (roomErr) {
            console.log('link-to-gas: Translation error for room', room.id, roomErr.message);
          }
        }
        
        if (translatedRooms > 0) {
          console.log(`link-to-gas: Auto-translated ${translatedRooms} rooms`);
        }
      }
    } catch (translateErr) {
      console.log('link-to-gas: Auto-translation error:', translateErr.message);
    }
    
    res.json({
      success: true,
      message: 'Property linked to GAS',
      gasPropertyId,
      stats: {
        roomsCreated,
        roomsUpdated,
        roomsTranslated: translatedRooms,
        imagesCreated,
        totalRooms: syncRooms.rows.length,
        totalImages: imageCount
      }
    });
  } catch (error) {
    console.error('Link to GAS error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Debug endpoint to check Beds24 calendar format
app.post('/api/gas-sync/connections/:id/debug-calendar', async (req, res) => {
  try {
    const { id } = req.params;
    const { roomId, propertyId, days = 7 } = req.body;
    
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    const credentials = typeof conn.credentials === 'string' ? JSON.parse(conn.credentials) : conn.credentials;
    const accessToken = conn.access_token || credentials?.token;
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token' });
    }
    
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    const results = {};
    
    // Build params based on what was provided
    const calParams = { 
      startDate: startDate, 
      endDate: endDate,
      includeNumAvail: true,
      includePrices: true,
      includeMinStay: true
    };
    if (roomId) calParams.roomId = parseInt(roomId);
    if (propertyId) calParams.propertyId = parseInt(propertyId);
    
    // Try calendar endpoint
    try {
      const calendarResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
        params: calParams,
        headers: { 'token': accessToken }
      });
      results.calendar = calendarResponse.data;
      results.calendarParams = calParams;  // Include params for debugging
    } catch (e) {
      results.calendar_error = e.response?.data || e.message;
    }
    
    // Try availability endpoint (inventory status)
    try {
      const availParams = { from: startDate, to: endDate };
      if (roomId) availParams.roomId = parseInt(roomId);
      if (propertyId) availParams.propertyId = parseInt(propertyId);
      
      const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
        params: availParams,
        headers: { 'token': accessToken }
      });
      results.availability = availResponse.data;
    } catch (e) {
      results.availability_error = e.response?.data || e.message;
    }
    
    // Try fixedPrices endpoint
    try {
      const priceParams = {};
      if (roomId) priceParams.roomId = parseInt(roomId);
      if (propertyId) priceParams.propertyId = parseInt(propertyId);
      
      const pricesResponse = await axios.get('https://beds24.com/api/v2/inventory/fixedPrices', {
        params: priceParams,
        headers: { 'token': accessToken }
      });
      results.fixedPrices = pricesResponse.data;
    } catch (e) {
      results.fixedPrices_error = e.response?.data || e.message;
    }
    
    // Try rooms/offers endpoint
    try {
      const offersParams = { arrival: startDate, departure: endDate };
      if (roomId) offersParams.roomId = parseInt(roomId);
      if (propertyId) offersParams.propertyId = parseInt(propertyId);
      
      const offersResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
        params: offersParams,
        headers: { 'token': accessToken }
      });
      results.offers = offersResponse.data;
    } catch (e) {
      results.offers_error = e.response?.data || e.message;
    }
    
    // Try properties endpoint with priceRules (to check priceLinking)
    if (propertyId) {
      try {
        const propsResponse = await axios.get('https://beds24.com/api/v2/properties', {
          params: { 
            id: parseInt(propertyId),
            includeAllRooms: true,
            includePriceRules: true
          },
          headers: { 'token': accessToken }
        });
        results.propertyWithRules = propsResponse.data;
      } catch (e) {
        results.propertyWithRules_error = e.response?.data || e.message;
      }
    }
    
    res.json({ 
      success: true, 
      roomId,
      propertyId,
      dateRange: { startDate, endDate },
      results
    });
    
  } catch (error) {
    res.json({ success: false, error: error.response?.data || error.message });
  }
});

// Debug endpoint to check price_linking status for a connection
app.get('/api/gas-sync/connections/:id/price-linking-status', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get rooms with price_linking
    const withLinking = await pool.query(`
      SELECT rt.id, rt.external_id, rt.name, rt.price_linking, sp.name as property_name
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
      WHERE sp.connection_id = $1 AND rt.price_linking IS NOT NULL
    `, [id]);
    
    // Get rooms without price_linking
    const withoutLinking = await pool.query(`
      SELECT rt.id, rt.external_id, rt.name, sp.name as property_name
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
      WHERE sp.connection_id = $1 AND rt.price_linking IS NULL
    `, [id]);
    
    res.json({
      success: true,
      withPriceLinking: withLinking.rows.length,
      withoutPriceLinking: withoutLinking.rows.length,
      linkedRooms: withLinking.rows,
      unlinkedRooms: withoutLinking.rows.slice(0, 10) // Just first 10
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Fix beds24_room_id for existing rooms (one-time migration)
app.post('/api/gas-sync/connections/:id/fix-room-ids', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get connection
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    if (conn.adapter_code !== 'beds24') {
      return res.json({ success: false, error: 'Only Beds24 connections supported' });
    }
    
    // Update bookable_units with beds24_room_id from gas_sync_room_types
    // Cast external_id to integer since beds24_room_id column is integer
    const result = await pool.query(`
      UPDATE bookable_units bu
      SET beds24_room_id = rt.external_id::integer
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
      WHERE rt.gas_room_id = bu.id
        AND sp.connection_id = $1
        AND bu.beds24_room_id IS NULL
      RETURNING bu.id, bu.name, rt.external_id as beds24_room_id
    `, [id]);
    
    res.json({ 
      success: true, 
      message: `Updated ${result.rowCount} rooms with beds24_room_id`,
      rooms: result.rows
    });
    
  } catch (error) {
    console.error('Fix room IDs error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Clear last_error for a connection
app.post('/api/gas-sync/connections/:id/clear-error', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('UPDATE gas_sync_connections SET last_error = NULL WHERE id = $1', [id]);
    res.json({ success: true, message: 'Error cleared' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Reconnect Beds24 - exchange new invite code for fresh tokens
app.post('/api/gas-sync/connections/:id/reconnect', async (req, res) => {
  try {
    const { id } = req.params;
    const { inviteCode } = req.body;
    
    if (!inviteCode) {
      return res.status(400).json({ success: false, error: 'inviteCode is required' });
    }
    
    // Get connection
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    if (conn.adapter_code !== 'beds24') {
      return res.json({ success: false, error: 'Only Beds24 connections supported' });
    }
    
    // Exchange invite code for token
    console.log('Reconnect: Exchanging invite code for token...');
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/setup', {
      headers: {
        'accept': 'application/json',
        'code': inviteCode
      }
    });
    
    if (!tokenResponse.data.token || !tokenResponse.data.refreshToken) {
      return res.status(400).json({ 
        success: false, 
        error: 'Failed to exchange invite code. Please generate a new one.' 
      });
    }
    
    // Update credentials
    let credentials = typeof conn.credentials === 'string' 
      ? JSON.parse(conn.credentials) 
      : (conn.credentials || {});
    
    credentials.token = tokenResponse.data.token;
    credentials.refreshToken = tokenResponse.data.refreshToken;
    credentials.expiresIn = tokenResponse.data.expiresIn;
    delete credentials.inviteCode;
    
    await pool.query(`
      UPDATE gas_sync_connections SET 
        credentials = $1,
        access_token = $2,
        refresh_token = $3,
        status = 'connected',
        last_error = NULL,
        last_error_at = NULL,
        updated_at = NOW()
      WHERE id = $4
    `, [JSON.stringify(credentials), credentials.token, credentials.refreshToken, id]);
    
    console.log('Reconnect: Token refreshed successfully');
    
    res.json({ success: true, message: 'Connection reconnected with fresh token' });
    
  } catch (error) {
    console.error('Reconnect error:', error.response?.data || error.message);
    res.status(500).json({ success: false, error: error.response?.data?.error || error.message });
  }
});

// Sync availability and pricing from Beds24 using OFFERS API (like Lehmann)
app.post('/api/gas-sync/connections/:connectionId/sync-availability', async (req, res) => {
  try {
    const { connectionId } = req.params;
    const { days = 14 } = req.body; // Default 14 days for speed
    
    // Get connection
    const connResult = await pool.query(
      'SELECT * FROM gas_sync_connections WHERE id = $1',
      [connectionId]
    );
    
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    
    // Route to appropriate handler based on adapter
    if (conn.adapter_code === 'calry') {
      // ===== CALRY AVAILABILITY SYNC =====
      const integrationAccountId = conn.external_account_id;
      
      if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
        return res.json({ success: false, error: 'Calry not configured on server' });
      }
      
      // Get all synced properties with linked rooms
      // Note: external_id might be room type ID, cm_property_id should be the actual Calry property ID
      const propsResult = await pool.query(`
        SELECT sp.id, sp.external_id, sp.cm_property_id, sp.name, sp.gas_property_id,
               p.cm_property_id as prop_cm_property_id
        FROM gas_sync_properties sp
        LEFT JOIN properties p ON p.id = sp.gas_property_id
        WHERE sp.connection_id = $1 AND sp.gas_property_id IS NOT NULL
      `, [connectionId]);
      
      if (propsResult.rows.length === 0) {
        return res.json({ success: false, error: 'No linked properties found.' });
      }
      
      console.log(`[Calry Sync] Found ${propsResult.rows.length} properties to sync`);
      
      // Ensure room_availability table exists
      await pool.query(`
        CREATE TABLE IF NOT EXISTS room_availability (
          id SERIAL PRIMARY KEY,
          room_id INTEGER NOT NULL,
          date DATE NOT NULL,
          cm_price DECIMAL(10,2),
          direct_price DECIMAL(10,2),
          is_available BOOLEAN DEFAULT true,
          is_blocked BOOLEAN DEFAULT false,
          min_stay INTEGER DEFAULT 1,
          max_stay INTEGER,
          source VARCHAR(50),
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          UNIQUE(room_id, date)
        )
      `);
      
      const today = new Date();
      const startDate = today.toISOString().split('T')[0];
      const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      
      let totalDaysUpdated = 0;
      let roomsSynced = 0;
      const errors = [];
      const debug = [];
      
      for (const prop of propsResult.rows) {
        try {
          // Try multiple sources for the Calry property ID
          const calryPropertyId = prop.cm_property_id || prop.prop_cm_property_id || prop.external_id;
          
          console.log(`[Calry Sync] Property: ${prop.name}`);
          console.log(`[Calry Sync]   - external_id: ${prop.external_id}`);
          console.log(`[Calry Sync]   - cm_property_id: ${prop.cm_property_id}`);
          console.log(`[Calry Sync]   - prop_cm_property_id: ${prop.prop_cm_property_id}`);
          console.log(`[Calry Sync]   - Using calryPropertyId: ${calryPropertyId}`);
          
          debug.push({
            property: prop.name,
            external_id: prop.external_id,
            cm_property_id: prop.cm_property_id,
            prop_cm_property_id: prop.prop_cm_property_id,
            using: calryPropertyId
          });
          
          if (!calryPropertyId) {
            errors.push({ property: prop.name, error: 'No Calry property ID found' });
            continue;
          }
          
          // Get room types for this property
          console.log(`[Calry Sync] Fetching room types from: /vrs/room-types/${calryPropertyId}`);
          const roomTypesResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/room-types/${calryPropertyId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId,
              'Content-Type': 'application/json'
            },
            timeout: 30000
          });
          
          const roomTypes = roomTypesResponse.data?.data || roomTypesResponse.data || [];
          console.log(`[Calry Sync] Found ${roomTypes.length} room types: ${roomTypes.map(rt => rt.id).join(', ')}`);
          
          for (const roomType of roomTypes) {
            const roomTypeId = String(roomType.id);
            
            // Find matching GAS room
            const roomResult = await pool.query(`
              SELECT id, name FROM bookable_units 
              WHERE property_id = $1 AND (cm_room_id = $2 OR cm_room_id = $3)
            `, [prop.gas_property_id, roomTypeId, roomTypeId.toString()]);
            
            let gasRoomId = roomResult.rows[0]?.id;
            let gasRoomName = roomResult.rows[0]?.name;
            
            if (!gasRoomId) {
              // Fall back to first room
              const anyRoom = await pool.query(`SELECT id, name FROM bookable_units WHERE property_id = $1 LIMIT 1`, [prop.gas_property_id]);
              gasRoomId = anyRoom.rows[0]?.id;
              gasRoomName = anyRoom.rows[0]?.name;
              if (gasRoomId) {
                await pool.query(`UPDATE bookable_units SET cm_room_id = $1 WHERE id = $2`, [roomTypeId, gasRoomId]);
                console.log(`[Calry Sync] Linked room type ${roomTypeId} to GAS room ${gasRoomId} (${gasRoomName})`);
              }
            }
            
            if (!gasRoomId) {
              console.log(`[Calry Sync] No GAS room found for room type ${roomTypeId}`);
              continue;
            }
            
            // FIXED: URL uses propertyId, query param uses roomTypeId
            console.log(`[Calry Sync] Fetching availability: /vrs/availability/${calryPropertyId}?roomTypeId=${roomTypeId}`);
            const availResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${calryPropertyId}`, {
              headers: {
                'Authorization': `Bearer ${CALRY_API_TOKEN}`,
                'workspaceId': CALRY_WORKSPACE_ID,
                'integrationAccountId': integrationAccountId,
                'Content-Type': 'application/json'
              },
              params: { startDate, endDate, roomTypeId: roomTypeId, rates: 'true' },
              timeout: 30000
            });
            
            // Response structure: { success: true, data: { propertyId, roomTypeId, dateWiseAvailability: [...] } }
            const responseData = availResponse.data?.data || availResponse.data || {};
            const availData = responseData.dateWiseAvailability || responseData.data || responseData || [];
            console.log(`[Calry Sync] Got ${Array.isArray(availData) ? availData.length : 'non-array'} availability records`);
            
            if (Array.isArray(availData) && availData.length > 0) {
              console.log(`[Calry Sync] Sample: ${JSON.stringify(availData[0])}`);
              
              for (const day of availData) {
                const date = day.date;
                if (!date) continue;
                
                // Handle price in different formats
                let price = null;
                if (day.price) {
                  if (typeof day.price === 'object' && day.price.amount !== undefined) {
                    price = parseFloat(day.price.amount);
                  } else {
                    price = parseFloat(day.price);
                  }
                }
                
                // Handle availability status - check multiple indicators
                const hasReservation = day.reservationIds && day.reservationIds.length > 0;
                const noUnitsAvailable = day.unitsAvailable === 0 || day.unitsAvailable === '0';
                const statusBlocked = day.status === 'BLOCKED' || day.status === 'blocked';
                
                const isAvailable = !hasReservation && !noUnitsAvailable && !statusBlocked && 
                                   (day.status === 'AVAILABLE' || day.available !== false);
                                   
                const minStay = day.minimumNights || day.minStay || day.minimumStay || 1;
                const maxStay = day.maximumNights || day.maxStay || day.maximumStay || null;
                
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, max_stay, source)
                  VALUES ($1, $2, $3, $3, $4, $5, $6, $7, 'calry')
                  ON CONFLICT (room_id, date) 
                  DO UPDATE SET 
                    cm_price = COALESCE($3, room_availability.cm_price),
                    direct_price = COALESCE($3, room_availability.direct_price),
                    is_available = $4,
                    is_blocked = $5,
                    min_stay = $6,
                    max_stay = $7,
                    source = 'calry',
                    updated_at = NOW()
                `, [gasRoomId, date, price, isAvailable, !isAvailable, minStay, maxStay]);
                
                totalDaysUpdated++;
              }
              roomsSynced++;
            }
          }
        } catch (propError) {
          console.error(`Calry sync error for property ${prop.name}:`, propError.message);
          errors.push({ property: prop.name, error: propError.message });
        }
      }
      
      await pool.query('UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1', [connectionId]);
      
      return res.json({
        success: true,
        message: 'Calry availability sync complete',
        stats: { propertiesChecked: propsResult.rows.length, roomsSynced, totalDaysUpdated, days },
        errors: errors.length > 0 ? errors : undefined,
        debug: debug
      });
    }
    
    // ===== SMOOBU AVAILABILITY SYNC =====
    if (conn.adapter_code === 'smoobu') {
      const smoobuApiKey = conn.api_key || conn.access_token;
      
      if (!smoobuApiKey) {
        return res.json({ success: false, error: 'Smoobu API key not found for this connection' });
      }
      
      // Get all synced properties with linked rooms
      const propsResult = await pool.query(`
        SELECT sp.id, sp.external_id as smoobu_apartment_id, sp.name, sp.gas_property_id
        FROM gas_sync_properties sp
        WHERE sp.connection_id = $1 AND sp.gas_property_id IS NOT NULL
      `, [connectionId]);
      
      if (propsResult.rows.length === 0) {
        return res.json({ success: false, error: 'No linked properties found.' });
      }
      
      console.log(`[Smoobu Sync] Found ${propsResult.rows.length} properties to sync`);
      
      // Ensure room_availability table exists
      await pool.query(`
        CREATE TABLE IF NOT EXISTS room_availability (
          id SERIAL PRIMARY KEY,
          room_id INTEGER NOT NULL,
          date DATE NOT NULL,
          cm_price DECIMAL(10,2),
          direct_price DECIMAL(10,2),
          is_available BOOLEAN DEFAULT true,
          is_blocked BOOLEAN DEFAULT false,
          min_stay INTEGER DEFAULT 1,
          max_stay INTEGER,
          source VARCHAR(50),
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          UNIQUE(room_id, date)
        )
      `);
      
      const today = new Date();
      const startDate = today.toISOString().split('T')[0];
      const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
      
      let totalDaysUpdated = 0;
      let roomsSynced = 0;
      const errors = [];
      
      // Collect all apartment IDs for batch request
      const apartmentIds = propsResult.rows.map(p => p.smoobu_apartment_id).filter(Boolean);
      
      if (apartmentIds.length === 0) {
        return res.json({ success: false, error: 'No Smoobu apartment IDs found' });
      }
      
      console.log(`[Smoobu Sync] Fetching rates for apartments: ${apartmentIds.join(', ')}`);
      
      try {
        // Smoobu rates endpoint returns availability and pricing
        const ratesResponse = await axios.get(
          `https://login.smoobu.com/api/rates?${apartmentIds.map(id => `apartments[]=${id}`).join('&')}&start_date=${startDate}&end_date=${endDate}`,
          {
            headers: {
              'Api-Key': smoobuApiKey,
              'Cache-Control': 'no-cache'
            },
            timeout: 30000
          }
        );
        
        const ratesData = ratesResponse.data?.data || ratesResponse.data || {};
        console.log(`[Smoobu Sync] Raw response keys:`, Object.keys(ratesData));
        
        for (const prop of propsResult.rows) {
          const apartmentId = prop.smoobu_apartment_id;
          const apartmentRates = ratesData[apartmentId];
          
          if (!apartmentRates) {
            console.log(`[Smoobu Sync] No rates data for apartment ${apartmentId}`);
            continue;
          }
          
          // Find GAS room for this property
          const roomResult = await pool.query(`
            SELECT id, name FROM bookable_units 
            WHERE property_id = $1 
            ORDER BY id LIMIT 1
          `, [prop.gas_property_id]);
          
          const gasRoomId = roomResult.rows[0]?.id;
          if (!gasRoomId) {
            console.log(`[Smoobu Sync] No GAS room found for property ${prop.name}`);
            continue;
          }
          
          let availCount = 0;
          let blockedCount = 0;
          
          // Smoobu returns rates as { "2026-01-24": { available: 1, price: 100, min_length_of_stay: 2 }, ... }
          for (const [date, info] of Object.entries(apartmentRates)) {
            const isAvailable = info.available > 0;
            const price = parseFloat(info.price) || null;
            const minStay = info.min_length_of_stay || 1;
            
            if (isAvailable) availCount++; else blockedCount++;
            
            await pool.query(`
              INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, source)
              VALUES ($1, $2, $3, $3, $4, $5, $6, 'smoobu')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET 
                cm_price = COALESCE($3, room_availability.cm_price),
                direct_price = COALESCE($3, room_availability.direct_price),
                is_available = $4,
                is_blocked = $5,
                min_stay = $6,
                source = 'smoobu',
                updated_at = NOW()
            `, [gasRoomId, date, price, isAvailable, !isAvailable, minStay]);
            
            totalDaysUpdated++;
          }
          
          console.log(`[Smoobu Sync] Property ${prop.name}: ${availCount} available, ${blockedCount} blocked`);
          roomsSynced++;
        }
        
      } catch (smoobuError) {
        console.error('[Smoobu Sync] Error:', smoobuError.response?.data || smoobuError.message);
        errors.push({ error: smoobuError.message });
      }
      
      await pool.query('UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1', [connectionId]);
      
      return res.json({
        success: true,
        message: 'Smoobu availability sync complete',
        stats: { propertiesChecked: propsResult.rows.length, roomsSynced, totalDaysUpdated, days },
        errors: errors.length > 0 ? errors : undefined
      });
    }
    
    // ===== BEDS24 AVAILABILITY SYNC =====
    if (conn.adapter_code !== 'beds24') {
      return res.json({ success: false, error: 'Only Beds24, Calry and Smoobu connections supported' });
    }
    
    // Get access token - try stored token first, then refresh
    let accessToken = conn.access_token;
    const refreshToken = conn.refresh_token;
    
    if (!accessToken && refreshToken) {
      try {
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': refreshToken }
        });
        accessToken = tokenResponse.data.token;
        await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [accessToken, connectionId]);
      } catch (tokenError) {
        return res.json({ success: false, error: 'Token expired. Please reconnect.' });
      }
    }
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token. Please reconnect to Beds24.' });
    }
    
    // Get all synced properties with linked rooms
    const propsResult = await pool.query(`
      SELECT sp.id, sp.external_id, sp.name, sp.gas_property_id
      FROM gas_sync_properties sp
      WHERE sp.connection_id = $1 AND sp.gas_property_id IS NOT NULL
    `, [connectionId]);
    
    if (propsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No linked properties found.' });
    }
    
    // Ensure room_availability table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_availability (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL,
        date DATE NOT NULL,
        cm_price DECIMAL(10,2),
        direct_price DECIMAL(10,2),
        is_available BOOLEAN DEFAULT true,
        is_blocked BOOLEAN DEFAULT false,
        min_stay INTEGER DEFAULT 1,
        max_stay INTEGER,
        source VARCHAR(50),
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(room_id, date)
      )
    `);
    
    const today = new Date();
    let totalDaysUpdated = 0;
    let roomsSynced = 0;
    const errors = [];
    
    // Build price linking map for all rooms - fetch in batches with long delays
    const priceLinkingMap = {};
    console.log(`Building price linking map for ${propsResult.rows.length} properties...`);
    
    // Fetch properties one at a time with 3 second delays to avoid rate limits
    for (let i = 0; i < propsResult.rows.length; i++) {
      const prop = propsResult.rows[i];
      try {
        const propResp = await axios.get('https://beds24.com/api/v2/properties', {
          headers: { 'token': accessToken },
          params: { 
            id: prop.external_id,
            includeAllRooms: true,
            includePriceRules: true
          }
        });
        
        const propData = propResp.data?.data?.[0];
        if (propData?.roomTypes) {
          for (const rt of propData.roomTypes) {
            const priceRule = rt.priceRules?.find(pr => pr.priceLinking?.roomId);
            if (priceRule?.priceLinking) {
              priceLinkingMap[rt.id] = {
                sourceRoomId: priceRule.priceLinking.roomId,
                priceId: priceRule.priceLinking.priceId || 1,
                offsetAmount: priceRule.priceLinking.offsetAmount || 0,
                offsetMultiplier: priceRule.priceLinking.offsetMultiplier || 1
              };
              
              // Also store in database for future use
              await pool.query(`
                UPDATE gas_sync_room_types SET price_linking = $1 WHERE external_id = $2
              `, [JSON.stringify(priceLinkingMap[rt.id]), String(rt.id)]);
            }
          }
        }
      } catch (e) {
        if (e.response?.status === 429) {
          console.log(`  Rate limited at property ${i+1}/${propsResult.rows.length} - waiting 60 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 60000));
          i--; // Retry this property
          continue;
        }
        // Silently skip other errors
      }
      
      // 3 second delay between properties
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
    
    console.log(`Price linking map built: ${Object.keys(priceLinkingMap).length} rooms with linked pricing`);
    
    // Cache for source room prices (avoid fetching same source multiple times)
    const sourceRoomPriceCache = {};
    
    for (const prop of propsResult.rows) {
      console.log(`Syncing availability for ${prop.name} (Beds24 ID: ${prop.external_id})`);
      
      // Get rooms for this property
      const roomsResult = await pool.query(`
        SELECT rt.external_id as beds24_room_id, rt.gas_room_id, bu.name
        FROM gas_sync_room_types rt
        JOIN bookable_units bu ON bu.id = rt.gas_room_id
        WHERE rt.sync_property_id = $1 AND rt.gas_room_id IS NOT NULL
      `, [prop.id]);
      
      if (roomsResult.rows.length === 0) {
        console.log(`  No linked rooms for ${prop.name}`);
        continue;
      }
      
      // Sync each room using CALENDAR API, fallback to fixedPrices if empty
      for (const room of roomsResult.rows) {
        try {
          let daysWithPrice = 0;
          let daysBlocked = 0;
          const beds24RoomId = parseInt(room.beds24_room_id);
          
          const startDate = today.toISOString().split('T')[0];
          const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
          
          // Check if this room has price linking
          const linking = priceLinkingMap[beds24RoomId];
          
          // Try CALENDAR API first - one call gets everything
          const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
            headers: { 'token': accessToken },
            params: { 
              roomId: beds24RoomId, 
              startDate, 
              endDate,
              includeNumAvail: true,
              includePrices: true,
              includeMinStay: true
            }
          });
          
          let calendarData = calResponse.data.data?.[0]?.calendar || [];
          
          // If no prices and has price linking, fetch from source room (with caching)
          const hasNoPrices = calendarData.length === 0 || !calendarData.some(e => e.price1);
          if (hasNoPrices && linking) {
            console.log(`  ${room.name}: No prices, fetching from linked room ${linking.sourceRoomId} (offset +${linking.offsetAmount})`);
            
            // Check cache first
            const cacheKey = `${linking.sourceRoomId}_${startDate}_${endDate}`;
            let sourcePriceMap = sourceRoomPriceCache[cacheKey];
            
            if (!sourcePriceMap) {
              try {
                const sourceCalResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
                  headers: { 'token': accessToken },
                  params: { 
                    roomId: linking.sourceRoomId, 
                    startDate, 
                    endDate,
                    includeNumAvail: true,
                    includePrices: true,
                    includeMinStay: true
                  }
                });
                
                const sourceCalendar = sourceCalResponse.data.data?.[0]?.calendar || [];
                
                // Create a price map from source (raw prices, offset applied later)
                sourcePriceMap = {};
                for (const entry of sourceCalendar) {
                  if (entry.price1) {
                    const fromDate = new Date(entry.from);
                    const toDate = new Date(entry.to);
                    for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                      const dateStr = d.toISOString().split('T')[0];
                      sourcePriceMap[dateStr] = entry.price1; // Store raw price, apply offset per-room
                    }
                  }
                }
                
                // Cache it
                sourceRoomPriceCache[cacheKey] = sourcePriceMap;
                console.log(`    Fetched and cached ${Object.keys(sourcePriceMap).length} prices from source room`);
              } catch (sourceErr) {
                console.log(`    Failed to fetch source room prices: ${sourceErr.message}`);
                sourcePriceMap = {};
              }
            } else {
              console.log(`    Using cached prices from source room (${Object.keys(sourcePriceMap).length} days)`);
            }
            
            // Apply offset to get final prices for this room
            const applyOffset = (price) => price ? (price * (linking.offsetMultiplier || 1)) + (linking.offsetAmount || 0) : null;
            
            // Merge source prices into calendarData
            if (calendarData.length > 0) {
              // Expand each calendar entry to individual days with prices
              const expandedData = [];
              for (const entry of calendarData) {
                const fromDate = new Date(entry.from);
                const toDate = new Date(entry.to);
                for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                  const dateStr = d.toISOString().split('T')[0];
                  expandedData.push({
                    from: dateStr,
                    to: dateStr,
                    numAvail: entry.numAvail,
                    minStay: entry.minStay,
                    price1: entry.price1 || applyOffset(sourcePriceMap[dateStr])
                  });
                }
              }
              calendarData = expandedData;
            } else {
              // No calendar data at all - create from source prices for requested date range
              calendarData = [];
              for (let i = 0; i < days; i++) {
                const d = new Date(today);
                d.setDate(d.getDate() + i);
                const dateStr = d.toISOString().split('T')[0];
                if (sourcePriceMap[dateStr]) {
                  calendarData.push({
                    from: dateStr,
                    to: dateStr,
                    numAvail: 1, // Assume available if we have no data
                    minStay: 1,
                    price1: applyOffset(sourcePriceMap[dateStr])
                  });
                }
              }
            }
          }
          
          if (calendarData.length > 0) {
            // Calendar has data - use it (Adelphi style)
            for (const entry of calendarData) {
              const fromDate = new Date(entry.from);
              const toDate = new Date(entry.to);
              
              for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];
                
                const numAvail = entry.numAvail || 0;
                const price = entry.price1 || null;
                const minStay = entry.minStay || 1;
                
                const isAvailable = numAvail > 0;
                const isBlocked = numAvail === 0;
                
                if (price !== null) daysWithPrice++;
                if (isBlocked) daysBlocked++;
                
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source)
                  VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24')
                  ON CONFLICT (room_id, date) 
                  DO UPDATE SET 
                    cm_price = COALESCE($3, room_availability.cm_price),
                    direct_price = COALESCE($3, room_availability.direct_price),
                    is_available = $4,
                    is_blocked = $5,
                    min_stay = $6,
                    cm_min_stay = $6,
                    source = 'beds24',
                    updated_at = NOW()
                `, [room.gas_room_id, dateStr, price, isAvailable, isBlocked, minStay]);
                
                totalDaysUpdated++;
              }
            }
          } else {
            // Calendar empty - use fixedPrices + availability (Belmont style)
            console.log(`  Calendar empty for ${room.name}, using fixedPrices fallback`);
            
            // Get fixedPrices
            const pricesResponse = await axios.get('https://beds24.com/api/v2/inventory/fixedPrices', {
              headers: { 'token': accessToken },
              params: { roomId: beds24RoomId }
            });
            const priceRules = (pricesResponse.data.data || []).filter(r => r.offerId === 1);
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Get availability
            const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
              headers: { 'token': accessToken },
              params: { roomId: beds24RoomId, startDate, endDate }
            });
            const availData = availResponse.data.data?.[0]?.availability || {};
            
            // Helper to find price for a date from fixedPrices rules
            const findPriceForDate = (dateStr) => {
              const matchingRules = priceRules.filter(rule => 
                dateStr >= rule.firstNight && dateStr <= rule.lastNight
              );
              if (matchingRules.length === 0) return null;
              // Use highest ID (most recent rule) if multiple match
              const bestRule = matchingRules.reduce((best, curr) => 
                curr.id > best.id ? curr : best
              );
              return { price: bestRule.roomPrice, minStay: bestRule.minNights || 1 };
            };
            
            // Process each day
            for (let i = 0; i < days; i++) {
              const dateObj = new Date(today);
              dateObj.setDate(dateObj.getDate() + i);
              const dateStr = dateObj.toISOString().split('T')[0];
              
              const isAvailable = availData[dateStr] === true;
              const isBlocked = !isAvailable;
              
              const priceInfo = findPriceForDate(dateStr);
              const price = priceInfo?.price || null;
              const minStay = priceInfo?.minStay || 1;
              
              if (price !== null) daysWithPrice++;
              if (isBlocked) daysBlocked++;
              
              await pool.query(`
                INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source)
                VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24')
                ON CONFLICT (room_id, date) 
                DO UPDATE SET 
                  cm_price = COALESCE($3, room_availability.cm_price),
                  direct_price = COALESCE($3, room_availability.direct_price),
                  is_available = $4,
                  is_blocked = $5,
                  min_stay = $6,
                  cm_min_stay = $6,
                  source = 'beds24',
                  updated_at = NOW()
              `, [room.gas_room_id, dateStr, price, isAvailable, isBlocked, minStay]);
              
              totalDaysUpdated++;
            }
          }
          
          roomsSynced++;
          console.log(`  ‚úì ${room.name}: ${daysWithPrice} prices, ${daysBlocked} blocked`);
          
          // Delay between rooms to avoid rate limits (5 seconds)
          await new Promise(resolve => setTimeout(resolve, 5000));
          
        } catch (roomError) {
          console.error(`  Error syncing ${room.name}:`, roomError.response?.data || roomError.message);
          errors.push({ room: room.name, error: roomError.message });
          if (roomError.response?.status === 429) {
            console.log('  Rate limited - waiting 60 seconds...');
            await new Promise(resolve => setTimeout(resolve, 60000));
          }
        }
      }
    }
    
    await pool.query('UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1', [connectionId]);
    
    res.json({
      success: true,
      message: 'Availability sync complete',
      stats: { propertiesChecked: propsResult.rows.length, roomsSynced, totalDaysUpdated, days },
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('Availability sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Manual full sync - checks for new/closed rooms
app.post('/api/gas-sync/connections/:connectionId/full-sync', async (req, res) => {
  try {
    const { connectionId } = req.params;
    
    // Get connection's account_id for proper ownership
    const connResult = await pool.query(
      'SELECT account_id FROM gas_sync_connections WHERE id = $1', 
      [connectionId]
    );
    
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const connectionAccountId = connResult.rows[0].account_id;
    console.log(`Full sync for connection ${connectionId}, account_id: ${connectionAccountId}`);
    
    // Run the regular sync (properties, rooms, images)
    const syncResponse = await axios.post(`http://localhost:${process.env.PORT || 3001}/api/gas-sync/connections/${connectionId}/sync`, {
      syncType: 'full'
    });
    
    // Then for each linked property, update the GAS data
    const propsResult = await pool.query(`
      SELECT id, gas_property_id FROM gas_sync_properties 
      WHERE connection_id = $1 AND gas_property_id IS NOT NULL
    `, [connectionId]);
    
    const linkResults = [];
    for (const prop of propsResult.rows) {
      try {
        // Re-link with skipImages to just update property/room data
        // Don't pass accountId - link-to-gas will use connection's account_id automatically
        const linkResponse = await axios.post(
          `http://localhost:${process.env.PORT || 3001}/api/gas-sync/properties/${prop.id}/link-to-gas`,
          { skipImages: true },
          { headers: { 'Content-Type': 'application/json' } }
        );
        linkResults.push({ propertyId: prop.id, success: true, stats: linkResponse.data.stats });
      } catch (linkError) {
        linkResults.push({ propertyId: prop.id, success: false, error: linkError.message });
      }
    }
    
    res.json({
      success: true,
      message: 'Full sync complete',
      syncResult: syncResponse.data,
      linkResults,
      account_id: connectionAccountId
    });
    
  } catch (error) {
    console.error('Full sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PROPERTY-LEVEL SYNC ENDPOINTS (Client Facing)
// These allow clients to sync individual properties
// Rate limited to once per hour per property
// =====================================================

/**
 * Sync prices and availability for a SINGLE property
 * Client-facing "Sync Prices" button
 * Pulls full year (365 days) of pricing in one go
 */
app.post('/api/gas-sync/properties/:propertyId/sync-prices', async (req, res) => {
  try {
    const { propertyId } = req.params;
    const { days = MANUAL_SYNC_DAYS, force } = req.body;
    const forceSync = force === true || force === 'true';
    
    await ensureSyncTrackingColumns();
    
    // Get property and connection info
    const propResult = await pool.query(`
      SELECT sp.*, c.access_token, c.refresh_token, c.credentials, c.api_key as connection_api_key, c.id as connection_id
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON c.id = sp.connection_id
      WHERE sp.id = $1 OR sp.external_id = $2
    `, [propertyId, String(propertyId)]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    
    // Check rate limit (unless force=true for admin)
    if (!forceSync && prop.last_price_sync) {
      const minutesSinceLastSync = (Date.now() - new Date(prop.last_price_sync).getTime()) / 60000;
      if (minutesSinceLastSync < SYNC_RATE_LIMIT_MINUTES) {
        const waitMinutes = Math.ceil(SYNC_RATE_LIMIT_MINUTES - minutesSinceLastSync);
        return res.json({ 
          success: false, 
          error: `Rate limited. Please wait ${waitMinutes} minutes before syncing again.`,
          nextSyncAvailable: new Date(new Date(prop.last_price_sync).getTime() + SYNC_RATE_LIMIT_MINUTES * 60000)
        });
      }
    }
    
    // Ensure we have a valid token
    let accessToken = prop.access_token;
    if (!accessToken && prop.refresh_token) {
      try {
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': prop.refresh_token }
        });
        accessToken = tokenResponse.data.token;
        await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', 
          [accessToken, prop.connection_id]);
      } catch (e) {
        return res.json({ success: false, error: 'Token expired. Please reconnect to Beds24.' });
      }
    }
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token. Please reconnect to Beds24.' });
    }
    
    // Get V1 credentials for fallback - check both 'credentials' and 'api_key' columns
    let credentials = {};
    if (prop.credentials) {
      credentials = typeof prop.credentials === 'string' 
        ? JSON.parse(prop.credentials || '{}') 
        : (prop.credentials || {});
    }
    // Also check api_key column (wizard stores here)
    if (!credentials.v1ApiKey && prop.connection_api_key) {
      const apiKeyCreds = typeof prop.connection_api_key === 'string'
        ? JSON.parse(prop.connection_api_key || '{}')
        : (prop.connection_api_key || {});
      if (apiKeyCreds.v1ApiKey) {
        credentials.v1ApiKey = apiKeyCreds.v1ApiKey;
      }
      if (apiKeyCreds.apiKey) {
        credentials.apiKey = apiKeyCreds.apiKey;
      }
    }
    const v1ApiKey = credentials.v1ApiKey || credentials.apiKey;
    
    console.log(`[Property Sync] ${prop.name}: V1 credentials check:`, {
      hasCredentials: !!prop.credentials,
      credentialsType: typeof prop.credentials,
      credentialsKeys: prop.credentials ? Object.keys(typeof prop.credentials === 'string' ? JSON.parse(prop.credentials) : prop.credentials) : [],
      hasV1ApiKey: !!v1ApiKey,
      hasPropKey: !!prop.prop_key,
      propKey: prop.prop_key ? prop.prop_key.substring(0, 5) + '...' : null
    });
    
    // Get rooms for this property
    const roomsResult = await pool.query(`
      SELECT rt.id, rt.external_id as beds24_room_id, rt.gas_room_id, rt.price_linking, bu.name
      FROM gas_sync_room_types rt
      JOIN bookable_units bu ON bu.id = rt.gas_room_id
      WHERE rt.sync_property_id = $1 AND rt.gas_room_id IS NOT NULL
    `, [prop.id]);
    
    if (roomsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No linked rooms found for this property' });
    }
    
    const today = new Date();
    const startDate = today.toISOString().split('T')[0];
    const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    let roomsSynced = 0;
    let totalDaysUpdated = 0;
    const errors = [];
    
    // Cache for source room prices (avoid fetching same source multiple times)
    const sourceRoomPriceCache = {};
    
    console.log(`[Property Sync] ${prop.name}: Syncing ${roomsResult.rows.length} rooms for ${days} days`);
    
    // Sync each room - one API call per room
    for (const room of roomsResult.rows) {
      try {
        const beds24RoomId = parseInt(room.beds24_room_id);
        const linking = room.price_linking ? (typeof room.price_linking === 'string' ? JSON.parse(room.price_linking) : room.price_linking) : null;
        
        // Fetch calendar from Beds24 V2
        const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
          headers: { 'token': accessToken },
          params: {
            roomId: beds24RoomId,
            startDate,
            endDate,
            includeNumAvail: true,
            includePrices: true,
            includeMinStay: true
          }
        });
        
        let calendarData = calResponse.data.data?.[0]?.calendar || [];
        let daysUpdated = 0;
        
        // Check if V2 returned any prices
        const hasAnyPrices = calendarData.some(entry => entry.price1 || entry.price);
        
        // If no prices and has price linking, fetch from source room
        if (!hasAnyPrices && linking && linking.sourceRoomId) {
          console.log(`  [${room.name}] No prices, fetching from linked room ${linking.sourceRoomId}`);
          
          const cacheKey = `${linking.sourceRoomId}_${startDate}_${endDate}`;
          let sourcePriceMap = sourceRoomPriceCache[cacheKey];
          
          if (!sourcePriceMap) {
            try {
              const sourceCalResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
                headers: { 'token': accessToken },
                params: {
                  roomId: linking.sourceRoomId,
                  startDate,
                  endDate,
                  includeNumAvail: true,
                  includePrices: true,
                  includeMinStay: true
                }
              });
              
              const sourceCalendar = sourceCalResponse.data.data?.[0]?.calendar || [];
              sourcePriceMap = {};
              
              for (const entry of sourceCalendar) {
                if (entry.price1 || entry.price) {
                  const fromDate = new Date(entry.from);
                  const toDate = new Date(entry.to);
                  for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    sourcePriceMap[dateStr] = {
                      price: entry.price1 || entry.price,
                      minStay: entry.minStay || 1
                    };
                  }
                }
              }
              
              sourceRoomPriceCache[cacheKey] = sourcePriceMap;
              console.log(`    Fetched ${Object.keys(sourcePriceMap).length} prices from source room`);
              
              // Rate limit protection
              await new Promise(resolve => setTimeout(resolve, 1500));
              
            } catch (sourceErr) {
              console.log(`    Failed to fetch source room: ${sourceErr.message}`);
              sourcePriceMap = {};
            }
          }
          
          // Apply offset to source prices
          const applyOffset = (price) => {
            if (!price) return null;
            return (price * (linking.offsetMultiplier || 1)) + (linking.offsetAmount || 0);
          };
          
          // Merge source prices into calendar data
          if (calendarData.length > 0) {
            // Expand calendar entries with prices from source
            const expandedData = [];
            for (const entry of calendarData) {
              const fromDate = new Date(entry.from);
              const toDate = new Date(entry.to);
              for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];
                const sourceData = sourcePriceMap[dateStr];
                expandedData.push({
                  from: dateStr,
                  to: dateStr,
                  numAvail: entry.numAvail,
                  minStay: entry.minStay || sourceData?.minStay || 1,
                  price1: entry.price1 || applyOffset(sourceData?.price)
                });
              }
            }
            calendarData = expandedData;
          } else {
            // No calendar data - create from source prices
            for (let i = 0; i < days; i++) {
              const d = new Date(today);
              d.setDate(d.getDate() + i);
              const dateStr = d.toISOString().split('T')[0];
              const sourceData = sourcePriceMap[dateStr];
              if (sourceData) {
                calendarData.push({
                  from: dateStr,
                  to: dateStr,
                  numAvail: 1,
                  minStay: sourceData.minStay || 1,
                  price1: applyOffset(sourceData.price)
                });
              }
            }
          }
        }
        // If still no prices and we have V1 credentials, try V1 getPrice fallback
        else if (!hasAnyPrices && v1ApiKey && prop.prop_key) {
          console.log(`  [${room.name}] V2 returned no prices, trying V1 fallback...`);
          
          // V1 fallback - get prices day by day (slower but works for Fixed Prices)
          let v1DebugLogged = false;
          for (let i = 0; i < Math.min(days, 30); i++) { // Limit V1 to 30 days to avoid rate limits
            const d = new Date(today);
            d.setDate(d.getDate() + i);
            const dateStr = d.toISOString().split('T')[0];
            const nextDay = new Date(d);
            nextDay.setDate(nextDay.getDate() + 1);
            const departStr = nextDay.toISOString().split('T')[0];
            
            try {
              const v1Response = await axios.post('https://api.beds24.com/json/getPrice', {
                authentication: { apiKey: v1ApiKey, propKey: prop.prop_key },
                roomId: String(beds24RoomId),
                arrival: dateStr,
                departure: departStr,
                numAdult: 2
              });
              
              const priceData = v1Response.data;
              
              // Debug: log first V1 response
              if (!v1DebugLogged) {
                console.log(`    V1 response for ${room.name}:`, JSON.stringify(priceData).substring(0, 300));
                v1DebugLogged = true;
              }
              
              const price = priceData?.price || priceData?.totalPrice || priceData?.[0]?.price || null;
              const minStay = priceData?.minStay || 1;
              const isAvailable = priceData?.available !== false && priceData?.numAvail !== 0;
              
              if (price !== null) {
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                  VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24-v1', NOW())
                  ON CONFLICT (room_id, date) 
                  DO UPDATE SET 
                    cm_price = COALESCE($3, room_availability.cm_price),
                    is_available = $4,
                    is_blocked = $5,
                    min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                    cm_min_stay = $6,
                    source = 'beds24-v1',
                    updated_at = NOW()
                `, [room.gas_room_id, dateStr, price, isAvailable, !isAvailable, minStay]);
                
                daysUpdated++;
              }
              
              // Small delay between V1 calls
              await new Promise(resolve => setTimeout(resolve, 300));
              
            } catch (v1Err) {
              if (!v1DebugLogged) {
                console.log(`    V1 error for ${room.name}:`, v1Err.response?.data || v1Err.message);
                v1DebugLogged = true;
              }
              if (v1Err.response?.status === 429) throw v1Err;
              // Skip individual day errors
            }
          }
        }
        
        // Process calendar data (V2 or from price linking)
        if (calendarData.length > 0 && (hasAnyPrices || (linking && linking.sourceRoomId))) {
          for (const entry of calendarData) {
            const fromDate = new Date(entry.from);
            const toDate = new Date(entry.to);
            
            for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
              const dateStr = d.toISOString().split('T')[0];
              const numAvail = entry.numAvail ?? 1;
              const price = entry.price1 || entry.price || null;
              const minStay = entry.minStay || 1;
              
              await pool.query(`
                INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24-v2', NOW())
                ON CONFLICT (room_id, date) 
                DO UPDATE SET 
                  cm_price = COALESCE($3, room_availability.cm_price),
                  is_available = $4,
                  is_blocked = $5,
                  min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                  cm_min_stay = $6,
                  source = 'beds24-v2',
                  updated_at = NOW()
              `, [room.gas_room_id, dateStr, price, numAvail > 0, numAvail === 0, minStay]);
              
              daysUpdated++;
            }
          }
        }
        
        roomsSynced++;
        totalDaysUpdated += daysUpdated;
        console.log(`  ‚úì ${room.name}: ${daysUpdated} days`);
        
        // Rate limit protection: 1.5s between rooms
        await new Promise(resolve => setTimeout(resolve, 1500));
        
      } catch (roomError) {
        console.error(`  ‚úó ${room.name}: ${roomError.message}`);
        errors.push({ room: room.name, error: roomError.message });
        
        // Stop on rate limit
        if (roomError.response?.status === 429) {
          errors.push({ error: 'Rate limited by Beds24. Some rooms may not have synced.' });
          break;
        }
      }
    }
    
    // Update last sync time
    await pool.query('UPDATE gas_sync_properties SET last_price_sync = NOW() WHERE id = $1', [prop.id]);
    
    res.json({
      success: true,
      property: prop.name,
      roomsSynced,
      totalDaysUpdated,
      dateRange: { startDate, endDate, days },
      errors: errors.length > 0 ? errors : undefined,
      nextSyncAvailable: new Date(Date.now() + SYNC_RATE_LIMIT_MINUTES * 60000)
    });
    
  } catch (error) {
    console.error('Property price sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Sync images for a SINGLE property
 * Uses V1 API - only call when user explicitly requests
 */
app.post('/api/gas-sync/properties/:propertyId/sync-images', async (req, res) => {
  try {
    const { propertyId } = req.params;
    const { force = false } = req.body;
    
    await ensureSyncTrackingColumns();
    
    // Get property and connection info
    const propResult = await pool.query(`
      SELECT sp.*, c.credentials, c.id as connection_id
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON c.id = sp.connection_id
      WHERE sp.id = $1 OR sp.external_id = $2
    `, [propertyId, String(propertyId)]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    
    // Check rate limit
    if (!force && prop.last_image_sync) {
      const minutesSinceLastSync = (Date.now() - new Date(prop.last_image_sync).getTime()) / 60000;
      if (minutesSinceLastSync < SYNC_RATE_LIMIT_MINUTES) {
        const waitMinutes = Math.ceil(SYNC_RATE_LIMIT_MINUTES - minutesSinceLastSync);
        return res.json({ 
          success: false, 
          error: `Rate limited. Please wait ${waitMinutes} minutes before syncing again.`
        });
      }
    }
    
    const credentials = typeof prop.credentials === 'string' 
      ? JSON.parse(prop.credentials || '{}') 
      : (prop.credentials || {});
    
    const v1ApiKey = credentials.v1ApiKey || credentials.apiKey;
    
    if (!v1ApiKey || !prop.prop_key) {
      return res.json({ 
        success: false, 
        error: 'V1 API key and prop_key required for image sync. Please add V1 credentials.' 
      });
    }
    
    console.log(`[Image Sync] ${prop.name}: Fetching images via V1 API`);
    
    // Fetch images via V1 API
    const v1Response = await axios.post('https://api.beds24.com/json/getPropertyContent', {
      authentication: { apiKey: v1ApiKey, propKey: prop.prop_key },
      images: true,
      roomIds: true
    });
    
    const content = v1Response.data?.getPropertyContent?.[0];
    if (!content) {
      return res.json({ success: false, error: 'No content returned from Beds24' });
    }
    
    const images = content.images || [];
    let imagesSynced = 0;
    
    // Store images in database
    for (let i = 0; i < images.length; i++) {
      const image = images[i];
      try {
        await pool.query(`
          INSERT INTO gas_sync_images (connection_id, sync_property_id, external_id, original_url, thumbnail_url, caption, sort_order, room_type_external_id, synced_at)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
          ON CONFLICT (connection_id, external_id) DO UPDATE SET
            original_url = EXCLUDED.original_url,
            thumbnail_url = EXCLUDED.thumbnail_url,
            caption = EXCLUDED.caption,
            sort_order = EXCLUDED.sort_order,
            synced_at = NOW()
        `, [
          prop.connection_id,
          prop.id,
          `${prop.external_id}_img_${i}`,
          image.url || image.imageUrl,
          image.thumbnail || image.url || image.imageUrl,
          image.description || image.caption || '',
          i,
          image.roomId || null
        ]);
        imagesSynced++;
      } catch (e) {
        console.log('  Image sync error:', e.message);
      }
    }
    
    // Update last sync time
    await pool.query('UPDATE gas_sync_properties SET last_image_sync = NOW() WHERE id = $1', [prop.id]);
    
    console.log(`  ‚úì ${imagesSynced} images synced`);
    
    res.json({
      success: true,
      property: prop.name,
      imagesSynced,
      totalImages: images.length
    });
    
  } catch (error) {
    console.error('Property image sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Sync content (descriptions, amenities) for a SINGLE property
 */
app.post('/api/gas-sync/properties/:propertyId/sync-content', async (req, res) => {
  try {
    const { propertyId } = req.params;
    const { force = false } = req.body;
    
    await ensureSyncTrackingColumns();
    
    // Get property and connection info
    const propResult = await pool.query(`
      SELECT sp.*, c.access_token, c.refresh_token, c.credentials, c.id as connection_id, c.adapter_code
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON c.id = sp.connection_id
      WHERE sp.id = $1 OR sp.external_id = $2
    `, [propertyId, String(propertyId)]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    
    // Skip content sync for Calry - it doesn't have a separate content endpoint
    // Calry content comes with the property data during initial import
    if (prop.adapter_code === 'calry') {
      return res.json({ 
        success: true, 
        message: 'Calry properties sync content during import. Use resync to refresh.',
        adapter: 'calry'
      });
    }
    
    // Check rate limit
    if (!force && prop.last_content_sync) {
      const minutesSinceLastSync = (Date.now() - new Date(prop.last_content_sync).getTime()) / 60000;
      if (minutesSinceLastSync < SYNC_RATE_LIMIT_MINUTES) {
        const waitMinutes = Math.ceil(SYNC_RATE_LIMIT_MINUTES - minutesSinceLastSync);
        return res.json({ 
          success: false, 
          error: `Rate limited. Please wait ${waitMinutes} minutes before syncing again.`
        });
      }
    }
    
    // Ensure we have a valid token
    let accessToken = prop.access_token;
    if (!accessToken && prop.refresh_token) {
      try {
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': prop.refresh_token }
        });
        accessToken = tokenResponse.data.token;
        await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', 
          [accessToken, prop.connection_id]);
      } catch (e) {
        return res.json({ success: false, error: 'Token expired. Please reconnect.' });
      }
    }
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token. Please reconnect to Beds24.' });
    }
    
    console.log(`[Content Sync] ${prop.name}: Fetching texts and amenities`);
    
    // Fetch property with texts and features from V2 API
    const propResponse = await axios.get('https://beds24.com/api/v2/properties', {
      headers: { 'token': accessToken, 'accept': 'application/json' },
      params: {
        id: prop.external_id,
        includeTexts: 'all',
        includeAllRooms: true,
        includeUnitDetails: true,
        includeFeatures: true
      }
    });
    
    const propData = propResponse.data?.data?.[0] || propResponse.data?.[0];
    if (!propData) {
      return res.json({ success: false, error: 'Property not found in Beds24' });
    }
    
    console.log(`[Content Sync] ${prop.name}: V2 response keys:`, Object.keys(propData).join(', '));
    
    // Update property description and features
    // V2 texts can be array or object
    let propertyDescription = '';
    let propTextsForStorage = propData.texts;
    
    if (propData.texts && Array.isArray(propData.texts) && propData.texts.length > 0) {
      const defaultText = propData.texts[0];
      propertyDescription = defaultText.propertyDescription || defaultText.description || '';
      console.log(`[Content Sync] V2 property texts keys:`, Object.keys(defaultText).join(', '));
      console.log(`[Content Sync] propertyDescription1:`, defaultText.propertyDescription1 ? 'YES' : 'NO');
      console.log(`[Content Sync] propertyDescription2:`, defaultText.propertyDescription2 ? 'YES' : 'NO');
    } else if (propData.texts && typeof propData.texts === 'object') {
      propertyDescription = propData.texts.description || '';
      console.log(`[Content Sync] V2 property texts (object) keys:`, Object.keys(propData.texts).join(', '));
    }
    
    const features = propData.features || propData.featureCodes || [];
    await pool.query(`
      UPDATE gas_sync_properties SET
        description = $1,
        raw_data = COALESCE(raw_data, '{}'::jsonb) || $2,
        synced_at = NOW()
      WHERE id = $3
    `, [
      propertyDescription,
      JSON.stringify({ texts: propData.texts, features }),
      prop.id
    ]);
    
    console.log(`[Content Sync] ${prop.name}: Found ${Array.isArray(features) ? features.length : 0} features`);
    
    // Update room texts from V2 API response - rooms are in roomTypes array
    let roomsUpdatedFromV2 = 0;
    const rooms = propData.roomTypes || propData.rooms || [];
    console.log(`[Content Sync] ${prop.name}: Found ${rooms.length} rooms in V2 response`);
    
    // Auto-repair: ensure gas_sync_room_types exist for each room
    if (rooms.length > 0 && prop.gas_property_id) {
      const existingSyncRooms = await pool.query(
        'SELECT external_id FROM gas_sync_room_types WHERE sync_property_id = $1',
        [prop.id]
      );
      const existingExternalIds = new Set(existingSyncRooms.rows.map(r => String(r.external_id)));
      
      for (const room of rooms) {
        const roomExtId = String(room.id || room.roomId);
        if (!existingExternalIds.has(roomExtId)) {
          // Check if a bookable_unit exists for this room
          const unit = await pool.query(
            `SELECT id, name, max_guests, quantity FROM bookable_units 
             WHERE property_id = $1 AND (cm_room_id::text = $2 OR beds24_room_id::text = $2)`,
            [prop.gas_property_id, roomExtId]
          );
          if (unit.rows.length > 0) {
            try {
              await pool.query(`
                INSERT INTO gas_sync_room_types (sync_property_id, connection_id, external_id, gas_room_id, name, max_guests, unit_count, synced_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
              `, [prop.id, prop.connection_id, roomExtId, unit.rows[0].id, unit.rows[0].name, unit.rows[0].max_guests || 2, unit.rows[0].quantity || 1]);
              console.log(`[Content Sync] Auto-created gas_sync_room_types for room ${roomExtId}`);
            } catch (e) {
              console.log(`[Content Sync] Auto-repair room ${roomExtId} error:`, e.message);
            }
          }
        }
      }
    }
    
    for (const room of rooms) {
      const roomId = room.id || room.roomId;
      
      // V2 room texts is an array: [{language: "en", displayName: "...", roomDescription: "...", auxiliary: "..."}]
      let displayName = '';
      let roomDescription = '';
      let auxiliaryText = '';
      
      if (room.texts && Array.isArray(room.texts) && room.texts.length > 0) {
        const roomText = room.texts[0]; // First = default language
        displayName = roomText.displayName || '';
        roomDescription = roomText.roomDescription || roomText.description || '';
        auxiliaryText = roomText.auxiliary || roomText.auxiliaryText || '';
        console.log(`[Content Sync] Room ${roomId}: displayName=${displayName ? 'YES' : 'NO'}, roomDesc=${roomDescription ? 'YES' : 'NO'}, auxiliary=${auxiliaryText ? 'YES' : 'NO'}`);
      }
      
      // Extract featureCodes from room
      let roomFeatureCodes = '';
      if (room.featureCodes) {
        if (Array.isArray(room.featureCodes)) {
          // Can be array of strings or array of arrays
          roomFeatureCodes = room.featureCodes.flat().join(',');
        } else if (typeof room.featureCodes === 'string') {
          roomFeatureCodes = room.featureCodes;
        }
        console.log(`[Content Sync] Room ${roomId} featureCodes:`, roomFeatureCodes.substring(0, 100));
      }
      
      // Update gas_sync_room_types with texts and featureCodes in expected format
      if (displayName || roomDescription || auxiliaryText || roomFeatureCodes) {
        const dataToStore = {
          texts: {
            displayName: { EN: displayName },
            roomDescription1: { EN: roomDescription },
            auxiliaryText: { EN: auxiliaryText }
          },
          featureCodes: roomFeatureCodes
        };
        
        await pool.query(`
          UPDATE gas_sync_room_types SET
            raw_data = COALESCE(raw_data, '{}'::jsonb) || $1,
            synced_at = NOW()
          WHERE sync_property_id = $2 AND external_id = $3
        `, [
          JSON.stringify(dataToStore),
          prop.id,
          String(roomId)
        ]);
        roomsUpdatedFromV2++;
        console.log(`[Content Sync] Updated room ${roomId} with texts${roomFeatureCodes ? ' and featureCodes' : ''}`);
      }
    }
    
    console.log(`[Content Sync] ${prop.name}: Updated ${roomsUpdatedFromV2} rooms with V2 texts`);
    
    // Map Beds24 features to GAS amenities
    if (features.length > 0) {
      // Get master amenities to match against
      const masterAmenities = await pool.query('SELECT id, amenity_code FROM master_amenities WHERE is_active = true');
      const amenityMap = {};
      masterAmenities.rows.forEach(a => {
        amenityMap[a.amenity_code.toUpperCase()] = a.id;
      });
      
      // Get rooms for this property
      const rooms = await pool.query(`
        SELECT rt.gas_room_id 
        FROM gas_sync_room_types rt 
        WHERE rt.sync_property_id = $1 AND rt.gas_room_id IS NOT NULL
      `, [prop.id]);
      
      // Apply features to each room
      for (const room of rooms.rows) {
        const roomId = room.gas_room_id;
        let amenitiesAdded = 0;
        
        for (const feature of features) {
          const code = (feature.code || feature.name || '').toUpperCase().replace(/[^A-Z0-9]/g, '_');
          const amenityId = amenityMap[code];
          
          if (amenityId) {
            try {
              await pool.query(`
                INSERT INTO room_amenity_selections (room_id, amenity_id, display_order)
                VALUES ($1, $2, $3)
                ON CONFLICT (room_id, amenity_id) DO NOTHING
              `, [roomId, amenityId, amenitiesAdded]);
              amenitiesAdded++;
            } catch (e) {
              // Skip duplicates
            }
          }
        }
      }
    }
    
    // Update room content if we have V1 credentials
    let roomsUpdated = 0;
    const credentials = typeof prop.credentials === 'string' 
      ? JSON.parse(prop.credentials || '{}') 
      : (prop.credentials || {});
    const v1ApiKey = credentials.v1ApiKey || credentials.apiKey;
    
    console.log(`[Content Sync] V1 credentials check - v1ApiKey: ${v1ApiKey ? 'YES' : 'NO'}, prop_key: ${prop.prop_key || 'NO'}`);
    
    if (v1ApiKey && prop.prop_key) {
      try {
        // First get the room external_ids we need
        const roomsForV1 = await pool.query(
          'SELECT id, external_id FROM gas_sync_room_types WHERE sync_property_id = $1',
          [prop.id]
        );
        const roomExternalIds = roomsForV1.rows.map(r => parseInt(r.external_id)).filter(id => !isNaN(id));
        console.log(`[Content Sync] Requesting V1 texts for room IDs:`, roomExternalIds.join(', '));
        
        console.log(`[Content Sync] Calling V1 API getPropertyContent for prop_key: ${prop.prop_key}`);
        // Request texts in multiple languages AND specific roomIds to get room-level texts
        const v1Response = await axios.post('https://api.beds24.com/json/getPropertyContent', {
          authentication: { apiKey: v1ApiKey, propKey: prop.prop_key },
          texts: ['EN', 'FR', 'NL', 'ES', 'DE'],
          roomIds: roomExternalIds.length > 0 ? roomExternalIds : true,
          featureCodes: true
        });
        
        const content = v1Response.data?.getPropertyContent?.[0];
        console.log(`[Content Sync] V1 response - has content: ${!!content}, texts type: ${Array.isArray(content?.texts) ? 'array' : typeof content?.texts}`);
        
        // Log raw structure to understand what Beds24 returns
        if (content?.texts) {
          console.log(`[Content Sync] V1 texts raw keys:`, Object.keys(content.texts).slice(0, 10).join(', '));
          if (Array.isArray(content.texts)) {
            console.log(`[Content Sync] V1 texts is ARRAY with ${content.texts.length} items`);
            content.texts.forEach((t, i) => {
              console.log(`[Content Sync] V1 texts[${i}] language=${t.language}, keys=${Object.keys(t).slice(0, 5).join(',')}`);
            });
          } else {
            console.log(`[Content Sync] V1 texts is OBJECT, language prop=${content.texts.language || 'NONE'}`);
            // Check if displayName has language keys directly
            if (content.texts.displayName) {
              console.log(`[Content Sync] V1 texts.displayName type=${typeof content.texts.displayName}, value=${JSON.stringify(content.texts.displayName).substring(0, 200)}`);
            }
          }
        }
        
        // Check for room-level data in V1 response
        if (content?.roomTypes) {
          console.log(`[Content Sync] V1 roomTypes found:`, Array.isArray(content.roomTypes) ? content.roomTypes.length + ' rooms' : typeof content.roomTypes);
          if (Array.isArray(content.roomTypes) && content.roomTypes[0]) {
            console.log(`[Content Sync] V1 roomTypes[0] keys:`, Object.keys(content.roomTypes[0]).join(', '));
            if (content.roomTypes[0].texts) {
              console.log(`[Content Sync] V1 roomTypes[0].texts keys:`, Object.keys(content.roomTypes[0].texts).join(', '));
            }
          }
        }
        if (content?.roomIds) {
          console.log(`[Content Sync] V1 roomIds found:`, typeof content.roomIds, Object.keys(content.roomIds).slice(0, 5).join(', '));
          // Look inside the first room
          const firstRoomId = Object.keys(content.roomIds)[0];
          if (firstRoomId) {
            const roomData = content.roomIds[firstRoomId];
            console.log(`[Content Sync] V1 roomIds[${firstRoomId}] keys:`, Object.keys(roomData).join(', '));
            if (roomData.texts) {
              console.log(`[Content Sync] V1 roomIds[${firstRoomId}].texts keys:`, Object.keys(roomData.texts).join(', '));
              if (roomData.texts.displayName) {
                console.log(`[Content Sync] V1 roomIds[${firstRoomId}].texts.displayName:`, JSON.stringify(roomData.texts.displayName).substring(0, 300));
              }
              if (roomData.texts.roomDescription1) {
                console.log(`[Content Sync] V1 roomIds[${firstRoomId}].texts.roomDescription1 keys:`, typeof roomData.texts.roomDescription1 === 'object' ? Object.keys(roomData.texts.roomDescription1).join(', ') : 'not object');
              }
            }
          }
        }
        
        // Log full content keys to see structure
        console.log(`[Content Sync] V1 content top-level keys:`, Object.keys(content).join(', '));
        
        if (content?.texts) {
          // V1 can return texts in two formats:
          // 1. Array: [{language: 'EN', propertyDescription1: '...'}, {language: 'FR', propertyDescription1: '...'}]
          // 2. Object: {propertyDescription1: {EN: '...', FR: '...'}, propertyDescription2: {EN: '...', FR: '...'}}
          
          const multiLangTexts = {};
          
          if (Array.isArray(content.texts)) {
            // Format 1: Array of language objects
            console.log(`[Content Sync] V1 texts is ARRAY with ${content.texts.length} items`);
            for (const langTexts of content.texts) {
              const lang = (langTexts.language || 'en').toLowerCase();
              for (const [key, value] of Object.entries(langTexts)) {
                if (key === 'language') continue;
                if (!multiLangTexts[key]) multiLangTexts[key] = {};
                multiLangTexts[key][lang] = value;
              }
            }
          } else {
            // Format 2: Object where each field has language keys
            console.log(`[Content Sync] V1 texts is OBJECT - checking for language keys in values`);
            for (const [fieldName, fieldValue] of Object.entries(content.texts)) {
              if (fieldValue && typeof fieldValue === 'object' && !Array.isArray(fieldValue)) {
                // Check if this looks like {EN: '...', FR: '...'}
                const keys = Object.keys(fieldValue);
                const looksLikeLangKeys = keys.some(k => ['EN', 'FR', 'DE', 'ES', 'NL', 'IT', 'PT'].includes(k.toUpperCase()));
                if (looksLikeLangKeys) {
                  // Normalize to lowercase keys
                  multiLangTexts[fieldName] = {};
                  for (const [lang, text] of Object.entries(fieldValue)) {
                    multiLangTexts[fieldName][lang.toLowerCase()] = text;
                  }
                } else {
                  // Just a regular object, store as-is with 'en' key
                  multiLangTexts[fieldName] = { en: typeof fieldValue === 'string' ? fieldValue : JSON.stringify(fieldValue) };
                }
              } else if (typeof fieldValue === 'string') {
                // Plain string - store as 'en'
                multiLangTexts[fieldName] = { en: fieldValue };
              }
            }
          }
          
          console.log(`[Content Sync] Languages in propertyDescription2:`, multiLangTexts.propertyDescription2 ? Object.keys(multiLangTexts.propertyDescription2).join(',') : 'none');
          
          console.log(`[Content Sync] Text fields found:`, Object.keys(multiLangTexts).filter(k => 
            k.includes('room') || k.includes('display') || k.includes('propertyDescription')
          ).join(', '));
          
          // Extract property-level descriptions for fallback
          const propDesc1 = multiLangTexts.propertyDescription1 || {};
          const propDesc2 = multiLangTexts.propertyDescription2 || {};
          console.log(`[Content Sync] Property descriptions - desc1 langs: ${Object.keys(propDesc1).join(',') || 'none'}, desc2 langs: ${Object.keys(propDesc2).join(',') || 'none'}`);
          
          const rooms = await pool.query(
            'SELECT id, external_id FROM gas_sync_room_types WHERE sync_property_id = $1',
            [prop.id]
          );
          
          // Get roomIds data from V1 response (this is where room-level texts live)
          const roomIdsData = content.roomIds || {};
          
          for (const room of rooms.rows) {
            // First try to get room-specific texts from roomIds (the correct location)
            const roomIdData = roomIdsData[room.external_id] || {};
            const roomIdTexts = roomIdData.texts || {};
            
            // Room texts in roomIds are already multilingual objects: {EN: "...", FR: "...", ES: "...", NL: "..."}
            const displayName = roomIdTexts.displayName || multiLangTexts[`displayName_${room.external_id}`] || multiLangTexts.displayName || {};
            const roomDesc = roomIdTexts.roomDescription1 || multiLangTexts[`roomDescription1_${room.external_id}`] || multiLangTexts.roomDescription1 || {};
            const auxText = roomIdTexts.auxiliaryText || multiLangTexts[`auxiliaryText_${room.external_id}`] || multiLangTexts.auxiliaryText || {};
            
            // Normalize language keys to lowercase
            const normalizeKeys = (obj) => {
              if (!obj || typeof obj !== 'object') return {};
              const result = {};
              for (const [key, value] of Object.entries(obj)) {
                result[key.toLowerCase()] = value;
              }
              return result;
            };
            
            const displayNameNorm = normalizeKeys(displayName);
            const roomDescNorm = normalizeKeys(roomDesc);
            const auxTextNorm = normalizeKeys(auxText);
            
            // Helper to check if object has any non-empty string values
            const hasContent = (obj) => {
              if (!obj || typeof obj !== 'object') return false;
              return Object.values(obj).some(v => typeof v === 'string' && v.trim().length > 0);
            };
            
            // Use property descriptions as fallback if room descriptions are empty
            const shortDesc = hasContent(roomDescNorm) ? roomDescNorm : propDesc1;
            const fullDesc = hasContent(auxTextNorm) ? auxTextNorm : propDesc2;
            
            console.log(`[Content Sync] Room ${room.external_id}: auxText hasContent=${hasContent(auxTextNorm)}, using propDesc2 for fullDesc=${!hasContent(auxTextNorm)}`);
            console.log(`[Content Sync] Room ${room.external_id}: displayName langs=${Object.keys(displayNameNorm).join(',') || 'none'}, shortDesc langs=${Object.keys(shortDesc).join(',') || 'none'}, fullDesc langs=${Object.keys(fullDesc).join(',') || 'none'}`);
            
            if (Object.keys(displayNameNorm).length > 0 || Object.keys(shortDesc).length > 0 || Object.keys(fullDesc).length > 0) {
              await pool.query(`
                UPDATE gas_sync_room_types SET
                  description = COALESCE($1, description),
                  raw_data = COALESCE(raw_data, '{}'::jsonb) || $2,
                  synced_at = NOW()
                WHERE id = $3
              `, [
                // Store first available language as plain description for backwards compat
                shortDesc.en || shortDesc.fr || shortDesc.nl || shortDesc.es || Object.values(shortDesc)[0] || null,
                JSON.stringify({ 
                  displayName: displayNameNorm, 
                  roomDescription1: roomDescNorm,
                  auxiliaryText: auxTextNorm,
                  propertyDescription1: propDesc1,
                  propertyDescription2: propDesc2,
                  // Store computed multilingual descriptions
                  short_description: shortDesc,
                  full_description: fullDesc
                }),
                room.id
              ]);
              roomsUpdated++;
            }
          }
        }
      } catch (v1Error) {
        console.log('  V1 content sync error:', v1Error.message);
      }
    } else {
      console.log(`[Content Sync] Skipping V1 API - missing credentials`);
    }
    
    // Update last sync time
    await pool.query('UPDATE gas_sync_properties SET last_content_sync = NOW() WHERE id = $1', [prop.id]);
    
    console.log(`  ‚úì Property updated, ${roomsUpdated} rooms updated`);
    
    res.json({
      success: true,
      property: prop.name,
      propertyUpdated: true,
      roomsUpdated
    });
    
  } catch (error) {
    console.error('Property content sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

/**
 * Get sync status for a property
 * Shows when each sync type was last run
 */
app.get('/api/gas-sync/properties/:propertyId/sync-status', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    await ensureSyncTrackingColumns();
    
    const result = await pool.query(`
      SELECT 
        sp.id,
        sp.name,
        sp.external_id,
        sp.last_price_sync,
        sp.last_image_sync,
        sp.last_content_sync,
        COUNT(rt.id) as total_rooms,
        COUNT(CASE WHEN rt.gas_room_id IS NOT NULL THEN 1 END) as linked_rooms,
        COUNT(DISTINCT si.id) as total_images
      FROM gas_sync_properties sp
      LEFT JOIN gas_sync_room_types rt ON rt.sync_property_id = sp.id
      LEFT JOIN gas_sync_images si ON si.sync_property_id = sp.id
      WHERE sp.id = $1 OR sp.external_id = $2
      GROUP BY sp.id
    `, [propertyId, String(propertyId)]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const prop = result.rows[0];
    const now = new Date();
    
    // Calculate if each sync is available (not rate limited)
    const canSyncPrices = !prop.last_price_sync || 
      (now - new Date(prop.last_price_sync)) > SYNC_RATE_LIMIT_MINUTES * 60000;
    const canSyncImages = !prop.last_image_sync || 
      (now - new Date(prop.last_image_sync)) > SYNC_RATE_LIMIT_MINUTES * 60000;
    const canSyncContent = !prop.last_content_sync || 
      (now - new Date(prop.last_content_sync)) > SYNC_RATE_LIMIT_MINUTES * 60000;
    
    res.json({
      success: true,
      property: {
        id: prop.id,
        name: prop.name,
        externalId: prop.external_id,
        rooms: {
          total: parseInt(prop.total_rooms),
          linked: parseInt(prop.linked_rooms)
        },
        images: parseInt(prop.total_images)
      },
      sync: {
        prices: {
          lastSync: prop.last_price_sync,
          canSync: canSyncPrices,
          nextAvailable: canSyncPrices ? null : new Date(new Date(prop.last_price_sync).getTime() + SYNC_RATE_LIMIT_MINUTES * 60000)
        },
        images: {
          lastSync: prop.last_image_sync,
          canSync: canSyncImages,
          nextAvailable: canSyncImages ? null : new Date(new Date(prop.last_image_sync).getTime() + SYNC_RATE_LIMIT_MINUTES * 60000)
        },
        content: {
          lastSync: prop.last_content_sync,
          canSync: canSyncContent,
          nextAvailable: canSyncContent ? null : new Date(new Date(prop.last_content_sync).getTime() + SYNC_RATE_LIMIT_MINUTES * 60000)
        }
      },
      rateLimitMinutes: SYNC_RATE_LIMIT_MINUTES
    });
    
  } catch (error) {
    console.error('Sync status error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// TIERED AVAILABILITY POLLING SYSTEM v2.1
// Syncs 18 months (540 days) without killing Beds24 rate limits
// =====================================================

/*
 TIER STRUCTURE (v2.1 - Extended for 12+ month availability):
 - Tier 1: Days 0-30   ‚Üí Every 15 minutes, 5 rooms/run (high activity)
 - Tier 2: Days 31-90  ‚Üí Every 2 hours, 5 rooms/run (booking window)
 - Tier 3: Days 91-180 ‚Üí Every 6 hours, 5 rooms/run (medium term)
 - Tier 4: Days 181-365 ‚Üí Every 12 hours, 5 rooms/run (full year)
 - Tier 5: Days 366-540 ‚Üí Every 24 hours, 3 rooms/run (far future)
 
 Rate limit friendly: Stagger rooms, ~2 second delay between API calls
 Manual sync: Pulls full year (365 days) in one go, rate limited to 1/hour/property
*/

const SYNC_TIERS = [
  { tier: 1, startDay: 0, endDay: 30, intervalMinutes: 15, roomsPerRun: 5, name: 'Immediate (0-30 days)' },
  { tier: 2, startDay: 31, endDay: 90, intervalMinutes: 120, roomsPerRun: 5, name: 'Near-term (31-90 days)' },
  { tier: 3, startDay: 91, endDay: 180, intervalMinutes: 360, roomsPerRun: 5, name: 'Medium-term (91-180 days)' },
  { tier: 4, startDay: 181, endDay: 365, intervalMinutes: 720, roomsPerRun: 5, name: 'Long-term (181-365 days)' },
  { tier: 5, startDay: 366, endDay: 540, intervalMinutes: 1440, roomsPerRun: 3, name: 'Far-future (366-540 days)' }
];

// Manual sync defaults - used when client clicks "Sync Prices"
const MANUAL_SYNC_DAYS = 365; // Pull full year on manual sync
const SYNC_RATE_LIMIT_MINUTES = 60; // Minimum time between manual syncs per property

// Add tier tracking columns
async function ensureTierTrackingColumns() {
  try {
    await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS tier1_synced_at TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS tier2_synced_at TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS tier3_synced_at TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS tier4_synced_at TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS tier5_synced_at TIMESTAMP`);
  } catch (e) {
    console.log('Tier columns may already exist:', e.message);
  }
}

// Add sync tracking columns for rate limiting
async function ensureSyncTrackingColumns() {
  try {
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS last_price_sync TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS last_image_sync TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS last_content_sync TIMESTAMP`);
  } catch (e) {
    console.log('Sync tracking columns may already exist:', e.message);
  }
}

// Tiered sync endpoint - call this from cron every 15 minutes
app.post('/api/gas-sync/tiered-availability-sync', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'];
  const isDev = process.env.NODE_ENV === 'development' || req.query.dev === 'true';
  
  if (!isDev && cronSecret !== process.env.CRON_SECRET) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  try {
    await ensureTierTrackingColumns();
    
    const now = new Date();
    const results = { tiers: [], totalRoomsSynced: 0, totalDaysUpdated: 0, errors: [] };
    
    // Get all active Beds24 connections
    const connections = await pool.query(`
      SELECT * FROM gas_sync_connections 
      WHERE adapter_code = 'beds24' AND sync_enabled = true AND status != 'syncing'
    `);
    
    for (const conn of connections.rows) {
      let accessToken = conn.access_token;
      
      // Always try to refresh token - access tokens expire quickly
      if (conn.refresh_token) {
        try {
          const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
            headers: { 'refreshToken': conn.refresh_token }
          });
          accessToken = tokenResponse.data.token;
          await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [accessToken, conn.id]);
        } catch (e) {
          results.errors.push({ connection: conn.id, error: 'Token refresh failed: ' + e.message });
          continue;
        }
      }
      
      if (!accessToken) continue;
      
      // Load price linking map from database for this connection
      const priceLinkingMap = {};
      const linkingResult = await pool.query(`
        SELECT rt.external_id, rt.price_linking
        FROM gas_sync_room_types rt
        JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
        WHERE sp.connection_id = $1 AND rt.price_linking IS NOT NULL
      `, [conn.id]);
      
      for (const row of linkingResult.rows) {
        if (row.price_linking) {
          priceLinkingMap[parseInt(row.external_id)] = row.price_linking;
        }
      }
      
      // Cache for source room prices within this connection
      const sourceRoomPriceCache = {};
      
      // Get rooms that need syncing for each tier
      for (const tier of SYNC_TIERS) {
        const tierColumn = `tier${tier.tier}_synced_at`;
        const cutoffTime = new Date(now.getTime() - tier.intervalMinutes * 60 * 1000);
        
        // Find rooms due for this tier sync
        const roomsResult = await pool.query(`
          SELECT rt.id, rt.external_id as beds24_room_id, rt.gas_room_id, bu.name
          FROM gas_sync_room_types rt
          JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
          JOIN bookable_units bu ON bu.id = rt.gas_room_id
          WHERE sp.connection_id = $1 
            AND rt.gas_room_id IS NOT NULL
            AND (rt.${tierColumn} IS NULL OR rt.${tierColumn} < $2)
          ORDER BY rt.${tierColumn} ASC NULLS FIRST
          LIMIT 5
        `, [conn.id, cutoffTime]);
        
        if (roomsResult.rows.length === 0) continue;
        
        const tierResult = { tier: tier.tier, name: tier.name, rooms: [], daysUpdated: 0 };
        
        for (const room of roomsResult.rows) {
          try {
            const beds24RoomId = parseInt(room.beds24_room_id);
            
            // Calculate date range for this tier
            const startDate = new Date(now.getTime() + tier.startDay * 24 * 60 * 60 * 1000);
            const endDate = new Date(now.getTime() + tier.endDay * 24 * 60 * 60 * 1000);
            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];
            
            // Check if this room has price linking
            const linking = priceLinkingMap[beds24RoomId];
            
            // Fetch calendar from Beds24
            const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
              headers: { 'token': accessToken },
              params: {
                roomId: beds24RoomId,
                startDate: startDateStr,
                endDate: endDateStr,
                includeNumAvail: true,
                includePrices: true,
                includeMinStay: true
              }
            });
            
            let calendarData = calResponse.data.data?.[0]?.calendar || [];
            let daysUpdated = 0;
            
            // If no prices and has price linking, get prices from source room in DATABASE
            const hasNoPrices = calendarData.length === 0 || !calendarData.some(e => e.price1);
            if (hasNoPrices && linking) {
              // Find the GAS room ID for the source Beds24 room
              const sourceRoomResult = await pool.query(`
                SELECT rt.gas_room_id 
                FROM gas_sync_room_types rt
                JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
                WHERE sp.connection_id = $1 AND rt.external_id = $2
              `, [conn.id, String(linking.sourceRoomId)]);
              
              const sourceGasRoomId = sourceRoomResult.rows[0]?.gas_room_id;
              
              if (sourceGasRoomId) {
                // Get prices from DATABASE for the source room (BASE)
                const sourcePricesResult = await pool.query(`
                  SELECT date, cm_price, min_stay
                  FROM room_availability
                  WHERE room_id = $1 AND date >= $2 AND date <= $3
                  ORDER BY date
                `, [sourceGasRoomId, startDateStr, endDateStr]);
                
                const sourcePriceMap = {};
                for (const row of sourcePricesResult.rows) {
                  const dateStr = row.date.toISOString().split('T')[0];
                  sourcePriceMap[dateStr] = { 
                    price: parseFloat(row.cm_price) || null, 
                    minStay: row.min_stay || 1 
                  };
                }
                
                console.log(`  üìä Found ${Object.keys(sourcePriceMap).length} BASE prices in DB for ${room.name}`);
                
                // Apply offset
                const applyOffset = (price) => price ? (price * (linking.offsetMultiplier || 1)) + (linking.offsetAmount || 0) : null;
                
                // Expand calendar data with prices from database
                if (calendarData.length > 0) {
                  const expandedData = [];
                  for (const entry of calendarData) {
                    const fromDate = new Date(entry.from);
                    const toDate = new Date(entry.to);
                    for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                      const dateStr = d.toISOString().split('T')[0];
                      const sourceData = sourcePriceMap[dateStr];
                      expandedData.push({
                        from: dateStr,
                        to: dateStr,
                        numAvail: entry.numAvail,
                        minStay: sourceData?.minStay || entry.minStay || 1,
                        price1: entry.price1 || applyOffset(sourceData?.price)
                      });
                    }
                  }
                  calendarData = expandedData;
                } else {
                  // No calendar data at all - create entries from source prices
                  calendarData = Object.entries(sourcePriceMap).map(([dateStr, data]) => ({
                    from: dateStr,
                    to: dateStr,
                    numAvail: 1, // Assume available if no data
                    minStay: data.minStay,
                    price1: applyOffset(data.price)
                  }));
                }
              }
            }
            
            // Process calendar data
            for (const entry of calendarData) {
              const fromDate = new Date(entry.from);
              const toDate = new Date(entry.to);
              
              for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toISOString().split('T')[0];
                const numAvail = entry.numAvail || 0;
                const price = entry.price1 || null;
                const minStay = entry.minStay || 1;
                
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                  VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24', NOW())
                  ON CONFLICT (room_id, date) 
                  DO UPDATE SET 
                    cm_price = COALESCE($3, room_availability.cm_price),
                    is_available = $4,
                    is_blocked = $5,
                    min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                    cm_min_stay = $6,
                    source = 'beds24',
                    updated_at = NOW()
                `, [room.gas_room_id, dateStr, price, numAvail > 0, numAvail === 0, minStay]);
                
                daysUpdated++;
              }
            }
            
            // ===== PUSH PRICES TO LINKED ROOMS =====
            // If this room has prices (like BASE), find all rooms linked to it and copy prices
            const hasSourcePrices = calendarData.some(e => e.price1);
            if (hasSourcePrices) {
              // Find all rooms that link to this room
              const linkedRoomsResult = await pool.query(`
                SELECT rt.gas_room_id, rt.price_linking, rt.name
                FROM gas_sync_room_types rt
                JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
                WHERE sp.connection_id = $1 
                  AND rt.gas_room_id IS NOT NULL
                  AND rt.price_linking->>'sourceRoomId' = $2
              `, [conn.id, String(beds24RoomId)]);
              
              if (linkedRoomsResult.rows.length > 0) {
                console.log(`  ‚Üí Pushing prices to ${linkedRoomsResult.rows.length} linked rooms`);
                
                for (const linkedRoom of linkedRoomsResult.rows) {
                  const linking = typeof linkedRoom.price_linking === 'string' 
                    ? JSON.parse(linkedRoom.price_linking) 
                    : linkedRoom.price_linking;
                  const multiplier = linking.offsetMultiplier || 1;
                  const offset = linking.offsetAmount || 0;
                  
                  let linkedDays = 0;
                  for (const entry of calendarData) {
                    const fromDate = new Date(entry.from);
                    const toDate = new Date(entry.to);
                    
                    for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                      const dateStr = d.toISOString().split('T')[0];
                      const basePrice = entry.price1 || null;
                      const linkedPrice = basePrice ? (basePrice * multiplier) + offset : null;
                      const minStay = entry.minStay || 1;
                      
                      // Only update price if we have one - don't overwrite availability
                      if (linkedPrice) {
                        await pool.query(`
                          INSERT INTO room_availability (room_id, date, cm_price, direct_price, min_stay, cm_min_stay, source, updated_at)
                          VALUES ($1, $2, $3, $3, $4, $4, 'beds24-linked', NOW())
                          ON CONFLICT (room_id, date) 
                          DO UPDATE SET 
                            cm_price = $3,
                            direct_price = $3,
                            min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $4 END,
                            cm_min_stay = $4,
                            source = 'beds24-linked',
                            updated_at = NOW()
                        `, [linkedRoom.gas_room_id, dateStr, linkedPrice, minStay]);
                        linkedDays++;
                      }
                    }
                  }
                  console.log(`    ‚úì ${linkedRoom.name}: ${linkedDays} days`);
                  results.totalDaysUpdated += linkedDays;
                }
              }
            }
            // ===== END PUSH PRICES TO LINKED ROOMS =====
            
            // Update tier sync timestamp
            await pool.query(`UPDATE gas_sync_room_types SET ${tierColumn} = NOW() WHERE id = $1`, [room.id]);
            
            tierResult.rooms.push({ id: room.id, name: room.name, daysUpdated });
            tierResult.daysUpdated += daysUpdated;
            results.totalRoomsSynced++;
            results.totalDaysUpdated += daysUpdated;
            
            // Rate limit protection: wait 2 seconds between API calls
            await new Promise(resolve => setTimeout(resolve, 2000));
            
          } catch (roomError) {
            results.errors.push({ room: room.id, name: room.name, tier: tier.tier, error: roomError.message });
            
            // If rate limited, stop this tier
            if (roomError.response?.status === 429) {
              console.log(`Rate limited on tier ${tier.tier}, stopping tier sync`);
              break;
            }
          }
        }
        
        if (tierResult.rooms.length > 0) {
          results.tiers.push(tierResult);
        }
      }
    }
    
    console.log(`Tiered sync complete: ${results.totalRoomsSynced} rooms, ${results.totalDaysUpdated} days`);
    res.json({ success: true, ...results });
    
  } catch (error) {
    console.error('Tiered sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Manual trigger for specific tier (for testing/debugging)
app.post('/api/gas-sync/connections/:connectionId/sync-tier/:tier', async (req, res) => {
  try {
    const { connectionId, tier } = req.params;
    const tierNum = parseInt(tier);
    const tierConfig = SYNC_TIERS.find(t => t.tier === tierNum);
    
    if (!tierConfig) {
      return res.json({ success: false, error: 'Invalid tier. Use 1-4.' });
    }
    
    // Get connection
    const conn = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [connectionId]);
    if (conn.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const connection = conn.rows[0];
    let accessToken = connection.access_token;
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token' });
    }
    
    const now = new Date();
    const startDate = new Date(now.getTime() + tierConfig.startDay * 24 * 60 * 60 * 1000);
    const endDate = new Date(now.getTime() + tierConfig.endDay * 24 * 60 * 60 * 1000);
    
    // Get all rooms for this connection
    const rooms = await pool.query(`
      SELECT rt.id, rt.external_id as beds24_room_id, rt.gas_room_id, bu.name
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
      JOIN bookable_units bu ON bu.id = rt.gas_room_id
      WHERE sp.connection_id = $1 AND rt.gas_room_id IS NOT NULL
    `, [connectionId]);
    
    const results = { tier: tierConfig, rooms: [], totalDays: 0 };
    
    for (const room of rooms.rows) {
      try {
        const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
          headers: { 'token': accessToken },
          params: {
            roomId: parseInt(room.beds24_room_id),
            startDate: startDate.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0],
            includeNumAvail: true,
            includePrices: true,
            includeMinStay: true
          }
        });
        
        const calendarData = calResponse.data.data?.[0]?.calendar || [];
        let daysUpdated = 0;
        
        for (const entry of calendarData) {
          const fromDate = new Date(entry.from);
          const toDate = new Date(entry.to);
          
          for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            
            await pool.query(`
              INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
              VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24', NOW())
              ON CONFLICT (room_id, date) 
              DO UPDATE SET 
                cm_price = COALESCE($3, room_availability.cm_price),
                is_available = $4,
                is_blocked = $5,
                min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                cm_min_stay = $6,
                source = 'beds24',
                updated_at = NOW()
            `, [room.gas_room_id, dateStr, entry.price1, (entry.numAvail || 0) > 0, (entry.numAvail || 0) === 0, entry.minStay || 1]);
            
            daysUpdated++;
          }
        }
        
        // Update tier timestamp
        await pool.query(`UPDATE gas_sync_room_types SET tier${tierNum}_synced_at = NOW() WHERE id = $1`, [room.id]);
        
        results.rooms.push({ name: room.name, daysUpdated });
        results.totalDays += daysUpdated;
        
        // Rate limit protection
        await new Promise(resolve => setTimeout(resolve, 2000));
        
      } catch (e) {
        results.rooms.push({ name: room.name, error: e.message });
      }
    }
    
    res.json({ success: true, ...results });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================
// V1 PRICING SYNC - For Fixed Prices (Belmont-style)
// ============================================
// This endpoint uses Beds24 V1 getRates API for properties using Fixed Prices
// Run once daily as V1 has stricter rate limits
// Only for rooms where V2 Calendar returns no pricing data

app.post('/api/gas-sync/v1-pricing-sync', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'];
  const isDev = process.env.NODE_ENV === 'development' || req.query.dev === 'true';
  
  if (!isDev && cronSecret !== process.env.CRON_SECRET) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  try {
    const results = { 
      properties: [], 
      totalRoomsUpdated: 0, 
      totalDaysUpdated: 0, 
      errors: [] 
    };
    
    // Get all Beds24 connections with V1 credentials
    const connections = await pool.query(`
      SELECT c.id, c.credentials, c.access_token, c.refresh_token
      FROM gas_sync_connections c
      WHERE c.adapter_code = 'beds24' AND c.sync_enabled = true
    `);
    
    for (const conn of connections.rows) {
      const credentials = typeof conn.credentials === 'string' 
        ? JSON.parse(conn.credentials) 
        : (conn.credentials || {});
      
      const v1ApiKey = credentials.v1ApiKey;
      if (!v1ApiKey) {
        console.log(`Connection ${conn.id}: No V1 API key, skipping`);
        continue;
      }
      
      // Get properties with prop_key for this connection
      const properties = await pool.query(`
        SELECT sp.id, sp.external_id, sp.name, sp.prop_key
        FROM gas_sync_properties sp
        WHERE sp.connection_id = $1 AND sp.prop_key IS NOT NULL AND sp.prop_key != ''
      `, [conn.id]);
      
      for (const prop of properties.rows) {
        try {
          console.log(`V1 Pricing Sync: ${prop.name} (${prop.external_id})`);
          
          // Call V1 getRates for this property (all rooms at once)
          const ratesResponse = await axios.post('https://api.beds24.com/json/getRates', {
            authentication: {
              apiKey: v1ApiKey,
              propKey: prop.prop_key
            }
          }, {
            headers: { 'Content-Type': 'application/json' }
          });
          
          const rates = ratesResponse.data;
          
          if (!Array.isArray(rates) || rates.length === 0) {
            console.log(`  No rates returned for ${prop.name}`);
            continue;
          }
          
          console.log(`  Got ${rates.length} rate rules`);
          
          // Get all room types for this property
          const roomTypes = await pool.query(`
            SELECT rt.id, rt.external_id as beds24_room_id, rt.gas_room_id, bu.name
            FROM gas_sync_room_types rt
            JOIN bookable_units bu ON bu.id = rt.gas_room_id
            WHERE rt.sync_property_id = $1 AND rt.gas_room_id IS NOT NULL
          `, [prop.id]);
          
          // Build a map of beds24_room_id -> gas_room_id
          const roomMap = {};
          for (const rt of roomTypes.rows) {
            roomMap[rt.beds24_room_id] = { gas_room_id: rt.gas_room_id, name: rt.name };
          }
          
          // Build date -> price map for each room (use HIGHER price for overlaps)
          const roomPrices = {}; // { beds24_room_id: { date: { price, minNights } } }
          
          const today = new Date();
          const maxDate = new Date(today.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year out
          
          for (const rate of rates) {
            const roomId = rate.roomId;
            const firstNight = new Date(rate.firstNight);
            const lastNight = new Date(rate.lastNight);
            const price = parseFloat(rate.roomPrice) || 0;
            const minNights = parseInt(rate.minNights) || 1;
            
            // Skip if no price or past dates
            if (price <= 0 || lastNight < today) continue;
            
            // Skip if room not in our system
            if (!roomMap[roomId]) continue;
            
            // Initialize room price map
            if (!roomPrices[roomId]) roomPrices[roomId] = {};
            
            // Expand date range
            for (let d = new Date(Math.max(firstNight.getTime(), today.getTime())); 
                 d <= lastNight && d <= maxDate; 
                 d.setDate(d.getDate() + 1)) {
              
              const dateStr = d.toISOString().split('T')[0];
              
              // Use HIGHER price for overlapping dates
              if (!roomPrices[roomId][dateStr] || price > roomPrices[roomId][dateStr].price) {
                roomPrices[roomId][dateStr] = { price, minNights };
              }
            }
          }
          
          // Now update room_availability for each room
          let propRoomsUpdated = 0;
          let propDaysUpdated = 0;
          
          for (const [beds24RoomId, dates] of Object.entries(roomPrices)) {
            const gasRoomId = roomMap[beds24RoomId]?.gas_room_id;
            if (!gasRoomId) continue;
            
            const dateCount = Object.keys(dates).length;
            if (dateCount === 0) continue;
            
            // Batch insert/update
            for (const [dateStr, data] of Object.entries(dates)) {
              await pool.query(`
                INSERT INTO room_availability (room_id, date, cm_price, direct_price, min_stay, cm_min_stay, source, updated_at)
                VALUES ($1, $2, $3, $3, $4, $4, 'beds24_v1', NOW())
                ON CONFLICT (room_id, date) 
                DO UPDATE SET 
                  cm_price = COALESCE($3, room_availability.cm_price),
                  min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $4 END,
                  cm_min_stay = $4,
                  source = 'beds24_v1',
                  updated_at = NOW()
              `, [gasRoomId, dateStr, data.price, data.minNights]);
              
              propDaysUpdated++;
            }
            
            propRoomsUpdated++;
          }
          
          results.properties.push({
            name: prop.name,
            external_id: prop.external_id,
            ratesFound: rates.length,
            roomsUpdated: propRoomsUpdated,
            daysUpdated: propDaysUpdated
          });
          
          results.totalRoomsUpdated += propRoomsUpdated;
          results.totalDaysUpdated += propDaysUpdated;
          
          // Rate limit protection: wait 5 seconds between properties
          await new Promise(resolve => setTimeout(resolve, 5000));
          
        } catch (propError) {
          console.error(`V1 Pricing error for ${prop.name}:`, propError.message);
          results.errors.push({ 
            property: prop.name, 
            error: propError.message 
          });
          
          // If rate limited, stop
          if (propError.response?.status === 429) {
            results.errors.push({ message: 'Rate limited by Beds24, stopping sync' });
            break;
          }
        }
      }
    }
    
    console.log(`V1 Pricing sync complete: ${results.totalRoomsUpdated} rooms, ${results.totalDaysUpdated} days`);
    res.json({ success: true, ...results });
    
  } catch (error) {
    console.error('V1 Pricing sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Manual V1 pricing sync for a single property
app.post('/api/gas-sync/properties/:propertyId/v1-pricing-sync', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    // Get property with connection
    const propResult = await pool.query(`
      SELECT sp.id, sp.external_id, sp.name, sp.prop_key, sp.connection_id,
             c.credentials
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    const credentials = typeof prop.credentials === 'string' 
      ? JSON.parse(prop.credentials) 
      : (prop.credentials || {});
    
    if (!credentials.v1ApiKey) {
      return res.json({ success: false, error: 'No V1 API key configured for this connection' });
    }
    
    if (!prop.prop_key) {
      return res.json({ success: false, error: 'No prop_key configured for this property' });
    }
    
    console.log(`Manual V1 Pricing Sync: ${prop.name}`);
    
    // Call V1 getRates
    const ratesResponse = await axios.post('https://api.beds24.com/json/getRates', {
      authentication: {
        apiKey: credentials.v1ApiKey,
        propKey: prop.prop_key
      }
    }, {
      headers: { 'Content-Type': 'application/json' }
    });
    
    const rates = ratesResponse.data;
    
    if (!Array.isArray(rates) || rates.length === 0) {
      return res.json({ success: true, message: 'No rates returned', ratesCount: 0 });
    }
    
    // Get room types
    const roomTypes = await pool.query(`
      SELECT rt.id, rt.external_id as beds24_room_id, rt.gas_room_id, bu.name
      FROM gas_sync_room_types rt
      JOIN bookable_units bu ON bu.id = rt.gas_room_id
      WHERE rt.sync_property_id = $1 AND rt.gas_room_id IS NOT NULL
    `, [prop.id]);
    
    const roomMap = {};
    for (const rt of roomTypes.rows) {
      roomMap[rt.beds24_room_id] = { gas_room_id: rt.gas_room_id, name: rt.name };
    }
    
    // Build date -> price map
    const roomPrices = {};
    const today = new Date();
    const maxDate = new Date(today.getTime() + 365 * 24 * 60 * 60 * 1000);
    
    for (const rate of rates) {
      const roomId = rate.roomId;
      const firstNight = new Date(rate.firstNight);
      const lastNight = new Date(rate.lastNight);
      const price = parseFloat(rate.roomPrice) || 0;
      const minNights = parseInt(rate.minNights) || 1;
      
      if (price <= 0 || lastNight < today) continue;
      if (!roomMap[roomId]) continue;
      
      if (!roomPrices[roomId]) roomPrices[roomId] = {};
      
      for (let d = new Date(Math.max(firstNight.getTime(), today.getTime())); 
           d <= lastNight && d <= maxDate; 
           d.setDate(d.getDate() + 1)) {
        
        const dateStr = d.toISOString().split('T')[0];
        
        if (!roomPrices[roomId][dateStr] || price > roomPrices[roomId][dateStr].price) {
          roomPrices[roomId][dateStr] = { price, minNights };
        }
      }
    }
    
    // Update room_availability
    let roomsUpdated = 0;
    let daysUpdated = 0;
    const roomDetails = [];
    
    for (const [beds24RoomId, dates] of Object.entries(roomPrices)) {
      const room = roomMap[beds24RoomId];
      if (!room?.gas_room_id) continue;
      
      const dateCount = Object.keys(dates).length;
      if (dateCount === 0) continue;
      
      for (const [dateStr, data] of Object.entries(dates)) {
        await pool.query(`
          INSERT INTO room_availability (room_id, date, cm_price, direct_price, min_stay, cm_min_stay, source, updated_at)
          VALUES ($1, $2, $3, $3, $4, $4, 'beds24_v1', NOW())
          ON CONFLICT (room_id, date) 
          DO UPDATE SET 
            cm_price = COALESCE($3, room_availability.cm_price),
            min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $4 END,
            cm_min_stay = $4,
            source = 'beds24_v1',
            updated_at = NOW()
        `, [room.gas_room_id, dateStr, data.price, data.minNights]);
        
        daysUpdated++;
      }
      
      roomsUpdated++;
      roomDetails.push({ name: room.name, beds24RoomId, daysUpdated: dateCount });
    }
    
    res.json({ 
      success: true, 
      property: prop.name,
      ratesFound: rates.length,
      roomsUpdated,
      daysUpdated,
      rooms: roomDetails
    });
    
  } catch (error) {
    console.error('Manual V1 pricing sync error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ROOM SYNC CHECK - Compare Beds24 vs GAS rooms
// =========================================================

// Check for room changes between Beds24 and GAS
// Check for new/removed properties in Beds24 compared to GAS
app.post('/api/gas-sync/connections/:id/check-properties', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get connection info
    const connResult = await pool.query(`
      SELECT * FROM gas_sync_connections WHERE id = $1
    `, [id]);
    
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    let credentials = conn.credentials || {};
    if (typeof credentials === 'string') {
      credentials = JSON.parse(credentials);
    }
    
    let cmProperties = []; // Normalized: { externalId, name, city, country }
    
    if (conn.adapter_code === 'calry') {
      // CALRY: Fetch properties via Calry API
      const integrationAccountId = conn.external_account_id || credentials.integrationAccountId;
      if (!integrationAccountId) {
        return res.status(400).json({ success: false, error: 'No integration account ID for this Calry connection.' });
      }
      
      const calryToken = conn.access_token || credentials.token || CALRY_API_TOKEN;
      const calryWorkspace = credentials.workspaceId || CALRY_WORKSPACE_ID;
      
      const propResponse = await axios.get(`${CALRY_API_BASE}/properties`, {
        headers: {
          'Authorization': `Bearer ${calryToken}`,
          'workspaceId': calryWorkspace,
          'integrationAccountId': integrationAccountId,
          'Content-Type': 'application/json'
        }
      });
      
      const calryProps = propResponse.data?.data || [];
      cmProperties = calryProps.map(p => ({
        externalId: String(p.id),
        name: p.name || p.internalName || 'Unnamed',
        city: p.address?.city || p.city || '',
        country: p.address?.country || p.country || ''
      }));
      
    } else {
      // BEDS24: Fetch properties via Beds24 API
      const refreshToken = credentials.refreshToken || conn.refresh_token;
      
      if (!refreshToken) {
        return res.status(400).json({ success: false, error: 'No API credentials for this connection. Please reconnect to Beds24.' });
      }
      
      const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
        headers: { 'refreshToken': refreshToken }
      });
      const accessToken = tokenResponse.data.token;
      
      const propertiesResponse = await axios.get('https://beds24.com/api/v2/properties', {
        headers: { token: accessToken }
      });
      
      const beds24Properties = propertiesResponse.data.data || [];
      cmProperties = beds24Properties.map(p => ({
        externalId: String(p.id),
        name: p.name,
        city: p.city || '',
        country: p.country || ''
      }));
    }
    
    // Get synced properties for this connection
    const syncedResult = await pool.query(`
      SELECT external_id, name, gas_property_id FROM gas_sync_properties WHERE connection_id = $1
    `, [id]);
    
    const syncedByExternalId = {};
    syncedResult.rows.forEach(p => { syncedByExternalId[String(p.external_id)] = p; });
    
    const matched = [];
    const newProperties = [];
    
    for (const cmProp of cmProperties) {
      const synced = syncedByExternalId[cmProp.externalId];
      
      if (synced) {
        matched.push({
          externalId: cmProp.externalId,
          name: cmProp.name,
          gasPropertyId: synced.gas_property_id
        });
      } else {
        newProperties.push({
          externalId: cmProp.externalId,
          name: cmProp.name,
          city: cmProp.city,
          country: cmProp.country
        });
      }
    }
    
    // Check for removed properties (in GAS but not in CM)
    const cmByExternalId = {};
    cmProperties.forEach(p => { cmByExternalId[p.externalId] = p; });
    
    const removedProperties = [];
    for (const synced of syncedResult.rows) {
      if (!cmByExternalId[String(synced.external_id)]) {
        removedProperties.push({
          externalId: synced.external_id,
          name: synced.name,
          gasPropertyId: synced.gas_property_id
        });
      }
    }
    
    res.json({
      success: true,
      matchedCount: matched.length,
      newProperties,
      removedProperties,
      adapterCode: conn.adapter_code
    });
    
  } catch (error) {
    console.error('Check properties error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Import a new property from Beds24 via gas_sync connection
app.post('/api/gas-sync/connections/:id/import-property', async (req, res) => {
  const client = await pool.connect();
  
  try {
    const { id } = req.params;
    const { externalId } = req.body;
    
    if (!externalId) {
      return res.json({ success: false, error: 'externalId required' });
    }
    
    // Get connection info
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    const accountId = conn.account_id;
    let credentials = conn.credentials || {};
    if (typeof credentials === 'string') credentials = JSON.parse(credentials);
    
    // CALRY: Use Calry API for import
    if (conn.adapter_code === 'calry') {
      const integrationAccountId = conn.external_account_id || credentials.integrationAccountId;
      if (!integrationAccountId) {
        client.release();
        return res.json({ success: false, error: 'No integration account ID for this Calry connection.' });
      }
      
      const calryToken = conn.access_token || credentials.token || CALRY_API_TOKEN;
      const calryWorkspace = credentials.workspaceId || CALRY_WORKSPACE_ID;
      const calryHeaders = {
        'Authorization': `Bearer ${calryToken}`,
        'workspaceId': calryWorkspace,
        'integrationAccountId': integrationAccountId,
        'Content-Type': 'application/json'
      };
      
      console.log(`üì• Importing Calry property ${externalId} for account ${accountId}`);
      
      // Fetch property details
      const propResponse = await axios.get(`${CALRY_API_BASE}/properties/${externalId}`, {
        headers: calryHeaders
      });
      const prop = propResponse.data?.data || propResponse.data;
      if (!prop) {
        client.release();
        return res.json({ success: false, error: 'Property not found in Calry' });
      }
      
      const address = prop.address || {};
      const coords = prop.coordinates || prop.location || {};
      
      await client.query('BEGIN');
      
      // Create/update property in GAS
      const existingProp = await client.query(
        'SELECT id FROM properties WHERE account_id = $1 AND cm_property_id = $2',
        [accountId, String(externalId)]
      );
      
      let gasPropertyId;
      let isUpdate = false;
      
      if (existingProp.rows.length > 0) {
        gasPropertyId = existingProp.rows[0].id;
        isUpdate = true;
        await client.query(`
          UPDATE properties SET
            name = $1, description = $2, property_type = $3,
            address = $4, city = $5, state = $6, postcode = $7, country = $8,
            latitude = $9, longitude = $10, currency = $11,
            check_in_from = $12, check_out_by = $13,
            cm_source = 'calry', updated_at = NOW()
          WHERE id = $14
        `, [
          prop.name || 'Property',
          prop.description || '',
          prop.propertyType || 'vacation_rental',
          address.street || address.line1 || '',
          address.city || '',
          address.state || '',
          address.postalCode || address.zip || '',
          address.country || '',
          coords.latitude || coords.lat || null,
          coords.longitude || coords.lng || null,
          prop.currency || 'EUR',
          prop.defaultCheckIn || prop.checkInTime || '15:00',
          prop.defaultCheckOut || prop.checkOutTime || '11:00',
          gasPropertyId
        ]);
      } else {
        const propResult = await client.query(`
          INSERT INTO properties (
            account_id, user_id, name, description, property_type,
            address, city, state, postcode, country,
            latitude, longitude, currency,
            check_in_from, check_out_by,
            cm_property_id, cm_source, status, created_at
          ) VALUES ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 'calry', 'active', NOW())
          RETURNING id
        `, [
          accountId,
          prop.name || 'Property',
          prop.description || '',
          prop.propertyType || 'vacation_rental',
          address.street || address.line1 || '',
          address.city || '',
          address.state || '',
          address.postalCode || address.zip || '',
          address.country || '',
          coords.latitude || coords.lat || null,
          coords.longitude || coords.lng || null,
          prop.currency || 'EUR',
          prop.defaultCheckIn || prop.checkInTime || '15:00',
          prop.defaultCheckOut || prop.checkOutTime || '11:00',
          String(externalId)
        ]);
        gasPropertyId = propResult.rows[0].id;
      }
      
      // Fetch room types
      let roomsAdded = 0;
      let roomsUpdated = 0;
      const importedRooms = [];
      
      try {
        const roomResponse = await axios.get(`${CALRY_API_BASE}/room-types/${externalId}`, {
          headers: calryHeaders
        });
        const roomTypes = roomResponse.data?.data || [];
        
        for (const rt of roomTypes) {
          const roomExtId = String(rt.id);
          const existingRoom = await client.query(
            'SELECT id FROM bookable_units WHERE property_id = $1 AND cm_room_id = $2',
            [gasPropertyId, roomExtId]
          );
          
          if (existingRoom.rows.length > 0) {
            const gasRoomId = existingRoom.rows[0].id;
            await client.query(`
              UPDATE bookable_units SET
                name = $1, max_guests = $2, max_adults = $3, max_children = $4,
                bedroom_count = $5, bathroom_count = $6, base_price = $7,
                description = $8, short_description = $9, updated_at = NOW()
              WHERE id = $10
            `, [
              rt.name || 'Room',
              rt.maxOccupancy || rt.maxGuests || 2,
              rt.maxAdults || null,
              rt.maxChildren || 0,
              rt.bedRoom?.count || rt.bedrooms || 1,
              rt.bathRoom?.count || rt.bathrooms || 1,
              rt.startPrice || rt.basePrice || 0,
              JSON.stringify({ en: rt.description || '' }),
              JSON.stringify({ en: rt.shortDescription || '' }),
              gasRoomId
            ]);
            roomsUpdated++;
            importedRooms.push({ externalId: roomExtId, gasRoomId, name: rt.name || 'Room', maxGuests: rt.maxOccupancy || 2, quantity: 1 });
          } else {
            const unitResult = await client.query(`
              INSERT INTO bookable_units (
                property_id, cm_room_id, cm_source, name,
                max_guests, max_adults, max_children,
                bedroom_count, bathroom_count, base_price,
                description, short_description, status, created_at
              ) VALUES ($1, $2, 'calry', $3, $4, $5, $6, $7, $8, $9, $10, $11, 'available', NOW())
              RETURNING id
            `, [
              gasPropertyId, roomExtId, rt.name || 'Room',
              rt.maxOccupancy || rt.maxGuests || 2,
              rt.maxAdults || null,
              rt.maxChildren || 0,
              rt.bedRoom?.count || rt.bedrooms || 1,
              rt.bathRoom?.count || rt.bathrooms || 1,
              rt.startPrice || rt.basePrice || 0,
              JSON.stringify({ en: rt.description || '' }),
              JSON.stringify({ en: rt.shortDescription || '' })
            ]);
            roomsAdded++;
            importedRooms.push({ externalId: roomExtId, gasRoomId: unitResult.rows[0].id, name: rt.name || 'Room', maxGuests: rt.maxOccupancy || 2, quantity: 1 });
          }
        }
      } catch (roomErr) {
        console.log('Calry room types fetch error:', roomErr.message);
      }
      
      // Create gas_sync_properties mapping
      const existingSyncProp = await client.query(
        'SELECT id FROM gas_sync_properties WHERE connection_id = $1 AND external_id = $2',
        [id, String(externalId)]
      );
      
      let syncPropertyId;
      if (existingSyncProp.rows.length === 0) {
        const syncPropResult = await client.query(`
          INSERT INTO gas_sync_properties (connection_id, external_id, gas_property_id, name, raw_data, created_at)
          VALUES ($1, $2, $3, $4, $5, NOW()) RETURNING id
        `, [id, String(externalId), gasPropertyId, prop.name || 'Property', JSON.stringify(prop)]);
        syncPropertyId = syncPropResult.rows[0].id;
      } else {
        syncPropertyId = existingSyncProp.rows[0].id;
        await client.query(
          'UPDATE gas_sync_properties SET gas_property_id = $1, name = $2, raw_data = $3, updated_at = NOW() WHERE id = $4',
          [gasPropertyId, prop.name || 'Property', JSON.stringify(prop), syncPropertyId]
        );
      }
      
      // Create gas_sync_room_types entries
      for (const rm of importedRooms) {
        const existingSyncRoom = await client.query(
          'SELECT id FROM gas_sync_room_types WHERE sync_property_id = $1 AND external_id = $2',
          [syncPropertyId, String(rm.externalId)]
        );
        if (existingSyncRoom.rows.length === 0) {
          await client.query(`
            INSERT INTO gas_sync_room_types (sync_property_id, connection_id, external_id, gas_room_id, name, max_guests, unit_count, synced_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
          `, [syncPropertyId, parseInt(id), String(rm.externalId), rm.gasRoomId, rm.name, rm.maxGuests, rm.quantity]);
        } else {
          await client.query(
            'UPDATE gas_sync_room_types SET gas_room_id = $1, name = $2, max_guests = $3, synced_at = NOW() WHERE id = $4',
            [rm.gasRoomId, rm.name, rm.maxGuests, existingSyncRoom.rows[0].id]
          );
        }
      }
      
      await client.query('COMMIT');
      client.release();
      
      console.log(`üéâ Calry import complete: ${prop.name} ‚Äî ${roomsAdded} rooms added, ${roomsUpdated} updated`);
      
      return res.json({
        success: true,
        propertyId: gasPropertyId,
        propertyName: prop.name || 'Property',
        roomsAdded,
        roomsUpdated,
        isUpdate,
        message: isUpdate
          ? `Updated ${prop.name}: ${roomsUpdated} rooms updated, ${roomsAdded} added`
          : `Imported ${prop.name} with ${roomsAdded} rooms.`
      });
    }
    
    // BEDS24: Original Beds24 import flow
    const refreshToken = credentials.refreshToken || conn.refresh_token;
    if (!refreshToken) {
      return res.json({ success: false, error: 'No API credentials. Please reconnect to Beds24.' });
    }
    
    // Get fresh access token
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
      headers: { 'refreshToken': refreshToken }
    });
    const accessToken = tokenResponse.data.token;
    
    // Fetch full property data from Beds24
    console.log(`üì• Importing Beds24 property ${externalId} for account ${accountId}`);
    
    const propResponse = await axios.get('https://beds24.com/api/v2/properties', {
      headers: { 'token': accessToken, 'accept': 'application/json' },
      params: {
        id: externalId,
        includeTexts: 'all',
        includePictures: true,
        includeAllRooms: true,
        includeUnitDetails: true
      }
    });
    
    const prop = propResponse.data.data?.[0] || propResponse.data[0];
    if (!prop) {
      return res.json({ success: false, error: 'Property not found in Beds24' });
    }
    
    await client.query('BEGIN');
    
    // Extract descriptions
    let propertyDescription = '';
    let shortDescription = '';
    let houseRules = '';
    if (prop.texts && Array.isArray(prop.texts) && prop.texts.length > 0) {
      const defaultText = prop.texts[0];
      propertyDescription = defaultText.propertyDescription || defaultText.description || '';
      shortDescription = defaultText.propertyShortDescription || defaultText.shortDescription || '';
      houseRules = defaultText.houseRules || defaultText.propertyHouseRules || '';
    }
    
    // Check if property already exists
    const existingProp = await client.query(
      'SELECT id FROM properties WHERE beds24_property_id::text = $1::text',
      [externalId]
    );
    
    let gasPropertyId;
    let isUpdate = false;
    
    if (existingProp.rows.length > 0) {
      gasPropertyId = existingProp.rows[0].id;
      isUpdate = true;
      
      await client.query(`
        UPDATE properties SET
          name = $1, property_type = $2, description = $3, short_description = $4,
          house_rules = $5, address = $6, city = $7, state = $8, postcode = $9,
          country = $10, latitude = $11, longitude = $12, check_in_from = $13,
          check_in_until = $14, check_out_by = $15, currency = $16, phone = $17,
          email = $18, website = $19, cm_source = 'beds24', account_id = $20, user_id = COALESCE(user_id, 1), updated_at = NOW()
        WHERE id = $21
      `, [
        prop.name || 'Property',
        prop.propertyType || 'hotel',
        JSON.stringify({ en: propertyDescription }),
        JSON.stringify({ en: shortDescription }),
        JSON.stringify({ en: houseRules }),
        prop.address || '', prop.city || '', prop.state || '',
        prop.postcode || prop.zipCode || '', prop.country || '',
        prop.latitude || null, prop.longitude || null,
        prop.checkInStart || prop.checkInFrom || '15:00',
        prop.checkInEnd || prop.checkInUntil || '22:00',
        prop.checkOutEnd || prop.checkOutBy || '11:00',
        prop.currency || 'USD',
        prop.phone || '', prop.email || '', prop.website || '',
        accountId, gasPropertyId
      ]);
    } else {
      const propertyResult = await client.query(`
        INSERT INTO properties (
          account_id, user_id, beds24_property_id, cm_source, name, property_type,
          description, short_description, house_rules,
          address, city, state, postcode, country,
          latitude, longitude, check_in_from, check_in_until, check_out_by,
          currency, phone, email, website, status
        ) VALUES (
          $1, 1, $2, 'beds24', $3, $4, $5, $6, $7, $8, $9, $10, $11, $12,
          $13, $14, $15, $16, $17, $18, $19, $20, $21, 'active'
        ) RETURNING id
      `, [
        accountId, externalId,
        prop.name || 'Property',
        prop.propertyType || 'hotel',
        JSON.stringify({ en: propertyDescription }),
        JSON.stringify({ en: shortDescription }),
        JSON.stringify({ en: houseRules }),
        prop.address || '', prop.city || '', prop.state || '',
        prop.postcode || prop.zipCode || '', prop.country || '',
        prop.latitude || null, prop.longitude || null,
        prop.checkInStart || prop.checkInFrom || '15:00',
        prop.checkInEnd || prop.checkInUntil || '22:00',
        prop.checkOutEnd || prop.checkOutBy || '11:00',
        prop.currency || 'USD',
        prop.phone || '', prop.email || '', prop.website || ''
      ]);
      gasPropertyId = propertyResult.rows[0].id;
    }
    
    console.log(`   ‚úì Property ${isUpdate ? 'updated' : 'created'} (GAS ID: ${gasPropertyId})`);
    
    // Import rooms
    let rooms = prop.roomTypes || prop.rooms || [];
    if (!Array.isArray(rooms)) rooms = [];
    
    let roomsAdded = 0;
    let roomsUpdated = 0;
    const importedRooms = [];
    
    function getBedNameImport(code) {
      const names = {
        'BED_BUNK': 'Bunkbed', 'BED_CHILD': 'Child Bed', 'BED_CRIB': 'Cot',
        'BED_DOUBLE': 'Double Bed', 'BED_KING': 'King Bed', 'BED_MURPHY': 'Murphy Bed',
        'BED_QUEEN': 'Queen Bed', 'BED_SOFA': 'Sofa Bed', 'BED_SINGLE': 'Single Bed',
        'BED_FUTON': 'Futon', 'BED_FLOORMATTRESS': 'Floor Mattress', 'BED_TODDLER': 'Toddler Bed',
        'BED_HAMMOCK': 'Hammock', 'BED_AIRMATTRESS': 'Air Mattress', 'BED_COUCH': 'Couch'
      };
      return names[code] || code;
    }
    
    for (const room of rooms) {
      const beds24RoomId = String(room.id || room.roomId);
      
      let roomDescription = '';
      let roomShortDesc = '';
      if (room.texts && Array.isArray(room.texts) && room.texts.length > 0) {
        const roomText = room.texts[0];
        roomDescription = roomText.roomDescription || roomText.description || '';
        roomShortDesc = roomText.roomShortDescription || roomText.shortDescription || '';
      }
      
      // Bed config
      let bedConfig = null;
      if (room.bedTypes && Array.isArray(room.bedTypes) && room.bedTypes.length > 0) {
        bedConfig = { beds: room.bedTypes.map(b => ({ type: b.type || 'BED_DOUBLE', quantity: b.quantity || 1, name: getBedNameImport(b.type || 'BED_DOUBLE') })) };
      } else if (room.featureCodes && typeof room.featureCodes === 'string') {
        const bedCodes = room.featureCodes.split(',').map(c => c.trim()).filter(c => c.startsWith('BED_'));
        if (bedCodes.length > 0) {
          const bedCounts = {};
          for (const code of bedCodes) bedCounts[code] = (bedCounts[code] || 0) + 1;
          bedConfig = { beds: Object.entries(bedCounts).map(([type, quantity]) => ({ type, quantity, name: getBedNameImport(type) })) };
        }
      }
      
      let bedroomCount = room.bedroomCount || room.bedrooms || null;
      let bathroomCount = room.bathroomCount || room.bathrooms || null;
      
      // Check if room exists
      const existingRoom = await client.query(`
        SELECT id FROM bookable_units 
        WHERE property_id = $1 AND (cm_room_id::text = $2::text OR beds24_room_id::text = $2::text)
      `, [gasPropertyId, beds24RoomId]);
      
      if (existingRoom.rows.length > 0) {
        const gasRoomId = existingRoom.rows[0].id;
        await client.query(`
          UPDATE bookable_units SET
            name = $1, unit_type = $2, description = $3, short_description = $4,
            max_guests = $5, max_adults = $6, max_children = $7, quantity = $8,
            base_price = $9, size_sqm = $10, bed_configuration = $11,
            bathroom_count = $12, bedroom_count = $13, min_stay = $14, max_stay = $15,
            beds24_room_id = $17, cm_room_id = $18, updated_at = NOW()
          WHERE id = $16
        `, [
          room.name || 'Room', room.roomType || 'double',
          JSON.stringify({ en: roomDescription }), JSON.stringify({ en: roomShortDesc }),
          room.maxPeople || room.maxGuests || 2, room.maxAdult || room.maxAdults || 2,
          room.maxChildren || 0, room.qty || room.quantity || 1,
          room.rackRate || room.basePrice || room.price || 100,
          room.size || room.sizeSqm || null,
          bedConfig ? JSON.stringify(bedConfig) : null,
          bathroomCount, bedroomCount, room.minStay || 1, room.maxStay || null,
          gasRoomId,
          parseInt(beds24RoomId) || null, beds24RoomId
        ]);
        roomsUpdated++;
        importedRooms.push({ externalId: beds24RoomId, gasRoomId, name: room.name || 'Room', maxGuests: room.maxPeople || room.maxGuests || 2, quantity: room.qty || room.quantity || 1 });
      } else {
        const unitResult = await client.query(`
          INSERT INTO bookable_units (
            property_id, beds24_room_id, cm_room_id, name, unit_type,
            description, short_description, max_guests, max_adults, max_children,
            quantity, base_price, size_sqm, bed_configuration,
            bathroom_count, bedroom_count, min_stay, max_stay, status
          ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,'available')
          RETURNING id
        `, [
          gasPropertyId, parseInt(beds24RoomId) || null, beds24RoomId,
          room.name || 'Room', room.roomType || 'double',
          JSON.stringify({ en: roomDescription }), JSON.stringify({ en: roomShortDesc }),
          room.maxPeople || room.maxGuests || 2, room.maxAdult || room.maxAdults || 2,
          room.maxChildren || 0, room.qty || room.quantity || 1,
          room.rackRate || room.basePrice || room.price || 100,
          room.size || room.sizeSqm || null,
          bedConfig ? JSON.stringify(bedConfig) : null,
          bathroomCount, bedroomCount, room.minStay || 1, room.maxStay || null
        ]);
        roomsAdded++;
        importedRooms.push({ externalId: beds24RoomId, gasRoomId: unitResult.rows[0].id, name: room.name || 'Room', maxGuests: room.maxPeople || room.maxGuests || 2, quantity: room.qty || room.quantity || 1 });
      }
    }
    
    // Create gas_sync_properties mapping
    const existingSyncProp = await client.query(
      'SELECT id FROM gas_sync_properties WHERE connection_id = $1 AND external_id = $2',
      [id, String(externalId)]
    );
    
    let syncPropertyId;
    if (existingSyncProp.rows.length === 0) {
      const syncPropResult = await client.query(`
        INSERT INTO gas_sync_properties (connection_id, external_id, gas_property_id, name, created_at)
        VALUES ($1, $2, $3, $4, NOW()) RETURNING id
      `, [id, String(externalId), gasPropertyId, prop.name || 'Property']);
      syncPropertyId = syncPropResult.rows[0].id;
    } else {
      syncPropertyId = existingSyncProp.rows[0].id;
      await client.query(`
        UPDATE gas_sync_properties SET gas_property_id = $1, name = $2, updated_at = NOW()
        WHERE id = $3
      `, [gasPropertyId, prop.name || 'Property', syncPropertyId]);
    }
    
    // Create gas_sync_room_types entries (required for sync-content and link-to-gas to work)
    for (const rm of importedRooms) {
      const existingSyncRoom = await client.query(
        'SELECT id FROM gas_sync_room_types WHERE sync_property_id = $1 AND external_id = $2',
        [syncPropertyId, String(rm.externalId)]
      );
      
      if (existingSyncRoom.rows.length === 0) {
        await client.query(`
          INSERT INTO gas_sync_room_types (sync_property_id, connection_id, external_id, gas_room_id, name, max_guests, unit_count, synced_at)
          VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
        `, [syncPropertyId, parseInt(id), String(rm.externalId), rm.gasRoomId, rm.name, rm.maxGuests, rm.quantity]);
      } else {
        await client.query(`
          UPDATE gas_sync_room_types SET gas_room_id = $1, name = $2, max_guests = $3, unit_count = $4, synced_at = NOW()
          WHERE id = $5
        `, [rm.gasRoomId, rm.name, rm.maxGuests, rm.quantity, existingSyncRoom.rows[0].id]);
      }
    }
    
    await client.query('COMMIT');
    
    console.log(`üéâ Import complete: ${prop.name} ‚Äî ${roomsAdded} rooms added, ${roomsUpdated} updated`);
    
    res.json({
      success: true,
      propertyId: gasPropertyId,
      propertyName: prop.name || 'Property',
      roomsAdded,
      roomsUpdated,
      isUpdate,
      message: isUpdate
        ? `Updated ${prop.name}: ${roomsUpdated} rooms updated, ${roomsAdded} added`
        : `Imported ${prop.name} with ${roomsAdded} rooms. Configure amenities & images in GAS.`
    });
    
  } catch (error) {
    await client.query('ROLLBACK').catch(() => {});
    console.error('Import property error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

app.post('/api/gas-sync/properties/:propertyId/check-room-changes', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    // Get sync property info
    const propResult = await pool.query(`
      SELECT sp.*, c.credentials, c.adapter_code
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    const credentials = prop.credentials;
    
    if (!credentials?.refreshToken) {
      return res.status(400).json({ success: false, error: 'No API credentials for this connection' });
    }
    
    // Get access token
    const tokenResponse = await axios.post('https://beds24.com/api/v2/authentication/token', {
      refreshToken: credentials.refreshToken
    });
    const accessToken = tokenResponse.data.token;
    
    // Fetch rooms from Beds24
    const roomsResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms', {
      headers: { token: accessToken },
      params: { propertyId: prop.external_id }
    });
    
    const beds24Rooms = roomsResponse.data.data || [];
    
    // Get GAS rooms for this property
    const gasRoomsResult = await pool.query(`
      SELECT rt.*, bu.name as gas_name, bu.status as gas_status, bu.is_hidden
      FROM gas_sync_room_types rt
      LEFT JOIN bookable_units bu ON rt.gas_room_id = bu.id
      WHERE rt.sync_property_id = $1
    `, [propertyId]);
    
    const gasRooms = gasRoomsResult.rows;
    
    // Build comparison
    const beds24ByExternalId = {};
    beds24Rooms.forEach(r => { beds24ByExternalId[String(r.id)] = r; });
    
    const gasByExternalId = {};
    gasRooms.forEach(r => { gasByExternalId[String(r.external_id)] = r; });
    
    const matched = [];
    const newRooms = [];
    const removedRooms = [];
    const nameChanges = [];
    
    // Check Beds24 rooms against GAS
    for (const b24Room of beds24Rooms) {
      const externalId = String(b24Room.id);
      const gasRoom = gasByExternalId[externalId];
      
      if (gasRoom) {
        // Room exists in both
        if (gasRoom.name !== b24Room.name) {
          nameChanges.push({
            external_id: externalId,
            beds24_name: b24Room.name,
            gas_name: gasRoom.name,
            gas_room_id: gasRoom.gas_room_id,
            sync_room_id: gasRoom.id
          });
        }
        matched.push({
          external_id: externalId,
          name: b24Room.name,
          gas_room_id: gasRoom.gas_room_id,
          is_hidden: gasRoom.is_hidden,
          status: gasRoom.gas_status
        });
      } else {
        // New room in Beds24, not in GAS
        newRooms.push({
          external_id: externalId,
          name: b24Room.name,
          max_guests: b24Room.maxPeople || 2,
          quantity: b24Room.qty || 1
        });
      }
    }
    
    // Check GAS rooms against Beds24 (find removed)
    for (const gasRoom of gasRooms) {
      const externalId = String(gasRoom.external_id);
      if (!beds24ByExternalId[externalId]) {
        // Room exists in GAS but not in Beds24 anymore
        removedRooms.push({
          external_id: externalId,
          name: gasRoom.name,
          gas_name: gasRoom.gas_name,
          gas_room_id: gasRoom.gas_room_id,
          sync_room_id: gasRoom.id,
          is_hidden: gasRoom.is_hidden,
          status: gasRoom.gas_status
        });
      }
    }
    
    res.json({
      success: true,
      property: prop.name,
      summary: {
        matched: matched.length,
        new: newRooms.length,
        removed: removedRooms.length,
        nameChanges: nameChanges.length
      },
      matched,
      newRooms,
      removedRooms,
      nameChanges
    });
    
  } catch (error) {
    console.error('Check room changes error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Import new rooms from Beds24
app.post('/api/gas-sync/properties/:propertyId/import-new-rooms', async (req, res) => {
  const client = await pool.connect();
  try {
    const { propertyId } = req.params;
    const { rooms } = req.body; // Array of { external_id, name, max_guests, quantity }
    
    if (!rooms || rooms.length === 0) {
      return res.json({ success: false, error: 'No rooms to import' });
    }
    
    // Get sync property info
    const propResult = await pool.query(`
      SELECT sp.*, c.credentials
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    
    await client.query('BEGIN');
    
    const imported = [];
    
    for (const room of rooms) {
      // Create bookable_unit first
      const unitResult = await client.query(`
        INSERT INTO bookable_units (property_id, name, max_guests, quantity, status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, 'active', NOW(), NOW())
        RETURNING id
      `, [prop.gas_property_id, room.name, room.max_guests || 2, room.quantity || 1]);
      
      const gasRoomId = unitResult.rows[0].id;
      
      // Create gas_sync_room_types entry
      await client.query(`
        INSERT INTO gas_sync_room_types (sync_property_id, external_id, name, max_guests, unit_count, gas_room_id, synced_at)
        VALUES ($1, $2, $3, $4, $5, $6, NOW())
      `, [propertyId, room.external_id, room.name, room.max_guests || 2, room.quantity || 1, gasRoomId]);
      
      imported.push({ external_id: room.external_id, name: room.name, gas_room_id: gasRoomId });
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: `Imported ${imported.length} rooms`,
      imported,
      websiteReminder: true
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Import rooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Archive removed rooms (no longer in Beds24)
app.post('/api/gas-sync/properties/:propertyId/archive-rooms', async (req, res) => {
  const client = await pool.connect();
  try {
    const { propertyId } = req.params;
    const { rooms } = req.body; // Array of { gas_room_id, sync_room_id }
    
    if (!rooms || rooms.length === 0) {
      return res.json({ success: false, error: 'No rooms to archive' });
    }
    
    await client.query('BEGIN');
    
    const archived = [];
    
    for (const room of rooms) {
      // Set bookable_unit to archived status and hidden
      if (room.gas_room_id) {
        await client.query(`
          UPDATE bookable_units 
          SET status = 'archived', is_hidden = true, updated_at = NOW()
          WHERE id = $1
        `, [room.gas_room_id]);
      }
      
      // Optionally mark sync room type as archived too
      if (room.sync_room_id) {
        await client.query(`
          UPDATE gas_sync_room_types
          SET synced_at = NOW()
          WHERE id = $1
        `, [room.sync_room_id]);
      }
      
      archived.push(room);
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: `Archived ${archived.length} rooms`,
      archived,
      websiteReminder: true
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Archive rooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Update room names from Beds24
app.post('/api/gas-sync/properties/:propertyId/update-room-names', async (req, res) => {
  const client = await pool.connect();
  try {
    const { propertyId } = req.params;
    const { rooms } = req.body; // Array of { gas_room_id, sync_room_id, new_name }
    
    if (!rooms || rooms.length === 0) {
      return res.json({ success: false, error: 'No rooms to update' });
    }
    
    await client.query('BEGIN');
    
    const updated = [];
    
    for (const room of rooms) {
      // Update bookable_unit name
      if (room.gas_room_id) {
        await client.query(`
          UPDATE bookable_units SET name = $1, updated_at = NOW() WHERE id = $2
        `, [room.new_name, room.gas_room_id]);
      }
      
      // Update sync room type name
      if (room.sync_room_id) {
        await client.query(`
          UPDATE gas_sync_room_types SET name = $1, synced_at = NOW() WHERE id = $2
        `, [room.new_name, room.sync_room_id]);
      }
      
      updated.push(room);
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: `Updated ${updated.length} room names`,
      updated,
      websiteReminder: true
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Update room names error:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Get sync status for a connection
app.get('/api/gas-sync/connections/:connectionId/sync-status', async (req, res) => {
  try {
    const { connectionId } = req.params;
    
    const rooms = await pool.query(`
      SELECT rt.id, bu.name, 
             rt.tier1_synced_at, rt.tier2_synced_at, rt.tier3_synced_at, rt.tier4_synced_at,
             (SELECT COUNT(*) FROM room_availability WHERE room_id = rt.gas_room_id) as availability_days
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
      JOIN bookable_units bu ON bu.id = rt.gas_room_id
      WHERE sp.connection_id = $1 AND rt.gas_room_id IS NOT NULL
    `, [connectionId]);
    
    const now = new Date();
    
    const roomStatus = rooms.rows.map(room => {
      const tiers = SYNC_TIERS.map(tier => {
        const syncedAt = room[`tier${tier.tier}_synced_at`];
        const cutoff = new Date(now.getTime() - tier.intervalMinutes * 60 * 1000);
        const isDue = !syncedAt || new Date(syncedAt) < cutoff;
        
        return {
          tier: tier.tier,
          name: tier.name,
          lastSync: syncedAt,
          isDue,
          interval: `${tier.intervalMinutes} mins`
        };
      });
      
      return {
        id: room.id,
        name: room.name,
        availabilityDays: parseInt(room.availability_days),
        tiers
      };
    });
    
    res.json({ success: true, rooms: roomStatus, tierConfig: SYNC_TIERS });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Run clients migration manually
// ====================================================
// ACCOUNTS SYSTEM - New unified account structure
// =====================================================

app.get('/api/setup-accounts', async (req, res) => {
  try {
    // Create the unified accounts table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS accounts (
        id SERIAL PRIMARY KEY,
        public_id UUID DEFAULT gen_random_uuid() UNIQUE NOT NULL,
        account_code VARCHAR(20) UNIQUE,
        parent_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        managed_by_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        role VARCHAR(20) NOT NULL DEFAULT 'admin',
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE,
        password_hash VARCHAR(255),
        phone VARCHAR(50),
        contact_name VARCHAR(255),
        business_name VARCHAR(255),
        logo_url VARCHAR(500),
        primary_color VARCHAR(20) DEFAULT '#6366f1',
        secondary_color VARCHAR(20) DEFAULT '#8b5cf6',
        address_line1 VARCHAR(255),
        address_line2 VARCHAR(255),
        city VARCHAR(100),
        region VARCHAR(100),
        postcode VARCHAR(20),
        country VARCHAR(100) DEFAULT 'GB',
        currency VARCHAR(3) DEFAULT 'GBP',
        timezone VARCHAR(50) DEFAULT 'Europe/London',
        plan VARCHAR(20) DEFAULT 'free',
        commission_percent DECIMAL(5,2) DEFAULT 0,
        api_key VARCHAR(64) UNIQUE,
        api_key_created_at TIMESTAMP,
        status VARCHAR(20) DEFAULT 'active',
        settings JSONB DEFAULT '{}',
        notes TEXT,
        last_login_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT valid_role CHECK (role IN ('master_admin', 'agency_admin', 'submaster_admin', 'admin', 'travel_agent'))
      )
    `);
    
    // Add account_code column if it doesn't exist
    await pool.query(`
      ALTER TABLE accounts ADD COLUMN IF NOT EXISTS account_code VARCHAR(20) UNIQUE
    `);
    console.log('‚úÖ Created accounts table');

    // Create indexes
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_accounts_parent ON accounts(parent_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_accounts_role ON accounts(role)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_accounts_email ON accounts(email)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_accounts_api_key ON accounts(api_key)`);
    console.log('‚úÖ Created accounts indexes');

    // =========================================================
    // MULTI-TENANT STRUCTURE - Agency Management & Distribution
    // =========================================================
    
    // Update role constraint to include travel_agent
    await pool.query(`ALTER TABLE accounts DROP CONSTRAINT IF EXISTS valid_role`).catch(e => console.log('Drop constraint:', e.message));
    await pool.query(`
      ALTER TABLE accounts ADD CONSTRAINT valid_role 
        CHECK (role IN ('master_admin', 'agency_admin', 'submaster_admin', 'admin', 'travel_agent'))
    `).catch(e => console.log('Add constraint:', e.message));
    
    // Add managed_by_id to accounts (which agency manages this account)
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS managed_by_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_accounts_managed_by ON accounts(managed_by_id)`);
    
    // Add contact_name to accounts
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS contact_name VARCHAR(255)`);
    
    // Add distribution settings to properties
    // distribution_mode: 'open', 'request', 'private'
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS distribution_mode VARCHAR(20) DEFAULT 'private'`);
    // owner_price: Base price owner wants per night
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS owner_price DECIMAL(10,2)`);
    // owner_account_id: Actual owner (vs manager)
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS owner_account_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL`);
    
    // Management requests table (Admin/SubMaster requesting Agency management)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS management_requests (
        id SERIAL PRIMARY KEY,
        requesting_account_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
        agency_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
        status VARCHAR(20) DEFAULT 'pending',
        message TEXT,
        response_message TEXT,
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        responded_at TIMESTAMP,
        CONSTRAINT valid_mgmt_status CHECK (status IN ('pending', 'approved', 'rejected', 'cancelled')),
        CONSTRAINT unique_mgmt_request UNIQUE (requesting_account_id, agency_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_mgmt_requests_requester ON management_requests(requesting_account_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_mgmt_requests_agency ON management_requests(agency_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_mgmt_requests_status ON management_requests(status)`);
    // Add unique constraint if not exists (for existing databases)
    await pool.query(`
      DO $$ BEGIN
        ALTER TABLE management_requests ADD CONSTRAINT unique_mgmt_request UNIQUE (requesting_account_id, agency_id);
      EXCEPTION WHEN duplicate_table THEN
        NULL;
      END $$
    `).catch(() => {});
    
    // Fix orphaned approved requests - if account is self-managed, cancel any approved requests
    await pool.query(`
      UPDATE management_requests mr
      SET status = 'cancelled', response_message = 'Management removed (data cleanup)', responded_at = NOW()
      WHERE mr.status = 'approved' 
        AND NOT EXISTS (
          SELECT 1 FROM accounts a 
          WHERE a.id = mr.requesting_account_id 
            AND a.managed_by_id = mr.agency_id
        )
    `).catch(() => {});
    
    // Distribution access table (Property ‚Üî Travel Agent relationship)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS distribution_access (
        id SERIAL PRIMARY KEY,
        property_id INTEGER NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
        travel_agent_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
        status VARCHAR(20) DEFAULT 'pending',
        commission_percent DECIMAL(5,2) DEFAULT 0,
        message TEXT,
        response_message TEXT,
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        approved_at TIMESTAMP,
        CONSTRAINT valid_dist_status CHECK (status IN ('pending', 'approved', 'rejected', 'revoked')),
        UNIQUE(property_id, travel_agent_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_dist_access_property ON distribution_access(property_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_dist_access_agent ON distribution_access(travel_agent_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_dist_access_status ON distribution_access(status)`);
    
    // Add booking tracking for who sold it and revenue split
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS sold_by_account_id INTEGER REFERENCES accounts(id)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS owner_amount DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS agent_amount DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS platform_fee DECIMAL(10,2)`);
    
    console.log('‚úÖ Created multi-tenant structure (management_requests, distribution_access)');
    // =========================================================
    // END MULTI-TENANT STRUCTURE
    // =========================================================

    // Add account_id to properties if not exists
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS account_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_properties_account ON properties(account_id)`);
    console.log('‚úÖ Added account_id to properties');

    res.json({ 
      success: true, 
      message: 'Accounts table created successfully!'
    });
  } catch (error) {
    console.error('Setup accounts error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Create Master Admin account
app.post('/api/setup-master-admin', async (req, res) => {
  try {
    const { name, email, password } = req.body;
    
    if (!name || !email || !password) {
      return res.json({ success: false, error: 'Name, email, and password required' });
    }
    
    // Check if master admin already exists
    const existing = await pool.query(`SELECT id FROM accounts WHERE role = 'master_admin'`);
    if (existing.rows.length > 0) {
      return res.json({ success: false, error: 'Master Admin already exists' });
    }
    
    // Hash password using crypto (built-in)
    const crypto = require('crypto');
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    
    // Generate API key
    const apiKey = 'gas_master_' + crypto.randomBytes(24).toString('hex');
    
    // Create master admin
    const result = await pool.query(`
      INSERT INTO accounts (name, email, password_hash, role, api_key, api_key_created_at, status)
      VALUES ($1, $2, $3, 'master_admin', $4, NOW(), 'active')
      RETURNING id, public_id, name, email, role
    `, [name, email, passwordHash, apiKey]);
    
    res.json({ 
      success: true, 
      message: 'Master Admin created!',
      account: result.rows[0],
      api_key: apiKey
    });
  } catch (error) {
    console.error('Create master admin error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// ACCOUNTS AUTHENTICATION
// =====================================================
const crypto = require('crypto');

// Generate a secure session token
function generateSessionToken() {
  return crypto.randomBytes(32).toString('hex');
}

// Find or create a traveller from booking data, and link to account/property
async function findOrCreateTraveller(pool, guestData, accountId, propertyId, bookingId = null, bookingTotal = 0) {
  if (!guestData.email) return null;
  
  const email = guestData.email.toLowerCase().trim();
  
  try {
    // Check if traveller exists
    let traveller = await pool.query('SELECT * FROM travellers WHERE email = $1', [email]);
    
    if (traveller.rows.length === 0) {
      // Create new traveller
      const result = await pool.query(`
        INSERT INTO travellers (email, phone, first_name, last_name, address, city, country, postal_code, status, marketing_opt_in)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'lead', $9)
        ON CONFLICT (email) DO UPDATE SET
          phone = COALESCE(NULLIF($2, ''), travellers.phone),
          first_name = COALESCE(NULLIF($3, ''), travellers.first_name),
          last_name = COALESCE(NULLIF($4, ''), travellers.last_name),
          updated_at = NOW()
        RETURNING *
      `, [
        email,
        guestData.phone || null,
        guestData.first_name || guestData.firstName || null,
        guestData.last_name || guestData.lastName || null,
        guestData.address || null,
        guestData.city || null,
        guestData.country || null,
        guestData.postal_code || guestData.postalCode || null,
        guestData.marketing_opt_in || false
      ]);
      traveller = result;
      console.log(`[Traveller] Created new traveller ${result.rows[0].id} for ${email}`);
    } else {
      console.log(`[Traveller] Found existing traveller ${traveller.rows[0].id} for ${email}`);
    }
    
    const travellerId = traveller.rows[0].id;
    
    // Link to account/property if provided
    if (accountId) {
      await pool.query(`
        INSERT INTO traveller_property_links (traveller_id, account_id, property_id, first_booking_id, total_spent, last_stay_date, source)
        VALUES ($1, $2, $3, $4, $5, CURRENT_DATE, 'booking')
        ON CONFLICT (traveller_id, account_id) DO UPDATE SET
          total_bookings = traveller_property_links.total_bookings + 1,
          total_spent = traveller_property_links.total_spent + $5,
          last_stay_date = CURRENT_DATE,
          updated_at = NOW()
      `, [travellerId, accountId, propertyId, bookingId, bookingTotal || 0]);
      console.log(`[Traveller] Linked traveller ${travellerId} to account ${accountId}`);
    }
    
    return traveller.rows[0];
  } catch (error) {
    console.error('[Traveller] Error in findOrCreateTraveller:', error.message);
    return null;
  }
}

// Generate unique account code from name
async function generateAccountCode(pool, name) {
  // Take first 4 chars of name, uppercase, remove non-alphanumeric
  let baseCode = (name || 'ACCT').toUpperCase().replace(/[^A-Z0-9]/g, '').substring(0, 4);
  if (baseCode.length < 2) baseCode = 'ACCT';
  
  // Check if code exists, if so add number
  let code = baseCode;
  let counter = 1;
  
  while (true) {
    const existing = await pool.query('SELECT id FROM accounts WHERE account_code = $1', [code]);
    if (existing.rows.length === 0) break;
    code = baseCode + counter;
    counter++;
    if (counter > 999) {
      code = baseCode + crypto.randomBytes(2).toString('hex').toUpperCase();
      break;
    }
  }
  
  return code;
}

// Login endpoint for accounts
app.post('/api/accounts/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    if (!email || !password) {
      return res.json({ success: false, error: 'Email and password required' });
    }
    
    // Hash the password
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    
    // Find account by email
    const result = await pool.query(`
      SELECT id, public_id, name, email, role, business_name, logo_url, 
             primary_color, secondary_color, status, api_key
      FROM accounts 
      WHERE email = $1
    `, [email.toLowerCase().trim()]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid email or password' });
    }
    
    const account = result.rows[0];
    
    // Check password
    const storedHash = await pool.query('SELECT password_hash FROM accounts WHERE id = $1', [account.id]);
    if (storedHash.rows[0].password_hash !== passwordHash) {
      return res.json({ success: false, error: 'Invalid email or password' });
    }
    
    // Check if account is active
    if (account.status !== 'active') {
      return res.json({ success: false, error: 'Account is not active. Please contact support.' });
    }
    
    // Generate session token
    const sessionToken = generateSessionToken();
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
    
    // Store session token (we'll use a simple approach - store in account or sessions table)
    // For now, we'll create a sessions table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS account_sessions (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        token VARCHAR(255) UNIQUE NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        ip_address VARCHAR(45),
        user_agent TEXT
      )
    `);
    
    // Clean up old sessions for this account (keep max 5)
    await pool.query(`
      DELETE FROM account_sessions 
      WHERE account_id = $1 
      AND id NOT IN (
        SELECT id FROM account_sessions 
        WHERE account_id = $1 
        ORDER BY created_at DESC 
        LIMIT 4
      )
    `, [account.id]);
    
    // Insert new session
    await pool.query(`
      INSERT INTO account_sessions (account_id, token, expires_at, ip_address, user_agent)
      VALUES ($1, $2, $3, $4, $5)
    `, [account.id, sessionToken, expiresAt, req.ip, req.get('User-Agent')]);
    
    // Update last login
    await pool.query(`
      UPDATE accounts SET last_login_at = NOW() WHERE id = $1
    `, [account.id]);
    
    res.json({
      success: true,
      message: 'Login successful',
      account: {
        id: account.id,
        public_id: account.public_id,
        name: account.name,
        email: account.email,
        role: account.role,
        business_name: account.business_name,
        logo_url: account.logo_url,
        primary_color: account.primary_color,
        secondary_color: account.secondary_color
      },
      token: sessionToken,
      expires_at: expiresAt
    });
  } catch (error) {
    console.error('Login error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get current account from session token
app.get('/api/accounts/me', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'No token provided' });
    }
    
    const token = authHeader.split(' ')[1];
    
    // Find valid session
    const session = await pool.query(`
      SELECT s.account_id, s.expires_at
      FROM account_sessions s
      WHERE s.token = $1 AND s.expires_at > NOW()
    `, [token]);
    
    if (session.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid or expired session' });
    }
    
    // Get account details - use * to avoid column not found errors during migration
    const account = await pool.query(`
      SELECT * FROM accounts WHERE id = $1
    `, [session.rows[0].account_id]);
    
    if (account.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    // Return safe subset of fields
    const acc = account.rows[0];
    res.json({ 
      success: true, 
      account: {
        id: acc.id,
        public_id: acc.public_id,
        account_code: acc.account_code || null,
        name: acc.name,
        email: acc.email,
        role: acc.role,
        business_name: acc.business_name,
        logo_url: acc.logo_url,
        primary_color: acc.primary_color,
        secondary_color: acc.secondary_color,
        status: acc.status,
        currency: acc.currency,
        timezone: acc.timezone,
        managed_by_id: acc.managed_by_id || null
      }
    });
  } catch (error) {
    console.error('Get account error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get account language settings
app.get('/api/account/language-settings', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'No token provided' });
    }
    
    const token = authHeader.split(' ')[1];
    const session = await pool.query(
      'SELECT account_id FROM account_sessions WHERE token = $1 AND expires_at > NOW()',
      [token]
    );
    
    if (session.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid session' });
    }
    
    // Support viewing another account's settings (master admin)
    let targetAccountId = session.rows[0].account_id;
    if (req.query.account_id && req.query.account_id !== String(targetAccountId)) {
      const adminCheck = await pool.query('SELECT role FROM accounts WHERE id = $1', [session.rows[0].account_id]);
      if (adminCheck.rows.length > 0 && adminCheck.rows[0].role === 'master_admin') {
        targetAccountId = req.query.account_id;
      }
    }
    
    const account = await pool.query(
      'SELECT settings FROM accounts WHERE id = $1',
      [targetAccountId]
    );
    
    if (account.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    const settings = account.rows[0].settings || {};
    
    res.json({
      success: true,
      primary_language: settings.primary_language || 'en',
      supported_languages: settings.supported_languages || ['en']
    });
  } catch (error) {
    console.error('Get language settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update account language settings
app.put('/api/account/language-settings', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'No token provided' });
    }
    
    const token = authHeader.split(' ')[1];
    const session = await pool.query(
      'SELECT account_id FROM account_sessions WHERE token = $1 AND expires_at > NOW()',
      [token]
    );
    
    if (session.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid session' });
    }
    
    // Support updating another account's settings (master admin)
    let accountId = session.rows[0].account_id;
    if (req.body.account_id && String(req.body.account_id) !== String(accountId)) {
      const adminCheck = await pool.query('SELECT role FROM accounts WHERE id = $1', [session.rows[0].account_id]);
      if (adminCheck.rows.length > 0 && adminCheck.rows[0].role === 'master_admin') {
        accountId = req.body.account_id;
      }
    }
    
    const { primary_language, supported_languages } = req.body;
    
    // Validate
    const validLangs = ['en', 'es', 'fr', 'de', 'nl', 'it', 'pt', 'pl', 'ru', 'ja', 'zh'];
    if (!validLangs.includes(primary_language)) {
      return res.json({ success: false, error: 'Invalid primary language' });
    }
    
    if (!Array.isArray(supported_languages) || supported_languages.length > 4) {
      return res.json({ success: false, error: 'Supported languages must be an array of max 4 languages' });
    }
    
    // Update settings JSONB field
    await pool.query(`
      UPDATE accounts 
      SET settings = COALESCE(settings, '{}'::jsonb) || $1::jsonb,
          updated_at = NOW()
      WHERE id = $2
    `, [JSON.stringify({ primary_language, supported_languages }), accountId]);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Update language settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Logout endpoint
app.post('/api/accounts/logout', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.split(' ')[1];
      await pool.query('DELETE FROM account_sessions WHERE token = $1', [token]);
    }
    res.json({ success: true, message: 'Logged out successfully' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// TEMPORARY: Admin password reset - clears password so Set Password can be used
// DELETE THIS ENDPOINT IN PRODUCTION after initial setup!
app.get('/api/admin/reset-password/:email', async (req, res) => {
  try {
    const email = decodeURIComponent(req.params.email).toLowerCase().trim();
    
    const result = await pool.query(
      'UPDATE accounts SET password_hash = NULL WHERE email = $1 RETURNING id, name, email',
      [email]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    res.json({ 
      success: true, 
      message: `Password cleared for ${result.rows[0].name}. Go to /login.html and use "Set Password" tab.`,
      account: result.rows[0]
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Set password for account (Master Admin only)
app.post('/api/admin/set-password', async (req, res) => {
  try {
    const { account_id, password } = req.body;
    
    if (!account_id || !password) {
      return res.json({ success: false, error: 'Account ID and password required' });
    }
    
    if (password.length < 8) {
      return res.json({ success: false, error: 'Password must be at least 8 characters' });
    }
    
    // Hash password
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    
    const result = await pool.query(
      'UPDATE accounts SET password_hash = $1, updated_at = NOW() WHERE id = $2 RETURNING id, name, email',
      [passwordHash, account_id]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    res.json({ 
      success: true, 
      message: `Password set for ${result.rows[0].name}`,
      account: result.rows[0]
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Set password for account (for accounts without password)
app.post('/api/accounts/set-password', async (req, res) => {
  try {
    const { email, password, confirm_password } = req.body;
    
    if (!email || !password || !confirm_password) {
      return res.json({ success: false, error: 'All fields required' });
    }
    
    if (password !== confirm_password) {
      return res.json({ success: false, error: 'Passwords do not match' });
    }
    
    if (password.length < 8) {
      return res.json({ success: false, error: 'Password must be at least 8 characters' });
    }
    
    // Check if account exists and doesn't have password
    const account = await pool.query('SELECT id, password_hash FROM accounts WHERE email = $1', [email.toLowerCase().trim()]);
    if (account.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    if (account.rows[0].password_hash) {
      return res.json({ success: false, error: 'Password already set. Use "Forgot Password" to reset it.' });
    }
    
    // Hash and set password
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    await pool.query('UPDATE accounts SET password_hash = $1 WHERE id = $2', [passwordHash, account.rows[0].id]);
    
    res.json({ success: true, message: 'Password set successfully. You can now log in.' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Forgot password - generates reset token and sends email
app.post('/api/accounts/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.json({ success: false, error: 'Email required' });
    }
    
    // Check if account exists
    const account = await pool.query('SELECT id, name, email FROM accounts WHERE email = $1', [email.toLowerCase().trim()]);
    
    // Always return success to not reveal if account exists
    if (account.rows.length === 0) {
      return res.json({ success: true, message: 'If an account exists with this email, a reset link has been sent.' });
    }
    
    // Generate reset token
    const resetToken = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour
    
    // Ensure password_reset_tokens table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS password_reset_tokens (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        token VARCHAR(255) UNIQUE NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        used BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Delete any existing tokens for this account
    await pool.query('DELETE FROM password_reset_tokens WHERE account_id = $1', [account.rows[0].id]);
    
    // Store new token
    await pool.query(
      'INSERT INTO password_reset_tokens (account_id, token, expires_at) VALUES ($1, $2, $3)',
      [account.rows[0].id, resetToken, expiresAt]
    );
    
    // Send reset email
    const resetUrl = `https://admin.gas.travel/reset-password.html?token=${resetToken}`;
    
    await sendEmail({
      to: account.rows[0].email,
      subject: 'Reset Your GAS Password',
      html: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; }
            .logo { font-size: 24px; font-weight: bold; color: #6366f1; margin-bottom: 30px; }
            .button { display: inline-block; background: #6366f1; color: white; padding: 14px 28px; text-decoration: none; border-radius: 8px; font-weight: 500; margin: 20px 0; }
            .footer { margin-top: 40px; font-size: 13px; color: #666; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="logo">üè® GAS Admin</div>
            <h2>Reset Your Password</h2>
            <p>Hi ${account.rows[0].name || 'there'},</p>
            <p>We received a request to reset your password. Click the button below to create a new password:</p>
            <a href="${resetUrl}" class="button">Reset Password</a>
            <p>Or copy this link: <br><a href="${resetUrl}">${resetUrl}</a></p>
            <p>This link will expire in 1 hour.</p>
            <p>If you didn't request this, you can safely ignore this email.</p>
            <div class="footer">
              <p>‚Äî The GAS Team</p>
            </div>
          </div>
        </body>
        </html>
      `
    });
    
    console.log(`Password reset email sent to ${account.rows[0].email}`);
    
    res.json({ success: true, message: 'If an account exists with this email, a reset link has been sent.' });
  } catch (error) {
    console.error('Forgot password error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Validate reset token (check if valid before showing reset form)
app.get('/api/accounts/validate-reset-token/:token', async (req, res) => {
  try {
    const { token } = req.params;
    
    const result = await pool.query(`
      SELECT prt.*, a.email, a.name 
      FROM password_reset_tokens prt
      JOIN accounts a ON a.id = prt.account_id
      WHERE prt.token = $1 AND prt.expires_at > NOW() AND prt.used = false
    `, [token]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid or expired reset link' });
    }
    
    res.json({ 
      success: true, 
      email: result.rows[0].email,
      name: result.rows[0].name
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Reset password with token
app.post('/api/accounts/reset-password', async (req, res) => {
  try {
    const { token, password, confirm_password } = req.body;
    
    if (!token || !password || !confirm_password) {
      return res.json({ success: false, error: 'All fields required' });
    }
    
    if (password !== confirm_password) {
      return res.json({ success: false, error: 'Passwords do not match' });
    }
    
    if (password.length < 8) {
      return res.json({ success: false, error: 'Password must be at least 8 characters' });
    }
    
    // Find valid token
    const tokenResult = await pool.query(`
      SELECT account_id FROM password_reset_tokens 
      WHERE token = $1 AND expires_at > NOW() AND used = false
    `, [token]);
    
    if (tokenResult.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid or expired reset link. Please request a new one.' });
    }
    
    const accountId = tokenResult.rows[0].account_id;
    
    // Hash and set new password
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    await pool.query('UPDATE accounts SET password_hash = $1, updated_at = NOW() WHERE id = $2', [passwordHash, accountId]);
    
    // Mark token as used
    await pool.query('UPDATE password_reset_tokens SET used = true WHERE token = $1', [token]);
    
    // Clear any existing sessions for security
    await pool.query('DELETE FROM account_sessions WHERE account_id = $1', [accountId]);
    
    res.json({ success: true, message: 'Password reset successfully. You can now log in.' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Change password for logged-in user
app.post('/api/accounts/change-password', async (req, res) => {
  try {
    const { current_password, new_password } = req.body;
    
    if (!current_password || !new_password) {
      return res.json({ success: false, error: 'Current password and new password required' });
    }
    
    if (new_password.length < 8) {
      return res.json({ success: false, error: 'New password must be at least 8 characters' });
    }
    
    // Get account from session token
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'Not authenticated' });
    }
    
    const token = authHeader.split(' ')[1];
    const session = await pool.query(`
      SELECT account_id FROM account_sessions 
      WHERE token = $1 AND expires_at > NOW()
    `, [token]);
    
    if (session.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid or expired session' });
    }
    
    const accountId = session.rows[0].account_id;
    
    // Verify current password
    const currentPasswordHash = crypto.createHash('sha256').update(current_password).digest('hex');
    const account = await pool.query('SELECT password_hash FROM accounts WHERE id = $1', [accountId]);
    
    if (account.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    if (account.rows[0].password_hash !== currentPasswordHash) {
      return res.json({ success: false, error: 'Current password is incorrect' });
    }
    
    // Update password
    const newPasswordHash = crypto.createHash('sha256').update(new_password).digest('hex');
    await pool.query('UPDATE accounts SET password_hash = $1, updated_at = NOW() WHERE id = $2', [newPasswordHash, accountId]);
    
    res.json({ success: true, message: 'Password changed successfully' });
  } catch (error) {
    console.error('Change password error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// ONBOARDING ENDPOINTS
// =====================================================

// Step 1: Create account during onboarding
app.post('/api/onboarding/create-account', async (req, res) => {
  try {
    const { name, email, password, channel_manager } = req.body;
    
    if (!name || !email || !password) {
      return res.json({ success: false, error: 'Name, email, and password are required' });
    }
    
    if (password.length < 8) {
      return res.json({ success: false, error: 'Password must be at least 8 characters' });
    }
    
    // Check if email already exists
    const existing = await pool.query('SELECT id FROM accounts WHERE email = $1', [email.toLowerCase().trim()]);
    if (existing.rows.length > 0) {
      return res.json({ success: false, error: 'An account with this email already exists. Please login instead.' });
    }
    
    // Get master admin as parent
    const masterResult = await pool.query(`SELECT id FROM accounts WHERE role = 'master_admin' LIMIT 1`);
    const parentId = masterResult.rows.length > 0 ? masterResult.rows[0].id : null;
    
    // Hash password
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    
    // Generate API key
    const apiKey = 'gas_' + crypto.randomBytes(24).toString('hex');
    
    // Generate account code
    const accountCode = await generateAccountCode(pool, name);
    
    // Create account (default role is 'admin')
    const result = await pool.query(`
      INSERT INTO accounts (
        name, email, password_hash, business_name, role, parent_id,
        account_code, api_key, api_key_created_at, status
      )
      VALUES ($1, $2, $3, $1, 'admin', $4, $5, $6, NOW(), 'active')
      RETURNING id, public_id, name, email, role, business_name, account_code
    `, [name, email.toLowerCase().trim(), passwordHash, parentId, accountCode, apiKey]);
    
    const account = result.rows[0];
    
    // Create session token
    const sessionToken = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
    
    // Ensure sessions table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS account_sessions (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        token VARCHAR(255) UNIQUE NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        ip_address VARCHAR(45),
        user_agent TEXT
      )
    `);
    
    await pool.query(`
      INSERT INTO account_sessions (account_id, token, expires_at, ip_address, user_agent)
      VALUES ($1, $2, $3, $4, $5)
    `, [account.id, sessionToken, expiresAt, req.ip, req.get('User-Agent')]);
    
    res.json({
      success: true,
      account: account,
      token: sessionToken
    });
  } catch (error) {
    console.error('Onboarding create account error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Step 2: Save channel manager credentials
app.post('/api/onboarding/save-credentials', async (req, res) => {
  try {
    const { account_id, channel_manager, api_key, invite_code } = req.body;
    
    if (!account_id || !channel_manager) {
      return res.json({ success: false, error: 'Account ID and channel manager required' });
    }
    
    // Store credentials in client_settings (create a client first if needed)
    // First, check if there's a client linked to this account
    let clientId;
    const existingClient = await pool.query(`
      SELECT c.id FROM clients c 
      JOIN accounts a ON c.email = a.email 
      WHERE a.id = $1
    `, [account_id]);
    
    if (existingClient.rows.length > 0) {
      clientId = existingClient.rows[0].id;
    } else {
      // Create a client record for this account
      const account = await pool.query('SELECT name, email FROM accounts WHERE id = $1', [account_id]);
      if (account.rows.length === 0) {
        return res.json({ success: false, error: 'Account not found' });
      }
      
      const clientResult = await pool.query(`
        INSERT INTO clients (name, email, status)
        VALUES ($1, $2, 'active')
        RETURNING id
      `, [account.rows[0].name, account.rows[0].email]);
      clientId = clientResult.rows[0].id;
    }
    
    // Store the API credentials
    const settingKey = channel_manager === 'smoobu' ? 'smoobu_api_key' : 
                       channel_manager === 'hostaway' ? 'hostaway_api_key' :
                       channel_manager === 'beds24' ? 'beds24_invite_code' : 'api_key';
    const settingValue = api_key || invite_code;
    
    await pool.query(`
      INSERT INTO client_settings (client_id, setting_key, setting_value)
      VALUES ($1, $2, $3)
      ON CONFLICT (client_id, setting_key) DO UPDATE SET setting_value = $3
    `, [clientId, settingKey, settingValue]);
    
    res.json({ success: true, client_id: clientId });
  } catch (error) {
    console.error('Save credentials error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Step 3: Import properties from channel manager
app.post('/api/onboarding/import-properties', async (req, res) => {
  try {
    const { account_id, channel_manager, api_key, invite_code, account_id: hostaway_account } = req.body;
    
    if (!account_id || !channel_manager) {
      return res.json({ success: false, error: 'Account ID and channel manager required' });
    }
    
    let propertyCount = 0;
    
    if (channel_manager === 'smoobu') {
      // Get properties from Smoobu
      const smoobuResponse = await axios.get('https://login.smoobu.com/api/apartments', {
        headers: { 
          'Api-Key': api_key,
          'Cache-Control': 'no-cache'
        }
      });
      
      const apartments = smoobuResponse.data.apartments || [];
      
      // Get client_id for this account
      const clientResult = await pool.query(`
        SELECT c.id FROM clients c 
        JOIN accounts a ON c.email = a.email 
        WHERE a.id = $1
      `, [account_id]);
      const clientId = clientResult.rows[0]?.id || 1;
      
      // Import each apartment as a property
      for (const apt of apartments) {
        // Check if already exists
        const existing = await pool.query('SELECT id FROM properties WHERE smoobu_id = $1', [apt.id.toString()]);
        
        if (existing.rows.length === 0) {
          // Create property
          const propResult = await pool.query(`
            INSERT INTO properties (user_id, client_id, account_id, name, smoobu_id, channel_manager)
            VALUES (1, $1, $2, $3, $4, 'smoobu')
            RETURNING id
          `, [clientId, account_id, apt.name, apt.id.toString()]);
          
          // Create bookable unit
          await pool.query(`
            INSERT INTO bookable_units (property_id, name, smoobu_id, max_guests, base_price)
            VALUES ($1, $2, $3, $4, $5)
          `, [propResult.rows[0].id, apt.name, apt.id.toString(), apt.maxOccupancy || 2, apt.price?.minimal || 100]);
          
          propertyCount++;
        }
      }
    } else if (channel_manager === 'hostaway') {
      // Hostaway import logic
      const tokenResponse = await axios.post('https://api.hostaway.com/v1/accessTokens', 
        `grant_type=client_credentials&client_id=${hostaway_account}&client_secret=${api_key}`,
        { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
      );
      
      const accessToken = tokenResponse.data.access_token;
      
      const listingsResponse = await axios.get('https://api.hostaway.com/v1/listings', {
        headers: { 'Authorization': 'Bearer ' + accessToken }
      });
      
      const listings = listingsResponse.data.result || [];
      
      const clientResult = await pool.query(`
        SELECT c.id FROM clients c 
        JOIN accounts a ON c.email = a.email 
        WHERE a.id = $1
      `, [account_id]);
      const clientId = clientResult.rows[0]?.id || 1;
      
      for (const listing of listings) {
        const existing = await pool.query('SELECT id FROM properties WHERE hostaway_id = $1', [listing.id.toString()]);
        
        if (existing.rows.length === 0) {
          const propResult = await pool.query(`
            INSERT INTO properties (user_id, client_id, account_id, name, hostaway_id, channel_manager)
            VALUES (1, $1, $2, $3, $4, 'hostaway')
            RETURNING id
          `, [clientId, account_id, listing.name, listing.id.toString()]);
          
          await pool.query(`
            INSERT INTO bookable_units (property_id, name, hostaway_id, max_guests, base_price)
            VALUES ($1, $2, $3, $4, $5)
          `, [propResult.rows[0].id, listing.name, listing.id.toString(), listing.personCapacity || 2, listing.price || 100]);
          
          propertyCount++;
        }
      }
    } else if (channel_manager === 'beds24') {
      // Beds24 uses invite code flow - different process
      // For now just acknowledge
      return res.json({ 
        success: true, 
        property_count: 0,
        message: 'Beds24 connection initiated. Properties will sync shortly.'
      });
    }
    
    res.json({ success: true, property_count: propertyCount });
  } catch (error) {
    console.error('Import properties error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Migrate existing agencies and clients to accounts
app.post('/api/migrate-to-accounts', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    let agenciesMigrated = 0;
    let clientsMigrated = 0;
    
    // Get master admin ID (or null if not created yet)
    const masterResult = await client.query(`SELECT id FROM accounts WHERE role = 'master_admin' LIMIT 1`);
    const masterAdminId = masterResult.rows.length > 0 ? masterResult.rows[0].id : null;
    
    // Migrate agencies -> accounts (role = agency_admin)
    const agencies = await client.query(`SELECT * FROM agencies`);
    for (const agency of agencies.rows) {
      // Check if already migrated (by email)
      const exists = await client.query(`SELECT id FROM accounts WHERE email = $1`, [agency.email]);
      if (exists.rows.length > 0) {
        // Update properties to use this account
        await client.query(`UPDATE properties SET account_id = $1 WHERE agency_id = $2`, [exists.rows[0].id, agency.id]);
        continue;
      }
      
      const result = await client.query(`
        INSERT INTO accounts (
          public_id, parent_id, role, name, email, phone, business_name,
          logo_url, primary_color, secondary_color,
          address_line1, address_line2, city, region, postcode, country,
          currency, timezone, plan, commission_percent, api_key, api_key_created_at,
          status, settings, notes, created_at, updated_at
        ) VALUES (
          $1, $2, 'agency_admin', $3, $4, $5, $3,
          $6, $7, $8,
          $9, $10, $11, $12, $13, $14,
          $15, $16, $17, $18, $19, $20,
          $21, $22, $23, $24, $25
        ) RETURNING id
      `, [
        agency.public_id, masterAdminId, agency.name, agency.email, agency.phone,
        agency.logo_url, agency.primary_color, agency.secondary_color,
        agency.address_line1, agency.address_line2, agency.city, agency.region, agency.postcode, agency.country,
        agency.currency, agency.timezone, agency.plan, agency.commission_percent, agency.api_key, agency.api_key_created_at,
        agency.status, agency.settings, agency.notes, agency.created_at, agency.updated_at
      ]);
      
      // Update properties that belonged to this agency
      await client.query(`UPDATE properties SET account_id = $1 WHERE agency_id = $2`, [result.rows[0].id, agency.id]);
      agenciesMigrated++;
    }
    
    // Migrate clients -> accounts (role = admin)
    const clients = await client.query(`SELECT * FROM clients`);
    for (const cl of clients.rows) {
      // Skip if email matches an agency (already migrated as agency_admin)
      const agencyMatch = await client.query(`SELECT id FROM accounts WHERE email = $1`, [cl.email]);
      if (agencyMatch.rows.length > 0) {
        // Update properties to use this account
        await client.query(`UPDATE properties SET account_id = $1 WHERE client_id = $2`, [agencyMatch.rows[0].id, cl.id]);
        continue;
      }
      
      // Find parent (if client had agency_id, find that agency's account)
      let parentId = masterAdminId;
      if (cl.agency_id) {
        const parentAgency = await client.query(`
          SELECT a.id FROM accounts a 
          JOIN agencies ag ON ag.email = a.email 
          WHERE ag.id = $1
        `, [cl.agency_id]);
        if (parentAgency.rows.length > 0) {
          parentId = parentAgency.rows[0].id;
        }
      }
      
      const result = await client.query(`
        INSERT INTO accounts (
          public_id, parent_id, role, name, email, phone, business_name,
          address_line1, address_line2, city, region, postcode, country,
          currency, timezone, plan, api_key, api_key_created_at,
          status, notes, created_at, updated_at
        ) VALUES (
          $1, $2, 'admin', $3, $4, $5, $6,
          $7, $8, $9, $10, $11, $12,
          $13, $14, $15, $16, $17,
          $18, $19, $20, $21
        ) RETURNING id
      `, [
        cl.public_id, parentId, cl.name, cl.email, cl.phone, cl.business_name,
        cl.address_line1, cl.address_line2, cl.city, cl.region, cl.postcode, cl.country,
        cl.currency, cl.timezone, cl.plan, cl.api_key, cl.api_key_created_at,
        cl.status, cl.notes, cl.created_at, cl.updated_at
      ]);
      
      // Update properties that belonged to this client
      await client.query(`UPDATE properties SET account_id = $1 WHERE client_id = $2`, [result.rows[0].id, cl.id]);
      clientsMigrated++;
    }
    
    await client.query('COMMIT');
    
    // Get final counts
    const accountCount = await pool.query(`SELECT COUNT(*) FROM accounts`);
    const propsLinked = await pool.query(`SELECT COUNT(*) FROM properties WHERE account_id IS NOT NULL`);
    
    res.json({ 
      success: true, 
      message: 'Migration complete!',
      agencies_migrated: agenciesMigrated,
      clients_migrated: clientsMigrated,
      total_accounts: parseInt(accountCount.rows[0].count),
      properties_linked: parseInt(propsLinked.rows[0].count)
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Get all accounts (for admin view)
app.get('/api/admin/accounts', async (req, res) => {
  try {
    // Ensure managed_by_id column exists (for backwards compatibility)
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS managed_by_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL`).catch(() => {});
    
    // Check if filtering by a specific account (when viewing as that account)
    const viewingAccountId = req.query.account_id;
    
    // Also check who is making the request
    let requestingAccount = null;
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.split(' ')[1];
      const session = await pool.query(`
        SELECT a.id, a.role, a.parent_id
        FROM account_sessions s
        JOIN accounts a ON s.account_id = a.id
        WHERE s.token = $1 AND s.expires_at > NOW()
      `, [token]);
      if (session.rows.length > 0) {
        requestingAccount = session.rows[0];
      }
    }
    
    let result;
    
    // Determine which accounts to show based on context
    const filterAccountId = viewingAccountId || (requestingAccount ? requestingAccount.id : null);
    const filterRole = requestingAccount ? requestingAccount.role : null;
    
    if (filterRole === 'master_admin' && !viewingAccountId) {
      // Master admin viewing all - show everything
      result = await pool.query(`
        SELECT 
          a.*,
          p.name as parent_name,
          m.name as managed_by_name,
          (SELECT COUNT(*) FROM accounts WHERE parent_id = a.id) as child_count,
          (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count,
          (SELECT COUNT(DISTINCT pc.property_id) FROM payment_configurations pc 
           JOIN properties prop ON pc.property_id = prop.id 
           WHERE prop.account_id = a.id AND pc.is_enabled = true) as payment_configured_count,
          (SELECT COUNT(*) FROM properties prop 
           WHERE prop.account_id = a.id 
           AND (prop.stripe_enabled = true OR EXISTS (
             SELECT 1 FROM payment_configurations pc WHERE pc.property_id = prop.id AND pc.is_enabled = true
           ))) as stripe_properties_count
        FROM accounts a
        LEFT JOIN accounts p ON a.parent_id = p.id
        LEFT JOIN accounts m ON a.managed_by_id = m.id
        ORDER BY 
          CASE a.role 
            WHEN 'master_admin' THEN 1 
            WHEN 'agency_admin' THEN 2 
            WHEN 'submaster_admin' THEN 3 
            WHEN 'admin' THEN 4 
          END,
          a.name
      `);
    } else if (filterAccountId) {
      // Get the viewing account's role
      const viewingAccount = await pool.query('SELECT id, role FROM accounts WHERE id = $1', [filterAccountId]);
      if (viewingAccount.rows.length === 0) {
        return res.json({ success: true, accounts: [] });
      }
      
      const viewerRole = viewingAccount.rows[0].role;
      
      if (viewerRole === 'master_admin') {
        // Master admin can see all
        result = await pool.query(`
          SELECT 
            a.*,
            p.name as parent_name,
            m.name as managed_by_name,
            (SELECT COUNT(*) FROM accounts WHERE parent_id = a.id) as child_count,
            (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count,
            (SELECT COUNT(DISTINCT pc.property_id) FROM payment_configurations pc 
             JOIN properties prop ON pc.property_id = prop.id 
             WHERE prop.account_id = a.id AND pc.is_enabled = true) as payment_configured_count,
            (SELECT COUNT(*) FROM properties prop 
             WHERE prop.account_id = a.id 
             AND (prop.stripe_enabled = true OR EXISTS (
               SELECT 1 FROM payment_configurations pc WHERE pc.property_id = prop.id AND pc.is_enabled = true
             ))) as stripe_properties_count
          FROM accounts a
          LEFT JOIN accounts p ON a.parent_id = p.id
          LEFT JOIN accounts m ON a.managed_by_id = m.id
          ORDER BY a.name
        `);
      } else if (viewerRole === 'agency_admin' || viewerRole === 'submaster_admin') {
        // Show self + direct children + grandchildren (recursive)
        result = await pool.query(`
          WITH RECURSIVE account_tree AS (
            SELECT id FROM accounts WHERE id = $1
            UNION ALL
            SELECT a.id FROM accounts a
            JOIN account_tree t ON a.parent_id = t.id
          )
          SELECT 
            a.*,
            p.name as parent_name,
            m.name as managed_by_name,
            (SELECT COUNT(*) FROM accounts WHERE parent_id = a.id) as child_count,
            (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count,
            (SELECT COUNT(DISTINCT pc.property_id) FROM payment_configurations pc 
             JOIN properties prop ON pc.property_id = prop.id 
             WHERE prop.account_id = a.id AND pc.is_enabled = true) as payment_configured_count,
            (SELECT COUNT(*) FROM properties prop 
             WHERE prop.account_id = a.id 
             AND (prop.stripe_enabled = true OR EXISTS (
               SELECT 1 FROM payment_configurations pc WHERE pc.property_id = prop.id AND pc.is_enabled = true
             ))) as stripe_properties_count
          FROM accounts a
          LEFT JOIN accounts p ON a.parent_id = p.id
          LEFT JOIN accounts m ON a.managed_by_id = m.id
          WHERE a.id IN (SELECT id FROM account_tree)
          ORDER BY 
            CASE a.role 
              WHEN 'master_admin' THEN 1 
              WHEN 'agency_admin' THEN 2 
              WHEN 'submaster_admin' THEN 3 
              WHEN 'admin' THEN 4 
            END,
            a.name
        `, [filterAccountId]);
      } else {
        // Admin - only show themselves
        result = await pool.query(`
          SELECT 
            a.*,
            p.name as parent_name,
            m.name as managed_by_name,
            (SELECT COUNT(*) FROM accounts WHERE parent_id = a.id) as child_count,
            (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count,
            (SELECT COUNT(DISTINCT pc.property_id) FROM payment_configurations pc 
             JOIN properties prop ON pc.property_id = prop.id 
             WHERE prop.account_id = a.id AND pc.is_enabled = true) as payment_configured_count,
            (SELECT COUNT(*) FROM properties prop 
             WHERE prop.account_id = a.id 
             AND (prop.stripe_enabled = true OR EXISTS (
               SELECT 1 FROM payment_configurations pc WHERE pc.property_id = prop.id AND pc.is_enabled = true
             ))) as stripe_properties_count
          FROM accounts a
          LEFT JOIN accounts p ON a.parent_id = p.id
          LEFT JOIN accounts m ON a.managed_by_id = m.id
          WHERE a.id = $1
        `, [filterAccountId]);
      }
    } else {
      // Fallback - return all (shouldn't normally reach here)
      result = await pool.query(`
        SELECT 
          a.*,
          p.name as parent_name,
          m.name as managed_by_name,
          (SELECT COUNT(*) FROM accounts WHERE parent_id = a.id) as child_count,
          (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count,
          (SELECT COUNT(DISTINCT pc.property_id) FROM payment_configurations pc 
           JOIN properties prop ON pc.property_id = prop.id 
           WHERE prop.account_id = a.id AND pc.is_enabled = true) as payment_configured_count,
          (SELECT COUNT(*) FROM properties prop 
           WHERE prop.account_id = a.id 
           AND (prop.stripe_enabled = true OR EXISTS (
             SELECT 1 FROM payment_configurations pc WHERE pc.property_id = prop.id AND pc.is_enabled = true
           ))) as stripe_properties_count
        FROM accounts a
        LEFT JOIN accounts p ON a.parent_id = p.id
        LEFT JOIN accounts m ON a.managed_by_id = m.id
        ORDER BY a.name
      `);
    }
    
    res.json({ success: true, accounts: result.rows });
  } catch (error) {
    console.error('Accounts error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Create master admin (only master admins can do this)
app.post('/api/admin/create-master-admin', async (req, res) => {
  try {
    const { name, email, password } = req.body;
    
    if (!name || !email || !password) {
      return res.json({ success: false, error: 'Name, email and password are required' });
    }
    
    if (password.length < 8) {
      return res.json({ success: false, error: 'Password must be at least 8 characters' });
    }
    
    // Verify the requester is a master admin
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'Not authenticated' });
    }
    
    const token = authHeader.split(' ')[1];
    const session = await pool.query(`
      SELECT s.account_id, a.role 
      FROM account_sessions s
      JOIN accounts a ON s.account_id = a.id
      WHERE s.token = $1 AND s.expires_at > NOW()
    `, [token]);
    
    if (session.rows.length === 0 || session.rows[0].role !== 'master_admin') {
      return res.json({ success: false, error: 'Only master admins can create other master admins' });
    }
    
    // Check if email already exists
    const existing = await pool.query('SELECT id FROM accounts WHERE email = $1', [email.toLowerCase().trim()]);
    if (existing.rows.length > 0) {
      return res.json({ success: false, error: 'An account with this email already exists' });
    }
    
    // Hash password
    const passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    
    // Generate API key
    const apiKey = 'gas_' + crypto.randomBytes(24).toString('hex');
    
    // Generate account code
    const accountCode = await generateAccountCode(pool, name);
    
    // Create master admin account
    const result = await pool.query(`
      INSERT INTO accounts (name, email, password_hash, role, account_code, api_key, api_key_created_at, status)
      VALUES ($1, $2, $3, 'master_admin', $4, $5, NOW(), 'active')
      RETURNING id, name, email, role, account_code
    `, [name, email.toLowerCase().trim(), passwordHash, accountCode, apiKey]);
    
    res.json({ success: true, account: result.rows[0] });
  } catch (error) {
    console.error('Create master admin error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update account role
app.post('/api/admin/accounts/:id/update-role', async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;
    
    if (!['agency_admin', 'submaster_admin', 'admin', 'travel_agent'].includes(role)) {
      return res.json({ success: false, error: 'Invalid role' });
    }
    
    await pool.query(`UPDATE accounts SET role = $1, updated_at = NOW() WHERE id = $2`, [role, id]);
    
    res.json({ success: true, message: 'Role updated' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete account (admin only)
app.delete('/api/admin/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Prevent deleting master admin accounts
    const account = await pool.query('SELECT role FROM accounts WHERE id = $1', [id]);
    if (account.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    if (account.rows[0].role === 'master_admin') {
      return res.json({ success: false, error: 'Cannot delete master admin accounts' });
    }
    
    // Check for properties
    const props = await pool.query('SELECT COUNT(*) FROM properties WHERE account_id = $1', [id]);
    if (parseInt(props.rows[0].count) > 0) {
      return res.json({ success: false, error: `Cannot delete account with ${props.rows[0].count} properties. Delete properties first.` });
    }
    
    // Get all connections for this account
    const connections = await pool.query('SELECT id FROM gas_sync_connections WHERE account_id = $1', [id]);
    
    // Delete related gas_sync data for each connection
    for (const conn of connections.rows) {
      await pool.query('DELETE FROM gas_sync_logs WHERE connection_id = $1', [conn.id]);
      await pool.query('DELETE FROM gas_sync_images WHERE connection_id = $1', [conn.id]);
      await pool.query('DELETE FROM gas_sync_reservations WHERE connection_id = $1', [conn.id]);
      await pool.query('DELETE FROM gas_sync_room_types WHERE connection_id = $1', [conn.id]);
      await pool.query('DELETE FROM gas_sync_properties WHERE connection_id = $1', [conn.id]);
    }
    
    // Delete connections
    await pool.query('DELETE FROM gas_sync_connections WHERE account_id = $1', [id]);
    
    // Delete the account
    await pool.query('DELETE FROM accounts WHERE id = $1', [id]);
    
    res.json({ success: true, message: 'Account deleted' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Generate account codes for all accounts missing one
app.post('/api/admin/generate-account-codes', async (req, res) => {
  try {
    // Get all accounts without codes
    const accounts = await pool.query(`
      SELECT id, name FROM accounts WHERE account_code IS NULL OR account_code = ''
    `);
    
    let count = 0;
    for (const account of accounts.rows) {
      const code = await generateAccountCode(pool, account.name);
      await pool.query(`UPDATE accounts SET account_code = $1 WHERE id = $2`, [code, account.id]);
      count++;
    }
    
    res.json({ success: true, count, message: `Generated ${count} account codes` });
  } catch (error) {
    console.error('Generate codes error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// AGENCY MANAGEMENT REQUESTS
// =====================================================

// Get list of available agencies (for Admin/SubMaster to request management)
app.get('/api/agencies/available', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, name, business_name, email, logo_url
      FROM accounts 
      WHERE role = 'agency_admin' AND status = 'active'
      ORDER BY name
    `);
    res.json({ success: true, agencies: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get management requests for an account (as requester or agency)
app.get('/api/management-requests', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    const role = req.query.role; // 'requester' or 'agency'
    const showAll = req.query.all === 'true';
    
    let query;
    
    if (showAll) {
      // Master admin viewing ALL requests
      query = await pool.query(`
        SELECT mr.*, 
               ra.name as requester_name, ra.email as requester_email, ra.business_name as requester_business,
               aa.name as agency_name, aa.email as agency_email, aa.business_name as agency_business,
               (SELECT COUNT(*) FROM properties WHERE account_id = mr.requesting_account_id) as property_count
        FROM management_requests mr
        JOIN accounts ra ON mr.requesting_account_id = ra.id
        JOIN accounts aa ON mr.agency_id = aa.id
        ORDER BY mr.requested_at DESC
      `);
    } else if (!accountId) {
      return res.json({ success: false, error: 'account_id required' });
    } else if (role === 'agency') {
      // Agency viewing requests made TO them
      query = await pool.query(`
        SELECT mr.*, 
               ra.name as requester_name, ra.email as requester_email, ra.business_name as requester_business,
               (SELECT COUNT(*) FROM properties WHERE account_id = mr.requesting_account_id) as property_count
        FROM management_requests mr
        JOIN accounts ra ON mr.requesting_account_id = ra.id
        WHERE mr.agency_id = $1
        ORDER BY mr.requested_at DESC
      `, [accountId]);
    } else {
      // Account viewing their own requests (requester mode)
      query = await pool.query(`
        SELECT mr.*, 
               a.name as agency_name, a.email as agency_email, a.business_name as agency_business
        FROM management_requests mr
        JOIN accounts a ON mr.agency_id = a.id
        WHERE mr.requesting_account_id = $1
        ORDER BY mr.requested_at DESC
      `, [accountId]);
    }
    
    res.json({ success: true, requests: query.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create a management request (Admin/SubMaster requesting Agency management)
app.post('/api/management-requests', async (req, res) => {
  try {
    const { requesting_account_id, agency_id, message } = req.body;
    
    if (!requesting_account_id || !agency_id) {
      return res.json({ success: false, error: 'requesting_account_id and agency_id required' });
    }
    
    // Check if agency exists and has agency_admin role
    const agency = await pool.query('SELECT id, role FROM accounts WHERE id = $1', [agency_id]);
    if (agency.rows.length === 0 || agency.rows[0].role !== 'agency_admin') {
      return res.json({ success: false, error: 'Invalid agency' });
    }
    
    // Check if already has pending request
    const existing = await pool.query(`
      SELECT id, status FROM management_requests 
      WHERE requesting_account_id = $1 AND agency_id = $2
    `, [requesting_account_id, agency_id]);
    
    if (existing.rows.length > 0) {
      const existingRequest = existing.rows[0];
      if (existingRequest.status === 'pending') {
        return res.json({ success: false, error: 'A pending request already exists' });
      }
      // Reset the existing request to pending (re-request)
      const result = await pool.query(`
        UPDATE management_requests 
        SET status = 'pending', message = $1, response_message = NULL, 
            requested_at = NOW(), responded_at = NULL
        WHERE id = $2
        RETURNING *
      `, [message, existingRequest.id]);
      return res.json({ success: true, request: result.rows[0] });
    }
    
    const result = await pool.query(`
      INSERT INTO management_requests (requesting_account_id, agency_id, message)
      VALUES ($1, $2, $3)
      RETURNING *
    `, [requesting_account_id, agency_id, message]);
    
    res.json({ success: true, request: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Respond to a management request (Agency approves/rejects)
app.post('/api/management-requests/:id/respond', async (req, res) => {
  try {
    const { id } = req.params;
    const { status, response_message } = req.body;
    
    if (!['approved', 'rejected', 'cancelled'].includes(status)) {
      return res.json({ success: false, error: 'Invalid status' });
    }
    
    // Get the request
    const request = await pool.query('SELECT * FROM management_requests WHERE id = $1', [id]);
    if (request.rows.length === 0) {
      return res.json({ success: false, error: 'Request not found' });
    }
    
    // Update request status
    await pool.query(`
      UPDATE management_requests 
      SET status = $1, response_message = $2, responded_at = NOW()
      WHERE id = $3
    `, [status, response_message, id]);
    
    // If approved, update the account's managed_by_id
    if (status === 'approved') {
      await pool.query(`
        UPDATE accounts SET managed_by_id = $1, updated_at = NOW()
        WHERE id = $2
      `, [request.rows[0].agency_id, request.rows[0].requesting_account_id]);
    }
    
    res.json({ success: true, message: `Request ${status}` });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete a management request (Master Admin only)
app.delete('/api/management-requests/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get the request to check if it was approved
    const request = await pool.query('SELECT * FROM management_requests WHERE id = $1', [id]);
    if (request.rows.length === 0) {
      return res.json({ success: false, error: 'Request not found' });
    }
    
    // If request was approved, also remove the managed_by_id relationship
    if (request.rows[0].status === 'approved') {
      await pool.query(`
        UPDATE accounts SET managed_by_id = NULL, updated_at = NOW()
        WHERE id = $1 AND managed_by_id = $2
      `, [request.rows[0].requesting_account_id, request.rows[0].agency_id]);
    }
    
    // Delete the request
    await pool.query('DELETE FROM management_requests WHERE id = $1', [id]);
    
    res.json({ success: true, message: 'Request deleted' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Remove agency management (go back to self-managed)
app.post('/api/accounts/:id/remove-management', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get current agency before removing
    const current = await pool.query('SELECT managed_by_id FROM accounts WHERE id = $1', [id]);
    const agencyId = current.rows[0]?.managed_by_id;
    
    console.log(`Removing management for account ${id}, current agency: ${agencyId}`);
    
    // Remove management
    await pool.query(`
      UPDATE accounts SET managed_by_id = NULL, updated_at = NOW()
      WHERE id = $1
    `, [id]);
    
    // Mark ALL approved/pending requests from this account as cancelled
    const updateResult = await pool.query(`
      UPDATE management_requests 
      SET status = 'cancelled', response_message = 'Management removed', responded_at = NOW()
      WHERE requesting_account_id = $1 AND status IN ('approved', 'pending')
    `, [id]);
    
    console.log(`Cancelled ${updateResult.rowCount} management requests`);
    
    res.json({ success: true, message: 'Now self-managed' });
  } catch (error) {
    console.error('Remove management error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Assign agency to an account (Master Admin)
app.post('/api/admin/accounts/:id/assign-agency', async (req, res) => {
  try {
    const { id } = req.params;
    const { agency_id } = req.body;
    
    if (!agency_id) {
      return res.json({ success: false, error: 'agency_id required' });
    }
    
    // Verify agency exists and has agency_admin role
    const agency = await pool.query('SELECT id, role FROM accounts WHERE id = $1', [agency_id]);
    if (agency.rows.length === 0 || agency.rows[0].role !== 'agency_admin') {
      return res.json({ success: false, error: 'Invalid agency' });
    }
    
    // Update account's managed_by_id
    await pool.query(`
      UPDATE accounts SET managed_by_id = $1, updated_at = NOW()
      WHERE id = $2
    `, [agency_id, id]);
    
    // Also create an approved management request record for tracking
    await pool.query(`
      INSERT INTO management_requests (requesting_account_id, agency_id, status, message, responded_at)
      VALUES ($1, $2, 'approved', 'Assigned by Master Admin', NOW())
      ON CONFLICT (requesting_account_id, agency_id) 
      DO UPDATE SET status = 'approved', message = 'Assigned by Master Admin', responded_at = NOW()
    `, [id, agency_id]).catch(e => console.log('Management request insert:', e.message));
    
    res.json({ success: true, message: 'Agency assigned' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// TRAVEL AGENT DISTRIBUTION ACCESS
// =====================================================

// Search properties available for distribution (for Travel Agents)
app.get('/api/distribution/properties', async (req, res) => {
  try {
    const { amenity, city, country, property_type } = req.query;
    
    let query = `
      SELECT p.id, p.name, p.city, p.country, p.property_type, p.hero_image_url,
             p.distribution_mode, p.owner_price,
             a.name as owner_name, a.business_name as owner_business
      FROM properties p
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE p.distribution_mode IN ('open', 'request') AND p.active = true
    `;
    const params = [];
    let paramIndex = 1;
    
    if (city) {
      query += ` AND LOWER(p.city) LIKE LOWER($${paramIndex++})`;
      params.push(`%${city}%`);
    }
    if (country) {
      query += ` AND LOWER(p.country) LIKE LOWER($${paramIndex++})`;
      params.push(`%${country}%`);
    }
    if (property_type) {
      query += ` AND p.property_type = $${paramIndex++}`;
      params.push(property_type);
    }
    
    query += ` ORDER BY p.name`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get distribution access for a travel agent
app.get('/api/distribution/access', async (req, res) => {
  try {
    const { travel_agent_id, property_id, status } = req.query;
    
    let query = `
      SELECT da.*, 
             p.name as property_name, p.city, p.country, p.hero_image_url, p.owner_price,
             a.name as owner_name
      FROM distribution_access da
      JOIN properties p ON da.property_id = p.id
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE 1=1
    `;
    const params = [];
    let paramIndex = 1;
    
    if (travel_agent_id) {
      query += ` AND da.travel_agent_id = $${paramIndex++}`;
      params.push(travel_agent_id);
    }
    if (property_id) {
      query += ` AND da.property_id = $${paramIndex++}`;
      params.push(property_id);
    }
    if (status) {
      query += ` AND da.status = $${paramIndex++}`;
      params.push(status);
    }
    
    query += ` ORDER BY da.requested_at DESC`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, access: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Request distribution access (Travel Agent requesting access to property)
app.post('/api/distribution/request', async (req, res) => {
  try {
    const { travel_agent_id, property_id, message } = req.body;
    
    if (!travel_agent_id || !property_id) {
      return res.json({ success: false, error: 'travel_agent_id and property_id required' });
    }
    
    // Check property exists and is available for distribution
    const property = await pool.query('SELECT distribution_mode FROM properties WHERE id = $1', [property_id]);
    if (property.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    if (property.rows[0].distribution_mode === 'private') {
      return res.json({ success: false, error: 'Property not available for distribution' });
    }
    
    // Check if already has access or pending request
    const existing = await pool.query(`
      SELECT id, status FROM distribution_access 
      WHERE property_id = $1 AND travel_agent_id = $2
    `, [property_id, travel_agent_id]);
    
    if (existing.rows.length > 0) {
      const status = existing.rows[0].status;
      if (status === 'approved') {
        return res.json({ success: false, error: 'Already have access to this property' });
      }
      if (status === 'pending') {
        return res.json({ success: false, error: 'Request already pending' });
      }
    }
    
    // If distribution_mode is 'open', auto-approve
    const autoApprove = property.rows[0].distribution_mode === 'open';
    
    const result = await pool.query(`
      INSERT INTO distribution_access (property_id, travel_agent_id, message, status, approved_at)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (property_id, travel_agent_id) 
      DO UPDATE SET status = $4, message = $3, requested_at = NOW(), approved_at = $5
      RETURNING *
    `, [property_id, travel_agent_id, message, autoApprove ? 'approved' : 'pending', autoApprove ? new Date() : null]);
    
    res.json({ success: true, access: result.rows[0], auto_approved: autoApprove });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Respond to distribution request (Property owner approves/rejects)
app.post('/api/distribution/access/:id/respond', async (req, res) => {
  try {
    const { id } = req.params;
    const { status, response_message } = req.body;
    
    if (!['approved', 'rejected'].includes(status)) {
      return res.json({ success: false, error: 'Status must be approved or rejected' });
    }
    
    await pool.query(`
      UPDATE distribution_access 
      SET status = $1, response_message = $2, approved_at = $3
      WHERE id = $4
    `, [status, response_message, status === 'approved' ? new Date() : null, id]);
    
    res.json({ success: true, message: `Request ${status}` });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Revoke distribution access
app.post('/api/distribution/access/:id/revoke', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.query(`UPDATE distribution_access SET status = 'revoked' WHERE id = $1`, [id]);
    
    res.json({ success: true, message: 'Access revoked' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get pending distribution requests for a property owner
app.get('/api/distribution/requests/pending', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    if (!account_id) {
      return res.json({ success: false, error: 'account_id required' });
    }
    
    const result = await pool.query(`
      SELECT da.*, 
             p.name as property_name,
             ta.name as agent_name, ta.business_name as agent_business, ta.email as agent_email
      FROM distribution_access da
      JOIN properties p ON da.property_id = p.id
      JOIN accounts ta ON da.travel_agent_id = ta.id
      WHERE p.account_id = $1 AND da.status = 'pending'
      ORDER BY da.requested_at DESC
    `, [account_id]);
    
    res.json({ success: true, requests: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Set account subscription (for testing/manual assignment)
app.post('/api/admin/accounts/:id/set-subscription', async (req, res) => {
  try {
    const { id } = req.params;
    const { plan_id, status, months } = req.body;
    
    // Check if subscription exists
    const existing = await pool.query('SELECT id FROM billing_subscriptions WHERE account_id = $1', [id]);
    
    const periodEnd = new Date();
    periodEnd.setMonth(periodEnd.getMonth() + (months || 12));
    
    if (existing.rows.length > 0) {
      // Update existing
      await pool.query(`
        UPDATE billing_subscriptions 
        SET plan_id = $1, status = $2, current_period_start = NOW(), current_period_end = $3, updated_at = NOW()
        WHERE account_id = $4
      `, [plan_id, status || 'active', periodEnd, id]);
    } else {
      // Insert new
      await pool.query(`
        INSERT INTO billing_subscriptions (account_id, plan_id, status, current_period_start, current_period_end)
        VALUES ($1, $2, $3, NOW(), $4)
      `, [id, plan_id, status || 'active', periodEnd]);
    }
    
    res.json({ success: true, message: 'Subscription updated' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get single account
app.get('/api/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT a.*, 
             m.name as managed_by_name,
             (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count
      FROM accounts a 
      LEFT JOIN accounts m ON a.managed_by_id = m.id
      WHERE a.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    res.json({ success: true, account: result.rows[0] });
  } catch (error) {
    console.error('Get account error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Create new account
app.post('/api/accounts', async (req, res) => {
  try {
    const { name, email, phone, account_code, role, status, password, contact_name, cm_type } = req.body;
    
    if (!name) {
      return res.json({ success: false, error: 'Account name is required' });
    }
    
    // Ensure account_code, password_hash, and cm_type columns exist
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS account_code VARCHAR(20)`).catch(() => {});
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS password_hash VARCHAR(255)`).catch(() => {});
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS contact_name VARCHAR(255)`).catch(() => {});
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS cm_type VARCHAR(100)`).catch(() => {});
    
    // Hash password if provided (using sha256 - same as login endpoint)
    let passwordHash = null;
    if (password) {
      passwordHash = crypto.createHash('sha256').update(password).digest('hex');
    }
    
    const result = await pool.query(`
      INSERT INTO accounts (name, email, phone, account_code, role, status, password_hash, contact_name, cm_type, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
      RETURNING *
    `, [name, email || null, phone || null, account_code || null, role || 'agency_admin', status || 'active', passwordHash, contact_name || null, cm_type || null]);
    
    const account = result.rows[0];
    
    // Generate session token for auto-login after registration
    let sessionToken = null;
    if (password && account.id) {
      sessionToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
      
      await pool.query(`
        CREATE TABLE IF NOT EXISTS account_sessions (
          id SERIAL PRIMARY KEY,
          account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
          token VARCHAR(255) UNIQUE NOT NULL,
          expires_at TIMESTAMP NOT NULL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          ip_address VARCHAR(45),
          user_agent TEXT
        )
      `);
      
      await pool.query(`
        INSERT INTO account_sessions (account_id, token, expires_at, ip_address, user_agent)
        VALUES ($1, $2, $3, $4, $5)
      `, [account.id, sessionToken, expiresAt, req.ip, req.get('User-Agent')]);
    }
    
    res.json({ success: true, account: account, token: sessionToken });
  } catch (error) {
    console.error('Create account error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Record CM interest from Other CM wizard
app.post('/api/cm-interest', async (req, res) => {
  try {
    const { account_id, channel_manager, num_properties, notes } = req.body;
    
    if (!account_id) {
      return res.json({ success: false, error: 'Account ID is required' });
    }
    
    // Create table if needed
    await pool.query(`
      CREATE TABLE IF NOT EXISTS cm_interest (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id),
        channel_manager VARCHAR(100),
        num_properties VARCHAR(50),
        notes TEXT,
        status VARCHAR(50) DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Insert interest record
    const result = await pool.query(`
      INSERT INTO cm_interest (account_id, channel_manager, num_properties, notes)
      VALUES ($1, $2, $3, $4)
      RETURNING *
    `, [account_id, channel_manager, num_properties, notes]);
    
    // Update account cm_type
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS cm_type VARCHAR(100)`).catch(() => {});
    await pool.query(`
      UPDATE accounts SET cm_type = $1 WHERE id = $2
    `, [channel_manager, account_id]);
    
    res.json({ success: true, interest: result.rows[0] });
  } catch (error) {
    console.error('CM interest error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get CM interest records (admin)
app.get('/api/cm-interest', async (req, res) => {
  try {
    const { status } = req.query;
    
    let query = `
      SELECT ci.*, a.name as account_name, a.email
      FROM cm_interest ci
      JOIN accounts a ON ci.account_id = a.id
    `;
    
    if (status) {
      query += ` WHERE ci.status = $1`;
    }
    
    query += ` ORDER BY ci.created_at DESC`;
    
    const result = status 
      ? await pool.query(query, [status])
      : await pool.query(query);
    
    res.json({ success: true, interests: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Calry integration ID for a PMS
app.get('/api/calry/integration-id/:pms', (req, res) => {
  const pms = req.params.pms.toLowerCase().replace(/[^a-z0-9_]/g, '_');
  const integrationId = CALRY_INTEGRATION_IDS[pms];
  
  if (integrationId) {
    res.json({ success: true, pms, integrationId });
  } else {
    res.json({ success: false, error: 'PMS not found', availablePms: Object.keys(CALRY_INTEGRATION_IDS) });
  }
});

// Update account
app.put('/api/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      account_code, name, email, phone, business_name, status, notes, role,
      contact_name, address_line1, address_line2, city, region, postcode, country, default_currency 
    } = req.body;
    
    // Ensure columns exist
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS account_code VARCHAR(20)`).catch(() => {});
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS contact_name VARCHAR(255)`).catch(() => {});
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS default_currency VARCHAR(10)`).catch(() => {});
    
    // Build dynamic update query
    const updates = [];
    const values = [];
    let paramIndex = 1;
    
    if (account_code !== undefined) {
      updates.push(`account_code = $${paramIndex++}`);
      values.push(account_code);
    }
    if (name !== undefined) {
      updates.push(`name = $${paramIndex++}`);
      values.push(name);
    }
    if (email !== undefined) {
      updates.push(`email = $${paramIndex++}`);
      values.push(email);
    }
    if (phone !== undefined) {
      updates.push(`phone = $${paramIndex++}`);
      values.push(phone);
    }
    if (contact_name !== undefined) {
      updates.push(`contact_name = $${paramIndex++}`);
      values.push(contact_name);
    }
    if (business_name !== undefined) {
      updates.push(`business_name = $${paramIndex++}`);
      values.push(business_name);
    }
    if (address_line1 !== undefined) {
      updates.push(`address_line1 = $${paramIndex++}`);
      values.push(address_line1);
    }
    if (address_line2 !== undefined) {
      updates.push(`address_line2 = $${paramIndex++}`);
      values.push(address_line2);
    }
    if (city !== undefined) {
      updates.push(`city = $${paramIndex++}`);
      values.push(city);
    }
    if (region !== undefined) {
      updates.push(`region = $${paramIndex++}`);
      values.push(region);
    }
    if (postcode !== undefined) {
      updates.push(`postcode = $${paramIndex++}`);
      values.push(postcode);
    }
    if (country !== undefined) {
      updates.push(`country = $${paramIndex++}`);
      values.push(country);
    }
    if (status !== undefined) {
      updates.push(`status = $${paramIndex++}`);
      values.push(status);
    }
    if (role !== undefined) {
      // Validate role
      const validRoles = ['admin', 'submaster_admin', 'agency_admin', 'master_admin', 'travel_agent'];
      if (validRoles.includes(role)) {
        updates.push(`role = $${paramIndex++}`);
        values.push(role);
      }
    }
    if (notes !== undefined) {
      updates.push(`notes = $${paramIndex++}`);
      values.push(notes);
    }
    if (default_currency !== undefined) {
      updates.push(`default_currency = $${paramIndex++}`);
      values.push(default_currency || null);
    }
    
    if (updates.length === 0) {
      return res.json({ success: false, error: 'No fields to update' });
    }
    
    updates.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(id);
    
    const result = await pool.query(`
      UPDATE accounts SET ${updates.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `, values);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    res.json({ success: true, account: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete account and all related data
app.delete('/api/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    console.log(`Deleting account ${id} and all related data...`);
    
    // Get all properties for this account
    const props = await pool.query('SELECT id FROM properties WHERE account_id = $1', [id]);
    const propIds = props.rows.map(p => p.id);
    
    if (propIds.length > 0) {
      // Get all rooms for these properties
      const rooms = await pool.query('SELECT id FROM bookable_units WHERE property_id = ANY($1)', [propIds]);
      const roomIds = rooms.rows.map(r => r.id);
      
      if (roomIds.length > 0) {
        // Delete room-related data
        await pool.query('DELETE FROM room_images WHERE room_id = ANY($1)', [roomIds]);
        await pool.query('DELETE FROM bookable_unit_amenities WHERE bookable_unit_id = ANY($1)', [roomIds]);
        await pool.query('DELETE FROM bookable_units WHERE id = ANY($1)', [roomIds]);
      }
      
      // Delete property-related data
      await pool.query('DELETE FROM property_images WHERE property_id = ANY($1)', [propIds]);
      await pool.query('DELETE FROM property_amenity_selections WHERE property_id = ANY($1)', [propIds]).catch(() => {});
      await pool.query('DELETE FROM reservations WHERE property_id = ANY($1)', [propIds]).catch(() => {});
      await pool.query('DELETE FROM properties WHERE id = ANY($1)', [propIds]);
    }
    
    // Delete account-related data
    await pool.query('DELETE FROM gas_sync_connections WHERE account_id = $1', [id]).catch(() => {});
    await pool.query('DELETE FROM management_requests WHERE requester_account_id = $1 OR target_account_id = $1', [id]).catch(() => {});
    
    // Delete the account
    const result = await pool.query('DELETE FROM accounts WHERE id = $1 RETURNING id, name', [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    console.log(`Account ${id} (${result.rows[0].name}) deleted successfully`);
    res.json({ success: true, message: `Account ${result.rows[0].name} deleted`, deletedProperties: propIds.length });
  } catch (error) {
    console.error('Delete account error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// STRIPE CONNECT INTEGRATION
// =====================================================

// Start Stripe Connect OAuth flow
app.get('/api/stripe/connect/:accountId', async (req, res) => {
    try {
        const { accountId } = req.params;
        
        // Verify account exists
        const account = await pool.query('SELECT * FROM accounts WHERE id = $1', [accountId]);
        if (account.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Account not found' });
        }
        
        // Build Stripe OAuth URL
        const state = Buffer.from(JSON.stringify({ accountId })).toString('base64');
        
        const stripeConnectUrl = `https://connect.stripe.com/oauth/authorize?` +
            `response_type=code&` +
            `client_id=${process.env.STRIPE_CLIENT_ID}&` +
            `scope=read_write&` +
            `state=${state}&` +
            `redirect_uri=${encodeURIComponent('https://admin.gas.travel/api/stripe/callback')}`;
        
        res.redirect(stripeConnectUrl);
    } catch (error) {
        console.error('Stripe connect error:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Stripe OAuth callback
app.get('/api/stripe/callback', async (req, res) => {
    try {
        const { code, state, error, error_description } = req.query;
        
        // Handle user cancellation or errors
        if (error) {
            console.error('Stripe OAuth error:', error, error_description);
            return res.redirect('https://admin.gas.travel/gas-admin.html#accounts?stripe_error=' + encodeURIComponent(error_description || error));
        }
        
        // Decode state to get account ID
        let accountId;
        try {
            const stateData = JSON.parse(Buffer.from(state, 'base64').toString());
            accountId = stateData.accountId;
        } catch (e) {
            return res.redirect('https://admin.gas.travel/gas-admin.html#accounts?stripe_error=invalid_state');
        }
        
        // Exchange authorization code for access token
        const response = await stripe.oauth.token({
            grant_type: 'authorization_code',
            code: code
        });
        
        const connectedAccountId = response.stripe_user_id;
        
        // Update account with Stripe connected account ID
        await pool.query(`
            UPDATE accounts 
            SET stripe_account_id = $1,
                stripe_account_status = 'active',
                stripe_onboarding_complete = true,
                updated_at = NOW()
            WHERE id = $2
        `, [connectedAccountId, accountId]);
        
        console.log(`‚úÖ Stripe connected for account ${accountId}: ${connectedAccountId}`);
        
        // Redirect back to admin accounts page with success
        res.redirect('https://admin.gas.travel/gas-admin.html#accounts?stripe_connected=true');
        
    } catch (error) {
        console.error('Stripe callback error:', error);
        res.redirect('https://admin.gas.travel/gas-admin.html#accounts?stripe_error=' + encodeURIComponent(error.message));
    }
});

// Get Stripe connection status for an account
app.get('/api/accounts/:accountId/stripe-status', async (req, res) => {
    try {
        const { accountId } = req.params;
        
        const result = await pool.query(`
            SELECT stripe_account_id, stripe_account_status, stripe_onboarding_complete
            FROM accounts WHERE id = $1
        `, [accountId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Account not found' });
        }
        
        const account = result.rows[0];
        
        res.json({
            success: true,
            connected: !!account.stripe_account_id,
            stripe_account_id: account.stripe_account_id,
            status: account.stripe_account_status,
            onboarding_complete: account.stripe_onboarding_complete
        });
        
    } catch (error) {
        console.error('Error getting Stripe status:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Disconnect Stripe account
app.post('/api/accounts/:accountId/stripe-disconnect', async (req, res) => {
    try {
        const { accountId } = req.params;
        
        // Get current stripe account ID
        const account = await pool.query('SELECT stripe_account_id FROM accounts WHERE id = $1', [accountId]);
        
        if (account.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Account not found' });
        }
        
        const stripeAccountId = account.rows[0].stripe_account_id;
        
        // Revoke access if connected
        if (stripeAccountId) {
            try {
                await stripe.oauth.deauthorize({
                    client_id: process.env.STRIPE_CLIENT_ID,
                    stripe_user_id: stripeAccountId
                });
            } catch (e) {
                console.log('Stripe deauthorize warning:', e.message);
            }
        }
        
        // Clear Stripe fields in database
        await pool.query(`
            UPDATE accounts 
            SET stripe_account_id = NULL,
                stripe_account_status = NULL,
                stripe_onboarding_complete = false,
                updated_at = NOW()
            WHERE id = $1
        `, [accountId]);
        
        res.json({ success: true, message: 'Stripe disconnected' });
        
    } catch (error) {
        console.error('Error disconnecting Stripe:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// =====================================================
// DEPOSIT RULES API
// =====================================================

// Get deposit rules for a property
app.get('/api/properties/:propertyId/deposit-rules', async (req, res) => {
    try {
        const { propertyId } = req.params;
        
        const result = await pool.query(`
            SELECT * FROM deposit_rules 
            WHERE property_id = $1 
            ORDER BY is_active DESC, created_at DESC
        `, [propertyId]);
        
        res.json({ success: true, rules: result.rows });
    } catch (error) {
        console.error('Error getting deposit rules:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Get single deposit rule
app.get('/api/deposit-rules/:ruleId', async (req, res) => {
    try {
        const { ruleId } = req.params;
        
        const result = await pool.query('SELECT * FROM deposit_rules WHERE id = $1', [ruleId]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Rule not found' });
        }
        
        res.json({ success: true, rule: result.rows[0] });
    } catch (error) {
        console.error('Error getting deposit rule:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Create deposit rule
app.post('/api/properties/:propertyId/deposit-rules', async (req, res) => {
    try {
        const { propertyId } = req.params;
        const {
            rule_name: rawRuleName,
            deposit_type,
            deposit_percentage,
            deposit_fixed_amount,
            balance_due_type,
            balance_due_days,
            auto_charge_balance,
            auto_charge_days_before,
            refund_policy,
            valid_from,
            valid_until,
            min_nights,
            max_nights,
            is_active
        } = req.body;
        const rule_name = mlStr(rawRuleName);
        
        // Get account_id from property
        const property = await pool.query('SELECT account_id FROM properties WHERE id = $1', [propertyId]);
        if (property.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Property not found' });
        }
        const accountId = property.rows[0].account_id;
        
        const result = await pool.query(`
            INSERT INTO deposit_rules (
                property_id, account_id, rule_name, deposit_type, deposit_percentage,
                deposit_fixed_amount, balance_due_type, balance_due_days,
                auto_charge_balance, auto_charge_days_before, refund_policy,
                valid_from, valid_until, min_nights, max_nights, is_active
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
            RETURNING *
        `, [
            propertyId, accountId, rule_name || 'Default',
            deposit_type || 'percentage', deposit_percentage || 30,
            deposit_fixed_amount, balance_due_type || 'days_before',
            balance_due_days || 14, auto_charge_balance || false,
            auto_charge_days_before || 14, refund_policy || 'flexible',
            valid_from || null, valid_until || null,
            min_nights || null, max_nights || null, is_active !== false
        ]);
        
        res.json({ success: true, rule: result.rows[0] });
    } catch (error) {
        console.error('Error creating deposit rule:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Update deposit rule
app.put('/api/deposit-rules/:ruleId', async (req, res) => {
    try {
        const { ruleId } = req.params;
        const {
            rule_name: rawRuleName,
            deposit_type,
            deposit_percentage,
            deposit_fixed_amount,
            balance_due_type,
            balance_due_days,
            auto_charge_balance,
            auto_charge_days_before,
            refund_policy,
            valid_from,
            valid_until,
            min_nights,
            max_nights,
            is_active
        } = req.body;
        const rule_name = mlStr(rawRuleName);
        
        const result = await pool.query(`
            UPDATE deposit_rules SET
                rule_name = COALESCE($1, rule_name),
                deposit_type = COALESCE($2, deposit_type),
                deposit_percentage = COALESCE($3, deposit_percentage),
                deposit_fixed_amount = $4,
                balance_due_type = COALESCE($5, balance_due_type),
                balance_due_days = COALESCE($6, balance_due_days),
                auto_charge_balance = COALESCE($7, auto_charge_balance),
                auto_charge_days_before = COALESCE($8, auto_charge_days_before),
                refund_policy = COALESCE($9, refund_policy),
                valid_from = $10,
                valid_until = $11,
                min_nights = $12,
                max_nights = $13,
                is_active = COALESCE($14, is_active),
                updated_at = NOW()
            WHERE id = $15
            RETURNING *
        `, [
            rule_name, deposit_type, deposit_percentage, deposit_fixed_amount,
            balance_due_type, balance_due_days, auto_charge_balance,
            auto_charge_days_before, refund_policy, valid_from, valid_until,
            min_nights, max_nights, is_active, ruleId
        ]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Rule not found' });
        }
        
        res.json({ success: true, rule: result.rows[0] });
    } catch (error) {
        console.error('Error updating deposit rule:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Delete deposit rule
app.delete('/api/deposit-rules/:ruleId', async (req, res) => {
    try {
        const { ruleId } = req.params;
        
        await pool.query('DELETE FROM deposit_rules WHERE id = $1', [ruleId]);
        
        res.json({ success: true, message: 'Rule deleted' });
    } catch (error) {
        console.error('Error deleting deposit rule:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Get account-level deposit rules (applies to all properties under account)
app.get('/api/accounts/:accountId/deposit-rules', async (req, res) => {
    try {
        const { accountId } = req.params;
        
        const result = await pool.query(`
            SELECT * FROM deposit_rules 
            WHERE account_id = $1 AND property_id IS NULL
            ORDER BY is_active DESC, created_at DESC
        `, [accountId]);
        
        res.json({ success: true, rules: result.rows });
    } catch (error) {
        console.error('Error getting account deposit rules:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Create account-level deposit rule (applies to all properties)
app.post('/api/accounts/:accountId/deposit-rules', async (req, res) => {
    try {
        const { accountId } = req.params;
        const {
            rule_name: rawRuleName,
            deposit_type,
            deposit_percentage,
            deposit_fixed_amount,
            balance_due_type,
            balance_due_days,
            auto_charge_balance,
            auto_charge_days_before,
            refund_policy,
            is_active
        } = req.body;
        const rule_name = mlStr(rawRuleName);
        
        const result = await pool.query(`
            INSERT INTO deposit_rules (
                property_id, account_id, rule_name, deposit_type, deposit_percentage,
                deposit_fixed_amount, balance_due_type, balance_due_days,
                auto_charge_balance, auto_charge_days_before, refund_policy, is_active
            ) VALUES (NULL, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            RETURNING *
        `, [
            accountId, rule_name || 'Account Default',
            deposit_type || 'percentage', deposit_percentage || 30,
            deposit_fixed_amount, balance_due_type || 'days_before',
            balance_due_days || 14, auto_charge_balance || false,
            auto_charge_days_before || 14, refund_policy || 'flexible',
            is_active !== false
        ]);
        
        res.json({ success: true, rule: result.rows[0] });
    } catch (error) {
        console.error('Error creating account deposit rule:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// =====================================================
// PAYMENT PROCESSING API
// =====================================================

// Create payment intent for a booking deposit
app.post('/api/bookings/:bookingId/create-payment', async (req, res) => {
    try {
        const { bookingId } = req.params;
        const { amount, payment_type } = req.body; // payment_type: 'deposit' or 'balance' or 'full'
        
        // Get booking with property and account info
        const booking = await pool.query(`
            SELECT b.*, p.account_id, p.name as property_name, a.stripe_account_id
            FROM bookings b
            JOIN properties p ON b.property_id = p.id
            JOIN accounts a ON p.account_id = a.id
            WHERE b.id = $1
        `, [bookingId]);
        
        if (booking.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Booking not found' });
        }
        
        const bookingData = booking.rows[0];
        
        if (!bookingData.stripe_account_id) {
            return res.status(400).json({ success: false, error: 'Property owner has not connected Stripe' });
        }
        
        // Create payment intent on connected account
        const paymentIntent = await stripe.paymentIntents.create({
            amount: Math.round(amount * 100), // Convert to cents
            currency: 'gbp', // Default to GBP, could be made dynamic
            metadata: {
                booking_id: bookingId,
                payment_type: payment_type,
                property_name: bookingData.property_name
            }
        }, {
            stripeAccount: bookingData.stripe_account_id
        });
        
        // Update booking with payment intent ID
        await pool.query(`
            UPDATE bookings SET stripe_payment_intent_id = $1, updated_at = NOW()
            WHERE id = $2
        `, [paymentIntent.id, bookingId]);
        
        res.json({
            success: true,
            client_secret: paymentIntent.client_secret,
            payment_intent_id: paymentIntent.id
        });
        
    } catch (error) {
        console.error('Error creating payment:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Confirm payment completed (webhook or manual)
app.post('/api/payments/confirm', async (req, res) => {
    try {
        const { payment_intent_id, booking_id } = req.body;
        
        // Get booking
        const booking = await pool.query(`
            SELECT b.*, p.account_id, a.stripe_account_id
            FROM bookings b
            JOIN properties p ON b.property_id = p.id
            JOIN accounts a ON p.account_id = a.id
            WHERE b.id = $1
        `, [booking_id]);
        
        if (booking.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Booking not found' });
        }
        
        const bookingData = booking.rows[0];
        
        // Verify payment with Stripe
        const paymentIntent = await stripe.paymentIntents.retrieve(
            payment_intent_id,
            { stripeAccount: bookingData.stripe_account_id }
        );
        
        if (paymentIntent.status !== 'succeeded') {
            return res.status(400).json({ success: false, error: 'Payment not completed' });
        }
        
        const amount = paymentIntent.amount / 100; // Convert from cents
        const paymentType = paymentIntent.metadata.payment_type || 'deposit';
        
        // Record transaction
        await pool.query(`
            INSERT INTO payment_transactions (
                booking_id, account_id, transaction_type, amount, currency,
                payment_gateway, gateway_transaction_id, status,
                payment_method_type, completed_at
            ) VALUES ($1, $2, $3, $4, $5, 'stripe', $6, 'completed', 'card', NOW())
        `, [
            booking_id, bookingData.account_id, paymentType, amount,
            paymentIntent.currency.toUpperCase(), payment_intent_id
        ]);
        
        // Update booking status
        let newStatus = 'deposit_paid';
        let updateFields = 'deposit_amount = $1, deposit_paid_at = NOW()';
        
        if (paymentType === 'balance') {
            newStatus = 'fully_paid';
            updateFields = 'balance_amount = $1, balance_paid_at = NOW()';
        } else if (paymentType === 'full') {
            newStatus = 'fully_paid';
            updateFields = 'total_amount = $1, deposit_paid_at = NOW(), balance_paid_at = NOW()';
        }
        
        await pool.query(`
            UPDATE bookings SET payment_status = $1, ${updateFields}, updated_at = NOW()
            WHERE id = $2
        `, [newStatus, amount, booking_id]);
        
        // Sync payment to Beds24 if booking is linked
        try {
          const beds24Check = await pool.query(`
            SELECT b.beds24_booking_id, bu.beds24_room_id
            FROM bookings b
            LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
            WHERE b.id = $1 AND b.beds24_booking_id IS NOT NULL
          `, [booking_id]);
          
          if (beds24Check.rows[0]?.beds24_booking_id) {
            const accessToken = await getBeds24AccessToken(pool);
            const paymentDesc = paymentType === 'balance' ? 'Balance payment via Stripe' : 
                               paymentType === 'full' ? 'Full payment via Stripe' : 'Deposit via Stripe';
            
            const paymentData = [{
              id: beds24Check.rows[0].beds24_booking_id,
              payments: [{
                description: paymentDesc,
                amount: amount,
                status: 'received',
                date: new Date().toISOString().split('T')[0]
              }]
            }];
            
            await axios.post('https://beds24.com/api/v2/bookings', paymentData, {
              headers: { 'token': accessToken, 'Content-Type': 'application/json' }
            });
            console.log(`Payment synced to Beds24 for booking ${booking_id}`);
          }
        } catch (beds24Error) {
          console.error('Could not sync payment to Beds24:', beds24Error.message);
          // Continue - don't fail the payment confirmation
        }
        
        res.json({ success: true, status: newStatus, amount: amount });
        
    } catch (error) {
        console.error('Error confirming payment:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Get payment history for a booking
app.get('/api/bookings/:bookingId/payments', async (req, res) => {
    try {
        const { bookingId } = req.params;
        
        const result = await pool.query(`
            SELECT * FROM payment_transactions
            WHERE booking_id = $1
            ORDER BY created_at DESC
        `, [bookingId]);
        
        res.json({ success: true, payments: result.rows });
    } catch (error) {
        console.error('Error getting payments:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Get Stripe info for a property (public - for checkout page)
app.get('/api/public/property/:propertyId/stripe-info', async (req, res) => {
    try {
        const { propertyId } = req.params;
        
        // First check new payment_configurations table
        let paymentConfig = await pool.query(`
            SELECT pc.*
            FROM payment_configurations pc
            WHERE pc.property_id = $1 AND pc.provider = 'stripe' AND pc.is_enabled = true
            LIMIT 1
        `, [propertyId]);
        
        // Fall back to account-level config
        if (paymentConfig.rows.length === 0) {
            paymentConfig = await pool.query(`
                SELECT pc.*
                FROM payment_configurations pc
                JOIN properties p ON pc.account_id = p.account_id
                WHERE p.id = $1 AND pc.property_id IS NULL AND pc.provider = 'stripe' AND pc.is_enabled = true
                LIMIT 1
            `, [propertyId]);
        }
        
        // If found in new table, use it
        if (paymentConfig.rows.length > 0) {
            const config = paymentConfig.rows[0];
            
            // Get deposit rules
            let depositRule = null;
            const ruleResult = await pool.query(`
                SELECT * FROM deposit_rules 
                WHERE (property_id = $1 OR (property_id IS NULL AND account_id = $2)) AND is_active = true 
                ORDER BY property_id NULLS LAST, created_at DESC LIMIT 1
            `, [propertyId, config.account_id]);
            
            if (ruleResult.rows.length > 0) {
                depositRule = ruleResult.rows[0];
            }
            
            return res.json({
                success: true,
                stripe_enabled: true,
                stripe_type: 'config',
                stripe_publishable_key: config.credentials?.publishable_key,
                deposit_rule: depositRule
            });
        }
        
        // Fall back to legacy property/account stripe fields
        const result = await pool.query(`
            SELECT p.id, p.account_id, p.stripe_publishable_key, p.stripe_secret_key, p.stripe_enabled,
                   a.stripe_account_id, a.stripe_account_status, a.stripe_onboarding_complete
            FROM properties p
            JOIN accounts a ON p.account_id = a.id
            WHERE p.id = $1
        `, [propertyId]);
        
        if (result.rows.length === 0) {
            return res.json({ success: true, stripe_enabled: false });
        }
        
        const data = result.rows[0];
        
        // Property-level Stripe takes priority
        const hasPropertyStripe = data.stripe_enabled && data.stripe_publishable_key && data.stripe_secret_key;
        const hasAccountStripe = !!(data.stripe_account_id && data.stripe_onboarding_complete);
        const stripeEnabled = hasPropertyStripe || hasAccountStripe;
        
        // Get deposit rules for this property (or fall back to account-level rule)
        let depositRule = null;
        if (stripeEnabled) {
            // First try property-specific rule
            const ruleResult = await pool.query(`
                SELECT * FROM deposit_rules 
                WHERE property_id = $1 AND is_active = true 
                ORDER BY created_at DESC LIMIT 1
            `, [propertyId]);
            
            if (ruleResult.rows.length > 0) {
                depositRule = ruleResult.rows[0];
            } else {
                // Fall back to account-level rule
                const accountRuleResult = await pool.query(`
                    SELECT dr.* FROM deposit_rules dr
                    JOIN properties p ON dr.account_id = p.account_id
                    WHERE p.id = $1 AND dr.property_id IS NULL AND dr.is_active = true
                    ORDER BY dr.created_at DESC LIMIT 1
                `, [propertyId]);
                
                if (accountRuleResult.rows.length > 0) {
                    depositRule = accountRuleResult.rows[0];
                }
            }
        }
        
        res.json({
            success: true,
            stripe_enabled: stripeEnabled,
            stripe_type: hasPropertyStripe ? 'property' : (hasAccountStripe ? 'connect' : null),
            stripe_publishable_key: hasPropertyStripe ? data.stripe_publishable_key : (hasAccountStripe ? process.env.STRIPE_PUBLISHABLE_KEY : null),
            stripe_account_id: hasAccountStripe ? data.stripe_account_id : null,
            deposit_rule: depositRule
        });
        
    } catch (error) {
        console.error('Error getting Stripe info:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// =====================================================
// GROUP BOOKING ENDPOINT
// Creates multiple bookings linked by a group_booking_id
// =====================================================
app.post('/api/public/create-group-booking', async (req, res) => {
    const client = await pool.connect();
    try {
        // Ensure group_booking_id column exists
        await client.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS group_booking_id VARCHAR(50)`);
        
        const { 
            rooms,  // Array of room booking data
            checkin,
            checkout,
            guest_first_name,
            guest_last_name,
            guest_email,
            guest_phone,
            guest_address,
            guest_city,
            guest_country,
            guest_postcode,
            notes,
            stripe_payment_intent_id,
            deposit_amount,
            total_amount
        } = req.body;
        
        if (!rooms || !Array.isArray(rooms) || rooms.length === 0) {
            return res.status(400).json({ success: false, error: 'No rooms provided' });
        }
        
        if (!checkin || !checkout) {
            return res.status(400).json({ success: false, error: 'Check-in and check-out dates required' });
        }
        
        // Generate unique group booking ID
        const groupBookingId = 'GRP-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9).toUpperCase();
        
        console.log(`DEBUG: Starting transaction for group ${groupBookingId}`);
        await client.query('BEGIN');
        console.log(`DEBUG: Transaction BEGIN completed`);
        
        const createdBookings = [];
        const cmResults = { beds24: [], hostaway: [], smoobu: [] };
        
        // Process each room
        for (let i = 0; i < rooms.length; i++) {
            const room = rooms[i];
            const roomId = room.roomId;
            const roomPrice = parseFloat(room.totalPrice) || 0;
            const roomGuests = room.guests || 1;
            
            // Get room and property info
            const roomInfo = await client.query(`
                SELECT bu.id, bu.name, bu.property_id, p.id as prop_id
                FROM bookable_units bu
                JOIN properties p ON bu.property_id = p.id
                WHERE bu.id = $1
            `, [roomId]);
            
            if (!roomInfo.rows[0]) {
                throw new Error(`Room ${roomId} not found`);
            }
            
            const roomData = roomInfo.rows[0];
            
            // Create booking in GAS database (matching working endpoint structure)
            const bookingResult = await client.query(`
                INSERT INTO bookings (
                    property_id, property_owner_id, bookable_unit_id,
                    arrival_date, departure_date,
                    num_adults, num_children,
                    guest_first_name, guest_last_name, guest_email, guest_phone,
                    accommodation_price, subtotal, grand_total,
                    status, booking_source, currency, group_booking_id
                )
                VALUES ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $11, $11, 'confirmed', 'direct', 'USD', $12)
                RETURNING *
            `, [
                roomData.property_id,
                roomId,
                checkin,
                checkout,
                roomGuests,
                0,
                guest_first_name,
                guest_last_name,
                guest_email,
                guest_phone || '',
                roomPrice,
                groupBookingId
            ]);
            
            const booking = bookingResult.rows[0];
            console.log(`DEBUG: Inserted booking ID ${booking.id} for room ${roomId}, group ${groupBookingId}`);
            console.log(`DEBUG: Full booking row: id=${booking.id}, property_id=${booking.property_id}, group_booking_id=${booking.group_booking_id}`);
            createdBookings.push(booking);
            
            // Block availability for these dates (copied from working endpoint)
            console.log(`Blocking dates for unit ${roomId} from ${checkin} to ${checkout}`);
            const startParts = checkin.split('-');
            const endParts = checkout.split('-');
            let current = new Date(startParts[0], startParts[1] - 1, startParts[2]);
            const checkOutDate = new Date(endParts[0], endParts[1] - 1, endParts[2]);
            
            while (current < checkOutDate) {
                const dateStr = current.toISOString().split('T')[0];
                try {
                    await client.query(`
                        INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
                        VALUES ($1, $2, false, true, 'booking')
                        ON CONFLICT (room_id, date) DO UPDATE SET is_available = false, is_blocked = true, source = 'booking'
                    `, [roomId, dateStr]);
                } catch (blockErr) {
                    console.error(`Error blocking date ${dateStr}:`, blockErr.message);
                }
                current.setDate(current.getDate() + 1);
            }
            console.log(`Finished blocking dates for unit ${roomId}`);
            
            // Get CM IDs for this unit (copied from working endpoint)
            const cmResult = await client.query(`
                SELECT bu.beds24_room_id, bu.smoobu_id, bu.hostaway_listing_id, p.account_id
                FROM bookable_units bu
                LEFT JOIN properties p ON bu.property_id = p.id
                WHERE bu.id = $1
            `, [roomId]);
            
            const cmData = cmResult.rows[0];
            
            // BEDS24 SYNC
            if (cmData?.beds24_room_id) {
                try {
                    const accessToken = await getBeds24AccessToken(pool);
                    
                    const beds24Booking = [{
                        roomId: cmData.beds24_room_id,
                        status: 'confirmed',
                        arrival: checkin,
                        departure: checkout,
                        numAdult: roomGuests,
                        numChild: 0,
                        firstName: guest_first_name,
                        lastName: guest_last_name,
                        email: guest_email,
                        mobile: guest_phone || '',
                        phone: guest_phone || '',
                        address: guest_address || '',
                        city: guest_city || '',
                        postcode: guest_postcode || '',
                        country: guest_country || '',
                        referer: `GAS #${booking.id}`,
                        notes: `GAS Booking ID: ${booking.id} | Group: ${groupBookingId} (Room ${i + 1}/${rooms.length})`,
                        price: roomPrice,
                        invoiceItems: [{
                            description: 'Accommodation',
                            status: '',
                            qty: 1,
                            amount: roomPrice,
                            vatRate: 0
                        }]
                    }];
                    
                    console.log('Pushing group booking to Beds24:', JSON.stringify(beds24Booking));
                    
                    const beds24Response = await axios.post('https://beds24.com/api/v2/bookings', beds24Booking, {
                        headers: {
                            'token': accessToken,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    console.log('Beds24 response:', JSON.stringify(beds24Response.data));
                    
                    if (beds24Response.data && beds24Response.data[0]?.success) {
                        const beds24Id = beds24Response.data[0]?.new?.id;
                        if (beds24Id) {
                            await client.query(`UPDATE bookings SET beds24_booking_id = $1 WHERE id = $2`, [beds24Id, booking.id]);
                            cmResults.beds24.push({ roomId, beds24Id });
                        }
                    }
                } catch (beds24Error) {
                    console.error('Error syncing to Beds24:', beds24Error.response?.data || beds24Error.message);
                }
            }
            
            // SMOOBU SYNC
            if (cmData?.smoobu_id) {
                try {
                    // Get Smoobu API key for this account
                    const smoobuKeyResult = await client.query(`
                        SELECT setting_value FROM client_settings 
                        WHERE client_id = $1 AND setting_key = 'smoobu_api_key'
                    `, [cmData.account_id]);
                    
                    const smoobuApiKey = smoobuKeyResult.rows[0]?.setting_value;
                    
                    if (smoobuApiKey) {
                        const smoobuResponse = await axios.post('https://login.smoobu.com/api/reservations', {
                            arrivalDate: checkin,
                            departureDate: checkout,
                            apartmentId: parseInt(cmData.smoobu_id),
                            channelId: 13, // Direct booking
                            firstName: guest_first_name,
                            lastName: guest_last_name,
                            email: guest_email,
                            phone: guest_phone || '',
                            adults: roomGuests,
                            children: 0,
                            price: roomPrice,
                            notice: `GAS Booking ID: ${booking.id} | Group: ${groupBookingId} (Room ${i + 1}/${rooms.length})`
                        }, {
                            headers: {
                                'Api-Key': smoobuApiKey,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        console.log('Smoobu response:', JSON.stringify(smoobuResponse.data));
                        
                        if (smoobuResponse.data?.id) {
                            const smoobuId = smoobuResponse.data.id;
                            await client.query(`UPDATE bookings SET smoobu_booking_id = $1 WHERE id = $2`, [smoobuId, booking.id]);
                            cmResults.smoobu.push({ roomId, smoobuId });
                        }
                    }
                } catch (smoobuError) {
                    console.error('Error syncing to Smoobu:', smoobuError.response?.data || smoobuError.message);
                }
            }
            
            // HOSTAWAY SYNC
            if (cmData?.hostaway_listing_id) {
                try {
                    const stored = await getStoredHostawayToken(pool);
                    
                    if (stored?.accessToken) {
                        const hostawayResponse = await axios.post('https://api.hostaway.com/v1/reservations', {
                            listingMapId: cmData.hostaway_listing_id,
                            channelId: 2000,
                            source: 'manual',
                            arrivalDate: checkin,
                            departureDate: checkout,
                            guestFirstName: guest_first_name,
                            guestLastName: guest_last_name,
                            guestEmail: guest_email,
                            guestPhone: guest_phone || '',
                            numberOfGuests: roomGuests,
                            adults: roomGuests,
                            children: 0,
                            totalPrice: roomPrice,
                            status: 'new',
                            comment: `GAS Booking ID: ${booking.id} | Group: ${groupBookingId} (Room ${i + 1}/${rooms.length})`
                        }, {
                            headers: {
                                'Authorization': `Bearer ${stored.accessToken}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (hostawayResponse.data?.result?.id) {
                            const hostawayId = hostawayResponse.data.result.id;
                            await client.query(`UPDATE bookings SET hostaway_reservation_id = $1 WHERE id = $2`, [hostawayId, booking.id]);
                            cmResults.hostaway.push({ roomId, hostawayId });
                        }
                    }
                } catch (hostawayError) {
                    console.error('Error syncing to Hostaway:', hostawayError.response?.data || hostawayError.message);
                }
            }
        }
        
        // Record Stripe payment transaction if deposit was paid (once for whole group)
        if (stripe_payment_intent_id && deposit_amount && createdBookings.length > 0) {
            try {
                // Use SAVEPOINT to prevent failed INSERT from aborting entire transaction
                await client.query('SAVEPOINT payment_tx');
                await client.query(`
                    INSERT INTO payment_transactions (booking_id, type, amount, currency, status, stripe_payment_intent_id, created_at)
                    VALUES ($1, 'deposit', $2, 'USD', 'completed', $3, NOW())
                `, [createdBookings[0].id, deposit_amount, stripe_payment_intent_id]);
                await client.query('RELEASE SAVEPOINT payment_tx');
            } catch (txError) {
                await client.query('ROLLBACK TO SAVEPOINT payment_tx');
                console.log('Could not record payment transaction:', txError.message);
            }
            
            // Update payment status on first booking (separate try/catch with savepoint)
            try {
                await client.query('SAVEPOINT payment_status');
                await client.query(`
                    UPDATE bookings SET payment_status = 'deposit_paid', stripe_payment_intent_id = $1, deposit_amount = $2
                    WHERE id = $3
                `, [stripe_payment_intent_id, deposit_amount, createdBookings[0].id]);
                await client.query('RELEASE SAVEPOINT payment_status');
            } catch (statusError) {
                await client.query('ROLLBACK TO SAVEPOINT payment_status');
                console.log('Could not update payment status:', statusError.message);
            }
        }
        
        console.log(`DEBUG: About to COMMIT transaction with ${createdBookings.length} bookings`);
        console.log(`DEBUG: Booking IDs to commit: ${createdBookings.map(b => b.id).join(', ')}`);
        
        // DEBUG: Verify data exists in transaction BEFORE commit
        const preCommitCheck = await client.query(
            `SELECT id, group_booking_id FROM bookings WHERE group_booking_id = $1`,
            [groupBookingId]
        );
        console.log(`DEBUG: PRE-COMMIT check found ${preCommitCheck.rows.length} bookings in transaction`);
        
        await client.query('COMMIT');
        
        console.log(`DEBUG: COMMIT completed successfully`);
        
        // DEBUG: Verify bookings exist on SAME connection before releasing
        const verifyBeforeRelease = await client.query(
            `SELECT id, group_booking_id FROM bookings WHERE group_booking_id = $1`,
            [groupBookingId]
        );
        console.log(`DEBUG: Same-connection verify found ${verifyBeforeRelease.rows.length} bookings`);
        console.log(`DEBUG: IDs on same connection: ${verifyBeforeRelease.rows.map(r => r.id).join(', ')}`);
        
        console.log(`Group booking created: ${groupBookingId} with ${createdBookings.length} rooms`);
        console.log(`Created booking IDs: ${createdBookings.map(b => b.id).join(', ')}`);
        
        // DEBUG: Verify bookings exist after commit on DIFFERENT connection
        try {
            const verifyResult = await pool.query(
                `SELECT id, group_booking_id FROM bookings WHERE group_booking_id = $1`,
                [groupBookingId]
            );
            console.log(`DEBUG: Pool verify found ${verifyResult.rows.length} bookings for ${groupBookingId}`);
            console.log(`DEBUG: Pool IDs: ${verifyResult.rows.map(r => r.id).join(', ')}`);
        } catch (verifyError) {
            console.log(`DEBUG: Pool verification query failed: ${verifyError.message}`);
        }
        
        // ========== SEND EMAIL ==========
        try {
            // Get property info for email
            const propertyResult = await pool.query(`
                SELECT p.id, p.name, p.email, a.email as account_email
                FROM properties p
                LEFT JOIN accounts a ON p.account_id = a.id
                WHERE p.id = $1
            `, [createdBookings[0]?.property_id]);
            
            const property = propertyResult.rows[0];
            
            // Build room info for email
            const roomsForEmail = rooms.map((room, index) => ({
                name: room.name || `Room ${index + 1}`,
                guests: room.guests || 1,
                price: room.totalPrice || 0
            }));
            
            // Calculate balance
            const depositPaid = deposit_amount && parseFloat(deposit_amount) > 0 ? parseFloat(deposit_amount) : 0;
            const balanceAmount = depositPaid > 0 ? parseFloat(total_amount) - depositPaid : 0;
            
            // Get upsells from request if present
            const upsells = req.body.upsells || [];
            
            const totals = {
                total: total_amount,
                depositAmount: depositPaid,
                balanceAmount: balanceAmount,
                currency: rooms[0]?.currency || '$',
                checkin: checkin,
                checkout: checkout,
                upsells: upsells
            };
            
            const guestInfo = {
                firstName: guest_first_name,
                lastName: guest_last_name,
                email: guest_email,
                phone: guest_phone
            };
            
            const emailHtml = generateGroupBookingConfirmationEmail(
                groupBookingId,
                createdBookings,
                roomsForEmail,
                property,
                guestInfo,
                totals
            );
            
            // Send to guest
            await sendEmail({
                to: guest_email,
                subject: `Group Booking Confirmed - ${property?.name || 'Your Reservation'} (Ref: ${groupBookingId})`,
                html: emailHtml
            });
            
            // Also send to property owner if different email
            if (property?.account_email && property.account_email !== guest_email) {
                await sendEmail({
                    to: property.account_email,
                    subject: `New Group Booking - ${guest_first_name} ${guest_last_name} (Ref: ${groupBookingId})`,
                    html: emailHtml
                });
            }
            
            console.log(`Group booking confirmation email sent to ${guest_email}`);
        } catch (emailError) {
            console.error('Group booking email error:', emailError.message);
            // Don't fail the booking if email fails
        }
        // ========== END EMAIL ==========
        
        // ========== SEND PARTNER WEBHOOKS ==========
        // Send webhook for each booking to notify partners (e.g., Elevate)
        for (const booking of createdBookings) {
            try {
                const webhookResult = await sendPartnerBookingWebhook(booking.id, 'booking.created');
                if (webhookResult.sent) {
                    console.log(`[Webhook] Sent booking.created for booking ${booking.id}`);
                }
            } catch (webhookError) {
                console.error(`[Webhook] Error sending webhook for booking ${booking.id}:`, webhookError.message);
                // Don't fail the booking if webhook fails
            }
        }
        // ========== END PARTNER WEBHOOKS ==========
        
        res.json({
            success: true,
            group_booking_id: groupBookingId,
            bookings: createdBookings.map(b => ({
                id: b.id,
                room_id: b.bookable_unit_id,
                beds24_id: b.beds24_booking_id,
                hostaway_id: b.hostaway_reservation_id
            })),
            total_rooms: createdBookings.length,
            total_amount: total_amount,
            cm_results: cmResults
        });
        
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Group booking error:', error.message);
        console.error('Group booking error stack:', error.stack);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        client.release();
    }
});

// Create payment intent for checkout (public endpoint)
app.post('/api/public/create-payment-intent', async (req, res) => {
    try {
        const { property_id, amount, currency, booking_data } = req.body;
        
        // First check payment_configurations table
        let paymentConfig = await pool.query(`
            SELECT pc.*
            FROM payment_configurations pc
            WHERE pc.property_id = $1 AND pc.provider = 'stripe' AND pc.is_enabled = true
            LIMIT 1
        `, [property_id]);
        
        // Fall back to account-level config
        if (paymentConfig.rows.length === 0) {
            paymentConfig = await pool.query(`
                SELECT pc.*
                FROM payment_configurations pc
                JOIN properties p ON pc.account_id = p.account_id
                WHERE p.id = $1 AND pc.property_id IS NULL AND pc.provider = 'stripe' AND pc.is_enabled = true
                LIMIT 1
            `, [property_id]);
        }
        
        let paymentIntent;
        
        // Use new payment_configurations if available
        if (paymentConfig.rows.length > 0 && paymentConfig.rows[0].credentials?.secret_key) {
            const config = paymentConfig.rows[0];
            const configStripe = new Stripe(config.credentials.secret_key);
            
            paymentIntent = await configStripe.paymentIntents.create({
                amount: Math.round(amount * 100),
                currency: (currency || 'gbp').toLowerCase(),
                metadata: {
                    property_id: property_id,
                    guest_email: booking_data?.email || '',
                    check_in: booking_data?.check_in || '',
                    check_out: booking_data?.check_out || ''
                }
            });
            
            return res.json({
                success: true,
                client_secret: paymentIntent.client_secret,
                payment_intent_id: paymentIntent.id,
                publishable_key: config.credentials.publishable_key
            });
        }
        
        // Fall back to legacy property stripe fields
        const result = await pool.query(`
            SELECT p.stripe_secret_key, p.stripe_publishable_key, p.stripe_enabled,
                   a.stripe_account_id
            FROM properties p
            JOIN accounts a ON p.account_id = a.id
            WHERE p.id = $1
        `, [property_id]);
        
        if (result.rows.length === 0) {
            return res.status(400).json({ success: false, error: 'Property not found' });
        }
        
        const prop = result.rows[0];
        
        // Use property's own Stripe keys if configured (legacy)
        if (prop.stripe_enabled && prop.stripe_secret_key) {
            const propertyStripe = new Stripe(prop.stripe_secret_key);
            
            paymentIntent = await propertyStripe.paymentIntents.create({
                amount: Math.round(amount * 100),
                currency: (currency || 'gbp').toLowerCase(),
                metadata: {
                    property_id: property_id,
                    guest_email: booking_data?.email || '',
                    check_in: booking_data?.check_in || '',
                    check_out: booking_data?.check_out || ''
                }
            });
            
            return res.json({
                success: true,
                client_secret: paymentIntent.client_secret,
                payment_intent_id: paymentIntent.id,
                publishable_key: prop.stripe_publishable_key
            });
        }
        // Fall back to Stripe Connect if account has it
        else if (prop.stripe_account_id) {
            paymentIntent = await stripe.paymentIntents.create({
                amount: Math.round(amount * 100),
                currency: (currency || 'gbp').toLowerCase(),
                metadata: {
                    property_id: property_id,
                    guest_email: booking_data?.email || '',
                    check_in: booking_data?.check_in || '',
                    check_out: booking_data?.check_out || ''
                }
            }, {
                stripeAccount: prop.stripe_account_id
            });
            
            return res.json({
                success: true,
                client_secret: paymentIntent.client_secret,
                payment_intent_id: paymentIntent.id
            });
        }
        else {
            return res.status(400).json({ success: false, error: 'Property not configured for payments. Please add Stripe keys in property settings.' });
        }
        
    } catch (error) {
        console.error('Error creating payment intent:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Get account subscription
app.get('/api/admin/accounts/:id/subscription', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(`
      SELECT bs.*, bp.name as plan_name, bp.price_monthly, bp.price_yearly
      FROM billing_subscriptions bs
      LEFT JOIN billing_plans bp ON bs.plan_id = bp.id
      WHERE bs.account_id = $1
    `, [id]);
    
    if (result.rows.length > 0) {
      res.json({ success: true, subscription: result.rows[0] });
    } else {
      res.json({ success: true, subscription: null });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// ACCOUNT SETTINGS (WordPress site linking, etc.)
// =====================================================

// Get account settings
app.get('/api/admin/accounts/:id/settings', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(
      'SELECT settings FROM accounts WHERE id = $1',
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    res.json({ 
      success: true, 
      settings: result.rows[0].settings || {}
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update account settings
app.post('/api/admin/accounts/:id/settings', async (req, res) => {
  try {
    const { id } = req.params;
    const { settings } = req.body;
    
    // Merge with existing settings
    const existing = await pool.query(
      'SELECT settings FROM accounts WHERE id = $1',
      [id]
    );
    
    if (existing.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    const currentSettings = existing.rows[0].settings || {};
    const newSettings = { ...currentSettings, ...settings };
    
    await pool.query(
      'UPDATE accounts SET settings = $1 WHERE id = $2',
      [JSON.stringify(newSettings), id]
    );
    
    res.json({ success: true, settings: newSettings });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Link account to WordPress site
app.post('/api/admin/accounts/:id/link-wordpress', async (req, res) => {
  try {
    const { id } = req.params;
    const { wordpress_site_id, wordpress_url } = req.body;
    
    const existing = await pool.query(
      'SELECT settings FROM accounts WHERE id = $1',
      [id]
    );
    
    if (existing.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    const currentSettings = existing.rows[0].settings || {};
    const newSettings = { 
      ...currentSettings, 
      wordpress_site_id,
      wordpress_url 
    };
    
    await pool.query(
      'UPDATE accounts SET settings = $1 WHERE id = $2',
      [JSON.stringify(newSettings), id]
    );
    
    res.json({ 
      success: true, 
      message: 'WordPress site linked successfully',
      settings: newSettings 
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// TASKS / TO-DO LIST
// =====================================================

// Get all tasks (master admin sees all, others see their own)
app.get('/api/admin/tasks', async (req, res) => {
  try {
    const { status, priority, account_id } = req.query;
    
    let query = `
      SELECT t.*, 
        a1.name as account_name,
        a2.name as created_by_name,
        a3.name as assigned_to_name
      FROM tasks t
      LEFT JOIN accounts a1 ON t.account_id = a1.id
      LEFT JOIN accounts a2 ON t.created_by = a2.id
      LEFT JOIN accounts a3 ON t.assigned_to = a3.id
      WHERE 1=1
    `;
    const params = [];
    
    if (status) {
      params.push(status);
      query += ` AND t.status = $${params.length}`;
    }
    if (priority) {
      params.push(priority);
      query += ` AND t.priority = $${params.length}`;
    }
    if (account_id) {
      params.push(account_id);
      query += ` AND t.account_id = $${params.length}`;
    }
    
    query += ` ORDER BY 
      CASE t.priority WHEN 'urgent' THEN 1 WHEN 'high' THEN 2 WHEN 'medium' THEN 3 ELSE 4 END,
      t.due_date ASC NULLS LAST,
      t.created_at DESC`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create task
app.post('/api/admin/tasks', async (req, res) => {
  try {
    const { title, description, status, priority, category, account_id, created_by, assigned_to, due_date } = req.body;
    
    if (!title) {
      return res.json({ success: false, error: 'Title is required' });
    }
    
    const result = await pool.query(`
      INSERT INTO tasks (title, description, status, priority, category, account_id, created_by, assigned_to, due_date)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `, [title, description, status || 'todo', priority || 'medium', category, account_id, created_by, assigned_to, due_date]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update task
app.put('/api/admin/tasks/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, status, priority, category, account_id, assigned_to, due_date } = req.body;
    
    // If marking as done, set completed_at
    const completed_at = status === 'done' ? 'NOW()' : 'NULL';
    
    const result = await pool.query(`
      UPDATE tasks SET 
        title = COALESCE($1, title),
        description = COALESCE($2, description),
        status = COALESCE($3, status),
        priority = COALESCE($4, priority),
        category = COALESCE($5, category),
        account_id = $6,
        assigned_to = $7,
        due_date = $8,
        completed_at = ${status === 'done' ? 'NOW()' : 'NULL'},
        updated_at = NOW()
      WHERE id = $9
      RETURNING *
    `, [title, description, status, priority, category, account_id, assigned_to, due_date, id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Task not found' });
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Quick update task status
app.patch('/api/admin/tasks/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    const result = await pool.query(`
      UPDATE tasks SET 
        status = $1,
        completed_at = ${status === 'done' ? 'NOW()' : 'NULL'},
        updated_at = NOW()
      WHERE id = $2
      RETURNING *
    `, [status, id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete task
app.delete('/api/admin/tasks/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM tasks WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Sync tasks from tasks.json file
app.post('/api/admin/tasks/sync-from-file', async (req, res) => {
  try {
    const fs = require('fs');
    const path = require('path');
    
    const filePath = path.join(__dirname, 'public', 'tasks.json');
    
    if (!fs.existsSync(filePath)) {
      return res.json({ success: false, error: 'tasks.json not found in public folder' });
    }
    
    const fileContent = fs.readFileSync(filePath, 'utf8');
    const data = JSON.parse(fileContent);
    
    if (!data.tasks || !Array.isArray(data.tasks)) {
      return res.json({ success: false, error: 'Invalid tasks.json format' });
    }
    
    // Clear existing tasks and insert new ones
    await pool.query('DELETE FROM tasks');
    
    let imported = 0;
    for (const task of data.tasks) {
      await pool.query(`
        INSERT INTO tasks (title, description, status, priority, category, completed_at)
        VALUES ($1, $2, $3, $4, $5, $6)
      `, [
        task.title,
        task.description || null,
        task.status || 'todo',
        task.priority || 'medium',
        task.category || null,
        task.completed ? new Date(task.completed) : null
      ]);
      imported++;
    }
    
    res.json({ success: true, message: `Imported ${imported} tasks from tasks.json`, updated: data.updated });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Sync amenities from amenities.json file
app.post('/api/admin/amenities/sync-from-file', async (req, res) => {
  try {
    const fs = require('fs');
    const path = require('path');
    
    const filePath = path.join(__dirname, 'public', 'amenities.json');
    
    if (!fs.existsSync(filePath)) {
      return res.json({ success: false, error: 'amenities.json not found in public folder' });
    }
    
    const fileContent = fs.readFileSync(filePath, 'utf8');
    const data = JSON.parse(fileContent);
    
    if (!data.amenities || !Array.isArray(data.amenities)) {
      return res.json({ success: false, error: 'Invalid amenities.json format' });
    }
    
    // Add level column if missing
    await pool.query(`
      ALTER TABLE master_amenities ADD COLUMN IF NOT EXISTS level VARCHAR(20) DEFAULT 'room'
    `);
    
    let imported = 0;
    let updated = 0;
    
    for (const amenity of data.amenities) {
      // Build amenity_name JSONB
      const amenityNameJson = JSON.stringify({ en: amenity.name });
      
      // Check if amenity exists by code
      const existing = await pool.query('SELECT id FROM master_amenities WHERE amenity_code = $1', [amenity.code]);
      
      if (existing.rows.length > 0) {
        // Update existing
        await pool.query(`
          UPDATE master_amenities SET 
            amenity_name = $1, category = $2, icon = $3, level = $4, updated_at = NOW()
          WHERE amenity_code = $5
        `, [amenityNameJson, amenity.category, amenity.icon, amenity.level || 'room', amenity.code]);
        updated++;
      } else {
        // Insert new
        await pool.query(`
          INSERT INTO master_amenities (amenity_code, amenity_name, category, icon, level)
          VALUES ($1, $2, $3, $4, $5)
        `, [amenity.code, amenityNameJson, amenity.category, amenity.icon, amenity.level || 'room']);
        imported++;
      }
    }
    
    res.json({ 
      success: true, 
      message: `Imported ${imported} new, updated ${updated} existing amenities`,
      updated: data.updated 
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/setup-clients', async (req, res) => {
  try {
    // 0. Create agencies table first (agencies manage multiple clients)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS agencies (
        id SERIAL PRIMARY KEY,
        public_id UUID DEFAULT gen_random_uuid() UNIQUE NOT NULL,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE,
        phone VARCHAR(50),
        logo_url VARCHAR(500),
        primary_color VARCHAR(20) DEFAULT '#6366f1',
        secondary_color VARCHAR(20) DEFAULT '#8b5cf6',
        custom_domain VARCHAR(255),
        website_url VARCHAR(500),
        address_line1 VARCHAR(255),
        address_line2 VARCHAR(255),
        city VARCHAR(100),
        region VARCHAR(100),
        postcode VARCHAR(20),
        country VARCHAR(100) DEFAULT 'GB',
        currency VARCHAR(3) DEFAULT 'GBP',
        timezone VARCHAR(50) DEFAULT 'Europe/London',
        plan VARCHAR(20) DEFAULT 'agency',
        commission_percent DECIMAL(5,2) DEFAULT 0,
        api_key VARCHAR(64) UNIQUE,
        api_key_created_at TIMESTAMP,
        status VARCHAR(20) DEFAULT 'active',
        settings JSONB DEFAULT '{}',
        white_label_enabled BOOLEAN DEFAULT FALSE,
        notes TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    console.log('‚úÖ Created agencies table');

    // 1. Create clients table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS clients (
        id SERIAL PRIMARY KEY,
        public_id UUID DEFAULT gen_random_uuid() UNIQUE NOT NULL,
        agency_id INTEGER REFERENCES agencies(id) ON DELETE SET NULL,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE,
        phone VARCHAR(50),
        business_name VARCHAR(255),
        address_line1 VARCHAR(255),
        address_line2 VARCHAR(255),
        city VARCHAR(100),
        region VARCHAR(100),
        postcode VARCHAR(20),
        country VARCHAR(100) DEFAULT 'GB',
        currency VARCHAR(3) DEFAULT 'GBP',
        timezone VARCHAR(50) DEFAULT 'Europe/London',
        date_format VARCHAR(20) DEFAULT 'DD/MM/YYYY',
        language VARCHAR(10) DEFAULT 'en',
        plan VARCHAR(20) DEFAULT 'free',
        subscription_status VARCHAR(20) DEFAULT 'active',
        features_enabled JSONB DEFAULT '{}',
        plan_started_at TIMESTAMP,
        plan_expires_at TIMESTAMP,
        stripe_customer_id VARCHAR(100),
        stripe_subscription_id VARCHAR(100),
        api_key VARCHAR(64) UNIQUE,
        api_key_created_at TIMESTAMP,
        api_requests_today INTEGER DEFAULT 0,
        api_requests_reset_at DATE,
        status VARCHAR(20) DEFAULT 'active',
        email_verified BOOLEAN DEFAULT FALSE,
        email_verified_at TIMESTAMP,
        notes TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Add agency_id column if it doesn't exist (for existing databases)
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS agency_id INTEGER REFERENCES agencies(id) ON DELETE SET NULL`);
    
    // Add public_id column if it doesn't exist (for existing databases)
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS public_id UUID DEFAULT gen_random_uuid() UNIQUE`);
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS business_name VARCHAR(255)`);
    
    // Ensure all existing clients have a public_id
    await pool.query(`UPDATE clients SET public_id = gen_random_uuid() WHERE public_id IS NULL`);
    
    // Add new columns to clients if they don't exist
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS subscription_status VARCHAR(20) DEFAULT 'active'`);
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS features_enabled JSONB DEFAULT '{}'`);
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS stripe_subscription_id VARCHAR(100)`);
    
    console.log('‚úÖ Created clients table with UUID public_id and agency_id');

    // 2. Create client_users table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS client_users (
        id SERIAL PRIMARY KEY,
        client_id INTEGER NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
        email VARCHAR(255) NOT NULL,
        password_hash VARCHAR(255),
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        phone VARCHAR(50),
        avatar_url TEXT,
        role VARCHAR(20) DEFAULT 'staff',
        status VARCHAR(20) DEFAULT 'active',
        invite_token VARCHAR(64),
        invite_expires_at TIMESTAMP,
        last_login_at TIMESTAMP,
        last_login_ip VARCHAR(45),
        login_count INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(client_id, email)
      )
    `);
    console.log('‚úÖ Created client_users table');

    // 3. Add client_id to properties
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS client_id INTEGER REFERENCES clients(id) ON DELETE SET NULL`);
    console.log('‚úÖ Added client_id to properties');

    // 4. Add client_id to channel_connections (if table exists)
    try {
      await pool.query(`ALTER TABLE channel_connections ADD COLUMN IF NOT EXISTS client_id INTEGER REFERENCES clients(id) ON DELETE SET NULL`);
      console.log('‚úÖ Added client_id to channel_connections');
    } catch (e) {
      console.log('‚ö†Ô∏è channel_connections table not found, skipping');
    }

    // 5. Create indexes
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_clients_email ON clients(email)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_clients_api_key ON clients(api_key)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_properties_client_id ON properties(client_id)`);
    console.log('‚úÖ Created indexes');

    // 5.5 Create client_settings table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS client_settings (
        id SERIAL PRIMARY KEY,
        client_id INTEGER NOT NULL REFERENCES clients(id) ON DELETE CASCADE,
        setting_key VARCHAR(100) NOT NULL,
        setting_value TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(client_id, setting_key)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_client_settings_client_id ON client_settings(client_id)`);
    console.log('‚úÖ Created client_settings table');

    // 6. Create default clients if none exist
    const existingClients = await pool.query('SELECT COUNT(*) FROM clients');
    if (parseInt(existingClients.rows[0].count) === 0) {
      // Generate API keys
      const crypto = require('crypto');
      const apiKey1 = 'gas_' + crypto.randomBytes(28).toString('hex');
      const apiKey2 = 'gas_' + crypto.randomBytes(28).toString('hex');
      
      // Create Lehmann House client
      await pool.query(`
        INSERT INTO clients (name, email, currency, plan, status, api_key, api_key_created_at)
        VALUES ('Lehmann House', 'info@lehmannhouse.com', 'GBP', 'free', 'active', $1, CURRENT_TIMESTAMP)
      `, [apiKey1]);
      console.log('‚úÖ Created Lehmann House client');
      
      // Create Hostaway Demo client
      await pool.query(`
        INSERT INTO clients (name, email, currency, plan, status, api_key, api_key_created_at)
        VALUES ('Hostaway Properties', 'demo@hostaway.com', 'GBP', 'free', 'active', $1, CURRENT_TIMESTAMP)
      `, [apiKey2]);
      console.log('‚úÖ Created Hostaway Properties client');
    }

    // Get final count
    const finalCount = await pool.query('SELECT COUNT(*) FROM clients');
    
    res.json({ 
      success: true, 
      message: 'Clients tables created successfully!',
      clients_count: parseInt(finalCount.rows[0].count)
    });
  } catch (error) {
    console.error('Setup clients error:', error);
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/setup-database', async (req, res) => {
  try {
    // Create channel_managers table first (referenced by channel_connections)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS channel_managers (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100),
        cm_code VARCHAR(50),
        cm_name VARCHAR(100),
        api_base_url VARCHAR(255),
        auth_type VARCHAR(50) DEFAULT 'oauth2',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Add columns if they don't exist (for existing tables)
    await pool.query(`ALTER TABLE channel_managers ADD COLUMN IF NOT EXISTS cm_code VARCHAR(50)`);
    await pool.query(`ALTER TABLE channel_managers ADD COLUMN IF NOT EXISTS cm_name VARCHAR(100)`);
    await pool.query(`ALTER TABLE channel_managers ADD COLUMN IF NOT EXISTS api_base_url VARCHAR(255)`);
    await pool.query(`ALTER TABLE channel_managers ADD COLUMN IF NOT EXISTS auth_type VARCHAR(50) DEFAULT 'oauth2'`);
    
    // Create unique index if not exists
    await pool.query(`CREATE UNIQUE INDEX IF NOT EXISTS idx_cm_code ON channel_managers(cm_code) WHERE cm_code IS NOT NULL`);
    
    // Update existing rows that might have name but not cm_code
    await pool.query(`UPDATE channel_managers SET cm_code = LOWER(name), cm_name = name WHERE cm_code IS NULL AND name IS NOT NULL`);
    
    // Insert or update Beds24
    const beds24Exists = await pool.query(`SELECT id FROM channel_managers WHERE cm_code = 'beds24' OR LOWER(name) = 'beds24'`);
    if (beds24Exists.rows.length === 0) {
      await pool.query(`INSERT INTO channel_managers (name, cm_code, cm_name, api_base_url, auth_type) VALUES ('Beds24', 'beds24', 'Beds24', 'https://beds24.com/api/v2', 'oauth2')`);
    } else {
      await pool.query(`UPDATE channel_managers SET cm_code = 'beds24', cm_name = 'Beds24' WHERE id = $1`, [beds24Exists.rows[0].id]);
    }
    
    // Insert or update Hostaway
    const hostawayExists = await pool.query(`SELECT id FROM channel_managers WHERE cm_code = 'hostaway' OR LOWER(name) = 'hostaway'`);
    if (hostawayExists.rows.length === 0) {
      await pool.query(`INSERT INTO channel_managers (name, cm_code, cm_name, api_base_url, auth_type) VALUES ('Hostaway', 'hostaway', 'Hostaway', 'https://api.hostaway.com/v1', 'oauth2')`);
    } else {
      await pool.query(`UPDATE channel_managers SET cm_code = 'hostaway', cm_name = 'Hostaway' WHERE id = $1`, [hostawayExists.rows[0].id]);
    }
    
    // Insert or update Smoobu
    const smoobuExists = await pool.query(`SELECT id FROM channel_managers WHERE cm_code = 'smoobu' OR LOWER(name) = 'smoobu'`);
    if (smoobuExists.rows.length === 0) {
      await pool.query(`INSERT INTO channel_managers (name, cm_code, cm_name, api_base_url, auth_type) VALUES ('Smoobu', 'smoobu', 'Smoobu', 'https://login.smoobu.com/api', 'api_key')`);
    } else {
      await pool.query(`UPDATE channel_managers SET cm_code = 'smoobu', cm_name = 'Smoobu' WHERE id = $1`, [smoobuExists.rows[0].id]);
    }
    
    // Create channel_connections table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS channel_connections (
        id SERIAL PRIMARY KEY,
        client_id INTEGER,
        cm_id INTEGER REFERENCES channel_managers(id),
        account_id VARCHAR(100),
        refresh_token TEXT,
        access_token TEXT,
        status VARCHAR(20) DEFAULT 'active',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    await pool.query(`CREATE TABLE IF NOT EXISTS properties (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL, description TEXT, address TEXT, city VARCHAR(100), country VARCHAR(100), property_type VARCHAR(50), star_rating INTEGER, hero_image_url TEXT, active BOOLEAN DEFAULT true, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);
    await pool.query(`CREATE TABLE IF NOT EXISTS rooms (id SERIAL PRIMARY KEY, property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE, name VARCHAR(255) NOT NULL, description TEXT, max_occupancy INTEGER, max_adults INTEGER, max_children INTEGER, base_price DECIMAL(10, 2), currency VARCHAR(3) DEFAULT 'USD', quantity INTEGER DEFAULT 1, active BOOLEAN DEFAULT true, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);
    await pool.query(`CREATE TABLE IF NOT EXISTS bookings (id SERIAL PRIMARY KEY, property_id INTEGER REFERENCES properties(id), room_id INTEGER REFERENCES rooms(id), check_in DATE NOT NULL, check_out DATE NOT NULL, num_adults INTEGER NOT NULL, num_children INTEGER DEFAULT 0, guest_first_name VARCHAR(100) NOT NULL, guest_last_name VARCHAR(100) NOT NULL, guest_email VARCHAR(255) NOT NULL, guest_phone VARCHAR(50), total_price DECIMAL(10, 2) NOT NULL, status VARCHAR(50) DEFAULT 'confirmed', beds24_booking_id VARCHAR(50), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);
    // Add beds24_booking_id column if it doesn't exist
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS beds24_booking_id VARCHAR(50)`);
    // Add smoobu_booking_id column
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS smoobu_booking_id VARCHAR(50)`);
    // Add bookable_unit_id column for linking to bookable_units table
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS bookable_unit_id INTEGER`);
    // Add hostaway columns
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS hostaway_listing_id INTEGER`);
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS hostaway_listing_id INTEGER`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS hostaway_reservation_id VARCHAR(50)`);
    
    // Add group booking column
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS group_booking_id VARCHAR(50)`);
    
    // Add payment tracking columns to bookings
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS deposit_amount DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS balance_amount DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS balance_due_date DATE`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS deposit_paid_at TIMESTAMP`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS balance_paid_at TIMESTAMP`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS payment_status VARCHAR(20) DEFAULT 'pending'`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS stripe_payment_intent_id VARCHAR(100)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS stripe_customer_id VARCHAR(100)`);
    await pool.query(`ALTER TABLE bookings ADD COLUMN IF NOT EXISTS refund_amount DECIMAL(10,2)`);
    
    // Create payment_transactions table if not exists
    await pool.query(`CREATE TABLE IF NOT EXISTS payment_transactions (
      id SERIAL PRIMARY KEY,
      booking_id INTEGER REFERENCES bookings(id),
      type VARCHAR(20) NOT NULL,
      amount DECIMAL(10,2) NOT NULL,
      currency VARCHAR(3) DEFAULT 'USD',
      status VARCHAR(20) DEFAULT 'pending',
      stripe_payment_intent_id VARCHAR(100),
      stripe_charge_id VARCHAR(100),
      error_message TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`);
    
    // Create reviews table for storing reviews from channel managers
    await pool.query(`
      CREATE TABLE IF NOT EXISTS reviews (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE SET NULL,
        external_id VARCHAR(100),
        source VARCHAR(50) NOT NULL DEFAULT 'manual',
        channel_name VARCHAR(100),
        reservation_id VARCHAR(100),
        guest_name VARCHAR(255),
        guest_avatar VARCHAR(500),
        guest_country VARCHAR(100),
        rating DECIMAL(3,1),
        title TEXT,
        comment TEXT,
        private_feedback TEXT,
        host_reply TEXT,
        host_reply_at TIMESTAMP,
        review_date DATE,
        stay_date_start DATE,
        stay_date_end DATE,
        is_public BOOLEAN DEFAULT true,
        is_approved BOOLEAN DEFAULT true,
        language VARCHAR(10),
        sub_ratings JSONB,
        raw_data JSONB,
        synced_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(source, external_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_account_id ON reviews(account_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_property_id ON reviews(property_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_source ON reviews(source)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_rating ON reviews(rating)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_review_date ON reviews(review_date)`);
    
    // Add smoobu columns
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS smoobu_id VARCHAR(50)`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS channel_manager VARCHAR(50)`);
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS smoobu_id VARCHAR(50)`);
    // Create unique index for smoobu_id if not exists
    await pool.query(`CREATE UNIQUE INDEX IF NOT EXISTS idx_properties_smoobu_id ON properties(smoobu_id) WHERE smoobu_id IS NOT NULL`);
    await pool.query(`CREATE UNIQUE INDEX IF NOT EXISTS idx_bookable_units_smoobu_id ON bookable_units(smoobu_id) WHERE smoobu_id IS NOT NULL`);
    // Add access_token column to channel_connections
    await pool.query(`ALTER TABLE channel_connections ADD COLUMN IF NOT EXISTS access_token TEXT`);
    
    // Fix currency column length (should be VARCHAR(3) not VARCHAR(2))
    await pool.query(`ALTER TABLE properties ALTER COLUMN currency TYPE VARCHAR(3)`);
    
    // Fix timezone column length if needed
    await pool.query(`ALTER TABLE properties ALTER COLUMN timezone TYPE VARCHAR(50)`);
    
    // Add tourist tax columns to properties
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS tourist_tax_enabled BOOLEAN DEFAULT false`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS tourist_tax_type VARCHAR(20) DEFAULT 'per_guest_per_night'`); // per_guest_per_night, per_night, per_booking, percentage
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS tourist_tax_amount DECIMAL(10, 2) DEFAULT 0`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS tourist_tax_name VARCHAR(100) DEFAULT 'Tourist Tax'`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS tourist_tax_max_nights INTEGER`); // NULL = no max
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS tourist_tax_exempt_children BOOLEAN DEFAULT true`);
    
    // Add description columns to properties and bookable_units for website display
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS short_description TEXT`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS full_description TEXT`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS display_name VARCHAR(255)`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS district VARCHAR(255)`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS state VARCHAR(255)`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS zip_code VARCHAR(50)`);
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS short_description TEXT`);
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS full_description TEXT`);
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS display_name VARCHAR(255)`);
    
    // Add pricing columns to room_availability
    await pool.query(`ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS reference_price DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS standard_price DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS available BOOLEAN DEFAULT true`);
    await pool.query(`ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS min_stay INTEGER DEFAULT 1`);
    
    // Create offers table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS offers (
        id SERIAL PRIMARY KEY,
        user_id INTEGER DEFAULT 1,
        property_id INTEGER,
        room_id INTEGER,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        discount_type VARCHAR(20) NOT NULL DEFAULT 'percentage',
        discount_value DECIMAL(10,2) NOT NULL,
        applies_to VARCHAR(20) DEFAULT 'standard_price',
        min_nights INTEGER DEFAULT 1,
        max_nights INTEGER,
        min_guests INTEGER,
        max_guests INTEGER,
        min_advance_days INTEGER,
        max_advance_days INTEGER,
        valid_from DATE,
        valid_until DATE,
        valid_days_of_week VARCHAR(20),
        allowed_checkin_days VARCHAR(20) DEFAULT '0,1,2,3,4,5,6',
        allowed_checkout_days VARCHAR(20) DEFAULT '0,1,2,3,4,5,6',
        stackable BOOLEAN DEFAULT false,
        priority INTEGER DEFAULT 0,
        available_website BOOLEAN DEFAULT true,
        available_agents BOOLEAN DEFAULT false,
        active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Add distribution columns if they don't exist
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS available_website BOOLEAN DEFAULT true`);
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS available_agents BOOLEAN DEFAULT false`);
    // Add check-in/check-out restriction columns
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS allowed_checkin_days VARCHAR(20) DEFAULT '0,1,2,3,4,5,6'`);
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS allowed_checkout_days VARCHAR(20) DEFAULT '0,1,2,3,4,5,6'`);
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS min_nights INTEGER DEFAULT 1`);
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS max_nights INTEGER`);
    // Add array columns for multi-select property/room targeting
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS property_ids INTEGER[]`);
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS room_ids INTEGER[]`);
    // Add account_id for proper multi-tenant scoping
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS account_id INTEGER`);
    // CRITICAL: Fix existing offers without account_id - set from property
    await pool.query(`
      UPDATE offers o
      SET account_id = COALESCE(p.account_id, p.client_id)
      FROM properties p
      WHERE o.property_id = p.id
        AND o.account_id IS NULL
    `);
    console.log('‚úÖ Fixed offers without account_id');
    // Fix discount_value to allow NULL or default to 0
    await pool.query(`ALTER TABLE offers ALTER COLUMN discount_value SET DEFAULT 0`);
    await pool.query(`ALTER TABLE offers ALTER COLUMN discount_value DROP NOT NULL`);
    // Add price_per_night for fixed-price corporate/agent offers
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS price_per_night DECIMAL(10,2)`);
    
    // Create vouchers table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS vouchers (
        id SERIAL PRIMARY KEY,
        user_id INTEGER DEFAULT 1,
        property_id INTEGER,
        code VARCHAR(50) UNIQUE NOT NULL,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        discount_type VARCHAR(20) NOT NULL DEFAULT 'percentage',
        discount_value DECIMAL(10,2) NOT NULL,
        applies_to VARCHAR(20) DEFAULT 'total',
        min_nights INTEGER DEFAULT 1,
        min_total DECIMAL(10,2),
        min_booking_value DECIMAL(10,2),
        max_uses INTEGER,
        uses_count INTEGER DEFAULT 0,
        single_use_per_guest BOOLEAN DEFAULT false,
        is_public BOOLEAN DEFAULT false,
        property_ids INTEGER[],
        room_ids INTEGER[],
        valid_from DATE,
        valid_until DATE,
        active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Add is_public column if not exists (for existing tables)
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS is_public BOOLEAN DEFAULT false`);
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS property_id INTEGER`);
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS min_booking_value DECIMAL(10,2)`);
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS times_used INTEGER DEFAULT 0`);
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS min_nights INTEGER DEFAULT 1`);
    
    // Multilingual support for vouchers
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS name_ml JSONB`);
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS description_ml JSONB`);
    await pool.query(`ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS terms_ml JSONB`);
    await pool.query(`UPDATE vouchers SET name_ml = jsonb_build_object('en', name) WHERE name_ml IS NULL AND name IS NOT NULL`);
    await pool.query(`UPDATE vouchers SET description_ml = jsonb_build_object('en', description) WHERE description_ml IS NULL AND description IS NOT NULL`);
    
    // Create voucher_uses table to track usage
    await pool.query(`
      CREATE TABLE IF NOT EXISTS voucher_uses (
        id SERIAL PRIMARY KEY,
        voucher_id INTEGER REFERENCES vouchers(id),
        booking_id INTEGER,
        guest_email VARCHAR(255),
        discount_applied DECIMAL(10,2),
        used_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Create upsells table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS upsells (
        id SERIAL PRIMARY KEY,
        user_id INTEGER DEFAULT 1,
        property_id INTEGER,
        room_id INTEGER,
        room_ids TEXT,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        price DECIMAL(10,2) NOT NULL,
        charge_type VARCHAR(30) DEFAULT 'per_booking',
        max_quantity INTEGER,
        image_url TEXT,
        category VARCHAR(50),
        active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Add new columns if they don't exist
    await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS room_ids TEXT`);
    await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS image_url TEXT`);
    await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS category VARCHAR(50)`);
    
    // Multilingual support for upsells
    await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS name_ml JSONB`);
    await pool.query(`ALTER TABLE upsells ADD COLUMN IF NOT EXISTS description_ml JSONB`);
    await pool.query(`UPDATE upsells SET name_ml = jsonb_build_object('en', name) WHERE name_ml IS NULL AND name IS NOT NULL`);
    await pool.query(`UPDATE upsells SET description_ml = jsonb_build_object('en', description) WHERE description_ml IS NULL AND description IS NOT NULL`);
    
    // Create fees table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS fees (
        id SERIAL PRIMARY KEY,
        user_id INTEGER DEFAULT 1,
        property_id INTEGER,
        room_id INTEGER,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        amount_type VARCHAR(20) DEFAULT 'fixed',
        amount DECIMAL(10,2) NOT NULL,
        apply_per VARCHAR(30) DEFAULT 'per_booking',
        is_tax BOOLEAN DEFAULT false,
        active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Create taxes table (Tourist/City Taxes with complex rules)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS taxes (
        id SERIAL PRIMARY KEY,
        user_id INTEGER DEFAULT 1,
        property_id INTEGER,
        room_id INTEGER,
        name VARCHAR(255) NOT NULL,
        country VARCHAR(10),
        amount_type VARCHAR(20) DEFAULT 'fixed',
        currency VARCHAR(10) DEFAULT 'EUR',
        amount DECIMAL(10,2) NOT NULL,
        charge_per VARCHAR(30) DEFAULT 'per_person_per_night',
        max_nights INTEGER,
        min_age INTEGER,
        star_tier VARCHAR(20),
        season_start DATE,
        season_end DATE,
        active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    res.json({ success: true, message: 'Database tables created!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/setup-users', async (req, res) => {
  try {
    await pool.query(`CREATE TABLE IF NOT EXISTS users (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL, email VARCHAR(255) UNIQUE NOT NULL, password_hash VARCHAR(255) NOT NULL, company VARCHAR(255), account_type VARCHAR(50) DEFAULT 'owner', api_key VARCHAR(255) UNIQUE, subscription_status VARCHAR(50) DEFAULT 'free', subscription_plan VARCHAR(50), created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)`);
    res.json({ success: true, message: 'Users table created!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// KNOWLEDGE BASE SYSTEM
// =====================================================

// Setup knowledge base tables
app.get('/api/setup-knowledge-base', async (req, res) => {
  try {
    // Categories for organizing knowledge
    await pool.query(`
      CREATE TABLE IF NOT EXISTS kb_categories (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(255) UNIQUE NOT NULL,
        description TEXT,
        icon VARCHAR(50),
        sort_order INTEGER DEFAULT 0,
        parent_id INTEGER REFERENCES kb_categories(id),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Main knowledge articles
    await pool.query(`
      CREATE TABLE IF NOT EXISTS kb_articles (
        id SERIAL PRIMARY KEY,
        category_id INTEGER REFERENCES kb_categories(id),
        title VARCHAR(500) NOT NULL,
        slug VARCHAR(500) UNIQUE NOT NULL,
        summary TEXT,
        content TEXT NOT NULL,
        keywords TEXT[],
        related_articles INTEGER[],
        status VARCHAR(50) DEFAULT 'published',
        views INTEGER DEFAULT 0,
        helpful_yes INTEGER DEFAULT 0,
        helpful_no INTEGER DEFAULT 0,
        created_by INTEGER,
        updated_by INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Track questions the AI couldn't answer
    await pool.query(`
      CREATE TABLE IF NOT EXISTS kb_unanswered (
        id SERIAL PRIMARY KEY,
        question TEXT NOT NULL,
        user_context TEXT,
        account_id INTEGER,
        session_id VARCHAR(255),
        times_asked INTEGER DEFAULT 1,
        status VARCHAR(50) DEFAULT 'new',
        resolved_article_id INTEGER REFERENCES kb_articles(id),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Chat history for context
    await pool.query(`
      CREATE TABLE IF NOT EXISTS kb_chat_history (
        id SERIAL PRIMARY KEY,
        session_id VARCHAR(255) NOT NULL,
        account_id INTEGER,
        role VARCHAR(50) NOT NULL,
        message TEXT NOT NULL,
        articles_used INTEGER[],
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Insert default categories if empty
    const catCheck = await pool.query('SELECT COUNT(*) FROM kb_categories');
    if (parseInt(catCheck.rows[0].count) === 0) {
      await pool.query(`
        INSERT INTO kb_categories (name, slug, description, icon, sort_order) VALUES
        ('Getting Started', 'getting-started', 'New to GAS? Start here', 'üöÄ', 1),
        ('Channel Managers', 'channel-managers', 'Connecting Beds24, Hostaway, Smoobu and more', 'üîó', 2),
        ('Properties & Rooms', 'properties-rooms', 'Managing your properties and units', 'üè®', 3),
        ('Images', 'images', 'Uploading and managing photos', 'üì∑', 4),
        ('Pricing & Offers', 'pricing-offers', 'Setting prices, creating offers and discounts', 'üí∞', 5),
        ('Availability', 'availability', 'Calendar and booking management', 'üìÖ', 6),
        ('Vouchers', 'vouchers', 'Creating and managing vouchers', 'üéüÔ∏è', 7),
        ('Upsells & Fees', 'upsells-fees', 'Additional charges and upsell options', '‚ûï', 8),
        ('Taxes', 'taxes', 'Tourist taxes and regional charges', 'üìã', 9),
        ('Content & SEO', 'content-seo', 'Descriptions, pages, and search optimization', '‚úèÔ∏è', 10),
        ('Website & Plugins', 'website-plugins', 'WordPress plugin and website integration', 'üåê', 11),
        ('Travel Agents', 'travel-agents', 'Information for travel agents and tour operators', '‚úàÔ∏è', 12),
        ('Account & Billing', 'account-billing', 'Managing your account and payments', 'üë§', 13),
        ('Troubleshooting', 'troubleshooting', 'Common issues and solutions', 'üîß', 14)
      `);
    }
    
    res.json({ success: true, message: 'Knowledge base tables created!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get all knowledge categories
app.get('/api/kb/categories', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT c.*, 
        (SELECT COUNT(*) FROM kb_articles WHERE category_id = c.id AND status = 'published') as article_count
      FROM kb_categories c
      ORDER BY c.sort_order, c.name
    `);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/update category
app.post('/api/kb/categories', async (req, res) => {
  try {
    const { id, name, slug, description, icon, sort_order, parent_id } = req.body;
    
    if (id) {
      // Update
      const result = await pool.query(`
        UPDATE kb_categories SET name = $1, slug = $2, description = $3, icon = $4, sort_order = $5, parent_id = $6
        WHERE id = $7 RETURNING *
      `, [name, slug, description, icon, sort_order, parent_id, id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      // Create
      const result = await pool.query(`
        INSERT INTO kb_categories (name, slug, description, icon, sort_order, parent_id)
        VALUES ($1, $2, $3, $4, $5, $6) RETURNING *
      `, [name, slug, description, icon, sort_order || 0, parent_id]);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get all articles (with optional filters)
app.get('/api/kb/articles', async (req, res) => {
  try {
    const { category_id, status, search } = req.query;
    let query = `
      SELECT a.*, c.name as category_name, c.icon as category_icon
      FROM kb_articles a
      LEFT JOIN kb_categories c ON a.category_id = c.id
      WHERE 1=1
    `;
    const params = [];
    
    if (category_id) {
      params.push(category_id);
      query += ` AND a.category_id = $${params.length}`;
    }
    
    if (status) {
      params.push(status);
      query += ` AND a.status = $${params.length}`;
    }
    
    if (search) {
      params.push(`%${search}%`);
      query += ` AND (a.title ILIKE $${params.length} OR a.content ILIKE $${params.length} OR a.summary ILIKE $${params.length})`;
    }
    
    query += ' ORDER BY a.category_id, a.title';
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get single article
app.get('/api/kb/articles/:id', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT a.*, c.name as category_name, c.icon as category_icon
      FROM kb_articles a
      LEFT JOIN kb_categories c ON a.category_id = c.id
      WHERE a.id = $1
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Article not found' });
    }
    
    // Increment views
    await pool.query('UPDATE kb_articles SET views = views + 1 WHERE id = $1', [req.params.id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/update article
app.post('/api/kb/articles', async (req, res) => {
  try {
    const { id, category_id, title, slug, summary, content, keywords, related_articles, status } = req.body;
    
    // Generate slug from title if not provided
    const finalSlug = slug || title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
    
    if (id) {
      // Update
      const result = await pool.query(`
        UPDATE kb_articles SET 
          category_id = $1, title = $2, slug = $3, summary = $4, content = $5, 
          keywords = $6, related_articles = $7, status = $8, updated_at = NOW()
        WHERE id = $9 RETURNING *
      `, [category_id, title, finalSlug, summary, content, keywords || [], related_articles || [], status || 'published', id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      // Create
      const result = await pool.query(`
        INSERT INTO kb_articles (category_id, title, slug, summary, content, keywords, related_articles, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *
      `, [category_id, title, finalSlug, summary, content, keywords || [], related_articles || [], status || 'published']);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete article
app.delete('/api/kb/articles/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM kb_articles WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Mark article as helpful/not helpful
app.post('/api/kb/articles/:id/feedback', async (req, res) => {
  try {
    const { helpful } = req.body;
    const field = helpful ? 'helpful_yes' : 'helpful_no';
    await pool.query(`UPDATE kb_articles SET ${field} = ${field} + 1 WHERE id = $1`, [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Search knowledge base (for AI to use)
app.get('/api/kb/search', async (req, res) => {
  try {
    const { q, limit = 5 } = req.query;
    
    if (!q) {
      return res.json({ success: true, data: [] });
    }
    
    // Search by keywords, title, summary, and content
    const searchTerms = q.toLowerCase().split(/\s+/).filter(t => t.length > 2);
    
    if (searchTerms.length === 0) {
      return res.json({ success: true, data: [] });
    }
    
    // Build search query with ranking
    const result = await pool.query(`
      SELECT a.id, a.title, a.summary, a.content, a.keywords, c.name as category_name, c.icon as category_icon,
        (
          -- Exact title match (highest)
          CASE WHEN LOWER(a.title) = $1 THEN 100 ELSE 0 END +
          -- Title contains search (high)
          CASE WHEN LOWER(a.title) LIKE $2 THEN 50 ELSE 0 END +
          -- Keywords match (high)
          CASE WHEN a.keywords && $3::text[] THEN 40 ELSE 0 END +
          -- Summary contains (medium)
          CASE WHEN LOWER(a.summary) LIKE $2 THEN 20 ELSE 0 END +
          -- Content contains (low)
          CASE WHEN LOWER(a.content) LIKE $2 THEN 10 ELSE 0 END
        ) as relevance
      FROM kb_articles a
      LEFT JOIN kb_categories c ON a.category_id = c.id
      WHERE a.status = 'published'
        AND (
          LOWER(a.title) LIKE $2
          OR LOWER(a.summary) LIKE $2
          OR LOWER(a.content) LIKE $2
          OR a.keywords && $3::text[]
        )
      ORDER BY relevance DESC, a.views DESC
      LIMIT $4
    `, [q.toLowerCase(), `%${q.toLowerCase()}%`, searchTerms, limit]);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get unanswered questions
app.get('/api/kb/unanswered', async (req, res) => {
  try {
    const { status } = req.query;
    let query = 'SELECT * FROM kb_unanswered';
    const params = [];
    
    if (status) {
      params.push(status);
      query += ' WHERE status = $1';
    }
    
    query += ' ORDER BY times_asked DESC, created_at DESC';
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Mark unanswered question as resolved
app.post('/api/kb/unanswered/:id/resolve', async (req, res) => {
  try {
    const { article_id } = req.body;
    await pool.query(`
      UPDATE kb_unanswered SET status = 'resolved', resolved_article_id = $1, updated_at = NOW()
      WHERE id = $2
    `, [article_id, req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete unanswered question
app.delete('/api/kb/unanswered/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM kb_unanswered WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Bulk import articles (for importing ChatGPT-generated docs)
app.post('/api/kb/import', async (req, res) => {
  try {
    const { articles } = req.body;
    
    if (!articles || !Array.isArray(articles)) {
      return res.json({ success: false, error: 'Articles array required' });
    }
    
    let imported = 0;
    let errors = [];
    
    for (const article of articles) {
      try {
        const slug = article.slug || article.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
        
        // Find or create category
        let categoryId = article.category_id;
        if (!categoryId && article.category) {
          const catResult = await pool.query('SELECT id FROM kb_categories WHERE slug = $1 OR name ILIKE $2', 
            [article.category.toLowerCase().replace(/[^a-z0-9]+/g, '-'), article.category]);
          if (catResult.rows.length > 0) {
            categoryId = catResult.rows[0].id;
          }
        }
        
        // Insert or update article
        await pool.query(`
          INSERT INTO kb_articles (category_id, title, slug, summary, content, keywords, status)
          VALUES ($1, $2, $3, $4, $5, $6, 'published')
          ON CONFLICT (slug) DO UPDATE SET
            category_id = EXCLUDED.category_id,
            title = EXCLUDED.title,
            summary = EXCLUDED.summary,
            content = EXCLUDED.content,
            keywords = EXCLUDED.keywords,
            updated_at = NOW()
        `, [categoryId, article.title, slug, article.summary, article.content, article.keywords || []]);
        
        imported++;
      } catch (e) {
        errors.push({ title: article.title, error: e.message });
      }
    }
    
    res.json({ success: true, imported, errors });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// AI Chat Support Endpoint
app.post('/api/ai-chat', async (req, res) => {
    try {
        const { message, context, history } = req.body;
        
        if (!message) {
            return res.json({ success: false, error: 'Message required' });
        }
        
        // Search knowledge base for relevant articles
        let knowledgeContent = '';
        let articlesFound = 0;
        
        try {
            // Extract keywords from the message (simple approach)
            const searchTerms = message.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .split(/\s+/)
                .filter(word => word.length > 2 && !['the', 'how', 'what', 'why', 'when', 'where', 'can', 'does', 'this', 'that', 'with', 'for', 'and', 'but', 'not'].includes(word));
            
            if (searchTerms.length > 0) {
                // Search articles by title, content, and keywords
                const searchQuery = searchTerms.join(' | '); // OR search
                const articlesResult = await pool.query(`
                    SELECT title, summary, content, 
                           ts_rank(to_tsvector('english', title || ' ' || COALESCE(summary, '') || ' ' || content), plainto_tsquery('english', $1)) as rank
                    FROM kb_articles 
                    WHERE status = 'published'
                      AND (
                          to_tsvector('english', title || ' ' || COALESCE(summary, '') || ' ' || content) @@ plainto_tsquery('english', $1)
                          OR title ILIKE ANY($2)
                          OR $1 = ANY(keywords)
                      )
                    ORDER BY rank DESC
                    LIMIT 5
                `, [searchTerms.join(' '), searchTerms.map(t => '%' + t + '%')]);
                
                if (articlesResult.rows.length > 0) {
                    articlesFound = articlesResult.rows.length;
                    knowledgeContent = articlesResult.rows.map(article => 
                        `### ${article.title}\n${article.content}`
                    ).join('\n\n---\n\n');
                }
            }
        } catch (dbError) {
            console.log('KB search error (tables may not exist):', dbError.message);
        }
        
        // Fallback base knowledge if no articles found
        const baseKnowledge = `
## GAS Dashboard Quick Reference

### Blog
Create SEO content: Blog menu ‚Üí Get Ideas ‚Üí Select category ‚Üí Generate Ideas ‚Üí Create Post from any idea

### Attractions  
Add local places: Attractions menu ‚Üí Suggest Places ‚Üí Select category ‚Üí Add This Place

### Pricing
- Standard tier: Public rates with discount badges
- Corporate/Agent tiers: Clean pricing without badges
- Create offers: Offers & Pricing ‚Üí Add Offer

### Websites
Manage at: Websites ‚Üí Deployed Sites

### Common Issues
- Content not showing? Check it's Published
- Prices wrong? Resync Connection
- Changes not visible? Clear browser cache (Ctrl+Shift+R)

### Support
Email: hello@gas.travel
`;

        const fullKnowledge = articlesFound > 0 
            ? `RELEVANT KNOWLEDGE BASE ARTICLES:\n\n${knowledgeContent}\n\n---\n\nGENERAL REFERENCE:\n${baseKnowledge}`
            : `KNOWLEDGE BASE:\n${baseKnowledge}`;
        
        // Build messages array
        const messages = [];
        
        // Add conversation history if provided
        if (history && Array.isArray(history)) {
            history.forEach(msg => {
                messages.push({
                    role: msg.role === 'assistant' ? 'assistant' : 'user',
                    content: msg.content
                });
            });
        }
        
        // Add current message
        messages.push({ role: 'user', content: message });
        
        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1000,
            system: `You are a helpful support assistant for GAS (Global Accommodation System). You help property owners use the dashboard.

${fullKnowledge}

CURRENT CONTEXT:
- User is viewing: ${context || 'Dashboard'} section
- Articles found in knowledge base: ${articlesFound}

GUIDELINES:
- Be friendly, concise, and helpful
- Use the knowledge base articles to answer accurately
- If you cannot find a clear answer in the knowledge base, say "I don't have specific information about that yet, but our team can help at hello@gas.travel"
- Keep responses brief (2-3 paragraphs max)
- Use bullet points for steps
- Don't use markdown formatting like ** or ## - just plain text`,
            messages: messages
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        const responseText = claudeResponse.data.content[0].text;
        
        // Log to unanswered if AI couldn't find good info
        const needsAnswer = responseText.toLowerCase().includes("don't have specific information") || 
                           responseText.toLowerCase().includes("i don't know") ||
                           responseText.toLowerCase().includes("not sure") ||
                           responseText.toLowerCase().includes("hello@gas.travel");
        
        if (needsAnswer) {
            let unansweredId = null;
            try {
                const result = await pool.query(`
                    INSERT INTO kb_unanswered (question, user_context, status)
                    VALUES ($1, $2, 'new')
                    RETURNING id
                `, [message, context || 'general']);
                unansweredId = result.rows[0]?.id;
                console.log('Logged unanswered question ID:', unansweredId);
            } catch (e) {
                console.error('Error logging unanswered question:', e.message);
            }
            
            // Send Slack notification
            if (process.env.SLACK_WEBHOOK_URL) {
                try {
                    await axios.post(process.env.SLACK_WEBHOOK_URL, {
                        blocks: [
                            {
                                type: "header",
                                text: {
                                    type: "plain_text",
                                    text: "üß≥ Gus couldn't answer this question",
                                    emoji: true
                                }
                            },
                            {
                                type: "section",
                                text: {
                                    type: "mrkdwn",
                                    text: `*Question:*\n"${message}"`
                                }
                            },
                            {
                                type: "context",
                                elements: [
                                    {
                                        type: "mrkdwn",
                                        text: `üìç *Section:* ${context || 'General'}  |  üÜî *ID:* #${unansweredId || 'N/A'}  |  üïê ${new Date().toLocaleTimeString()}`
                                    }
                                ]
                            },
                            {
                                type: "divider"
                            },
                            {
                                type: "section",
                                text: {
                                    type: "mrkdwn",
                                    text: "üëâ Add answer in <https://www.gas.travel/gas-admin.html|GAS Admin> ‚Üí Knowledge Base ‚Üí Unanswered"
                                }
                            }
                        ]
                    });
                } catch (slackError) {
                    console.error('Slack notification failed:', slackError.message);
                }
            }
        }
        
        // Log successful article usage for analytics (optional)
        if (articlesFound > 0) {
            console.log(`AI Chat: Found ${articlesFound} relevant articles for: "${message.substring(0, 50)}..."`);
        }
        
        res.json({ 
            success: true, 
            response: responseText,
            articlesUsed: articlesFound
        });
        
    } catch (error) {
        console.error('AI Chat error:', error.response?.data || error.message);
        res.json({ success: false, error: 'Failed to get AI response' });
    }
});

// =====================================================
// SLACK EVENTS API - Receive replies to add to KB
// =====================================================

// Test endpoint
app.get('/api/slack/events', (req, res) => {
    res.json({ ok: true, message: 'Slack events endpoint is working. POST requests accepted.' });
});

app.post('/api/slack/events', async (req, res) => {
    console.log('Slack event received:', JSON.stringify(req.body).substring(0, 500));
    try {
        const { type, challenge, event } = req.body;
        
        // Slack URL verification challenge
        if (type === 'url_verification') {
            return res.json({ challenge });
        }
        
        // Handle message events
        if (type === 'event_callback' && event) {
            // Ignore bot messages (prevent loops)
            if (event.bot_id || event.subtype === 'bot_message') {
                return res.json({ ok: true });
            }
            
            // Check if it's a reply in a thread (has thread_ts)
            if (event.type === 'message' && event.thread_ts && event.text) {
                const answer = event.text;
                
                // Get the parent message to find the question
                // For now, we'll just add the answer with a generic title
                // The question ID should be in the parent message
                
                try {
                    // Extract question ID from thread if mentioned (format: #123)
                    const idMatch = answer.match(/#(\d+)/);
                    let questionId = idMatch ? idMatch[1] : null;
                    let question = 'Question from Slack';
                    let cleanAnswer = answer.replace(/#\d+\s*/, '').trim(); // Remove #ID from answer
                    
                    // If we have a question ID, get the original question
                    if (questionId) {
                        const questionResult = await pool.query(
                            'SELECT question FROM kb_unanswered WHERE id = $1',
                            [questionId]
                        );
                        if (questionResult.rows.length > 0) {
                            question = questionResult.rows[0].question;
                        }
                    }
                    
                    // Create KB article
                    const title = question.length > 100 ? question.substring(0, 100) + '...' : question;
                    const slug = title.toLowerCase()
                        .replace(/[^a-z0-9]+/g, '-')
                        .replace(/(^-|-$)/g, '')
                        .substring(0, 80) + '-' + Date.now();
                    
                    await pool.query(`
                        INSERT INTO kb_articles (title, slug, content, summary, status)
                        VALUES ($1, $2, $3, $4, 'published')
                    `, [title, slug, cleanAnswer, cleanAnswer.substring(0, 200)]);
                    
                    // Mark unanswered as resolved
                    if (questionId) {
                        await pool.query(
                            'UPDATE kb_unanswered SET status = $1 WHERE id = $2',
                            ['resolved', questionId]
                        );
                    }
                    
                    // Send confirmation back to Slack
                    if (process.env.SLACK_WEBHOOK_URL) {
                        await axios.post(process.env.SLACK_WEBHOOK_URL, {
                            text: `‚úÖ Added to Knowledge Base!\n\n*Q:* ${question}\n*A:* ${cleanAnswer.substring(0, 200)}${cleanAnswer.length > 200 ? '...' : ''}\n\n_Gus will now know this answer!_`
                        });
                    }
                } catch (dbError) {
                    console.error('Error adding to KB from Slack:', dbError);
                }
            }
        }
        
        res.json({ ok: true });
    } catch (error) {
        console.error('Slack events error:', error);
        res.json({ ok: true }); // Always return ok to Slack
    }
});

// =====================================================
// BILLING & SUBSCRIPTION SYSTEM
// =====================================================

// Setup billing tables
// Setup just the websites tables (separate from billing to avoid errors)
app.get('/api/setup-websites', async (req, res) => {
  try {
    console.log('üåê Setting up website tables...');
    
    // Add code column to website_templates if needed
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS code VARCHAR(50)`);
    await pool.query(`UPDATE website_templates SET code = slug WHERE code IS NULL`);
    
    // Websites table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS websites (
        id SERIAL PRIMARY KEY,
        public_id VARCHAR(20) UNIQUE NOT NULL,
        owner_type VARCHAR(20) NOT NULL DEFAULT 'account',
        owner_id INTEGER NOT NULL,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(100),
        template_code VARCHAR(50),
        site_url VARCHAR(500),
        admin_url VARCHAR(500),
        custom_domain VARCHAR(255),
        instawp_site_id VARCHAR(255),
        instawp_data JSONB DEFAULT '{}',
        website_type VARCHAR(30) DEFAULT 'portfolio',
        status VARCHAR(20) DEFAULT 'draft',
        default_currency VARCHAR(3) DEFAULT 'GBP',
        timezone VARCHAR(50) DEFAULT 'Europe/London',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_websites_owner ON websites(owner_type, owner_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_websites_status ON websites(status)`);
    
    // Website Units junction table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_units (
        id SERIAL PRIMARY KEY,
        website_id INTEGER NOT NULL REFERENCES websites(id) ON DELETE CASCADE,
        unit_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        display_order INTEGER DEFAULT 0,
        is_featured BOOLEAN DEFAULT FALSE,
        custom_name VARCHAR(255),
        custom_description TEXT,
        custom_price_modifier DECIMAL(5,2),
        is_active BOOLEAN DEFAULT TRUE,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(website_id, unit_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_units_website ON website_units(website_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_units_unit ON website_units(unit_id)`);
    
    // Website Pages
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_pages (
        id SERIAL PRIMARY KEY,
        website_id INTEGER NOT NULL REFERENCES websites(id) ON DELETE CASCADE,
        page_type VARCHAR(50) NOT NULL,
        slug VARCHAR(100),
        title VARCHAR(255),
        content JSONB DEFAULT '{}',
        is_published BOOLEAN DEFAULT FALSE,
        display_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Migration tracking column
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS migrated_to_website_id INTEGER`);
    
    console.log('‚úÖ Website tables created successfully');
    res.json({ success: true, message: 'Website tables created' });
  } catch (error) {
    console.error('Setup websites error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Enhanced Website Builder Schema Setup
app.get('/api/setup-website-builder', async (req, res) => {
  try {
    console.log('üîß Setting up enhanced Website Builder schema...');
    
    // 1. Enhance websites table with setup tracking
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS setup_complete BOOLEAN DEFAULT false`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS setup_progress JSONB DEFAULT '{}'`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS theme_mode VARCHAR(20) DEFAULT 'developer'`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS last_synced_at TIMESTAMP`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS sync_source VARCHAR(20)`);
    console.log('  ‚úì websites table enhanced');
    
    // 2. Enhance website_templates with schema support
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS code VARCHAR(50)`);
    await pool.query(`UPDATE website_templates SET code = slug WHERE code IS NULL`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS schema JSONB DEFAULT '{}'`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS category VARCHAR(50)`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS sections JSONB DEFAULT '{}'`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS thumbnail_url VARCHAR(500)`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS is_premium BOOLEAN DEFAULT false`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS min_tier VARCHAR(20) DEFAULT 'starter'`);
    console.log('  ‚úì website_templates table enhanced');
    
    // 3. Enhance website_settings to support per-website (not just per-account)
    await pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS website_id INTEGER REFERENCES websites(id) ON DELETE CASCADE`);
    await pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS last_synced_at TIMESTAMP`);
    await pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS sync_source VARCHAR(20)`);
    await pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS variant VARCHAR(50)`);
    await pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS is_enabled BOOLEAN DEFAULT true`);
    await pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS display_order INTEGER DEFAULT 0`);
    
    // Create index for website_id lookups
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_settings_website ON website_settings(website_id)`);
    
    // Create unique index for website+section (allows null website_id for legacy)
    await pool.query(`CREATE UNIQUE INDEX IF NOT EXISTS idx_website_settings_unique 
      ON website_settings(website_id, section) WHERE website_id IS NOT NULL`);
    console.log('  ‚úì website_settings table enhanced');
    
    // 4. Enhance website_pages for sub-pages and better content management
    await pool.query(`ALTER TABLE website_pages ADD COLUMN IF NOT EXISTS parent_id INTEGER REFERENCES website_pages(id) ON DELETE SET NULL`);
    await pool.query(`ALTER TABLE website_pages ADD COLUMN IF NOT EXISTS template VARCHAR(50)`);
    await pool.query(`ALTER TABLE website_pages ADD COLUMN IF NOT EXISTS seo_title VARCHAR(255)`);
    await pool.query(`ALTER TABLE website_pages ADD COLUMN IF NOT EXISTS seo_description TEXT`);
    await pool.query(`ALTER TABLE website_pages ADD COLUMN IF NOT EXISTS featured_image VARCHAR(500)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_pages_parent ON website_pages(parent_id)`);
    console.log('  ‚úì website_pages table enhanced');
    
    // 5. Create theme_registry table (separate from website_templates for clarity)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS theme_registry (
        id SERIAL PRIMARY KEY,
        code VARCHAR(50) UNIQUE NOT NULL,
        name VARCHAR(100) NOT NULL,
        description TEXT,
        version VARCHAR(20) DEFAULT '1.0.0',
        schema JSONB NOT NULL DEFAULT '{}',
        sections JSONB NOT NULL DEFAULT '{}',
        color_presets JSONB DEFAULT '[]',
        font_presets JSONB DEFAULT '[]',
        thumbnail_url VARCHAR(500),
        preview_url VARCHAR(500),
        download_url VARCHAR(500),
        is_active BOOLEAN DEFAULT true,
        is_premium BOOLEAN DEFAULT false,
        min_tier VARCHAR(20) DEFAULT 'starter',
        sort_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    console.log('  ‚úì theme_registry table created');
    
    // 6. Create website_sync_log for tracking sync history
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_sync_log (
        id SERIAL PRIMARY KEY,
        website_id INTEGER REFERENCES websites(id) ON DELETE CASCADE,
        direction VARCHAR(20) NOT NULL,
        sections_synced JSONB DEFAULT '[]',
        status VARCHAR(20) DEFAULT 'success',
        error_message TEXT,
        source_data JSONB,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_sync_log_website ON website_sync_log(website_id)`);
    console.log('  ‚úì website_sync_log table created');
    
    // 7. Insert Developer theme into theme_registry if not exists
    const developerThemeSchema = {
      code: 'developer',
      name: 'GAS Developer Theme',
      version: '1.0.0',
      sections: {
        header: {
          label: 'Header & Navigation',
          required: true,
          order: 1,
          fields: {
            developer_logo_text: { type: 'text', label: 'Logo Text', default: 'Your Property' },
            developer_logo_image: { type: 'image', label: 'Logo Image' },
            developer_header_bg: { type: 'color', label: 'Background Color', default: '#ffffff' },
            developer_header_text: { type: 'color', label: 'Text Color', default: '#1e293b' },
            developer_header_transparent: { type: 'toggle', label: 'Transparent on Homepage', default: true },
            developer_header_sticky: { type: 'toggle', label: 'Sticky Header', default: true },
            developer_header_cta_text: { type: 'text', label: 'CTA Button Text', default: 'Book Now' },
            developer_header_cta_url: { type: 'text', label: 'CTA Button URL', default: '/book-now/' },
            developer_header_cta_bg: { type: 'color', label: 'CTA Button Color', default: '#2563eb' }
          }
        },
        hero: {
          label: 'Hero Section',
          required: true,
          order: 2,
          fields: {
            developer_hero_bg: { type: 'image', label: 'Background Image' },
            developer_hero_video_url: { type: 'url', label: 'Video URL (MP4)' },
            developer_hero_title: { type: 'text', label: 'Title', default: 'Find Your Perfect Vacation Rental' },
            developer_hero_subtitle: { type: 'textarea', label: 'Subtitle', default: 'Discover stunning vacation rentals with luxury amenities.' },
            developer_hero_badge: { type: 'text', label: 'Badge Text', default: 'Welcome to Paradise' },
            developer_hero_opacity: { type: 'range', label: 'Overlay Opacity', min: 0, max: 100, default: 30 },
            developer_hero_overlay_color: { type: 'color', label: 'Overlay Color', default: '#0f172a' },
            developer_search_btn_bg: { type: 'color', label: 'Search Button Color', default: '#2563eb' },
            developer_hero_trust_1: { type: 'text', label: 'Trust Badge 1', default: 'Instant Booking' },
            developer_hero_trust_2: { type: 'text', label: 'Trust Badge 2', default: 'Best Price Guarantee' },
            developer_hero_trust_3: { type: 'text', label: 'Trust Badge 3', default: '24/7 Support' }
          }
        },
        intro: {
          label: 'Introduction',
          required: false,
          order: 3,
          fields: {
            developer_intro_enabled: { type: 'toggle', label: 'Enable Section', default: true },
            developer_intro_title: { type: 'text', label: 'Title', default: 'Welcome to Our Property' },
            developer_intro_text: { type: 'textarea', label: 'Text', default: 'We are delighted to have you here.' },
            developer_intro_bg: { type: 'color', label: 'Background Color', default: '#ffffff' },
            developer_intro_btn_text: { type: 'text', label: 'Button Text' },
            developer_intro_btn_url: { type: 'text', label: 'Button URL' }
          }
        },
        featured: {
          label: 'Featured Properties',
          required: true,
          order: 4,
          fields: {
            developer_featured_enabled: { type: 'toggle', label: 'Enable Section', default: true },
            developer_featured_mode: { type: 'select', label: 'Display Mode', options: ['all', 'featured', 'selected'], default: 'all' },
            developer_featured_count: { type: 'number', label: 'Number to Show', default: 3 },
            developer_featured_title: { type: 'text', label: 'Section Title', default: 'Featured Properties' },
            developer_featured_subtitle: { type: 'textarea', label: 'Section Subtitle' },
            developer_featured_btn_text: { type: 'text', label: 'Button Text', default: 'View All Properties' },
            developer_featured_btn_url: { type: 'text', label: 'Button URL', default: '/book-now/' }
          }
        },
        about: {
          label: 'About Section',
          required: false,
          order: 5,
          fields: {
            developer_about_enabled: { type: 'toggle', label: 'Enable Section', default: true },
            developer_about_image: { type: 'image', label: 'Image' },
            developer_about_title: { type: 'text', label: 'Title', default: 'Experience Luxury & Comfort' },
            developer_about_text: { type: 'textarea', label: 'Description' },
            developer_about_layout: { type: 'select', label: 'Layout', options: ['image-left', 'image-right'], default: 'image-left' },
            developer_about_feature_1: { type: 'text', label: 'Feature 1', default: 'Spacious Bedrooms' },
            developer_about_feature_2: { type: 'text', label: 'Feature 2', default: 'Luxury Bathrooms' },
            developer_about_feature_3: { type: 'text', label: 'Feature 3', default: 'Prime Locations' },
            developer_about_feature_4: { type: 'text', label: 'Feature 4', default: 'Full Amenities' },
            developer_about_feature_5: { type: 'text', label: 'Feature 5', default: 'Entertainment Areas' },
            developer_about_feature_6: { type: 'text', label: 'Feature 6', default: 'Private Parking' }
          }
        },
        reviews: {
          label: 'Reviews Section',
          required: false,
          order: 6,
          fields: {
            developer_reviews_enabled: { type: 'toggle', label: 'Enable Section', default: false },
            developer_reviews_title: { type: 'text', label: 'Title', default: 'What Our Guests Say' },
            developer_reviews_subtitle: { type: 'text', label: 'Subtitle' },
            developer_reviews_bg: { type: 'color', label: 'Background Color', default: '#0f172a' },
            developer_reviews_style: { type: 'select', label: 'Display Style', options: ['slider', 'grid', 'badges', 'summary'], default: 'slider' }
          }
        },
        cta: {
          label: 'Call to Action',
          required: false,
          order: 7,
          fields: {
            developer_cta_enabled: { type: 'toggle', label: 'Enable Section', default: true },
            developer_cta_title: { type: 'text', label: 'Title', default: 'Ready to Book Your Stay?' },
            developer_cta_text: { type: 'textarea', label: 'Text' },
            developer_cta_background: { type: 'color', label: 'Background Color', default: '#2563eb' },
            developer_cta_btn_text: { type: 'text', label: 'Button Text', default: 'Browse Properties' },
            developer_cta_btn_url: { type: 'text', label: 'Button URL', default: '/book-now/' }
          }
        },
        footer: {
          label: 'Footer',
          required: true,
          order: 8,
          fields: {
            developer_footer_bg: { type: 'color', label: 'Background Color', default: '#0f172a' },
            developer_footer_text: { type: 'color', label: 'Text Color', default: '#e2e8f0' },
            developer_footer_tagline: { type: 'text', label: 'Tagline', default: 'Your perfect vacation awaits.' },
            developer_footer_copyright: { type: 'text', label: 'Copyright Text' },
            developer_footer_email: { type: 'text', label: 'Contact Email' },
            developer_footer_phone: { type: 'text', label: 'Contact Phone' },
            developer_footer_address: { type: 'textarea', label: 'Address' }
          }
        },
        colors: {
          label: 'Colors & Fonts',
          required: false,
          order: 9,
          fields: {
            developer_primary_color: { type: 'color', label: 'Primary Color', default: '#2563eb' },
            developer_secondary_color: { type: 'color', label: 'Secondary Color', default: '#0f172a' },
            developer_accent_color: { type: 'color', label: 'Accent Color', default: '#f59e0b' },
            developer_body_font: { type: 'select', label: 'Body Font', options: ['Inter', 'Open Sans', 'Roboto', 'Lato', 'Poppins'], default: 'Inter' },
            developer_heading_font: { type: 'select', label: 'Heading Font', options: ['Inter', 'Playfair Display', 'Montserrat', 'Roboto Slab'], default: 'Inter' }
          }
        }
      }
    };
    
    await pool.query(`
      INSERT INTO theme_registry (code, name, description, version, schema, sections, is_active, min_tier)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (code) DO UPDATE SET
        name = EXCLUDED.name,
        schema = EXCLUDED.schema,
        sections = EXCLUDED.sections,
        updated_at = NOW()
    `, [
      'developer',
      'GAS Developer Theme',
      'Clean, modern theme for vacation rentals with full customization options',
      '1.0.0',
      JSON.stringify(developerThemeSchema),
      JSON.stringify(developerThemeSchema.sections),
      true,
      'starter'
    ]);
    console.log('  ‚úì Developer theme schema added to registry');
    
    // 8. Add Light and Dark template variations
    const lightDefaults = {
      header_bg_color: '#ffffff',
      header_text_color: '#1e293b',
      header_logo_color: '#0f172a',
      header_cta_bg: '#2563eb',
      primary_color: '#2563eb',
      secondary_color: '#0f172a',
      bg_color: '#ffffff',
      bg_alt_color: '#f8fafc',
      text_color: '#1e293b',
      footer_bg: '#0f172a',
      footer_text: '#ffffff'
    };
    
    const darkDefaults = {
      header_bg_color: '#0f172a',
      header_text_color: '#e2e8f0',
      header_logo_color: '#f8fafc',
      header_cta_bg: '#6366f1',
      primary_color: '#6366f1',
      secondary_color: '#f8fafc',
      bg_color: '#0f172a',
      bg_alt_color: '#1e293b',
      text_color: '#e2e8f0',
      footer_bg: '#020617',
      footer_text: '#e2e8f0'
    };
    
    // Insert Light template
    await pool.query(`
      INSERT INTO website_templates (name, slug, description, preview_image, template_type, tier, is_active, features)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (slug) DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        features = EXCLUDED.features,
        is_active = EXCLUDED.is_active
    `, [
      'Developer Light',
      'developer-light',
      'Clean, bright theme with white backgrounds. Professional and modern design perfect for luxury properties.',
      '/images/templates/developer-light-preview.jpg',
      'theme',
      'starter',
      true,
      JSON.stringify({ defaults: lightDefaults, wp_theme: 'developer', variant: 'light' })
    ]);
    
    // Insert Dark template
    await pool.query(`
      INSERT INTO website_templates (name, slug, description, preview_image, template_type, tier, is_active, features)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (slug) DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        features = EXCLUDED.features,
        is_active = EXCLUDED.is_active
    `, [
      'Developer Dark',
      'developer-dark',
      'Elegant dark theme with grey/black backgrounds. Sophisticated look ideal for boutique and premium properties.',
      '/images/templates/developer-dark-preview.jpg',
      'theme',
      'starter',
      true,
      JSON.stringify({ defaults: darkDefaults, wp_theme: 'developer-dark', variant: 'dark' })
    ]);
    console.log('  ‚úì Light and Dark template variations added');
    
    console.log('‚úÖ Website Builder schema setup complete');
    res.json({ 
      success: true, 
      message: 'Website Builder schema setup complete',
      tables_enhanced: ['websites', 'website_templates', 'website_settings', 'website_pages'],
      tables_created: ['theme_registry', 'website_sync_log']
    });
    
  } catch (error) {
    console.error('Setup website builder error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get available website templates
app.get('/api/templates', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, name, slug, description, preview_image, template_type, tier, is_active, features
      FROM website_templates
      WHERE is_active = true
      ORDER BY name
    `);
    
    // Parse features JSON for each template
    const templates = result.rows.map(t => ({
      ...t,
      features: typeof t.features === 'string' ? JSON.parse(t.features) : t.features,
      defaults: t.features?.defaults || {}
    }));
    
    res.json({ success: true, templates });
  } catch (error) {
    console.error('Get templates error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get single template with full details
app.get('/api/templates/:slug', async (req, res) => {
  try {
    const { slug } = req.params;
    const result = await pool.query(`
      SELECT * FROM website_templates WHERE slug = $1
    `, [slug]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Template not found' });
    }
    
    const template = result.rows[0];
    template.features = typeof template.features === 'string' ? JSON.parse(template.features) : template.features;
    
    res.json({ success: true, template });
  } catch (error) {
    console.error('Get template error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Seed default templates (run once or to reset)
app.post('/api/templates/seed', async (req, res) => {
  try {
    const lightDefaults = {
      header_bg_color: '#ffffff',
      header_text_color: '#1e293b',
      header_logo_color: '#0f172a',
      header_cta_bg: '#2563eb',
      primary_color: '#2563eb',
      secondary_color: '#0f172a',
      bg_color: '#ffffff',
      bg_alt_color: '#f8fafc',
      text_color: '#1e293b',
      footer_bg: '#0f172a',
      footer_text: '#ffffff'
    };
    
    const darkDefaults = {
      header_bg_color: '#0f172a',
      header_text_color: '#e2e8f0',
      header_logo_color: '#f8fafc',
      header_cta_bg: '#6366f1',
      primary_color: '#6366f1',
      secondary_color: '#f8fafc',
      bg_color: '#0f172a',
      bg_alt_color: '#1e293b',
      text_color: '#e2e8f0',
      footer_bg: '#020617',
      footer_text: '#e2e8f0'
    };
    
    // Upsert Light template
    await pool.query(`
      INSERT INTO website_templates (name, slug, description, preview_image, template_type, tier, is_active, features)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (slug) DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        features = EXCLUDED.features,
        is_active = EXCLUDED.is_active
    `, [
      'Developer Light',
      'developer-light',
      'Clean, bright theme with white backgrounds. Professional and modern design perfect for luxury properties.',
      '/images/templates/developer-light-preview.jpg',
      'theme',
      'starter',
      true,
      JSON.stringify({ defaults: lightDefaults, wp_theme: 'developer', variant: 'light' })
    ]);
    
    // Upsert Dark template
    await pool.query(`
      INSERT INTO website_templates (name, slug, description, preview_image, template_type, tier, is_active, features)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (slug) DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        features = EXCLUDED.features,
        is_active = EXCLUDED.is_active
    `, [
      'Developer Dark',
      'developer-dark',
      'Elegant dark theme with grey/black backgrounds. Sophisticated look ideal for boutique and premium properties.',
      '/images/templates/developer-dark-preview.jpg',
      'theme',
      'starter',
      true,
      JSON.stringify({ defaults: darkDefaults, wp_theme: 'developer-dark', variant: 'dark' })
    ]);
    
    res.json({ success: true, message: 'Templates seeded successfully' });
  } catch (error) {
    console.error('Seed templates error:', error);
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/setup-billing', async (req, res) => {
  try {
    // Subscription plans (editable by admin)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_plans (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        slug VARCHAR(100) UNIQUE NOT NULL,
        description TEXT,
        price_monthly DECIMAL(10,2) NOT NULL,
        price_yearly DECIMAL(10,2),
        currency VARCHAR(3) DEFAULT 'GBP',
        max_properties INTEGER,
        features JSONB DEFAULT '[]',
        is_active BOOLEAN DEFAULT true,
        stripe_price_id_monthly VARCHAR(255),
        stripe_price_id_yearly VARCHAR(255),
        sort_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Credit packages (editable by admin)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_credit_packages (
        id SERIAL PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        credits INTEGER NOT NULL,
        price DECIMAL(10,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'GBP',
        bonus_credits INTEGER DEFAULT 0,
        is_active BOOLEAN DEFAULT true,
        stripe_price_id VARCHAR(255),
        sort_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Tasks/To-Do list
    await pool.query(`
      CREATE TABLE IF NOT EXISTS tasks (
        id SERIAL PRIMARY KEY,
        title VARCHAR(255) NOT NULL,
        description TEXT,
        status VARCHAR(50) DEFAULT 'todo',
        priority VARCHAR(20) DEFAULT 'medium',
        category VARCHAR(100),
        account_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        created_by INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        assigned_to INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        due_date DATE,
        completed_at TIMESTAMP,
        sort_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Extras/services that cost credits
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_extras (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(255) UNIQUE NOT NULL,
        description TEXT,
        credit_cost INTEGER NOT NULL,
        category VARCHAR(100),
        icon VARCHAR(50),
        is_active BOOLEAN DEFAULT true,
        requires_booking BOOLEAN DEFAULT false,
        sort_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Account subscriptions
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_subscriptions (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        plan_id INTEGER REFERENCES billing_plans(id),
        status VARCHAR(50) DEFAULT 'active',
        billing_cycle VARCHAR(20) DEFAULT 'monthly',
        stripe_subscription_id VARCHAR(255),
        stripe_customer_id VARCHAR(255),
        current_period_start TIMESTAMP,
        current_period_end TIMESTAMP,
        cancelled_at TIMESTAMP,
        feature_overrides JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Add feature_overrides column if missing (for existing tables)
    await pool.query(`
      ALTER TABLE billing_subscriptions ADD COLUMN IF NOT EXISTS feature_overrides JSONB DEFAULT '{}'
    `);
    
    // Account credit balance
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_credits (
        id SERIAL PRIMARY KEY,
        account_id INTEGER UNIQUE REFERENCES accounts(id) ON DELETE CASCADE,
        balance INTEGER DEFAULT 0,
        lifetime_purchased INTEGER DEFAULT 0,
        lifetime_spent INTEGER DEFAULT 0,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Credit transactions log
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_credit_transactions (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        amount INTEGER NOT NULL,
        type VARCHAR(50) NOT NULL,
        description TEXT,
        reference_type VARCHAR(50),
        reference_id INTEGER,
        balance_after INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Payment history
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_payments (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        amount DECIMAL(10,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'GBP',
        type VARCHAR(50) NOT NULL,
        status VARCHAR(50) DEFAULT 'completed',
        description TEXT,
        stripe_payment_id VARCHAR(255),
        stripe_invoice_id VARCHAR(255),
        metadata JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Insert default plans if empty
    const planCheck = await pool.query('SELECT COUNT(*) FROM billing_plans');
    if (parseInt(planCheck.rows[0].count) === 0) {
      await pool.query(`
        INSERT INTO billing_plans (name, slug, description, price_monthly, price_yearly, max_properties, features, sort_order) VALUES
        ('Starter', 'starter', 'Perfect for single properties', 29.00, 290.00, 1, '{"properties": 1, "websites": 1, "booking_plugin": true, "theme": "basic", "blog_module": false, "attractions_module": false, "reviews_widget": false, "support": "email", "free_trial": false, "white_label": false, "features_list": ["1 property", "1 website", "Booking plugin", "Basic theme", "Email support"]}', 1),
        ('Professional', 'professional', 'For growing businesses', 59.00, 590.00, 10, '{"properties": 10, "websites": 1, "booking_plugin": true, "theme": "standard", "blog_module": true, "attractions_module": false, "reviews_widget": false, "support": "email", "free_trial": true, "white_label": false, "features_list": ["Up to 10 properties", "1 website", "Booking plugin", "All standard themes", "Blog module", "Email support", "14-day free trial"]}', 2),
        ('Business', 'business', 'For established operators', 99.00, 990.00, 50, '{"properties": 50, "websites": 1, "booking_plugin": true, "theme": "standard", "blog_module": true, "attractions_module": true, "reviews_widget": false, "support": "priority", "free_trial": true, "white_label": false, "features_list": ["Up to 50 properties", "1 website", "Booking plugin", "All standard themes", "Blog module", "Attractions module", "Priority support", "14-day free trial"]}', 3),
        ('Enterprise', 'enterprise', 'Unlimited scale', 199.00, 1990.00, NULL, '{"properties": null, "websites": 10, "booking_plugin": true, "theme": "premium", "blog_module": true, "attractions_module": true, "reviews_widget": true, "support": "dedicated", "free_trial": true, "white_label": true, "features_list": ["Unlimited properties", "Up to 10 websites", "Booking plugin", "All themes including premium", "Blog module", "Attractions module", "Reviews widget", "Dedicated support", "White-label option", "14-day free trial"]}', 4)
      `);
    }
    
    // Insert default credit packages if empty
    const creditCheck = await pool.query('SELECT COUNT(*) FROM billing_credit_packages');
    if (parseInt(creditCheck.rows[0].count) === 0) {
      await pool.query(`
        INSERT INTO billing_credit_packages (name, credits, price, bonus_credits, sort_order) VALUES
        ('10 Credits', 10, 10.00, 0, 1),
        ('25 Credits', 25, 20.00, 0, 2),
        ('50 Credits', 50, 40.00, 0, 3),
        ('100 Credits', 100, 75.00, 0, 4)
      `);
    }
    
    // Insert default extras if empty
    const extrasCheck = await pool.query('SELECT COUNT(*) FROM billing_extras');
    if (parseInt(extrasCheck.rows[0].count) === 0) {
      await pool.query(`
        INSERT INTO billing_extras (name, slug, description, credit_cost, category, icon, sort_order) VALUES
        ('Additional Website', 'additional-website', 'Add another website to your account', 20, 'Websites', 'üåê', 1),
        ('Reviews Widget', 'reviews-widget', 'Display reviews from TripAdvisor, Booking.com, Google', 15, 'Modules', '‚≠ê', 2),
        ('Attractions Module', 'attractions-module', 'Showcase nearby attractions and things to do', 10, 'Modules', 'üìç', 3),
        ('Premium Theme', 'premium-theme', 'Access to premium website design', 25, 'Themes', '‚ú®', 4),
        ('Setup Assistance Call (30 min)', 'setup-call', 'One-on-one video call to help you get started', 5, 'Support', 'üìû', 5),
        ('We Setup For You', 'full-setup', 'We configure everything for you', 20, 'Support', 'üé®', 6),
        ('Custom Integration', 'custom-integration', 'Custom channel manager or API integration', 30, 'Development', 'üîß', 7),
        ('Training Session (1 hour)', 'training', 'Personalised training session', 10, 'Support', 'üìö', 8)
      `);
    }
    
    // Deliverables tracking - what templates/plugins have been delivered to each account
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_deliverables (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        deliverable_type VARCHAR(50) NOT NULL,
        deliverable_id INTEGER,
        deliverable_name VARCHAR(255) NOT NULL,
        delivered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        delivered_by INTEGER,
        source VARCHAR(50) DEFAULT 'subscription',
        notes TEXT,
        UNIQUE(account_id, deliverable_type, deliverable_id)
      )
    `);
    
    // Available templates/themes catalog
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_templates (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(255) UNIQUE NOT NULL,
        description TEXT,
        preview_image VARCHAR(500),
        template_type VARCHAR(50) DEFAULT 'theme',
        tier VARCHAR(50) DEFAULT 'basic',
        download_url VARCHAR(500),
        version VARCHAR(20) DEFAULT '1.0.0',
        is_active BOOLEAN DEFAULT true,
        features JSONB DEFAULT '[]',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Insert default templates if empty
    const templateCheck = await pool.query('SELECT COUNT(*) FROM website_templates');
    if (parseInt(templateCheck.rows[0].count) === 0) {
      await pool.query(`
        INSERT INTO website_templates (name, slug, description, template_type, tier, version) VALUES
        ('Developer Theme', 'developer-theme', 'Clean developer-focused theme with full customization', 'theme', 'basic', '2.0.0'),
        ('GAS Booking Plugin', 'gas-booking-plugin', 'Core booking system plugin', 'plugin', 'basic', '4.0.0'),
        ('GAS Blog Plugin', 'gas-blog-plugin', 'Blog functionality with SEO', 'plugin', 'professional', '1.0.0'),
        ('GAS Attractions Plugin', 'gas-attractions-plugin', 'Nearby attractions showcase', 'plugin', 'business', '1.0.0'),
        ('GAS Reviews Plugin', 'gas-reviews-plugin', 'Reviews from multiple sources', 'plugin', 'enterprise', '1.0.0'),
        ('GAS Properties Plugin', 'gas-properties-plugin', 'Multi-property portfolio display', 'plugin', 'professional', '1.0.0')
      `);
    }
    
    // InstaWP/WordPress hosting settings (global platform settings)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS instawp_settings (
        id SERIAL PRIMARY KEY,
        api_url VARCHAR(500) DEFAULT 'https://sites.gas.travel/gas-api.php',
        api_key VARCHAR(500),
        default_template VARCHAR(255),
        templates JSONB DEFAULT '{}',
        webhook_secret VARCHAR(255),
        is_enabled BOOLEAN DEFAULT false,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Account websites (InstaWP sites created for accounts)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS account_websites (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        instawp_site_id VARCHAR(255),
        site_name VARCHAR(255),
        site_url VARCHAR(500),
        admin_url VARCHAR(500),
        template_used VARCHAR(255),
        custom_domain VARCHAR(255),
        status VARCHAR(50) DEFAULT 'creating',
        instawp_data JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(account_id)
      )
    `);
    
    // ============================================================
    // MULTI-WEBSITE ARCHITECTURE
    // ============================================================
    
    // Add code column to website_templates if it doesn't exist
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS code VARCHAR(50)`);
    await pool.query(`UPDATE website_templates SET code = slug WHERE code IS NULL`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS category VARCHAR(50)`);
    await pool.query(`ALTER TABLE website_templates ADD COLUMN IF NOT EXISTS sections JSONB DEFAULT '{}'`);
    
    // Websites (independent entities - many per account)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS websites (
        id SERIAL PRIMARY KEY,
        public_id VARCHAR(20) UNIQUE NOT NULL,
        owner_type VARCHAR(20) NOT NULL DEFAULT 'account',
        owner_id INTEGER NOT NULL,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(100),
        template_code VARCHAR(50),
        site_url VARCHAR(500),
        admin_url VARCHAR(500),
        custom_domain VARCHAR(255),
        instawp_site_id VARCHAR(255),
        instawp_data JSONB DEFAULT '{}',
        website_type VARCHAR(30) DEFAULT 'portfolio',
        status VARCHAR(20) DEFAULT 'draft',
        default_currency VARCHAR(3) DEFAULT 'GBP',
        timezone VARCHAR(50) DEFAULT 'Europe/London',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_websites_owner ON websites(owner_type, owner_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_websites_status ON websites(status)`);
    
    // Website Units (which units are on which website - many-to-many)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_units (
        id SERIAL PRIMARY KEY,
        website_id INTEGER NOT NULL REFERENCES websites(id) ON DELETE CASCADE,
        unit_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        display_order INTEGER DEFAULT 0,
        is_featured BOOLEAN DEFAULT FALSE,
        custom_name VARCHAR(255),
        custom_description TEXT,
        custom_price_modifier DECIMAL(5,2),
        is_active BOOLEAN DEFAULT TRUE,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(website_id, unit_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_units_website ON website_units(website_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_units_unit ON website_units(unit_id)`);
    
    // Website Pages (custom pages per website)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_pages (
        id SERIAL PRIMARY KEY,
        website_id INTEGER NOT NULL REFERENCES websites(id) ON DELETE CASCADE,
        page_type VARCHAR(50) NOT NULL,
        slug VARCHAR(100),
        title VARCHAR(255),
        content JSONB DEFAULT '{}',
        is_published BOOLEAN DEFAULT FALSE,
        display_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Add migrated_to_website_id column to deployed_sites for migration tracking
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS migrated_to_website_id INTEGER`);
    
    // Property payment settings
    await pool.query(`
      CREATE TABLE IF NOT EXISTS property_payment_settings (
        id SERIAL PRIMARY KEY,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE UNIQUE,
        payment_enabled BOOLEAN DEFAULT true,
        deposit_type VARCHAR(20) DEFAULT 'percentage',
        deposit_amount DECIMAL(10,2) DEFAULT 25,
        balance_due_days INTEGER DEFAULT 14,
        stripe_account_id VARCHAR(255),
        stripe_connected BOOLEAN DEFAULT false,
        paypal_email VARCHAR(255),
        bank_details JSONB DEFAULT '{}',
        accepted_methods JSONB DEFAULT '["card"]',
        currency VARCHAR(3) DEFAULT 'GBP',
        cancellation_policy TEXT,
        refund_policy JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Guest payments (transactions from booking site)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS guest_payments (
        id SERIAL PRIMARY KEY,
        booking_id INTEGER REFERENCES bookings(id) ON DELETE SET NULL,
        property_id INTEGER REFERENCES properties(id) ON DELETE SET NULL,
        account_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        guest_email VARCHAR(255),
        guest_name VARCHAR(255),
        amount DECIMAL(10,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'GBP',
        payment_type VARCHAR(50) DEFAULT 'deposit',
        payment_method VARCHAR(50),
        status VARCHAR(50) DEFAULT 'pending',
        stripe_payment_id VARCHAR(255),
        stripe_transfer_id VARCHAR(255),
        paypal_transaction_id VARCHAR(255),
        metadata JSONB DEFAULT '{}',
        paid_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // NEW: Billing Products
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_products (
        id SERIAL PRIMARY KEY,
        code VARCHAR(50) NOT NULL UNIQUE,
        name VARCHAR(100) NOT NULL,
        description TEXT,
        category VARCHAR(50) DEFAULT 'general',
        price_monthly DECIMAL(10,2) DEFAULT 0,
        price_yearly DECIMAL(10,2) DEFAULT 0,
        currency VARCHAR(3) DEFAULT 'GBP',
        feature_flags JSONB DEFAULT '[]',
        is_active BOOLEAN DEFAULT TRUE,
        is_public BOOLEAN DEFAULT TRUE,
        display_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // NEW: Billing Add-ons
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_addons (
        id SERIAL PRIMARY KEY,
        code VARCHAR(50) NOT NULL UNIQUE,
        name VARCHAR(100) NOT NULL,
        description TEXT,
        price_monthly DECIMAL(10,2) DEFAULT 0,
        price_yearly DECIMAL(10,2) DEFAULT 0,
        currency VARCHAR(3) DEFAULT 'GBP',
        feature_flags JSONB DEFAULT '[]',
        extra_properties INTEGER DEFAULT 0,
        extra_rooms INTEGER DEFAULT 0,
        extra_users INTEGER DEFAULT 0,
        requires_plan_codes JSONB DEFAULT '[]',
        is_active BOOLEAN DEFAULT TRUE,
        is_public BOOLEAN DEFAULT TRUE,
        display_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // NEW: Affiliate Tiers
    await pool.query(`
      CREATE TABLE IF NOT EXISTS affiliate_tiers (
        id SERIAL PRIMARY KEY,
        code VARCHAR(20) NOT NULL UNIQUE,
        name VARCHAR(50) NOT NULL,
        commission_rate DECIMAL(5,2) NOT NULL,
        min_referrals INTEGER DEFAULT 0,
        min_revenue DECIMAL(10,2) DEFAULT 0,
        color VARCHAR(7) DEFAULT '#CD7F32',
        icon VARCHAR(10) DEFAULT 'ü•â',
        display_order INTEGER DEFAULT 0,
        is_active BOOLEAN DEFAULT TRUE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // NEW: Affiliates
    await pool.query(`
      CREATE TABLE IF NOT EXISTS affiliates (
        id SERIAL PRIMARY KEY,
        account_id INTEGER NOT NULL UNIQUE,
        referral_code VARCHAR(20) NOT NULL UNIQUE,
        referral_link VARCHAR(255),
        tier_id INTEGER REFERENCES affiliate_tiers(id),
        tier_code VARCHAR(20) DEFAULT 'bronze',
        total_referrals INTEGER DEFAULT 0,
        active_referrals INTEGER DEFAULT 0,
        lifetime_earnings DECIMAL(10,2) DEFAULT 0,
        payout_method VARCHAR(20) DEFAULT 'airwallex',
        payout_details JSONB DEFAULT '{}',
        min_payout DECIMAL(10,2) DEFAULT 50,
        is_active BOOLEAN DEFAULT TRUE,
        approved_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // NEW: Affiliate Referrals
    await pool.query(`
      CREATE TABLE IF NOT EXISTS affiliate_referrals (
        id SERIAL PRIMARY KEY,
        affiliate_id INTEGER NOT NULL REFERENCES affiliates(id),
        referred_account_id INTEGER NOT NULL UNIQUE,
        status VARCHAR(20) DEFAULT 'pending',
        signed_up_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        converted_at TIMESTAMP,
        churned_at TIMESTAMP,
        referral_source VARCHAR(50)
      )
    `);
    
    // NEW: Affiliate Commissions
    await pool.query(`
      CREATE TABLE IF NOT EXISTS affiliate_commissions (
        id SERIAL PRIMARY KEY,
        affiliate_id INTEGER NOT NULL REFERENCES affiliates(id),
        referral_id INTEGER REFERENCES affiliate_referrals(id),
        source_type VARCHAR(20) NOT NULL,
        source_id INTEGER,
        gross_amount DECIMAL(10,2) NOT NULL,
        commission_rate DECIMAL(5,2) NOT NULL,
        commission_amount DECIMAL(10,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'GBP',
        status VARCHAR(20) DEFAULT 'pending',
        payout_id INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // NEW: Affiliate Payouts
    await pool.query(`
      CREATE TABLE IF NOT EXISTS affiliate_payouts (
        id SERIAL PRIMARY KEY,
        affiliate_id INTEGER NOT NULL REFERENCES affiliates(id),
        amount DECIMAL(10,2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'GBP',
        status VARCHAR(20) DEFAULT 'pending',
        payout_method VARCHAR(20),
        provider_payout_id VARCHAR(100),
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        processed_at TIMESTAMP,
        paid_at TIMESTAMP,
        notes TEXT
      )
    `);
    
    // Seed Products
    await pool.query(`
      INSERT INTO billing_products (code, name, description, category, price_monthly, price_yearly, display_order) VALUES
      ('wp-theme-developer', 'Developer Theme', 'Professional WordPress theme', 'template', 15, 150, 1),
      ('wp-plugin-booking', 'WP Booking Plugin', 'Booking widget for WordPress', 'plugin', 10, 100, 2),
      ('app-blogger', 'Smart Blogger', 'AI-powered blog content', 'app', 9, 90, 3),
      ('app-attractions', 'Attractions & SEO', 'Local attractions and SEO', 'app', 9, 90, 4),
      ('app-marketing', 'Marketing Tools', 'Social media campaigns', 'app', 12, 120, 5),
      ('portal-builder', 'Portal Builder', 'Create niche travel portals', 'template', 29, 290, 6)
      ON CONFLICT (code) DO NOTHING
    `);
    
    // Seed Add-ons
    await pool.query(`
      INSERT INTO billing_addons (code, name, description, price_monthly, extra_properties, display_order) VALUES
      ('extra-property', 'Extra Property', 'Add one additional property', 5, 1, 1),
      ('extra-5-properties', 'Property Pack', 'Add 5 additional properties', 20, 5, 2),
      ('priority-support', 'Priority Support', '24/7 priority support', 15, 0, 3)
      ON CONFLICT (code) DO NOTHING
    `);
    
    // Seed Affiliate Tiers
    await pool.query(`
      INSERT INTO affiliate_tiers (code, name, commission_rate, min_referrals, min_revenue, color, icon, display_order) VALUES
      ('bronze', 'Bronze', 5.00, 0, 0, '#CD7F32', 'ü•â', 1),
      ('silver', 'Silver', 10.00, 5, 0, '#C0C0C0', 'ü•à', 2),
      ('gold', 'Gold', 15.00, 10, 500, '#FFD700', 'ü•á', 3)
      ON CONFLICT (code) DO NOTHING
    `);
    
    res.json({ success: true, message: 'Billing tables created with default data!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// BILLING PLANS ADMIN (Master Admin Only)
// =====================================================

// Get all plans
app.get('/api/admin/billing/plans', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_plans ORDER BY sort_order, price_monthly');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/update plan
app.post('/api/admin/billing/plans', async (req, res) => {
  try {
    const { id, name, slug, description, price_monthly, price_yearly, currency, max_properties, features, is_active, sort_order } = req.body;
    
    if (id) {
      const result = await pool.query(`
        UPDATE billing_plans SET 
          name = $1, slug = $2, description = $3, price_monthly = $4, price_yearly = $5,
          currency = $6, max_properties = $7, features = $8, is_active = $9, sort_order = $10
        WHERE id = $11 RETURNING *
      `, [name, slug, description, price_monthly, price_yearly, currency || 'GBP', max_properties, JSON.stringify(features || []), is_active !== false, sort_order || 0, id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      const result = await pool.query(`
        INSERT INTO billing_plans (name, slug, description, price_monthly, price_yearly, currency, max_properties, features, is_active, sort_order)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *
      `, [name, slug, description, price_monthly, price_yearly, currency || 'GBP', max_properties, JSON.stringify(features || []), is_active !== false, sort_order || 0]);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete plan
app.delete('/api/admin/billing/plans/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM billing_plans WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// BILLING PRODUCTS ADMIN
// =====================================================

// Get all products
app.get('/api/admin/billing/products', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_products ORDER BY display_order, name');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create product
app.post('/api/admin/billing/products', async (req, res) => {
  try {
    const { code, name, description, category, price_monthly, price_yearly, is_active } = req.body;
    
    const result = await pool.query(`
      INSERT INTO billing_products (code, name, description, category, price_monthly, price_yearly, is_active)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *
    `, [code, name, description, category || 'general', price_monthly || 0, price_yearly || 0, is_active !== false]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update product
app.put('/api/admin/billing/products/:id', async (req, res) => {
  try {
    const { code, name, description, category, price_monthly, price_yearly, is_active } = req.body;
    
    const result = await pool.query(`
      UPDATE billing_products 
      SET code = $1, name = $2, description = $3, category = $4, 
          price_monthly = $5, price_yearly = $6, is_active = $7,
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $8
      RETURNING *
    `, [code, name, description, category || 'general', price_monthly || 0, price_yearly || 0, is_active !== false, req.params.id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete product
app.delete('/api/admin/billing/products/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM billing_products WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// BILLING ADD-ONS ADMIN
// =====================================================

// Get all addons
app.get('/api/admin/billing/addons', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_addons ORDER BY display_order, name');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create addon
app.post('/api/admin/billing/addons', async (req, res) => {
  try {
    const { code, name, description, price_monthly, extra_properties, is_active } = req.body;
    
    const result = await pool.query(`
      INSERT INTO billing_addons (code, name, description, price_monthly, extra_properties, is_active)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING *
    `, [code, name, description, price_monthly || 0, extra_properties || 0, is_active !== false]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update addon
app.put('/api/admin/billing/addons/:id', async (req, res) => {
  try {
    const { code, name, description, price_monthly, extra_properties, is_active } = req.body;
    
    const result = await pool.query(`
      UPDATE billing_addons 
      SET code = $1, name = $2, description = $3, price_monthly = $4, 
          extra_properties = $5, is_active = $6, updated_at = CURRENT_TIMESTAMP
      WHERE id = $7
      RETURNING *
    `, [code, name, description, price_monthly || 0, extra_properties || 0, is_active !== false, req.params.id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete addon
app.delete('/api/admin/billing/addons/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM billing_addons WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// SUBSCRIPTIONS ADMIN
// =====================================================

// Get all subscriptions with account info
app.get('/api/admin/billing/subscriptions', async (req, res) => {
  try {
    const { plan, status } = req.query;
    
    let query = `
      SELECT s.*, a.name as account_name, 
             (SELECT COUNT(*) FROM billing_subscription_addons WHERE subscription_id = s.id) as addon_count,
             COALESCE(s.locked_price, p.price_monthly) as mrr
      FROM billing_subscriptions s
      LEFT JOIN accounts a ON a.id = s.account_id
      LEFT JOIN billing_plans p ON p.id = s.plan_id
      WHERE 1=1
    `;
    const params = [];
    
    if (plan) {
      params.push(plan);
      query += ` AND s.plan_code = $${params.length}`;
    }
    if (status) {
      params.push(status);
      query += ` AND s.status = $${params.length}`;
    }
    
    query += ' ORDER BY s.created_at DESC';
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// WEBSITE AUTO-DEPLOY SYSTEM
// =====================================================

const VPS_DEPLOY_URL = 'https://sites.gas.travel/gas-deploy.php';
const VPS_DEPLOY_API_KEY = process.env.VPS_DEPLOY_API_KEY || 'gas-deploy-2024-secure-key';

// Create deployed_sites table
app.get('/api/setup-deploy', async (req, res) => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS deployed_sites (
        id SERIAL PRIMARY KEY,
        property_id INTEGER REFERENCES properties(id) ON DELETE SET NULL,
        property_ids JSONB DEFAULT '[]',
        room_ids JSONB DEFAULT '[]',
        account_id INTEGER REFERENCES accounts(id) ON DELETE SET NULL,
        blog_id INTEGER,
        site_url VARCHAR(255),
        admin_url VARCHAR(255),
        slug VARCHAR(100),
        site_name VARCHAR(255),
        status VARCHAR(50) DEFAULT 'pending',
        wp_username VARCHAR(100),
        wp_password_temp VARCHAR(100),
        deployed_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Add columns if they don't exist (for existing tables)
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS property_ids JSONB DEFAULT '[]'`);
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS room_ids JSONB DEFAULT '[]'`);
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS site_name VARCHAR(255)`);
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS custom_domain VARCHAR(255)`);
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS template VARCHAR(50) DEFAULT 'developer-light'`);
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS ga4_measurement_id VARCHAR(50)`);
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS ga4_property_id VARCHAR(100)`);
    
    // Pricing tier support - allows different pricing for different client types (corporate, wholesale, etc.)
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS pricing_tier VARCHAR(50) DEFAULT 'standard'`);
    await pool.query(`ALTER TABLE offers ADD COLUMN IF NOT EXISTS pricing_tier VARCHAR(50) DEFAULT 'standard'`);
    
    // Add website_url column to bookable_units if it doesn't exist
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS website_url VARCHAR(255)`);
    
    res.json({ success: true, message: 'Deployed sites table created/updated with room_ids support' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER API SYSTEM - For Channel Manager Integration
// =====================================================

// Setup partner tables
app.get('/api/setup-partners', async (req, res) => {
  try {
    // Partners table - companies like Elevate that integrate with GAS
    await pool.query(`
      CREATE TABLE IF NOT EXISTS partners (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        code VARCHAR(50) UNIQUE NOT NULL,
        contact_name VARCHAR(255),
        contact_email VARCHAR(255),
        api_key VARCHAR(64) UNIQUE,
        api_secret VARCHAR(64),
        webhook_url VARCHAR(500),
        webhook_secret VARCHAR(64),
        permissions JSONB DEFAULT '["sync:read", "sync:write", "website:read", "website:write"]',
        rate_limit_per_minute INTEGER DEFAULT 60,
        is_active BOOLEAN DEFAULT true,
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Partner API key requests - pending approvals
    await pool.query(`
      CREATE TABLE IF NOT EXISTS partner_key_requests (
        id SERIAL PRIMARY KEY,
        company_name VARCHAR(255) NOT NULL,
        contact_name VARCHAR(255) NOT NULL,
        contact_email VARCHAR(255) NOT NULL,
        website VARCHAR(500),
        use_case TEXT,
        status VARCHAR(20) DEFAULT 'pending',
        reviewed_by INTEGER,
        reviewed_at TIMESTAMP,
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    // Link accounts to partners
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS partner_id INTEGER REFERENCES partners(id)`);
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS partner_external_id VARCHAR(255)`);
    
    // Partner API request logs
    await pool.query(`
      CREATE TABLE IF NOT EXISTS partner_api_logs (
        id SERIAL PRIMARY KEY,
        partner_id INTEGER REFERENCES partners(id),
        endpoint VARCHAR(255),
        method VARCHAR(10),
        status_code INTEGER,
        request_body JSONB,
        response_time_ms INTEGER,
        error_message TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    res.json({ success: true, message: 'Partner tables created' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Partner authentication middleware
async function authenticatePartner(req, res, next) {
  const apiKey = req.headers['x-partner-key'];
  
  if (!apiKey) {
    return res.status(401).json({ 
      success: false, 
      error: 'Partner API key required. Include X-Partner-Key header.' 
    });
  }
  
  try {
    const result = await pool.query(`
      SELECT * FROM partners WHERE api_key = $1 AND is_active = true
    `, [apiKey]);
    
    if (result.rows.length === 0) {
      return res.status(401).json({ success: false, error: 'Invalid or inactive partner API key' });
    }
    
    req.partner = result.rows[0];
    
    // Log the request (async, don't wait)
    const startTime = Date.now();
    res.on('finish', () => {
      pool.query(`
        INSERT INTO partner_api_logs (partner_id, endpoint, method, status_code, response_time_ms)
        VALUES ($1, $2, $3, $4, $5)
      `, [req.partner.id, req.path, req.method, res.statusCode, Date.now() - startTime]).catch(() => {});
    });
    
    next();
  } catch (error) {
    console.error('Partner auth error:', error);
    res.status(500).json({ success: false, error: 'Authentication error' });
  }
}

// Check partner permission
function hasPartnerPermission(req, permission) {
  if (!req.partner || !req.partner.permissions) return false;
  const perms = typeof req.partner.permissions === 'string' 
    ? JSON.parse(req.partner.permissions) 
    : req.partner.permissions;
  return perms.includes(permission) || perms.includes('*');
}

// =====================================================
// PARTNER KEY REQUEST ENDPOINTS
// =====================================================

// Request a partner API key (public endpoint)
app.post('/api/partner/request-key', async (req, res) => {
  try {
    const { company_name, contact_name, contact_email, website, use_case } = req.body;
    
    if (!company_name || !contact_name || !contact_email) {
      return res.json({ success: false, error: 'Company name, contact name, and email are required' });
    }
    
    // Check for existing pending request
    const existing = await pool.query(`
      SELECT id FROM partner_key_requests 
      WHERE contact_email = $1 AND status = 'pending'
    `, [contact_email]);
    
    if (existing.rows.length > 0) {
      return res.json({ success: false, error: 'A pending request already exists for this email' });
    }
    
    const result = await pool.query(`
      INSERT INTO partner_key_requests (company_name, contact_name, contact_email, website, use_case)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *
    `, [company_name, contact_name, contact_email, website, use_case]);
    
    res.json({ 
      success: true, 
      message: 'Request submitted. We will review and contact you within 2 business days.',
      request_id: result.rows[0].id
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Admin: List partner key requests
app.get('/api/admin/partner-requests', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM partner_key_requests ORDER BY created_at DESC
    `);
    res.json({ success: true, requests: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Admin: Approve partner request and create partner
app.post('/api/admin/partner-requests/:id/approve', async (req, res) => {
  try {
    const { id } = req.params;
    const { permissions } = req.body;
    
    // Get the request
    const reqResult = await pool.query('SELECT * FROM partner_key_requests WHERE id = $1', [id]);
    if (reqResult.rows.length === 0) {
      return res.json({ success: false, error: 'Request not found' });
    }
    const request = reqResult.rows[0];
    
    // Generate API key and secret
    const crypto = require('crypto');
    const apiKey = 'gp_' + crypto.randomBytes(32).toString('hex');
    const apiSecret = crypto.randomBytes(32).toString('hex');
    const webhookSecret = 'whsec_' + crypto.randomBytes(24).toString('hex');
    
    // Create partner code from company name
    const code = request.company_name.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 50);
    
    // Create the partner
    const partnerResult = await pool.query(`
      INSERT INTO partners (name, code, contact_name, contact_email, api_key, api_secret, webhook_secret, permissions)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *
    `, [
      request.company_name, 
      code, 
      request.contact_name, 
      request.contact_email, 
      apiKey, 
      apiSecret, 
      webhookSecret,
      permissions || ['sync:read', 'sync:write', 'website:read', 'website:write']
    ]);
    
    // Update request status
    await pool.query(`
      UPDATE partner_key_requests SET status = 'approved', reviewed_at = NOW() WHERE id = $1
    `, [id]);
    
    res.json({ 
      success: true, 
      partner: partnerResult.rows[0],
      credentials: {
        api_key: apiKey,
        api_secret: apiSecret,
        webhook_secret: webhookSecret
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Admin: List all partners
app.get('/api/admin/partners', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT p.*, 
        (SELECT COUNT(*) FROM accounts WHERE partner_id = p.id) as client_count,
        (SELECT COUNT(*) FROM partner_api_logs WHERE partner_id = p.id AND created_at > NOW() - INTERVAL '24 hours') as requests_24h
      FROM partners p
      ORDER BY p.created_at DESC
    `);
    res.json({ success: true, partners: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// SERVICE CREDENTIALS VAULT
// =====================================================

// Setup credentials table
app.get('/api/setup-credentials', async (req, res) => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS service_credentials (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        category VARCHAR(50) DEFAULT 'other',
        url TEXT,
        username VARCHAR(255),
        password TEXT,
        api_key TEXT,
        notes TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    res.json({ success: true, message: 'Credentials table created' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// List all credentials (Master Admin only)
app.get('/api/admin/credentials', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM service_credentials ORDER BY category, name
    `);
    res.json({ success: true, credentials: result.rows });
  } catch (error) {
    // Table might not exist yet
    if (error.message.includes('does not exist')) {
      res.json({ success: true, credentials: [] });
    } else {
      res.json({ success: false, error: error.message });
    }
  }
});

// Create credential
app.post('/api/admin/credentials', async (req, res) => {
  try {
    const { name, category, url, username, password, api_key, notes } = req.body;
    
    if (!name) {
      return res.json({ success: false, error: 'Name is required' });
    }
    
    const result = await pool.query(`
      INSERT INTO service_credentials (name, category, url, username, password, api_key, notes)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *
    `, [name, category || 'other', url, username, password, api_key, notes]);
    
    res.json({ success: true, credential: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update credential
app.put('/api/admin/credentials/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, category, url, username, password, api_key, notes } = req.body;
    
    if (!name) {
      return res.json({ success: false, error: 'Name is required' });
    }
    
    const result = await pool.query(`
      UPDATE service_credentials 
      SET name = $1, category = $2, url = $3, username = $4, password = $5, api_key = $6, notes = $7, updated_at = CURRENT_TIMESTAMP
      WHERE id = $8
      RETURNING *
    `, [name, category || 'other', url, username, password, api_key, notes, id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Credential not found' });
    }
    
    res.json({ success: true, credential: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete credential
app.delete('/api/admin/credentials/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      DELETE FROM service_credentials WHERE id = $1 RETURNING *
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Credential not found' });
    }
    
    res.json({ success: true, message: 'Credential deleted' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// GASSYNC PARTNER API - Calry-Compatible Schema
// =====================================================

// Create/Update Property (Calry-compatible)
app.post('/api/partner/v1/properties', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { 
      external_id,       // Partner's property ID
      account_external_id, // Partner's client ID
      name,
      description,
      address,
      city,
      country,
      postcode,
      latitude,
      longitude,
      email,
      phone,
      website,
      check_in_time,
      check_out_time,
      currency,
      timezone,
      images,           // Array of image URLs
      policies          // JSON object
    } = req.body;
    
    if (!external_id || !name) {
      return res.json({ success: false, error: 'external_id and name are required' });
    }
    
    // Find or create account for this partner's client
    let accountId = null;
    if (account_external_id) {
      const accResult = await pool.query(`
        SELECT id FROM accounts 
        WHERE partner_id = $1 AND partner_external_id = $2
      `, [req.partner.id, account_external_id]);
      
      if (accResult.rows.length > 0) {
        accountId = accResult.rows[0].id;
      } else {
        // Create account for this client
        const newAcc = await pool.query(`
          INSERT INTO accounts (name, partner_id, partner_external_id, role)
          VALUES ($1, $2, $3, 'client')
          RETURNING id
        `, [`${req.partner.name} Client - ${account_external_id}`, req.partner.id, account_external_id]);
        accountId = newAcc.rows[0].id;
      }
    }
    
    // Upsert property
    const result = await pool.query(`
      INSERT INTO properties (
        account_id, cm_property_id, name, description, 
        address, city, country, postcode,
        latitude, longitude, email, phone, website_url,
        check_in_time, check_out_time, currency, timezone
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
      ON CONFLICT (cm_property_id) WHERE cm_property_id IS NOT NULL
      DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        address = EXCLUDED.address,
        city = EXCLUDED.city,
        country = EXCLUDED.country,
        postcode = EXCLUDED.postcode,
        latitude = EXCLUDED.latitude,
        longitude = EXCLUDED.longitude,
        email = EXCLUDED.email,
        phone = EXCLUDED.phone,
        website_url = EXCLUDED.website_url,
        check_in_time = EXCLUDED.check_in_time,
        check_out_time = EXCLUDED.check_out_time,
        currency = EXCLUDED.currency,
        timezone = EXCLUDED.timezone,
        updated_at = NOW()
      RETURNING *
    `, [
      accountId, external_id, name, description,
      address, city, country, postcode,
      latitude, longitude, email, phone, website,
      check_in_time || '15:00', check_out_time || '11:00', currency || 'GBP', timezone || 'Europe/London'
    ]);
    
    res.json({ success: true, property: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Properties
app.get('/api/partner/v1/properties', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { account_external_id } = req.query;
    
    let query = `
      SELECT p.*, a.partner_external_id as account_external_id
      FROM properties p
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE a.partner_id = $1
    `;
    const params = [req.partner.id];
    
    if (account_external_id) {
      query += ` AND a.partner_external_id = $2`;
      params.push(account_external_id);
    }
    
    const result = await pool.query(query, params);
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/Update Unit (Room) - Calry-compatible
app.post('/api/partner/v1/units', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const {
      external_id,        // Partner's unit ID
      property_external_id, // Partner's property ID
      name,
      description,
      room_type,          // e.g., 'double', 'twin', 'suite'
      max_occupancy,
      default_occupancy,
      bed_configuration,  // e.g., '1 King' or '2 Singles'
      size_sqm,
      base_price,
      currency,
      amenities,          // Array of strings
      images              // Array of image URLs
    } = req.body;
    
    if (!external_id || !property_external_id || !name) {
      return res.json({ success: false, error: 'external_id, property_external_id, and name are required' });
    }
    
    // Find property by external ID
    const propResult = await pool.query(`
      SELECT p.id FROM properties p
      JOIN accounts a ON p.account_id = a.id
      WHERE p.cm_property_id = $1 AND a.partner_id = $2
    `, [property_external_id, req.partner.id]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    const propertyId = propResult.rows[0].id;
    
    // Upsert room
    const result = await pool.query(`
      INSERT INTO bookable_units (
        property_id, cm_room_id, name, description,
        room_type, max_occupancy, default_occupancy,
        bed_type, size_sqm, base_price, currency
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      ON CONFLICT (cm_room_id) WHERE cm_room_id IS NOT NULL
      DO UPDATE SET
        name = EXCLUDED.name,
        description = EXCLUDED.description,
        room_type = EXCLUDED.room_type,
        max_occupancy = EXCLUDED.max_occupancy,
        default_occupancy = EXCLUDED.default_occupancy,
        bed_type = EXCLUDED.bed_type,
        size_sqm = EXCLUDED.size_sqm,
        base_price = EXCLUDED.base_price,
        currency = EXCLUDED.currency,
        updated_at = NOW()
      RETURNING *
    `, [
      propertyId, external_id, name, description,
      room_type, max_occupancy || 2, default_occupancy || 2,
      bed_configuration, size_sqm, base_price, currency || 'GBP'
    ]);
    
    res.json({ success: true, unit: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Units
app.get('/api/partner/v1/units', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { property_external_id } = req.query;
    
    let query = `
      SELECT bu.*, p.cm_property_id as property_external_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON p.account_id = a.id
      WHERE a.partner_id = $1
    `;
    const params = [req.partner.id];
    
    if (property_external_id) {
      query += ` AND p.cm_property_id = $2`;
      params.push(property_external_id);
    }
    
    const result = await pool.query(query, params);
    res.json({ success: true, units: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update Availability - Calry-compatible
app.post('/api/partner/v1/availability', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const {
      unit_external_id,
      availability        // Array of { date, available, price, min_stay, max_stay }
    } = req.body;
    
    if (!unit_external_id || !availability || !Array.isArray(availability)) {
      return res.json({ success: false, error: 'unit_external_id and availability array required' });
    }
    
    // Find room
    const roomResult = await pool.query(`
      SELECT bu.id FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON p.account_id = a.id
      WHERE bu.cm_room_id = $1 AND a.partner_id = $2
    `, [unit_external_id, req.partner.id]);
    
    if (roomResult.rows.length === 0) {
      return res.json({ success: false, error: 'Unit not found' });
    }
    const roomId = roomResult.rows[0].id;
    
    // Upsert availability records
    for (const day of availability) {
      await pool.query(`
        INSERT INTO room_availability (room_id, date, available, price, min_stay, max_stay)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (room_id, date) DO UPDATE SET
          available = EXCLUDED.available,
          price = EXCLUDED.price,
          min_stay = EXCLUDED.min_stay,
          max_stay = EXCLUDED.max_stay,
          updated_at = NOW()
      `, [roomId, day.date, day.available !== false, day.price, day.min_stay || 1, day.max_stay]);
    }
    
    res.json({ success: true, updated: availability.length });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Availability
app.get('/api/partner/v1/availability', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { unit_external_id, start_date, end_date } = req.query;
    
    if (!unit_external_id) {
      return res.json({ success: false, error: 'unit_external_id required' });
    }
    
    const result = await pool.query(`
      SELECT ra.date, ra.available, ra.price, ra.min_stay, ra.max_stay
      FROM room_availability ra
      JOIN bookable_units bu ON ra.room_id = bu.id
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON p.account_id = a.id
      WHERE bu.cm_room_id = $1 AND a.partner_id = $2
        AND ra.date >= COALESCE($3, CURRENT_DATE)
        AND ra.date <= COALESCE($4, CURRENT_DATE + INTERVAL '365 days')
      ORDER BY ra.date
    `, [unit_external_id, req.partner.id, start_date, end_date]);
    
    res.json({ success: true, availability: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/Update Reservation - Calry-compatible
app.post('/api/partner/v1/reservations', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const {
      external_id,          // Partner's reservation ID
      unit_external_id,
      status,               // 'confirmed', 'cancelled', 'pending'
      check_in,
      check_out,
      guest_first_name,
      guest_last_name,
      guest_email,
      guest_phone,
      num_guests,
      num_adults,
      num_children,
      total_price,
      currency,
      source,               // e.g., 'booking.com', 'direct', 'airbnb'
      notes,
      special_requests
    } = req.body;
    
    if (!external_id || !unit_external_id || !check_in || !check_out) {
      return res.json({ success: false, error: 'external_id, unit_external_id, check_in, and check_out required' });
    }
    
    // Find room and property
    const roomResult = await pool.query(`
      SELECT bu.id as room_id, p.id as property_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON p.account_id = a.id
      WHERE bu.cm_room_id = $1 AND a.partner_id = $2
    `, [unit_external_id, req.partner.id]);
    
    if (roomResult.rows.length === 0) {
      return res.json({ success: false, error: 'Unit not found' });
    }
    const { room_id, property_id } = roomResult.rows[0];
    
    // Upsert reservation
    const result = await pool.query(`
      INSERT INTO bookings (
        property_id, room_id, cm_booking_id, status,
        check_in, check_out, guest_first_name, guest_last_name,
        guest_email, guest_phone, num_guests, num_adults, num_children,
        total_price, currency, source, notes, special_requests
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
      ON CONFLICT (cm_booking_id) WHERE cm_booking_id IS NOT NULL
      DO UPDATE SET
        status = EXCLUDED.status,
        check_in = EXCLUDED.check_in,
        check_out = EXCLUDED.check_out,
        guest_first_name = EXCLUDED.guest_first_name,
        guest_last_name = EXCLUDED.guest_last_name,
        guest_email = EXCLUDED.guest_email,
        guest_phone = EXCLUDED.guest_phone,
        num_guests = EXCLUDED.num_guests,
        num_adults = EXCLUDED.num_adults,
        num_children = EXCLUDED.num_children,
        total_price = EXCLUDED.total_price,
        currency = EXCLUDED.currency,
        source = EXCLUDED.source,
        notes = EXCLUDED.notes,
        special_requests = EXCLUDED.special_requests,
        updated_at = NOW()
      RETURNING *
    `, [
      property_id, room_id, external_id, status || 'confirmed',
      check_in, check_out, guest_first_name, guest_last_name,
      guest_email, guest_phone, num_guests || num_adults || 1, num_adults, num_children,
      total_price, currency || 'GBP', source, notes, special_requests
    ]);
    
    res.json({ success: true, reservation: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Reservations
app.get('/api/partner/v1/reservations', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { property_external_id, unit_external_id, start_date, end_date, status } = req.query;
    
    let query = `
      SELECT b.*, bu.cm_room_id as unit_external_id, p.cm_property_id as property_external_id
      FROM bookings b
      JOIN bookable_units bu ON b.room_id = bu.id
      JOIN properties p ON b.property_id = p.id
      JOIN accounts a ON p.account_id = a.id
      WHERE a.partner_id = $1
    `;
    const params = [req.partner.id];
    let paramIndex = 2;
    
    if (property_external_id) {
      query += ` AND p.cm_property_id = $${paramIndex++}`;
      params.push(property_external_id);
    }
    if (unit_external_id) {
      query += ` AND bu.cm_room_id = $${paramIndex++}`;
      params.push(unit_external_id);
    }
    if (start_date) {
      query += ` AND b.check_out >= $${paramIndex++}`;
      params.push(start_date);
    }
    if (end_date) {
      query += ` AND b.check_in <= $${paramIndex++}`;
      params.push(end_date);
    }
    if (status) {
      query += ` AND b.status = $${paramIndex++}`;
      params.push(status);
    }
    
    query += ` ORDER BY b.check_in DESC`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, reservations: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update Rates - Calry-compatible
app.post('/api/partner/v1/rates', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'sync:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const {
      unit_external_id,
      rates                 // Array of { date, price, currency }
    } = req.body;
    
    if (!unit_external_id || !rates || !Array.isArray(rates)) {
      return res.json({ success: false, error: 'unit_external_id and rates array required' });
    }
    
    // Find room
    const roomResult = await pool.query(`
      SELECT bu.id FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON p.account_id = a.id
      WHERE bu.cm_room_id = $1 AND a.partner_id = $2
    `, [unit_external_id, req.partner.id]);
    
    if (roomResult.rows.length === 0) {
      return res.json({ success: false, error: 'Unit not found' });
    }
    const roomId = roomResult.rows[0].id;
    
    // Update prices in availability table
    for (const rate of rates) {
      await pool.query(`
        INSERT INTO room_availability (room_id, date, price, available)
        VALUES ($1, $2, $3, true)
        ON CONFLICT (room_id, date) DO UPDATE SET
          price = EXCLUDED.price,
          updated_at = NOW()
      `, [roomId, rate.date, rate.price]);
    }
    
    res.json({ success: true, updated: rates.length });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// WEBSITE BUILDER PARTNER API
// =====================================================

// Create Website for Partner's Client
app.post('/api/partner/v1/websites', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'website:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const {
      account_external_id,
      property_external_id,
      site_name,
      template,            // 'developer-light' or 'developer-dark'
      pricing_tier         // 'standard', 'corporate', etc.
    } = req.body;
    
    if (!account_external_id || !site_name) {
      return res.json({ success: false, error: 'account_external_id and site_name required' });
    }
    
    // Find account
    const accResult = await pool.query(`
      SELECT id FROM accounts 
      WHERE partner_id = $1 AND partner_external_id = $2
    `, [req.partner.id, account_external_id]);
    
    if (accResult.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found. Create property first.' });
    }
    const accountId = accResult.rows[0].id;
    
    // Find property if specified
    let propertyId = null;
    let roomIds = [];
    if (property_external_id) {
      const propResult = await pool.query(`
        SELECT id FROM properties WHERE cm_property_id = $1 AND account_id = $2
      `, [property_external_id, accountId]);
      if (propResult.rows.length > 0) {
        propertyId = propResult.rows[0].id;
        // Get all rooms for this property
        const roomsResult = await pool.query('SELECT id FROM bookable_units WHERE property_id = $1', [propertyId]);
        roomIds = roomsResult.rows.map(r => r.id);
      }
    }
    
    // Create deployed site record
    const slug = site_name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const result = await pool.query(`
      INSERT INTO deployed_sites (
        account_id, property_id, room_ids, site_name, slug, 
        template, pricing_tier, status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, 'development')
      RETURNING *
    `, [accountId, propertyId, JSON.stringify(roomIds), site_name, slug, 
        template || 'developer-light', pricing_tier || 'standard']);
    
    res.json({ success: true, website: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Websites
app.get('/api/partner/v1/websites', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'website:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { account_external_id } = req.query;
    
    let query = `
      SELECT ds.*, a.partner_external_id as account_external_id
      FROM deployed_sites ds
      JOIN accounts a ON ds.account_id = a.id
      WHERE a.partner_id = $1
    `;
    const params = [req.partner.id];
    
    if (account_external_id) {
      query += ` AND a.partner_external_id = $2`;
      params.push(account_external_id);
    }
    
    const result = await pool.query(query, params);
    res.json({ success: true, websites: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update Website Section
app.put('/api/partner/v1/websites/:websiteId/:section', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'website:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { websiteId, section } = req.params;
    const settings = req.body;
    
    // Verify website belongs to partner's client
    const wsResult = await pool.query(`
      SELECT ds.id FROM deployed_sites ds
      JOIN accounts a ON ds.account_id = a.id
      WHERE ds.id = $1 AND a.partner_id = $2
    `, [websiteId, req.partner.id]);
    
    if (wsResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    // Valid sections
    const validSections = [
      'header', 'hero', 'intro', 'featured', 'about', 
      'reviews', 'contact', 'footer', 'colors', 'seo'
    ];
    
    if (!validSections.includes(section)) {
      return res.json({ success: false, error: `Invalid section. Must be one of: ${validSections.join(', ')}` });
    }
    
    // Upsert website settings
    const result = await pool.query(`
      INSERT INTO website_settings (deployed_site_id, section, settings)
      VALUES ($1, $2, $3)
      ON CONFLICT (deployed_site_id, section) DO UPDATE SET
        settings = EXCLUDED.settings,
        updated_at = NOW()
      RETURNING *
    `, [websiteId, section, JSON.stringify(settings)]);
    
    res.json({ success: true, section, settings: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Website Section
app.get('/api/partner/v1/websites/:websiteId/:section', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'website:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { websiteId, section } = req.params;
    
    // Verify website belongs to partner's client
    const result = await pool.query(`
      SELECT ws.settings FROM website_settings ws
      JOIN deployed_sites ds ON ws.deployed_site_id = ds.id
      JOIN accounts a ON ds.account_id = a.id
      WHERE ds.id = $1 AND ws.section = $2 AND a.partner_id = $3
    `, [websiteId, section, req.partner.id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: true, section, settings: {} });
    }
    
    res.json({ success: true, section, settings: result.rows[0].settings });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get All Website Settings
app.get('/api/partner/v1/websites/:websiteId/all-settings', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'website:read')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { websiteId } = req.params;
    
    const result = await pool.query(`
      SELECT ws.section, ws.settings FROM website_settings ws
      JOIN deployed_sites ds ON ws.deployed_site_id = ds.id
      JOIN accounts a ON ds.account_id = a.id
      WHERE ds.id = $1 AND a.partner_id = $2
    `, [websiteId, req.partner.id]);
    
    // Convert to object keyed by section
    const settings = {};
    result.rows.forEach(row => {
      settings[row.section] = row.settings;
    });
    
    res.json({ success: true, settings });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Deploy Website (trigger WordPress creation)
app.post('/api/partner/v1/websites/:websiteId/deploy', authenticatePartner, async (req, res) => {
  if (!hasPartnerPermission(req, 'website:write')) {
    return res.status(403).json({ success: false, error: 'Permission denied' });
  }
  
  try {
    const { websiteId } = req.params;
    
    // Verify website belongs to partner's client
    const wsResult = await pool.query(`
      SELECT ds.* FROM deployed_sites ds
      JOIN accounts a ON ds.account_id = a.id
      WHERE ds.id = $1 AND a.partner_id = $2
    `, [websiteId, req.partner.id]);
    
    if (wsResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = wsResult.rows[0];
    
    // TODO: Trigger actual WordPress deployment via VPS
    // For now, just update status
    await pool.query(`
      UPDATE deployed_sites SET status = 'deploying', updated_at = NOW()
      WHERE id = $1
    `, [websiteId]);
    
    res.json({ 
      success: true, 
      message: 'Deployment initiated',
      website_id: websiteId,
      status: 'deploying'
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// DEPLOYED SITES SETTINGS - Clean Per-Site Architecture
// =====================================================

// Migration endpoint to add deployed_site_id support
app.get('/api/migrate-website-settings', async (req, res) => {
  try {
    const results = [];
    
    // 1. Add deployed_site_id column
    await pool.query(`
      ALTER TABLE website_settings 
      ADD COLUMN IF NOT EXISTS deployed_site_id INTEGER REFERENCES deployed_sites(id) ON DELETE CASCADE
    `);
    results.push('Added deployed_site_id column');
    
    // 2. Create index for lookups
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_website_settings_deployed_site 
      ON website_settings(deployed_site_id)
    `);
    results.push('Created deployed_site_id index');
    
    // 3. Drop old conflicting constraints if they exist
    await pool.query(`
      ALTER TABLE website_settings 
      DROP CONSTRAINT IF EXISTS website_settings_account_id_section_key
    `).catch(() => {});
    results.push('Removed old account_id+section constraint');
    
    // 4. Create unique constraint for deployed_site_id + section
    await pool.query(`
      CREATE UNIQUE INDEX IF NOT EXISTS idx_website_settings_deployed_unique 
      ON website_settings(deployed_site_id, section) 
      WHERE deployed_site_id IS NOT NULL
    `);
    results.push('Created deployed_site_id+section unique index');
    
    // 5. Check current state
    const tableInfo = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'website_settings'
      ORDER BY ordinal_position
    `);
    
    const countResult = await pool.query(`SELECT COUNT(*) as total FROM website_settings`);
    const deployedCount = await pool.query(`SELECT COUNT(*) as total FROM website_settings WHERE deployed_site_id IS NOT NULL`);
    
    res.json({ 
      success: true, 
      message: 'Migration completed',
      results,
      columns: tableInfo.rows.map(r => r.column_name),
      stats: {
        total_rows: countResult.rows[0].total,
        rows_with_deployed_site_id: deployedCount.rows[0].total
      }
    });
  } catch (error) {
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET single deployed site by ID
app.get('/api/deployed-sites/:id', async (req, res) => {
  try {
    const siteId = parseInt(req.params.id);
    
    const result = await pool.query(`
      SELECT ds.*, 
             p.name as property_name,
             a.name as account_name
      FROM deployed_sites ds
      LEFT JOIN properties p ON p.id = ds.property_id
      LEFT JOIN accounts a ON a.id = ds.account_id
      WHERE ds.id = $1
    `, [siteId]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Site not found' });
    }
    
    res.json({ success: true, site: result.rows[0] });
  } catch (error) {
    console.error('Get deployed site error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET settings for a deployed site
app.get('/api/deployed-sites/:id/settings/:section', async (req, res) => {
  try {
    const deployedSiteId = parseInt(req.params.id);
    const section = req.params.section;
    
    // Verify deployed site exists and get template
    const siteResult = await pool.query(
      'SELECT id, account_id, template, site_name FROM deployed_sites WHERE id = $1',
      [deployedSiteId]
    );
    
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = siteResult.rows[0];
    
    // Try to get per-site settings first
    let result = await pool.query(`
      SELECT settings, variant, is_enabled, display_order, updated_at
      FROM website_settings
      WHERE deployed_site_id = $1 AND section = $2
    `, [deployedSiteId, section]);
    
    if (result.rows.length > 0) {
      console.log(`Loaded ${section} settings for deployed site ${deployedSiteId}`);
      return res.json({ 
        success: true, 
        settings: result.rows[0].settings,
        source: 'deployed_site',
        template: site.template
      });
    }
    
    // Fall back to account-based settings (legacy)
    result = await pool.query(`
      SELECT settings, variant, is_enabled, display_order, updated_at
      FROM website_settings
      WHERE account_id = $1 AND section = $2 AND deployed_site_id IS NULL
      ORDER BY updated_at DESC
      LIMIT 1
    `, [site.account_id, section]);
    
    if (result.rows.length > 0) {
      console.log(`Loaded ${section} settings from account ${site.account_id} for deployed site ${deployedSiteId}`);
      return res.json({ 
        success: true, 
        settings: result.rows[0].settings,
        source: 'account_fallback',
        template: site.template
      });
    }
    
    // No settings found, return null (frontend will use template defaults)
    console.log(`No ${section} settings found for deployed site ${deployedSiteId}, using template defaults`);
    res.json({ 
      success: true, 
      settings: null,
      source: 'template_defaults',
      template: site.template
    });
    
  } catch (error) {
    console.error('Get deployed site settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET all settings for a deployed site
app.get('/api/deployed-sites/:id/settings', async (req, res) => {
  try {
    const deployedSiteId = parseInt(req.params.id);
    
    // Verify deployed site exists
    const siteResult = await pool.query(
      'SELECT id, account_id, template, site_name, site_url FROM deployed_sites WHERE id = $1',
      [deployedSiteId]
    );
    
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = siteResult.rows[0];
    
    // Get all per-site settings
    const result = await pool.query(`
      SELECT section, settings, updated_at
      FROM website_settings
      WHERE deployed_site_id = $1
    `, [deployedSiteId]);
    
    const allSettings = {};
    result.rows.forEach(row => {
      allSettings[row.section] = row.settings;
    });
    
    res.json({ 
      success: true, 
      site: {
        id: site.id,
        name: site.site_name,
        template: site.template,
        site_url: site.site_url
      },
      settings: allSettings,
      sections_saved: Object.keys(allSettings)
    });
    
  } catch (error) {
    console.error('Get all deployed site settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// SAVE settings for a deployed site
app.post('/api/deployed-sites/:id/settings/:section', async (req, res) => {
  try {
    const deployedSiteId = parseInt(req.params.id);
    const section = req.params.section;
    const { settings } = req.body;
    
    if (!settings) {
      return res.json({ success: false, error: 'Settings object required' });
    }
    
    // Verify deployed site exists and get info for WordPress push
    const siteResult = await pool.query(
      'SELECT id, account_id, template, site_name, site_url FROM deployed_sites WHERE id = $1',
      [deployedSiteId]
    );
    
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = siteResult.rows[0];
    
    console.log(`Saving ${section} settings for deployed site ${deployedSiteId} (${site.site_name})`);
    console.log('Settings:', JSON.stringify(settings, null, 2));
    
    // UPSERT: Try update first, then insert
    const updateResult = await pool.query(`
      UPDATE website_settings 
      SET settings = $1, updated_at = CURRENT_TIMESTAMP, sync_source = 'gas'
      WHERE deployed_site_id = $2 AND section = $3
    `, [JSON.stringify(settings), deployedSiteId, section]);
    
    if (updateResult.rowCount === 0) {
      // No existing row, insert new one
      await pool.query(`
        INSERT INTO website_settings (deployed_site_id, account_id, section, settings, sync_source, updated_at)
        VALUES ($1, $2, $3, $4, 'gas', CURRENT_TIMESTAMP)
      `, [deployedSiteId, site.account_id, section, JSON.stringify(settings)]);
      console.log(`Inserted new ${section} settings for deployed site ${deployedSiteId}`);
    } else {
      console.log(`Updated ${section} settings for deployed site ${deployedSiteId}`);
    }
    
    // Push to WordPress if site has URL
    let wpPushResult = null;
    if (site.site_url) {
      wpPushResult = await pushSettingsToWordPress(site.site_url, section, settings);
    }
    
    res.json({ 
      success: true, 
      message: 'Settings saved',
      deployed_site_id: deployedSiteId,
      section,
      wordpress_push: wpPushResult
    });
    
  } catch (error) {
    console.error('Save deployed site settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Helper function to push settings to WordPress
async function pushSettingsToWordPress(siteUrl, section, settings) {
  try {
    // Hardcoded API key for WordPress VPS
    const apiKey = 'GAS_SECRET_KEY_2024!';
    
    console.log(`Pushing ${section} to WordPress: ${siteUrl}`);
    
    // Key mapping from GAS short keys to WordPress theme_mod keys
    // Note: WordPress API adds section prefix (e.g. developer_header_) so we only need the suffix
    const keyMapping = {
      // Hero section - these get developer_hero_ prefix from WP
      'image-url': 'bg',
      'video-url': 'video_url',
      'video-mobile': 'video_mobile',
      'mobile-image-url': 'mobile_image_url',
      'headline': 'title',
      'subheadline': 'subtitle',
      'overlay-color': 'overlay_color',
      'overlay': 'opacity',
      'height': 'height',
      'button-text': 'badge',
      'button-link': 'badge_link',
      'badge-bg': 'badge_bg',
      'badge-text': 'badge_text',
      'badge-border': 'badge_border',
      // Header section - these get developer_header_ prefix from WP
      'logo-image-url': 'logo_image',
      'logo-text': 'logo_text',
      'site-name': 'logo_text',
      'bg-color': 'bg_color',
      'text-color': 'text_color',
      'underline-color': 'underline_color',
      'transparent': 'transparent',
      'sticky': 'sticky',
      'cta-button-text': 'cta_text',
      'cta-text': 'cta_text',
      'cta-bg': 'cta_bg',
      'cta-text-color': 'cta_text_color',
      // Trust badges
      'trust-1': 'trust_1',
      'trust-2': 'trust_2',
      'trust-3': 'trust_3',
      'trust-text-color': 'trust_text_color',
      // Search
      'search-btn-bg': 'search_btn_bg',
      'search-btn-text': 'search_btn_text',
      'search-label-color': 'search_label_color',
      'search-max-guests': 'search_max_guests',
      // Favicon
      'favicon-image-url': 'site_icon',
      // Hero Slider Images - map to theme_mod names (without _url suffix)
      'slide-1-url': 'slide_1',
      'slide-2-url': 'slide_2',
      'slide-3-url': 'slide_3',
      'slide-4-url': 'slide_4',
      'background-type': 'background_type',
      'slider-duration': 'slider_duration',
      'slider-transition': 'slider_transition',
      // Global Typography & Styles
      'heading-font': 'heading_font',
      'body-font': 'body_font',
      'title-size': 'title_size',
      'body-size': 'body_size',
      'primary-color': 'primary_color',
      'secondary-color': 'secondary_color',
      'accent-color': 'accent_color',
      'link-color': 'link_color',
      'btn-primary-bg': 'btn_primary_bg',
      'btn-primary-text': 'btn_primary_text',
      'btn-secondary-bg': 'btn_secondary_bg',
      'btn-secondary-text': 'btn_secondary_text',
      'btn-radius': 'btn_radius'
    };
    
    // Transform settings keys
    const transformedSettings = {};
    for (const [key, value] of Object.entries(settings)) {
      const wpKey = keyMapping[key] || key;
      transformedSettings[wpKey] = value;
    }
    
    // Log slider-specific settings for debugging
    console.log('WordPress push for section:', section);
    if (section === 'hero') {
      console.log('Slider settings being pushed:');
      console.log('  background-type:', settings['background-type']);
      console.log('  slide-1-url:', settings['slide-1-url']);
      console.log('  slide-2-url:', settings['slide-2-url']);
      console.log('  slide-3-url:', settings['slide-3-url']);
      console.log('  slide-4-url:', settings['slide-4-url']);
      console.log('  Transformed to:');
      console.log('    background_type:', transformedSettings['background_type']);
      console.log('    slide_1:', transformedSettings['slide_1']);
      console.log('    slide_2:', transformedSettings['slide_2']);
    }
    
    console.log('Transformed settings:', JSON.stringify(transformedSettings, null, 2));
    
    const response = await fetch('https://sites.gas.travel/gas-api.php', {
      method: 'POST',
      headers: {
        'X-API-Key': 'gas-deploy-2024-secure-key',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: 'update_settings',
        site_url: siteUrl,
        section,
        settings: transformedSettings
      })
    });
    
    const responseText = await response.text();
    console.log('WordPress API raw response:', responseText);
    
    // Try to parse as JSON
    try {
      const data = JSON.parse(responseText);
      return data;
    } catch (parseError) {
      console.error('Failed to parse WordPress response as JSON:', responseText);
      return { success: false, error: 'Invalid JSON response from WordPress', raw: responseText };
    }
    
  } catch (error) {
    console.error('WordPress push error:', error);
    return { success: false, error: error.message };
  }
}

// Helper function to create default WordPress menu after deployment
async function createDefaultWordPressMenu(siteUrl) {
  try {
    const cleanUrl = siteUrl.replace(/\/$/, '');
    console.log(`Creating default menu for: ${cleanUrl}`);
    
    const response = await fetch(`${cleanUrl}/wp-json/developer-theme/v1/create-menu`, {
      method: 'POST',
      headers: {
        'X-GAS-API-Key': 'GAS_SECRET_KEY_2024!',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        menu_items: [
          { title: 'Home', url: '/', order: 1 },
          { title: 'Rooms', url: '/book-now/', order: 2 },
          { title: 'Contact Us', url: '/contact/', order: 3 },
          { title: 'Book Now', url: '/book-now/', order: 4, classes: 'developer-nav-cta' }
        ]
      })
    });
    
    const responseText = await response.text();
    console.log('Menu creation response:', responseText);
    
    try {
      return JSON.parse(responseText);
    } catch (e) {
      return { success: false, error: 'Invalid response', raw: responseText };
    }
  } catch (error) {
    console.error('Menu creation error:', error);
    return { success: false, error: error.message };
  }
}

// Debug endpoint to check raw website_settings
app.get('/api/debug/settings/:siteId/:section', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM website_settings WHERE deployed_site_id = $1 AND section = $2',
      [req.params.siteId, req.params.section]
    );
    res.json({ rows: result.rows, count: result.rows.length });
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Check VPS status
app.get('/api/deploy/status', async (req, res) => {
  try {
    const response = await fetch(`${VPS_DEPLOY_URL}?action=status`, {
      method: 'GET',
      headers: {
        'X-API-Key': VPS_DEPLOY_API_KEY
      }
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.json({ success: false, error: 'Could not connect to VPS: ' + error.message });
  }
});

// List sites on VPS
app.get('/api/deploy/sites', async (req, res) => {
  try {
    const response = await fetch(`${VPS_DEPLOY_URL}?action=list-sites`, {
      method: 'GET',
      headers: {
        'X-API-Key': VPS_DEPLOY_API_KEY
      }
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.json({ success: false, error: 'Could not connect to VPS: ' + error.message });
  }
});

// Plugin License Creation
app.post('/api/plugin-license/create', async (req, res) => {
  try {
    const { email, account_id, product, room_ids, display_settings } = req.body;
    
    if (!email) {
      return res.json({ success: false, error: 'Email is required' });
    }
    
    // Generate a license key
    const licenseKey = 'GAS-' + require('crypto').randomBytes(16).toString('hex').toUpperCase();
    
    // Get download URL from GitHub (latest release)
    const latest = await getLatestGitHubRelease();
    const downloadUrl = latest.download_url || 'https://github.com/rezintelhelp-hub/gas-booking-plugin/releases/latest';
    
    // Store the license with room_ids and display_settings
    const result = await pool.query(`
      INSERT INTO plugin_licenses (account_id, email, license_key, product, room_ids, display_settings, status, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, 'active', NOW())
      RETURNING id, license_key
    `, [account_id || null, email, licenseKey, product || 'gas-booking-plugin', JSON.stringify(room_ids || []), JSON.stringify(display_settings || {})]);
    
    // TODO: Send email with license key and download link
    // TODO: Integrate with payment system
    
    res.json({ 
      success: true, 
      license_key: licenseKey,
      download_url: downloadUrl,
      version: latest.version,
      rooms_count: room_ids ? room_ids.length : 0,
      message: 'License created successfully'
    });
  } catch (error) {
    console.error('Error creating plugin license:', error);
    // If table doesn't exist or column missing, create/alter it
    if (error.code === '42P01' || error.code === '42703') {
      try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS plugin_licenses (
            id SERIAL PRIMARY KEY,
            account_id INTEGER,
            email VARCHAR(255) NOT NULL,
            license_key VARCHAR(100) UNIQUE NOT NULL,
            product VARCHAR(100) DEFAULT 'gas-booking-plugin',
            status VARCHAR(50) DEFAULT 'active',
            plan VARCHAR(50) DEFAULT 'plugin',
            room_ids JSONB DEFAULT '[]',
            display_settings JSONB DEFAULT '{}',
            created_at TIMESTAMP DEFAULT NOW(),
            expires_at TIMESTAMP,
            last_used_at TIMESTAMP,
            FOREIGN KEY (account_id) REFERENCES accounts(id)
          )
        `);
        // Try adding columns if table exists but columns don't
        await pool.query(`ALTER TABLE plugin_licenses ADD COLUMN IF NOT EXISTS room_ids JSONB DEFAULT '[]'`).catch(() => {});
        await pool.query(`ALTER TABLE plugin_licenses ADD COLUMN IF NOT EXISTS display_settings JSONB DEFAULT '{}'`).catch(() => {});
        
        // Retry the insert
        const licenseKey = 'GAS-' + require('crypto').randomBytes(16).toString('hex').toUpperCase();
        const latest = await getLatestGitHubRelease();
        const downloadUrl = latest.download_url || 'https://github.com/rezintelhelp-hub/gas-booking-plugin/releases/latest';
        const result = await pool.query(`
          INSERT INTO plugin_licenses (account_id, email, license_key, product, room_ids, display_settings, status, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, 'active', NOW())
          RETURNING id, license_key
        `, [req.body.account_id || null, req.body.email, licenseKey, req.body.product || 'gas-booking-plugin', JSON.stringify(req.body.room_ids || []), JSON.stringify(req.body.display_settings || {})]);
        
        return res.json({ 
          success: true, 
          license_key: licenseKey,
          download_url: downloadUrl,
          version: latest.version,
          rooms_count: req.body.room_ids ? req.body.room_ids.length : 0,
          message: 'License created successfully'
        });
      } catch (retryError) {
        return res.json({ success: false, error: retryError.message });
      }
    }
    res.json({ success: false, error: error.message });
  }
});

// Premium VPS Provision API Config
const PROVISION_API_URL = 'https://provision.custom.gas.travel';
const PROVISION_API_KEY = process.env.PROVISION_API_KEY || 'GAS-PROVISION-1df6d2558a1f45c0e6325690524432ca';

// Provision a custom bespoke site (called after DNS is set up)
app.post('/api/custom-site/provision', async (req, res) => {
  try {
    const { request_id, slug, site_name, admin_email, account_id } = req.body;
    
    if (!slug || !admin_email) {
      return res.json({ success: false, error: 'slug and admin_email required' });
    }
    
    // If request_id provided, get account_id from the request
    let finalAccountId = account_id;
    if (request_id && !finalAccountId) {
      const reqResult = await pool.query('SELECT account_id FROM custom_site_requests WHERE id = $1', [request_id]);
      if (reqResult.rows.length > 0) {
        finalAccountId = reqResult.rows[0].account_id;
      }
    }
    
    // Call the provision API on premium VPS
    const response = await fetch(`${PROVISION_API_URL}/api/provision-site`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': PROVISION_API_KEY
      },
      body: JSON.stringify({ slug, site_name, admin_email })
    });
    
    const data = await response.json();
    
    if (data.success) {
      // Ensure account_id column exists
      await pool.query(`ALTER TABLE custom_sites ADD COLUMN IF NOT EXISTS account_id INTEGER`).catch(() => {});
      
      // Save to custom_sites table with account_id
      try {
        await pool.query(`
          INSERT INTO custom_sites (slug, domain, site_name, admin_email, credentials, account_id, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, NOW())
        `, [slug, data.site.domain, site_name, admin_email, JSON.stringify(data.credentials), finalAccountId]);
      } catch (dbError) {
        // Create table if it doesn't exist
        if (dbError.code === '42P01') {
          await pool.query(`
            CREATE TABLE IF NOT EXISTS custom_sites (
              id SERIAL PRIMARY KEY,
              slug VARCHAR(100) UNIQUE NOT NULL,
              domain VARCHAR(255) NOT NULL,
              site_name VARCHAR(255),
              admin_email VARCHAR(255),
              credentials TEXT,
              account_id INTEGER,
              created_at TIMESTAMP DEFAULT NOW()
            )
          `);
          await pool.query(`
            INSERT INTO custom_sites (slug, domain, site_name, admin_email, credentials, account_id, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, NOW())
          `, [slug, data.site.domain, site_name, admin_email, JSON.stringify(data.credentials), finalAccountId]);
        }
      }
      
      // Update the request status if request_id provided
      if (request_id) {
        await pool.query(`
          UPDATE custom_site_requests 
          SET status = 'provisioned', 
              notes = $1,
              updated_at = NOW()
          WHERE id = $2
        `, [JSON.stringify(data), request_id]);
      }
      
      res.json({
        success: true,
        site: data.site,
        credentials: {
          username: data.credentials?.wp_user || data.credentials?.username || 'admin',
          password: data.credentials?.wp_pass || data.credentials?.password || undefined
        },
        message: 'Site provisioned successfully'
      });
    } else {
      res.json({ success: false, error: data.error || 'Provisioning failed' });
    }
  } catch (error) {
    console.error('Error provisioning site:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get custom site requests (for admin to review)
app.get('/api/custom-site/requests', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM custom_site_requests 
      ORDER BY created_at DESC
    `);
    res.json({ success: true, requests: result.rows });
  } catch (error) {
    res.json({ success: true, requests: [] });
  }
});

// Delete a custom site request
app.delete('/api/custom-site/requests/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query('DELETE FROM custom_site_requests WHERE id = $1 RETURNING id', [id]);
    if (result.rowCount > 0) {
      res.json({ success: true });
    } else {
      res.json({ success: false, error: 'Request not found' });
    }
  } catch (error) {
    console.error('Delete error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get provisioned sites list
app.get('/api/custom-site/provisioned', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM custom_sites 
      ORDER BY created_at DESC
    `);
    res.json({ success: true, sites: result.rows });
  } catch (error) {
    // Table might not exist yet - create it
    if (error.code === '42P01') {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS custom_sites (
          id SERIAL PRIMARY KEY,
          slug VARCHAR(100) UNIQUE NOT NULL,
          domain VARCHAR(255) NOT NULL,
          site_name VARCHAR(255),
          admin_email VARCHAR(255),
          credentials TEXT,
          created_at TIMESTAMP DEFAULT NOW()
        )
      `);
    }
    res.json({ success: true, sites: [] });
  }
});

// Get my custom site (for client view)
app.get('/api/my-custom-site', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    
    if (!accountId) {
      return res.json({ success: false, error: 'account_id required' });
    }
    
    // Look up custom site by account_id
    const result = await pool.query(`
      SELECT * FROM custom_sites 
      WHERE account_id = $1 
      ORDER BY created_at DESC 
      LIMIT 1
    `, [accountId]);
    
    if (result.rows.length > 0) {
      res.json({ success: true, site: result.rows[0] });
    } else {
      // Also check custom_site_requests for linked sites
      const requestResult = await pool.query(`
        SELECT cs.* 
        FROM custom_sites cs
        JOIN custom_site_requests csr ON cs.slug = csr.subdomain
        WHERE csr.account_id = $1 AND csr.status = 'provisioned'
        ORDER BY cs.created_at DESC
        LIMIT 1
      `, [accountId]);
      
      if (requestResult.rows.length > 0) {
        res.json({ success: true, site: requestResult.rows[0] });
      } else {
        res.json({ success: false, site: null });
      }
    }
  } catch (error) {
    console.error('Error getting my custom site:', error);
    res.json({ success: false, error: error.message });
  }
});

// Link custom site to account (admin only)
app.post('/api/custom-site/link', async (req, res) => {
  try {
    const { slug, account_id } = req.body;
    
    if (!slug || !account_id) {
      return res.json({ success: false, error: 'slug and account_id required' });
    }
    
    // Add account_id column if it doesn't exist
    await pool.query(`ALTER TABLE custom_sites ADD COLUMN IF NOT EXISTS account_id INTEGER`).catch(() => {});
    
    // Update the site
    const result = await pool.query(`
      UPDATE custom_sites 
      SET account_id = $1 
      WHERE slug = $2
      RETURNING *
    `, [account_id, slug]);
    
    if (result.rows.length > 0) {
      res.json({ success: true, site: result.rows[0], message: `Site ${slug} linked to account ${account_id}` });
    } else {
      res.json({ success: false, error: 'Site not found' });
    }
  } catch (error) {
    console.error('Error linking custom site:', error);
    res.json({ success: false, error: error.message });
  }
});

// Manually register an existing bespoke site
app.post('/api/custom-site/register', async (req, res) => {
  try {
    const { slug, site_name, admin_email, wp_user, wp_pass } = req.body;
    
    if (!slug) {
      return res.json({ success: false, error: 'slug is required' });
    }
    
    const domain = `${slug}.custom.gas.travel`;
    const credentials = JSON.stringify({ wp_user: wp_user || 'admin', wp_pass: wp_pass || '' });
    
    // Create table if needed
    await pool.query(`
      CREATE TABLE IF NOT EXISTS custom_sites (
        id SERIAL PRIMARY KEY,
        slug VARCHAR(100) UNIQUE NOT NULL,
        domain VARCHAR(255) NOT NULL,
        site_name VARCHAR(255),
        admin_email VARCHAR(255),
        credentials TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    await pool.query(`
      INSERT INTO custom_sites (slug, domain, site_name, admin_email, credentials, created_at)
      VALUES ($1, $2, $3, $4, $5, NOW())
      ON CONFLICT (slug) DO UPDATE SET
        site_name = EXCLUDED.site_name,
        admin_email = EXCLUDED.admin_email,
        credentials = EXCLUDED.credentials
    `, [slug, domain, site_name || slug, admin_email || '', credentials]);
    
    res.json({ success: true, message: 'Site registered' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Custom Site Request
app.post('/api/custom-site/request', async (req, res) => {
  try {
    const { email, phone, account_id, project_description, reference_url } = req.body;
    
    if (!email || !project_description) {
      return res.json({ success: false, error: 'Email and project description are required' });
    }
    
    // Store the request
    const result = await pool.query(`
      INSERT INTO custom_site_requests (account_id, email, phone, project_description, reference_url, status, created_at)
      VALUES ($1, $2, $3, $4, $5, 'pending', NOW())
      RETURNING id
    `, [account_id || null, email, phone || null, project_description, reference_url || null]);
    
    // TODO: Send notification email to admin
    // TODO: Send confirmation email to customer
    
    res.json({ 
      success: true, 
      request_id: result.rows[0].id,
      message: 'Request submitted successfully'
    });
  } catch (error) {
    console.error('Error submitting custom site request:', error);
    // If table doesn't exist, create it
    if (error.code === '42P01') {
      try {
        await pool.query(`
          CREATE TABLE IF NOT EXISTS custom_site_requests (
            id SERIAL PRIMARY KEY,
            account_id INTEGER,
            email VARCHAR(255) NOT NULL,
            phone VARCHAR(50),
            project_description TEXT NOT NULL,
            reference_url VARCHAR(500),
            status VARCHAR(50) DEFAULT 'pending',
            quoted_price DECIMAL(10,2),
            notes TEXT,
            created_at TIMESTAMP DEFAULT NOW(),
            updated_at TIMESTAMP DEFAULT NOW(),
            FOREIGN KEY (account_id) REFERENCES accounts(id)
          )
        `);
        // Retry the insert
        const result = await pool.query(`
          INSERT INTO custom_site_requests (account_id, email, phone, project_description, reference_url, status, created_at)
          VALUES ($1, $2, $3, $4, $5, 'pending', NOW())
          RETURNING id
        `, [req.body.account_id || null, req.body.email, req.body.phone || null, req.body.project_description, req.body.reference_url || null]);
        
        return res.json({ 
          success: true, 
          request_id: result.rows[0].id,
          message: 'Request submitted successfully'
        });
      } catch (retryError) {
        return res.json({ success: false, error: retryError.message });
      }
    }
    res.json({ success: false, error: error.message });
  }
});

// Create custom bespoke site immediately (saves request AND provisions site)
app.post('/api/custom-site/create', async (req, res) => {
  try {
    const { subdomain, email, phone, account_id, project_description, reference_url } = req.body;
    
    if (!subdomain || !email || !project_description) {
      return res.json({ success: false, error: 'Subdomain, email and project description are required' });
    }
    
    // Clean subdomain
    const cleanSubdomain = subdomain.toLowerCase().replace(/[^a-z0-9-]/g, '');
    if (cleanSubdomain.length < 3) {
      return res.json({ success: false, error: 'Subdomain must be at least 3 characters' });
    }
    
    console.log(`[Custom Site] Creating ${cleanSubdomain}.custom.gas.travel for ${email}`);
    
    // 1. Store the request first
    let requestId;
    try {
      const requestResult = await pool.query(`
        INSERT INTO custom_site_requests (account_id, email, phone, project_description, reference_url, subdomain, status, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, 'provisioning', NOW())
        RETURNING id
      `, [account_id || null, email, phone || null, project_description, reference_url || null, cleanSubdomain]);
      requestId = requestResult.rows[0].id;
    } catch (dbError) {
      // Add subdomain column if it doesn't exist
      if (dbError.code === '42703') {
        await pool.query(`ALTER TABLE custom_site_requests ADD COLUMN IF NOT EXISTS subdomain VARCHAR(100)`);
        const requestResult = await pool.query(`
          INSERT INTO custom_site_requests (account_id, email, phone, project_description, reference_url, subdomain, status, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, 'provisioning', NOW())
          RETURNING id
        `, [account_id || null, email, phone || null, project_description, reference_url || null, cleanSubdomain]);
        requestId = requestResult.rows[0].id;
      } else if (dbError.code === '42P01') {
        // Create table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS custom_site_requests (
            id SERIAL PRIMARY KEY,
            account_id INTEGER,
            email VARCHAR(255) NOT NULL,
            phone VARCHAR(50),
            project_description TEXT NOT NULL,
            reference_url VARCHAR(500),
            subdomain VARCHAR(100),
            status VARCHAR(50) DEFAULT 'pending',
            quoted_price DECIMAL(10,2),
            notes TEXT,
            created_at TIMESTAMP DEFAULT NOW(),
            updated_at TIMESTAMP DEFAULT NOW()
          )
        `);
        const requestResult = await pool.query(`
          INSERT INTO custom_site_requests (account_id, email, phone, project_description, reference_url, subdomain, status, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, 'provisioning', NOW())
          RETURNING id
        `, [account_id || null, email, phone || null, project_description, reference_url || null, cleanSubdomain]);
        requestId = requestResult.rows[0].id;
      } else {
        throw dbError;
      }
    }
    
    // 2. Call the provision API on custom.gas.travel VPS
    console.log(`[Custom Site] Calling provision API for ${cleanSubdomain}...`);
    
    const provisionResponse = await fetch(`${PROVISION_API_URL}/api/provision-site`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': PROVISION_API_KEY
      },
      body: JSON.stringify({ 
        slug: cleanSubdomain, 
        site_name: cleanSubdomain, 
        admin_email: email 
      }),
      timeout: 120000 // 2 minutes - site creation takes time
    });
    
    const provisionData = await provisionResponse.json();
    console.log(`[Custom Site] Provision response:`, JSON.stringify(provisionData).substring(0, 500));
    
    if (provisionData.success) {
      // 3. Save to custom_sites table
      try {
        await pool.query(`
          INSERT INTO custom_sites (slug, domain, site_name, admin_email, account_id, credentials, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, NOW())
        `, [cleanSubdomain, `${cleanSubdomain}.custom.gas.travel`, cleanSubdomain, email, account_id || null, JSON.stringify(provisionData.credentials)]);
      } catch (siteDbError) {
        if (siteDbError.code === '42P01') {
          await pool.query(`
            CREATE TABLE IF NOT EXISTS custom_sites (
              id SERIAL PRIMARY KEY,
              slug VARCHAR(100) UNIQUE NOT NULL,
              domain VARCHAR(255) NOT NULL,
              site_name VARCHAR(255),
              admin_email VARCHAR(255),
              account_id INTEGER,
              credentials TEXT,
              status VARCHAR(50) DEFAULT 'active',
              created_at TIMESTAMP DEFAULT NOW()
            )
          `);
          await pool.query(`
            INSERT INTO custom_sites (slug, domain, site_name, admin_email, account_id, credentials, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, NOW())
          `, [cleanSubdomain, `${cleanSubdomain}.custom.gas.travel`, cleanSubdomain, email, account_id || null, JSON.stringify(provisionData.credentials)]);
        } else if (siteDbError.code === '42703') {
          await pool.query(`ALTER TABLE custom_sites ADD COLUMN IF NOT EXISTS account_id INTEGER`);
          await pool.query(`
            INSERT INTO custom_sites (slug, domain, site_name, admin_email, account_id, credentials, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, NOW())
          `, [cleanSubdomain, `${cleanSubdomain}.custom.gas.travel`, cleanSubdomain, email, account_id || null, JSON.stringify(provisionData.credentials)]);
        }
      }
      
      // 4. Update request status
      await pool.query(`
        UPDATE custom_site_requests 
        SET status = 'provisioned', updated_at = NOW()
        WHERE id = $1
      `, [requestId]);
      
      // 5. Auto-create plugin license for this account
      let licenseKey = null;
      if (account_id) {
        try {
          const crypto = require('crypto');
          licenseKey = 'GAS-' + crypto.randomBytes(16).toString('hex').toUpperCase();
          await pool.query(`
            INSERT INTO plugin_licenses (account_id, email, license_key, product, room_ids, display_settings, status, created_at)
            VALUES ($1, $2, $3, 'gas-booking-plugin', '[]', '{}', 'active', NOW())
          `, [account_id, email, licenseKey]);
          console.log(`[Custom Site] ‚úÖ Auto-created license ${licenseKey} for account ${account_id}`);
        } catch (licError) {
          console.error(`[Custom Site] License creation failed (non-blocking):`, licError.message);
          // Non-blocking - site still created successfully
        }
      }
      
      console.log(`[Custom Site] ‚úÖ Site created: ${cleanSubdomain}.custom.gas.travel`);
      
      res.json({
        success: true,
        site: {
          url: `https://${cleanSubdomain}.custom.gas.travel`,
          admin_url: `https://${cleanSubdomain}.custom.gas.travel/wp-admin`,
          domain: `${cleanSubdomain}.custom.gas.travel`
        },
        credentials: {
          username: provisionData.credentials?.wp_user || provisionData.credentials?.username || 'admin',
          password: provisionData.credentials?.wp_pass || provisionData.credentials?.password || undefined
        },
        license_key: licenseKey,
        request_id: requestId,
        message: 'Custom site created successfully'
      });
    } else {
      // Update request status to failed
      await pool.query(`
        UPDATE custom_site_requests 
        SET status = 'failed', notes = $1, updated_at = NOW()
        WHERE id = $2
      `, [provisionData.error || 'Provisioning failed', requestId]);
      
      res.json({ success: false, error: provisionData.error || 'Failed to provision site' });
    }
  } catch (error) {
    console.error('[Custom Site] Error creating site:', error);
    res.json({ success: false, error: error.message });
  }
});

// Deploy a new site (room-level selection)
app.post('/api/deploy/create', async (req, res) => {
  try {
    const { site_name, slug, admin_email, account_id, room_ids, rooms, property_ids, use_theme, use_plugin, template, enable_blog, enable_attractions } = req.body;
    
    // Validate required fields
    if (!site_name || !slug || !admin_email) {
      return res.json({ success: false, error: 'Site name, slug, and admin email are required' });
    }
    
    if (!room_ids || room_ids.length === 0) {
      return res.json({ success: false, error: 'At least one room must be selected' });
    }
    
    if (!account_id) {
      return res.json({ success: false, error: 'Account ID is required. Please select an account or deploy from within a client account.' });
    }
    
    // Verify account exists
    const accountCheck = await pool.query('SELECT id, name FROM accounts WHERE id = $1', [account_id]);
    if (accountCheck.rows.length === 0) {
      return res.json({ success: false, error: `Account ID ${account_id} not found` });
    }
    
    // Determine theme based on template
    const selectedTemplate = template || 'developer-light';
    const wpTheme = selectedTemplate === 'developer-dark' ? 'gas-theme-developer-dark' : 'gas-theme-developer-light';
    
    // Get unique property IDs from selected rooms
    const uniquePropertyIds = property_ids || [...new Set(rooms.map(r => r.property_id))];
    
    // Get API key from first property (optional, may not exist)
    let gasApiKey = '';
    try {
      const propResult = await pool.query(
        'SELECT api_key FROM properties WHERE id = $1',
        [uniquePropertyIds[0]]
      );
      gasApiKey = propResult.rows[0]?.api_key || '';
    } catch (e) {
      // api_key column may not exist, that's OK
      console.log('Note: api_key not available, continuing without it');
    }
    
    // Get account code if available
    let accountCode = null;
    try {
      const accountResult = await pool.query(
        'SELECT account_code FROM accounts WHERE id = $1',
        [account_id]
      );
      accountCode = accountResult.rows[0]?.account_code || null;
    } catch (e) {
      console.log('Note: account_code not available');
    }
    
    console.log(`[Deploy] Creating site "${site_name}" for account ${account_id} (${accountCheck.rows[0].name}) with template ${selectedTemplate}`);
    
    // Call VPS to create site (no API key required in auto mode)
    const response = await fetch(`${VPS_DEPLOY_URL}?action=create-site`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        site_name,
        slug: slug.toLowerCase().replace(/[^a-z0-9-]/g, ''),
        admin_email,
        room_ids,
        rooms,
        property_ids: uniquePropertyIds,
        gas_api_key: gasApiKey,
        account_id,
        account_code: accountCode,
        use_theme: use_theme !== false,
        use_plugin: use_plugin !== false,
        theme: wpTheme,
        template: selectedTemplate,
        enable_blog: enable_blog === true,
        enable_attractions: enable_attractions === true
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      // Store deployment record with template
      try {
        await pool.query(`
          INSERT INTO deployed_sites 
          (property_id, property_ids, room_ids, account_id, blog_id, site_url, admin_url, slug, site_name, status, wp_username, wp_password_temp, template, deployed_at)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW())
        `, [
          uniquePropertyIds[0],
          JSON.stringify(uniquePropertyIds),
          JSON.stringify(room_ids),
          account_id,
          data.site.blog_id,
          data.site.url,
          data.site.admin_url,
          data.site.slug,
          site_name,
          'deployed',
          data.credentials.username,
          data.credentials.password || null,
          selectedTemplate
        ]);
        
        console.log(`[Deploy] Site "${site_name}" saved to database for account ${account_id}`);
        
        // Update rooms with site URL
        for (const roomId of room_ids) {
          await pool.query(
            'UPDATE bookable_units SET website_url = $1 WHERE id = $2',
            [data.site.url, roomId]
          );
        }
        
        // Auto-setup Google Analytics & Search Console
        if (analyticsAdmin && searchConsole) {
          try {
            console.log(`[Deploy] Setting up Google Analytics for ${site_name}...`);
            
            // Create GA4 property
            const propertyResponse = await analyticsAdmin.properties.create({
              requestBody: {
                parent: `accounts/${GA4_ACCOUNT_ID}`,
                displayName: site_name,
                timeZone: 'Europe/London',
                currencyCode: 'GBP',
                industryCategory: 'TRAVEL',
                propertyType: 'PROPERTY_TYPE_ORDINARY'
              }
            });
            
            const propertyId = propertyResponse.data.name;
            console.log(`[Deploy] Created GA4 property: ${propertyId}`);
            
            // Create web data stream
            const streamResponse = await analyticsAdmin.properties.dataStreams.create({
              parent: propertyId,
              requestBody: {
                type: 'WEB_DATA_STREAM',
                displayName: `${site_name} - Website`,
                webStreamData: {
                  defaultUri: data.site.url
                }
              }
            });
            
            const measurementId = streamResponse.data.webStreamData?.measurementId;
            console.log(`[Deploy] Created data stream: ${measurementId}`);
            
            // Save GA4 ID to deployed_sites
            await pool.query(
              'UPDATE deployed_sites SET ga4_measurement_id = $1, ga4_property_id = $2 WHERE site_url = $3',
              [measurementId, propertyId, data.site.url]
            );
            
            // Add to Search Console
            console.log(`[Deploy] Adding to Search Console: ${data.site.url}`);
            await searchConsole.sites.add({
              siteUrl: data.site.url
            });
            console.log(`[Deploy] Site added to Search Console`);
            
            // Push GA4 ID to WordPress via settings sync
            try {
              await pushSettingsToWordPress(data.site.url, 'seo', {
                'google-analytics-id': measurementId
              });
              console.log(`[Deploy] Pushed GA4 ID to WordPress`);
            } catch (wpError) {
              console.error(`[Deploy] Failed to push GA4 to WordPress:`, wpError.message);
            }
            
          } catch (googleError) {
            console.error(`[Deploy] Google setup failed (non-blocking):`, googleError.message);
            // Don't fail the deployment - this is nice-to-have
          }
        }
        
        // Create default WordPress menu
        try {
          console.log(`[Deploy] Creating default menu for ${site_name}...`);
          await createDefaultWordPressMenu(data.site.url);
          console.log(`[Deploy] Default menu created`);
        } catch (menuError) {
          console.error(`[Deploy] Menu creation failed (non-blocking):`, menuError.message);
        }
      } catch (dbError) {
        console.error('[Deploy] WordPress site created but database save failed:', dbError);
        // Return success with warning - site exists on WordPress but not in GAS DB
        return res.json({
          success: true,
          warning: 'Site created on WordPress but failed to save to GAS database. Please contact support.',
          db_error: dbError.message,
          site: data.site,
          credentials: {
            username: data.credentials?.wp_user || data.credentials?.username || 'admin',
            password: data.credentials?.wp_pass || data.credentials?.password || undefined
          }
        });
      }
    }
    
    res.json(data);
  } catch (error) {
    console.error('Deploy error:', error);
    res.json({ success: false, error: 'Deployment failed: ' + error.message });
  }
});

// Get deployment info for a property
app.get('/api/deploy/property/:id', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM deployed_sites WHERE property_id = $1 ORDER BY created_at DESC LIMIT 1',
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: true, deployed: false });
    }
    
    res.json({ success: true, deployed: true, site: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add existing deployed site (for legacy sites not deployed through GAS)
app.post('/api/admin/deployed-sites/add-existing', async (req, res) => {
  try {
    const { account_id, property_id, site_name, site_url, admin_url, status } = req.body;
    
    const result = await pool.query(`
      INSERT INTO deployed_sites (account_id, property_id, site_name, site_url, admin_url, status, deployed_at)
      VALUES ($1, $2, $3, $4, $5, $6, NOW())
      RETURNING *
    `, [account_id, property_id, site_name, site_url, admin_url, status || 'deployed']);
    
    res.json({ success: true, site: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update deployed site status
app.put('/api/admin/deployed-sites/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const {
      account_id,
      property_id,
      property_ids,
      room_ids,
      blog_id,
      site_url,
      admin_url,
      slug,
      site_name,
      status,
      custom_domain,
      template,
      wp_username,
      ga4_measurement_id,
      ga4_property_id
    } = req.body;
    
    // Build dynamic UPDATE query based on provided fields
    const updates = [];
    const values = [id];
    let paramIndex = 2;
    
    if (account_id !== undefined) {
      updates.push(`account_id = $${paramIndex++}`);
      values.push(account_id);
    }
    if (property_id !== undefined) {
      updates.push(`property_id = $${paramIndex++}`);
      values.push(property_id);
    }
    if (property_ids !== undefined) {
      updates.push(`property_ids = $${paramIndex++}`);
      values.push(JSON.stringify(property_ids));
    }
    if (room_ids !== undefined) {
      updates.push(`room_ids = $${paramIndex++}`);
      values.push(JSON.stringify(room_ids));
    }
    if (blog_id !== undefined) {
      updates.push(`blog_id = $${paramIndex++}`);
      values.push(blog_id);
    }
    if (site_url !== undefined) {
      updates.push(`site_url = $${paramIndex++}`);
      values.push(site_url);
    }
    if (admin_url !== undefined) {
      updates.push(`admin_url = $${paramIndex++}`);
      values.push(admin_url);
    }
    if (slug !== undefined) {
      updates.push(`slug = $${paramIndex++}`);
      values.push(slug);
    }
    if (site_name !== undefined) {
      updates.push(`site_name = $${paramIndex++}`);
      values.push(site_name);
    }
    if (status !== undefined) {
      updates.push(`status = $${paramIndex++}`);
      values.push(status);
    }
    if (custom_domain !== undefined) {
      updates.push(`custom_domain = $${paramIndex++}`);
      values.push(custom_domain);
    }
    if (template !== undefined) {
      updates.push(`template = $${paramIndex++}`);
      values.push(template);
    }
    if (wp_username !== undefined) {
      updates.push(`wp_username = $${paramIndex++}`);
      values.push(wp_username);
    }
    if (ga4_measurement_id !== undefined) {
      updates.push(`ga4_measurement_id = $${paramIndex++}`);
      values.push(ga4_measurement_id);
    }
    if (ga4_property_id !== undefined) {
      updates.push(`ga4_property_id = $${paramIndex++}`);
      values.push(ga4_property_id);
    }
    
    if (updates.length === 0) {
      return res.json({ success: false, error: 'No fields to update' });
    }
    
    updates.push('updated_at = NOW()');
    
    const result = await pool.query(`
      UPDATE deployed_sites SET
        ${updates.join(', ')}
      WHERE id = $1
      RETURNING *
    `, values);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Site not found' });
    }
    
    res.json({ success: true, site: result.rows[0] });
  } catch (error) {
    console.error('Update deployed site error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Delete deployed site
app.delete('/api/admin/deployed-sites/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { permanent } = req.query;
    
    // Get deployment record first to clear related data
    const siteResult = await pool.query('SELECT * FROM deployed_sites WHERE id = $1', [id]);
    const site = siteResult.rows[0];
    
    if (!site) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    if (permanent === 'true') {
      // Clear website URL from property
      if (site.property_id) {
        await pool.query('UPDATE properties SET website_url = NULL WHERE id = $1', [site.property_id]);
      }
      
      // Clear website URL from rooms
      if (site.room_ids) {
        const roomIds = typeof site.room_ids === 'string' 
          ? JSON.parse(site.room_ids || '[]') 
          : (site.room_ids || []);
        if (roomIds.length > 0) {
          await pool.query('UPDATE bookable_units SET website_url = NULL WHERE id = ANY($1)', [roomIds]);
        }
      }
      
      // Delete from websites table first (foreign key constraint)
      await pool.query('DELETE FROM websites WHERE deployed_site_id = $1', [id]);
      
      // Delete from website_settings if exists
      await pool.query('DELETE FROM website_settings WHERE deployed_site_id = $1', [id]);
      
      // Permanently delete from deployed_sites
      await pool.query('DELETE FROM deployed_sites WHERE id = $1', [id]);
      res.json({ success: true, message: 'Site permanently deleted' });
    } else {
      // Soft delete - just change status
      await pool.query("UPDATE deployed_sites SET status = 'deleted', updated_at = NOW() WHERE id = $1", [id]);
      res.json({ success: true, message: 'Site marked as deleted' });
    }
  } catch (error) {
    console.error('Delete deployed site error:', error);
    res.json({ success: false, error: error.message });
  }
});

// TEMPORARY: Add missing columns - visit once then remove
app.get('/api/admin/fix-missing-columns-xK9mP2nL', async (req, res) => {
  try {
    const results = [];
    
    // Add booking_webhook_url to accounts table
    await pool.query(`
      ALTER TABLE accounts 
      ADD COLUMN IF NOT EXISTS booking_webhook_url TEXT,
      ADD COLUMN IF NOT EXISTS webhook_secret TEXT
    `);
    results.push('Added booking_webhook_url and webhook_secret to accounts table');
    
    // Fix ALL foreign keys that reference accounts to cascade on delete
    const fkFixes = [
      { table: 'partner_tenant_mapping', column: 'gas_account_id' },
      { table: 'room_types', column: 'account_id' },
      { table: 'properties', column: 'account_id' },
      { table: 'websites', column: 'account_id' },
      { table: 'deployed_sites', column: 'account_id' },
      { table: 'website_settings', column: 'account_id' },
      { table: 'channel_connections', column: 'gas_account_id' },
      { table: 'gas_sync_connections', column: 'account_id' },
      { table: 'payment_configurations', column: 'account_id' },
      { table: 'bookings', column: 'account_id' },
      { table: 'offers', column: 'account_id' },
    ];
    
    for (const fk of fkFixes) {
      try {
        await pool.query(`ALTER TABLE ${fk.table} DROP CONSTRAINT IF EXISTS ${fk.table}_${fk.column}_fkey`);
        await pool.query(`
          ALTER TABLE ${fk.table} ADD CONSTRAINT ${fk.table}_${fk.column}_fkey 
          FOREIGN KEY (${fk.column}) REFERENCES accounts(id) ON DELETE CASCADE
        `);
        results.push(`Fixed ${fk.table}.${fk.column} FK to CASCADE`);
      } catch (err) {
        results.push(`Skipped ${fk.table}.${fk.column}: ${err.message}`);
      }
    }
    
    res.json({ success: true, message: 'Fixes applied', results });
  } catch (error) {
    console.error('Fix columns error:', error);
    res.json({ success: false, error: error.message });
  }
});

// MIGRATION: Create Turbines & GAS Network tables - visit once
app.get('/api/admin/migrate-turbines-network-xK9mP2nL', async (req, res) => {
  try {
    const results = [];
    
    // 1. Turbine Connections (social media accounts)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS turbine_connections (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        platform VARCHAR(50) NOT NULL,
        platform_user_id VARCHAR(255),
        platform_username VARCHAR(255),
        access_token TEXT,
        refresh_token TEXT,
        token_expires_at TIMESTAMP,
        page_id VARCHAR(255),
        page_name VARCHAR(255),
        status VARCHAR(20) DEFAULT 'active',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    results.push('Created turbine_connections table');
    
    // 2. Tags (for contact interests/preferences)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS network_tags (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        name VARCHAR(100) NOT NULL,
        category VARCHAR(50),
        icon VARCHAR(10),
        color VARCHAR(7) DEFAULT '#3b82f6',
        is_system BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    results.push('Created network_tags table');
    
    // 3. Contacts (CRM)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS network_contacts (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        email VARCHAR(255) NOT NULL,
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        phone VARCHAR(50),
        source VARCHAR(50) DEFAULT 'manual',
        source_details VARCHAR(255),
        total_bookings INTEGER DEFAULT 0,
        total_spent DECIMAL(10,2) DEFAULT 0,
        last_stayed_at DATE,
        last_property_id INTEGER,
        notes TEXT,
        unsubscribed BOOLEAN DEFAULT false,
        unsubscribed_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(account_id, email)
      )
    `);
    results.push('Created network_contacts table');
    
    // 4. Contact Tags (many-to-many)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS network_contact_tags (
        id SERIAL PRIMARY KEY,
        contact_id INTEGER REFERENCES network_contacts(id) ON DELETE CASCADE,
        tag_id INTEGER REFERENCES network_tags(id) ON DELETE CASCADE,
        created_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(contact_id, tag_id)
      )
    `);
    results.push('Created network_contact_tags table');
    
    // 5. Segments (saved audience filters)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS network_segments (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        name VARCHAR(100) NOT NULL,
        description TEXT,
        filter_tags INTEGER[],
        filter_source VARCHAR(50),
        filter_min_bookings INTEGER,
        filter_last_stayed_after DATE,
        filter_last_stayed_before DATE,
        contact_count INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    results.push('Created network_segments table');
    
    // 6. Campaigns
    await pool.query(`
      CREATE TABLE IF NOT EXISTS turbine_campaigns (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        name VARCHAR(255) NOT NULL,
        property_id INTEGER REFERENCES properties(id) ON DELETE SET NULL,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE SET NULL,
        discount_type VARCHAR(20),
        discount_value DECIMAL(10,2),
        custom_price DECIMAL(10,2),
        start_date DATE,
        end_date DATE,
        min_nights INTEGER DEFAULT 1,
        offer_code VARCHAR(20) UNIQUE,
        gas_lite_slug VARCHAR(100),
        target_type VARCHAR(20) DEFAULT 'all',
        target_tags INTEGER[],
        target_segment_id INTEGER REFERENCES network_segments(id) ON DELETE SET NULL,
        channels JSONB DEFAULT '{"email": false, "facebook": false, "instagram": false}',
        email_subject VARCHAR(255),
        email_body TEXT,
        social_caption TEXT,
        social_image_url TEXT,
        hero_image_url TEXT,
        status VARCHAR(20) DEFAULT 'draft',
        scheduled_at TIMESTAMP,
        sent_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    // Add new columns if they don't exist
    await pool.query(`ALTER TABLE turbine_campaigns ADD COLUMN IF NOT EXISTS offer_code VARCHAR(20) UNIQUE`);
    await pool.query(`ALTER TABLE turbine_campaigns ADD COLUMN IF NOT EXISTS hero_image_url TEXT`);
    results.push('Created turbine_campaigns table');
    
    // 7. Campaign Analytics
    await pool.query(`
      CREATE TABLE IF NOT EXISTS turbine_campaign_stats (
        id SERIAL PRIMARY KEY,
        campaign_id INTEGER REFERENCES turbine_campaigns(id) ON DELETE CASCADE,
        channel VARCHAR(50),
        sent_count INTEGER DEFAULT 0,
        delivered_count INTEGER DEFAULT 0,
        opened_count INTEGER DEFAULT 0,
        clicked_count INTEGER DEFAULT 0,
        booked_count INTEGER DEFAULT 0,
        revenue DECIMAL(10,2) DEFAULT 0,
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    results.push('Created turbine_campaign_stats table');
    
    // 8. Travellers - Central traveller database
    await pool.query(`
      CREATE TABLE IF NOT EXISTS travellers (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        phone VARCHAR(50),
        phone_verified BOOLEAN DEFAULT false,
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        address TEXT,
        city VARCHAR(100),
        country VARCHAR(100),
        postal_code VARCHAR(20),
        password_hash VARCHAR(255),
        avatar_url TEXT,
        preferred_currency VARCHAR(10) DEFAULT 'USD',
        preferred_language VARCHAR(10) DEFAULT 'en',
        location_preferences JSONB DEFAULT '[]',
        interests JSONB DEFAULT '[]',
        status VARCHAR(20) DEFAULT 'lead',
        marketing_opt_in BOOLEAN DEFAULT false,
        last_login_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    results.push('Created travellers table');
    
    // 9. Traveller-Account Link (which properties has a traveller booked with)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS traveller_property_links (
        id SERIAL PRIMARY KEY,
        traveller_id INTEGER REFERENCES travellers(id) ON DELETE CASCADE,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        property_id INTEGER REFERENCES properties(id) ON DELETE SET NULL,
        first_booking_id INTEGER,
        total_bookings INTEGER DEFAULT 1,
        total_spent DECIMAL(10,2) DEFAULT 0,
        last_stay_date DATE,
        source VARCHAR(50),
        tags JSONB DEFAULT '[]',
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(traveller_id, account_id)
      )
    `);
    results.push('Created traveller_property_links table');
    
    // 10. Traveller Experiences (UGC - videos/photos)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS traveller_experiences (
        id SERIAL PRIMARY KEY,
        traveller_id INTEGER REFERENCES travellers(id) ON DELETE CASCADE,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE SET NULL,
        booking_id INTEGER,
        media_type VARCHAR(20),
        media_url TEXT,
        thumbnail_url TEXT,
        caption TEXT,
        rating INTEGER,
        qr_code_used VARCHAR(50),
        status VARCHAR(20) DEFAULT 'pending',
        approved_by INTEGER,
        approved_at TIMESTAMP,
        view_count INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    results.push('Created traveller_experiences table');
    
    // 11. Add some default system tags
    const defaultTags = [
      { name: 'Dog Friendly', category: 'pets', icon: 'üêï' },
      { name: 'Cat Friendly', category: 'pets', icon: 'üê±' },
      { name: 'Horse Lover', category: 'pets', icon: 'üê¥' },
      { name: 'Family', category: 'travel_style', icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶' },
      { name: 'Couples', category: 'travel_style', icon: 'üíë' },
      { name: 'Solo', category: 'travel_style', icon: 'üß≥' },
      { name: 'Business', category: 'travel_style', icon: 'üíº' },
      { name: 'Hiking', category: 'interests', icon: 'ü•æ' },
      { name: 'Beach', category: 'interests', icon: 'üèñÔ∏è' },
      { name: 'Skiing', category: 'interests', icon: '‚õ∑Ô∏è' },
      { name: 'Golf', category: 'interests', icon: '‚õ≥' },
      { name: 'Wine', category: 'interests', icon: 'üç∑' },
      { name: 'Spa & Wellness', category: 'interests', icon: 'üíÜ' },
      { name: 'Cycling', category: 'interests', icon: 'üö¥' },
      { name: 'Fishing', category: 'interests', icon: 'üé£' },
      { name: 'VIP', category: 'status', icon: '‚≠ê' },
      { name: 'Repeat Guest', category: 'status', icon: 'üîÑ' },
      { name: 'Newsletter', category: 'source', icon: 'üìß' }
    ];
    
    for (const tag of defaultTags) {
      await pool.query(`
        INSERT INTO network_tags (account_id, name, category, icon, is_system)
        VALUES (NULL, $1, $2, $3, true)
        ON CONFLICT DO NOTHING
      `, [tag.name, tag.category, tag.icon]);
    }
    results.push('Added default system tags');
    
    // Create indexes for performance
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_network_contacts_account ON network_contacts(account_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_network_contacts_email ON network_contacts(email)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_turbine_campaigns_account ON turbine_campaigns(account_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_turbine_campaigns_status ON turbine_campaigns(status)`);
    results.push('Created indexes');
    
    res.json({ success: true, message: 'Turbines & GAS Network tables created', results });
  } catch (error) {
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  }
});

// TEMPORARY: Fix foreign key constraints - visit once then remove
app.get('/api/admin/fix-fk-constraints-xK9mP2nL', async (req, res) => {
  try {
    const results = [];
    
    // Fix websites table FK to cascade on delete
    await pool.query('ALTER TABLE websites DROP CONSTRAINT IF EXISTS websites_deployed_site_id_fkey');
    await pool.query(`
      ALTER TABLE websites ADD CONSTRAINT websites_deployed_site_id_fkey 
      FOREIGN KEY (deployed_site_id) REFERENCES deployed_sites(id) ON DELETE CASCADE
    `);
    results.push('Fixed websites.deployed_site_id FK to CASCADE');
    
    // Also fix website_settings if it exists without cascade
    await pool.query('ALTER TABLE website_settings DROP CONSTRAINT IF EXISTS website_settings_deployed_site_id_fkey');
    await pool.query(`
      ALTER TABLE website_settings ADD CONSTRAINT website_settings_deployed_site_id_fkey 
      FOREIGN KEY (deployed_site_id) REFERENCES deployed_sites(id) ON DELETE CASCADE
    `);
    results.push('Fixed website_settings.deployed_site_id FK to CASCADE');
    
    res.json({ success: true, message: 'Foreign key constraints fixed', results });
  } catch (error) {
    console.error('Fix FK error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get all deployed sites
app.get('/api/admin/deployed-sites', async (req, res) => {
  try {
    const includeDeleted = req.query.include_deleted === 'true';
    const accountId = req.query.account_id;
    const includeChildren = req.query.include_children !== 'false'; // Default to true
    
    let conditions = [];
    let params = [];
    let paramIndex = 1;
    
    if (!includeDeleted) {
      conditions.push("ds.status != 'deleted'");
    }
    
    if (accountId) {
      // Check if this is an agency_admin or master_admin account
      const accountCheck = await pool.query(
        'SELECT role FROM accounts WHERE id = $1',
        [accountId]
      );
      const accountRole = accountCheck.rows[0]?.role;
      
      if (includeChildren && (accountRole === 'agency_admin' || accountRole === 'master_admin')) {
        // Include sites from this account AND all child accounts
        conditions.push(`(ds.account_id = $${paramIndex} OR ds.account_id IN (SELECT id FROM accounts WHERE parent_id = $${paramIndex}))`);
      } else {
        conditions.push(`ds.account_id = $${paramIndex}`);
      }
      params.push(accountId);
      paramIndex++;
    }
    
    const whereClause = conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : '';
    
    const result = await pool.query(`
      SELECT ds.*, p.name as property_name, a.name as account_name
      FROM deployed_sites ds
      LEFT JOIN properties p ON ds.property_id = p.id
      LEFT JOIN accounts a ON ds.account_id = a.id
      ${whereClause}
      ORDER BY ds.deployed_at DESC
    `, params);
    res.json({ success: true, sites: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get rooms linked to a deployed website
app.get('/api/admin/deployed-sites/:id/rooms', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get the site to find account_id AND current room_ids
    const siteResult = await pool.query('SELECT account_id, property_id, room_ids FROM deployed_sites WHERE id = $1', [id]);
    console.log('Site result for id', id, ':', siteResult.rows);
    
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Site not found' });
    }
    
    const accountId = siteResult.rows[0].account_id;
    const roomIdsJson = siteResult.rows[0].room_ids;
    
    // Parse room_ids - this is what WordPress actually uses
    let linkedRoomIds = [];
    if (roomIdsJson) {
      linkedRoomIds = typeof roomIdsJson === 'string' ? JSON.parse(roomIdsJson) : roomIdsJson;
    }
    
    console.log('Account ID:', accountId, 'Linked room_ids:', linkedRoomIds);
    
    if (!accountId) {
      return res.json({ success: true, propertyGroups: [], linkedRoomIds: [], message: 'No account linked to site' });
    }
    
    // Get ALL properties for this account
    const propertiesResult = await pool.query(`
      SELECT id, name FROM properties
      WHERE account_id = $1
      ORDER BY name
    `, [accountId]);
    
    // Get ALL rooms for all properties in this account
    const roomsResult = await pool.query(`
      SELECT bu.*, p.name as property_name 
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1
      ORDER BY p.name, bu.name
    `, [accountId]);
    
    // Group rooms by property
    const propertyGroups = propertiesResult.rows.map(prop => ({
      property: prop,
      rooms: roomsResult.rows.filter(r => r.property_id === prop.id)
    }));
    
    console.log('Found properties:', propertiesResult.rows.length, 'rooms:', roomsResult.rows.length);
    
    // Return hierarchical structure AND which rooms are currently linked
    res.json({ success: true, propertyGroups: propertyGroups, linkedRoomIds: linkedRoomIds });
  } catch (error) {
    console.error('Get deployed site rooms error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update which rooms are linked to a deployed website
app.put('/api/admin/deployed-sites/:id/rooms', async (req, res) => {
  try {
    const { id } = req.params;
    const { roomIds } = req.body;
    
    // Ensure website_id column exists
    await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS website_id INTEGER');
    
    // Get the site to find property_id and site_url
    const siteResult = await pool.query('SELECT property_id, site_url FROM deployed_sites WHERE id = $1', [id]);
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Site not found' });
    }
    
    const propertyId = siteResult.rows[0].property_id;
    const siteUrl = siteResult.rows[0].site_url;
    
    if (!propertyId) {
      return res.json({ success: false, error: 'No property linked to this site' });
    }
    
    // Update the room_ids in deployed_sites
    await pool.query(`
      UPDATE deployed_sites SET room_ids = $1, updated_at = NOW() WHERE id = $2
    `, [JSON.stringify(roomIds || []), id]);
    
    // Also update bookable_units.website_id for tracking
    // First, unlink all rooms from this website
    await pool.query(`
      UPDATE bookable_units SET website_id = NULL WHERE property_id = $1
    `, [propertyId]);
    
    // Then link the selected rooms
    if (roomIds && roomIds.length > 0) {
      await pool.query(`
        UPDATE bookable_units SET website_id = $1 WHERE id = ANY($2::int[]) AND property_id = $3
      `, [id, roomIds, propertyId]);
    }
    
    console.log(`Updated website ${id} rooms: ${roomIds?.length || 0} rooms linked. room_ids updated in deployed_sites.`);
    
    // Push room_ids to WordPress via gas-api.php
    let wpUpdated = false;
    if (siteUrl) {
      try {
        const wpResponse = await fetch('https://sites.gas.travel/gas-api.php', {
          method: 'POST',
          headers: {
            'X-API-Key': VPS_DEPLOY_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'update_option',
            site_url: siteUrl,
            option_name: 'gas_room_ids',
            option_value: JSON.stringify(roomIds || [])
          })
        });
        const wpData = await wpResponse.json();
        console.log('WordPress gas_room_ids update:', wpData);
        wpUpdated = wpData.success;
      } catch (wpError) {
        console.log('WordPress gas_room_ids push failed:', wpError.message);
      }
    }
    
    res.json({ success: true, linkedCount: roomIds?.length || 0, wpUpdated });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update deployed site status (master override)
app.put('/api/deployed-sites/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    // Validate status
    const validStatuses = ['development', 'deployed', 'live', 'on-hold', 'active', 'pending'];
    if (!validStatuses.includes(status)) {
      return res.json({ success: false, error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` });
    }
    
    const result = await pool.query(`
      UPDATE deployed_sites SET status = $2, updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `, [id, status]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    console.log(`Deployed site ${id} status updated to: ${status}`);
    res.json({ success: true, site: result.rows[0] });
  } catch (error) {
    console.error('Update deployed site status error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update deployed site pricing tier
app.put('/api/deployed-sites/:id/pricing-tier', async (req, res) => {
  try {
    const { id } = req.params;
    const { pricing_tier } = req.body;
    
    // Validate pricing tier
    const validTiers = ['standard', 'corporate_1', 'corporate_2', 'corporate_3', 'agent_1', 'agent_2', 'agent_3'];
    if (!validTiers.includes(pricing_tier)) {
      return res.json({ success: false, error: `Invalid pricing tier. Must be one of: ${validTiers.join(', ')}` });
    }
    
    const result = await pool.query(`
      UPDATE deployed_sites SET pricing_tier = $2, updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `, [id, pricing_tier]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = result.rows[0];
    console.log(`Deployed site ${id} pricing tier updated to: ${pricing_tier}`);
    
    // Push pricing_tier to WordPress via gas-api.php
    try {
      if (site.site_url) {
        const wpResponse = await fetch('https://sites.gas.travel/gas-api.php', {
          method: 'POST',
          headers: {
            'X-API-Key': VPS_DEPLOY_API_KEY,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'update_option',
            site_url: site.site_url,
            option_name: 'gas_pricing_tier',
            option_value: pricing_tier
          })
        });
        const wpData = await wpResponse.json();
        console.log('WordPress pricing_tier update:', wpData);
      }
    } catch (wpError) {
      console.log('WordPress pricing_tier push failed:', wpError.message);
    }
    
    res.json({ success: true, site: site });
  } catch (error) {
    console.error('Update deployed site pricing tier error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Connect custom domain to deployed site
app.post('/api/deployed-sites/connect-domain', async (req, res) => {
  try {
    const { site_id, domain } = req.body;
    
    if (!site_id || !domain) {
      return res.json({ success: false, error: 'site_id and domain are required' });
    }
    
    // Clean domain
    const cleanDomain = domain.toLowerCase().replace(/^(https?:\/\/)?(www\.)?/, '').replace(/\/$/, '');
    
    // Get the deployed site
    const siteResult = await pool.query('SELECT * FROM deployed_sites WHERE id = $1', [site_id]);
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = siteResult.rows[0];
    const blogId = site.blog_id;
    
    console.log(`[Custom Domain] Connecting ${cleanDomain} to site ${site_id} (blog_id: ${blogId})`);
    
    // Call the VPS API to set up Nginx, SSL, and WordPress
    const SITES_VPS_URL = 'https://sites.gas.travel/gas-api.php';
    
    const vpsResponse = await fetch(SITES_VPS_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': process.env.VPS_DEPLOY_API_KEY || 'GAS-DEPLOY-SECRET-2024'
      },
      body: JSON.stringify({
        action: 'connect-custom-domain',
        blog_id: blogId,
        domain: cleanDomain
      })
    });
    
    const vpsData = await vpsResponse.json();
    console.log(`[Custom Domain] VPS response:`, vpsData);
    
    if (vpsData.success) {
      // Update the deployed_sites table
      await pool.query(`
        UPDATE deployed_sites 
        SET custom_domain = $1, updated_at = NOW()
        WHERE id = $2
      `, [cleanDomain, site_id]);
      
      res.json({ 
        success: true, 
        domain: cleanDomain,
        url: `https://${cleanDomain}`,
        message: 'Domain connected successfully'
      });
    } else {
      res.json({ success: false, error: vpsData.error || 'Failed to connect domain on VPS' });
    }
  } catch (error) {
    console.error('[Custom Domain] Error connecting domain:', error);
    res.json({ success: false, error: error.message });
  }
});

// Remove custom domain from deployed site
app.post('/api/deployed-sites/remove-domain', async (req, res) => {
  try {
    const { site_id } = req.body;
    
    if (!site_id) {
      return res.json({ success: false, error: 'site_id is required' });
    }
    
    // Get the deployed site
    const siteResult = await pool.query('SELECT * FROM deployed_sites WHERE id = $1', [site_id]);
    if (siteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = siteResult.rows[0];
    const customDomain = site.custom_domain;
    
    if (!customDomain) {
      return res.json({ success: false, error: 'No custom domain configured' });
    }
    
    console.log(`[Custom Domain] Removing ${customDomain} from site ${site_id}`);
    
    // Call VPS API to remove the domain mapping
    const SITES_VPS_URL = 'https://sites.gas.travel/gas-api.php';
    
    const vpsResponse = await fetch(SITES_VPS_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': process.env.VPS_DEPLOY_API_KEY || 'GAS-DEPLOY-SECRET-2024'
      },
      body: JSON.stringify({
        action: 'remove-custom-domain',
        blog_id: site.blog_id,
        domain: customDomain
      })
    });
    
    const vpsData = await vpsResponse.json();
    
    // Update database regardless of VPS response
    await pool.query(`
      UPDATE deployed_sites 
      SET custom_domain = NULL, updated_at = NOW()
      WHERE id = $1
    `, [site_id]);
    
    res.json({ 
      success: true, 
      message: 'Domain removed'
    });
  } catch (error) {
    console.error('[Custom Domain] Error removing domain:', error);
    res.json({ success: false, error: error.message });
  }
});

// Manually set custom domain (for already configured sites)
app.post('/api/deployed-sites/set-custom-domain', async (req, res) => {
  try {
    const { site_id, domain } = req.body;
    
    if (!site_id) {
      return res.json({ success: false, error: 'site_id is required' });
    }
    
    const cleanDomain = domain ? domain.toLowerCase().replace(/^(https?:\/\/)?(www\.)?/, '').replace(/\/$/, '') : null;
    
    await pool.query(`
      UPDATE deployed_sites 
      SET custom_domain = $1, updated_at = NOW()
      WHERE id = $2
    `, [cleanDomain, site_id]);
    
    res.json({ 
      success: true, 
      domain: cleanDomain,
      message: cleanDomain ? `Custom domain set to ${cleanDomain}` : 'Custom domain removed'
    });
  } catch (error) {
    console.error('[Custom Domain] Error setting domain:', error);
    res.json({ success: false, error: error.message });
  }
});

// Delete a deployed site
app.delete('/api/deploy/:id', async (req, res) => {
  try {
    const deployId = req.params.id;
    const forceDelete = req.query.force === 'true';
    
    // Get deployment record
    const result = await pool.query('SELECT * FROM deployed_sites WHERE id = $1', [deployId]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Deployment not found' });
    }
    
    const deployment = result.rows[0];
    let vpsDeleted = false;
    let vpsError = null;
    
    // Try to delete from VPS (but don't fail if it doesn't work)
    try {
      const response = await fetch(`${VPS_DEPLOY_URL}?action=delete-site`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': VPS_DEPLOY_API_KEY
        },
        body: JSON.stringify({
          blog_id: deployment.blog_id,
          confirm: 'DELETE'
        })
      });
      const data = await response.json();
      vpsDeleted = data.success;
      if (!data.success) vpsError = data.error;
    } catch (e) {
      vpsError = e.message;
    }
    
    // Always delete from database if VPS succeeded, force=true, or site already marked deleted
    if (vpsDeleted || forceDelete || deployment.status === 'deleted') {
      await pool.query('DELETE FROM deployed_sites WHERE id = $1', [deployId]);
      
      // Clear website URL from property
      await pool.query(
        'UPDATE properties SET website_url = NULL WHERE id = $1',
        [deployment.property_id]
      );
      
      // Clear website URL from rooms
      const roomIds = typeof deployment.room_ids === 'string' 
        ? JSON.parse(deployment.room_ids || '[]') 
        : (deployment.room_ids || []);
      for (const roomId of roomIds) {
        await pool.query(
          'UPDATE bookable_units SET website_url = NULL WHERE id = $1',
          [roomId]
        );
      }
      
      res.json({ 
        success: true, 
        message: 'Site deleted from database',
        vps_deleted: vpsDeleted,
        vps_error: vpsError
      });
    } else {
      // VPS failed but not force - mark as deleted instead
      await pool.query(
        'UPDATE deployed_sites SET status = $1, updated_at = NOW() WHERE id = $2',
        ['deleted', deployId]
      );
      res.json({ 
        success: true, 
        message: 'Marked as deleted (VPS site may still exist). Use ?force=true to remove from database.',
        vps_error: vpsError
      });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// AFFILIATE SYSTEM
// =====================================================

// Get all affiliates (admin)
app.get('/api/admin/affiliates', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT a.*, acc.name as account_name,
             (SELECT COALESCE(SUM(commission_amount), 0) 
              FROM affiliate_commissions 
              WHERE affiliate_id = a.id AND status = 'pending') as pending_amount
      FROM affiliates a
      LEFT JOIN accounts acc ON acc.id = a.account_id
      ORDER BY a.active_referrals DESC, a.lifetime_earnings DESC
    `);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get current user's affiliate info
app.get('/api/affiliate/me', async (req, res) => {
  try {
    // Get account ID from session/auth - for now use header or query
    const accountId = req.headers['x-account-id'] || req.query.account_id;
    if (!accountId) {
      return res.json({ success: false, error: 'Account ID required' });
    }
    
    const result = await pool.query(`
      SELECT a.*, 
             (SELECT COALESCE(SUM(commission_amount), 0) 
              FROM affiliate_commissions 
              WHERE affiliate_id = a.id AND status = 'pending') as pending_amount,
             (SELECT COALESCE(SUM(commission_amount), 0) 
              FROM affiliate_commissions 
              WHERE affiliate_id = a.id 
              AND created_at >= DATE_TRUNC('month', CURRENT_DATE)) as month_earnings
      FROM affiliates a
      WHERE a.account_id = $1
    `, [accountId]);
    
    if (result.rows.length > 0) {
      res.json({ success: true, affiliate: result.rows[0] });
    } else {
      res.json({ success: true, affiliate: null });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get current user's referrals
app.get('/api/affiliate/referrals', async (req, res) => {
  try {
    const accountId = req.headers['x-account-id'] || req.query.account_id;
    if (!accountId) {
      return res.json({ success: false, error: 'Account ID required' });
    }
    
    const result = await pool.query(`
      SELECT r.*, acc.name as account_name, s.plan_code,
             (SELECT COALESCE(SUM(commission_amount), 0) 
              FROM affiliate_commissions c 
              WHERE c.referral_id = r.id) as total_commission
      FROM affiliate_referrals r
      JOIN affiliates a ON a.id = r.affiliate_id
      LEFT JOIN accounts acc ON acc.id = r.referred_account_id
      LEFT JOIN billing_subscriptions s ON s.account_id = r.referred_account_id
      WHERE a.account_id = $1
      ORDER BY r.signed_up_at DESC
    `, [accountId]);
    
    res.json({ success: true, referrals: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Join affiliate program
app.post('/api/affiliate/join', async (req, res) => {
  try {
    const accountId = req.headers['x-account-id'] || req.body.account_id;
    if (!accountId) {
      return res.json({ success: false, error: 'Account ID required' });
    }
    
    // Check if already an affiliate
    const existing = await pool.query(
      'SELECT id FROM affiliates WHERE account_id = $1',
      [accountId]
    );
    
    if (existing.rows.length > 0) {
      return res.json({ success: false, error: 'Already an affiliate' });
    }
    
    // Generate unique referral code
    const account = await pool.query('SELECT name FROM accounts WHERE id = $1', [accountId]);
    const baseName = (account.rows[0]?.name || 'REF').toUpperCase().replace(/[^A-Z]/g, '').substring(0, 8);
    const randomNum = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
    const referralCode = `${baseName}${randomNum}`;
    
    // Get bronze tier
    const bronzeTier = await pool.query("SELECT id FROM affiliate_tiers WHERE code = 'bronze'");
    const tierId = bronzeTier.rows[0]?.id || 1;
    
    const result = await pool.query(`
      INSERT INTO affiliates (account_id, referral_code, referral_link, tier_id, tier_code, approved_at)
      VALUES ($1, $2, $3, $4, 'bronze', CURRENT_TIMESTAMP)
      RETURNING *
    `, [accountId, referralCode, `https://gas.travel/ref/${referralCode}`, tierId]);
    
    res.json({ success: true, affiliate: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Request payout
app.post('/api/affiliate/payout', async (req, res) => {
  const client = await pool.connect();
  try {
    const accountId = req.headers['x-account-id'] || req.body.account_id;
    if (!accountId) {
      return res.json({ success: false, error: 'Account ID required' });
    }
    
    await client.query('BEGIN');
    
    // Get affiliate and pending amount
    const affiliateResult = await client.query(`
      SELECT a.id, 
             (SELECT COALESCE(SUM(commission_amount), 0) 
              FROM affiliate_commissions 
              WHERE affiliate_id = a.id AND status = 'pending') as pending_amount
      FROM affiliates a
      WHERE a.account_id = $1
    `, [accountId]);
    
    if (affiliateResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.json({ success: false, error: 'Not an affiliate' });
    }
    
    const affiliate = affiliateResult.rows[0];
    const pendingAmount = parseFloat(affiliate.pending_amount || 0);
    
    if (pendingAmount < 50) {
      await client.query('ROLLBACK');
      return res.json({ success: false, error: 'Minimum payout is ¬£50' });
    }
    
    // Create payout record
    const payoutResult = await client.query(`
      INSERT INTO affiliate_payouts (affiliate_id, amount, currency, status)
      VALUES ($1, $2, 'GBP', 'pending')
      RETURNING id
    `, [affiliate.id, pendingAmount]);
    
    // Mark commissions as processing
    await client.query(`
      UPDATE affiliate_commissions 
      SET status = 'processing', payout_id = $1
      WHERE affiliate_id = $2 AND status = 'pending'
    `, [payoutResult.rows[0].id, affiliate.id]);
    
    await client.query('COMMIT');
    
    res.json({ success: true, payout_id: payoutResult.rows[0].id, amount: pendingAmount });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Track referral signup (called when someone signs up via referral link)
app.post('/api/affiliate/track', async (req, res) => {
  try {
    const { referral_code, referred_account_id } = req.body;
    
    // Find affiliate by code
    const affiliateResult = await pool.query(
      'SELECT id FROM affiliates WHERE referral_code = $1',
      [referral_code]
    );
    
    if (affiliateResult.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid referral code' });
    }
    
    const affiliateId = affiliateResult.rows[0].id;
    
    // Check if already referred
    const existing = await pool.query(
      'SELECT id FROM affiliate_referrals WHERE referred_account_id = $1',
      [referred_account_id]
    );
    
    if (existing.rows.length > 0) {
      return res.json({ success: false, error: 'Account already has a referrer' });
    }
    
    // Create referral record
    await pool.query(`
      INSERT INTO affiliate_referrals (affiliate_id, referred_account_id, status, referral_source)
      VALUES ($1, $2, 'pending', 'link')
    `, [affiliateId, referred_account_id]);
    
    // Update affiliate stats
    await pool.query(`
      UPDATE affiliates SET total_referrals = total_referrals + 1 WHERE id = $1
    `, [affiliateId]);
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// CREDIT PACKAGES ADMIN
// =====================================================

// Get all credit packages
app.get('/api/admin/billing/credit-packages', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_credit_packages ORDER BY sort_order, price');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/update credit package
app.post('/api/admin/billing/credit-packages', async (req, res) => {
  try {
    const { id, name, credits, price, currency, bonus_credits, is_active, sort_order } = req.body;
    
    if (id) {
      const result = await pool.query(`
        UPDATE billing_credit_packages SET 
          name = $1, credits = $2, price = $3, currency = $4, bonus_credits = $5, is_active = $6, sort_order = $7
        WHERE id = $8 RETURNING *
      `, [name, credits, price, currency || 'GBP', bonus_credits || 0, is_active !== false, sort_order || 0, id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      const result = await pool.query(`
        INSERT INTO billing_credit_packages (name, credits, price, currency, bonus_credits, is_active, sort_order)
        VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *
      `, [name, credits, price, currency || 'GBP', bonus_credits || 0, is_active !== false, sort_order || 0]);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete credit package
app.delete('/api/admin/billing/credit-packages/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM billing_credit_packages WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// EXTRAS ADMIN
// =====================================================

// Get all extras
app.get('/api/admin/billing/extras', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_extras ORDER BY sort_order, name');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/update extra
app.post('/api/admin/billing/extras', async (req, res) => {
  try {
    const { id, name, slug, description, credit_cost, category, icon, is_active, requires_booking, sort_order } = req.body;
    
    const finalSlug = slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
    
    if (id) {
      const result = await pool.query(`
        UPDATE billing_extras SET 
          name = $1, slug = $2, description = $3, credit_cost = $4, category = $5, 
          icon = $6, is_active = $7, requires_booking = $8, sort_order = $9
        WHERE id = $10 RETURNING *
      `, [name, finalSlug, description, credit_cost, category, icon, is_active !== false, requires_booking || false, sort_order || 0, id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      const result = await pool.query(`
        INSERT INTO billing_extras (name, slug, description, credit_cost, category, icon, is_active, requires_booking, sort_order)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *
      `, [name, finalSlug, description, credit_cost, category, icon, is_active !== false, requires_booking || false, sort_order || 0]);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete extra
app.delete('/api/admin/billing/extras/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM billing_extras WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// ACCOUNT BILLING (For Users)
// =====================================================

// Get account's subscription and credits
app.get('/api/billing/my-account', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ success: false, error: 'Not authenticated' });
    }
    
    // Get account from token
    const sessionResult = await pool.query(`
      SELECT a.* FROM accounts a
      JOIN account_sessions s ON a.id = s.account_id
      WHERE s.token = $1 AND s.expires_at > NOW()
    `, [token]);
    
    if (sessionResult.rows.length === 0) {
      return res.status(401).json({ success: false, error: 'Invalid session' });
    }
    
    const account = sessionResult.rows[0];
    
    // Get subscription
    const subResult = await pool.query(`
      SELECT s.*, p.name as plan_name, p.features, p.max_properties
      FROM billing_subscriptions s
      LEFT JOIN billing_plans p ON s.plan_id = p.id
      WHERE s.account_id = $1 AND s.status = 'active'
      ORDER BY s.created_at DESC LIMIT 1
    `, [account.id]);
    
    // Get credits
    const creditResult = await pool.query(`
      SELECT * FROM billing_credits WHERE account_id = $1
    `, [account.id]);
    
    // Get recent credit transactions
    const transResult = await pool.query(`
      SELECT * FROM billing_credit_transactions 
      WHERE account_id = $1 
      ORDER BY created_at DESC LIMIT 10
    `, [account.id]);
    
    res.json({
      success: true,
      subscription: subResult.rows[0] || null,
      credits: creditResult.rows[0] || { balance: 0, lifetime_purchased: 0, lifetime_spent: 0 },
      recent_transactions: transResult.rows
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get available plans (for upgrade/signup)
app.get('/api/billing/plans', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_plans WHERE is_active = true ORDER BY sort_order, price_monthly');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get available credit packages
app.get('/api/billing/credit-packages', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_credit_packages WHERE is_active = true ORDER BY sort_order, price');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get available extras
app.get('/api/billing/extras', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM billing_extras WHERE is_active = true ORDER BY sort_order, name');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Assign subscription to account (admin function)
app.post('/api/admin/billing/assign-subscription', async (req, res) => {
  try {
    const { account_id, plan_id, billing_cycle = 'monthly', status = 'active', feature_overrides = {} } = req.body;
    
    // Validate plan exists
    const planResult = await pool.query('SELECT * FROM billing_plans WHERE id = $1', [plan_id]);
    if (planResult.rows.length === 0) {
      return res.json({ success: false, error: 'Plan not found' });
    }
    
    // Calculate period dates
    const now = new Date();
    const periodEnd = new Date(now);
    if (billing_cycle === 'yearly') {
      periodEnd.setFullYear(periodEnd.getFullYear() + 1);
    } else {
      periodEnd.setMonth(periodEnd.getMonth() + 1);
    }
    
    // Check if subscription exists
    const existingResult = await pool.query(`
      SELECT id FROM billing_subscriptions WHERE account_id = $1
    `, [account_id]);
    
    let result;
    if (existingResult.rows.length > 0) {
      // Update existing subscription
      result = await pool.query(`
        UPDATE billing_subscriptions SET
          plan_id = $2,
          status = $3,
          billing_cycle = $4,
          current_period_start = $5,
          current_period_end = $6,
          feature_overrides = $7,
          updated_at = NOW()
        WHERE account_id = $1
        RETURNING *
      `, [account_id, plan_id, status, billing_cycle, now, periodEnd, JSON.stringify(feature_overrides)]);
    } else {
      // Insert new subscription
      result = await pool.query(`
        INSERT INTO billing_subscriptions (account_id, plan_id, status, billing_cycle, current_period_start, current_period_end, feature_overrides)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *
      `, [account_id, plan_id, status, billing_cycle, now, periodEnd, JSON.stringify(feature_overrides)]);
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get subscription for an account
app.get('/api/admin/billing/subscription/:accountId', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT s.*, p.name as plan_name, p.slug as plan_slug, p.features
      FROM billing_subscriptions s
      JOIN billing_plans p ON s.plan_id = p.id
      WHERE s.account_id = $1 AND s.status = 'active'
      ORDER BY s.created_at DESC LIMIT 1
    `, [req.params.accountId]);
    
    res.json({ success: true, data: result.rows[0] || null });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Cancel subscription
app.post('/api/admin/billing/cancel-subscription', async (req, res) => {
  try {
    const { account_id } = req.body;
    
    await pool.query(`
      UPDATE billing_subscriptions 
      SET status = 'cancelled', cancelled_at = NOW(), updated_at = NOW()
      WHERE account_id = $1 AND status = 'active'
    `, [account_id]);
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add credits to account (admin function or after Stripe payment)
app.post('/api/billing/add-credits', async (req, res) => {
  try {
    const { account_id, amount, description, type = 'purchase', reference_type, reference_id } = req.body;
    
    // Upsert credits record
    await pool.query(`
      INSERT INTO billing_credits (account_id, balance, lifetime_purchased, updated_at)
      VALUES ($1, $2, $2, NOW())
      ON CONFLICT (account_id) DO UPDATE SET
        balance = billing_credits.balance + $2,
        lifetime_purchased = billing_credits.lifetime_purchased + $2,
        updated_at = NOW()
    `, [account_id, amount]);
    
    // Get new balance
    const balanceResult = await pool.query('SELECT balance FROM billing_credits WHERE account_id = $1', [account_id]);
    const newBalance = balanceResult.rows[0]?.balance || amount;
    
    // Log transaction
    await pool.query(`
      INSERT INTO billing_credit_transactions (account_id, amount, type, description, reference_type, reference_id, balance_after)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, [account_id, amount, type, description, reference_type, reference_id, newBalance]);
    
    res.json({ success: true, new_balance: newBalance });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Spend credits on an extra
app.post('/api/billing/spend-credits', async (req, res) => {
  try {
    const { account_id, extra_id, notes } = req.body;
    
    // Get the extra
    const extraResult = await pool.query('SELECT * FROM billing_extras WHERE id = $1', [extra_id]);
    if (extraResult.rows.length === 0) {
      return res.json({ success: false, error: 'Extra not found' });
    }
    const extra = extraResult.rows[0];
    
    // Check balance
    const balanceResult = await pool.query('SELECT balance FROM billing_credits WHERE account_id = $1', [account_id]);
    const currentBalance = balanceResult.rows[0]?.balance || 0;
    
    if (currentBalance < extra.credit_cost) {
      return res.json({ success: false, error: 'Insufficient credits', required: extra.credit_cost, available: currentBalance });
    }
    
    // Deduct credits
    await pool.query(`
      UPDATE billing_credits SET 
        balance = balance - $1,
        lifetime_spent = lifetime_spent + $1,
        updated_at = NOW()
      WHERE account_id = $2
    `, [extra.credit_cost, account_id]);
    
    // Get new balance
    const newBalanceResult = await pool.query('SELECT balance FROM billing_credits WHERE account_id = $1', [account_id]);
    const newBalance = newBalanceResult.rows[0]?.balance || 0;
    
    // Log transaction
    await pool.query(`
      INSERT INTO billing_credit_transactions (account_id, amount, type, description, reference_type, reference_id, balance_after)
      VALUES ($1, $2, 'spend', $3, 'extra', $4, $5)
    `, [account_id, -extra.credit_cost, `${extra.name}${notes ? ' - ' + notes : ''}`, extra.id, newBalance]);
    
    res.json({ success: true, new_balance: newBalance, extra: extra.name });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update existing plans with new feature structure (run once)
app.get('/api/admin/billing/update-plans', async (req, res) => {
  try {
    // Update Starter - no API access
    await pool.query(`
      UPDATE billing_plans SET 
        max_properties = 1,
        features = '{"properties": 1, "websites": 1, "booking_plugin": true, "theme": "basic", "blog_module": false, "attractions_module": false, "reviews_widget": false, "api_access": false, "support": "email", "free_trial": false, "white_label": false, "features_list": ["1 property", "1 website", "Booking plugin", "Basic theme", "Email support"]}'
      WHERE slug = 'starter'
    `);
    
    // Update Professional - no API access
    await pool.query(`
      UPDATE billing_plans SET 
        max_properties = 10,
        features = '{"properties": 10, "websites": 1, "booking_plugin": true, "theme": "standard", "blog_module": true, "attractions_module": false, "reviews_widget": false, "api_access": false, "support": "email", "free_trial": true, "white_label": false, "features_list": ["Up to 10 properties", "1 website", "Booking plugin", "All standard themes", "Blog module", "Email support", "14-day free trial"]}'
      WHERE slug = 'professional'
    `);
    
    // Update Business - no API access
    await pool.query(`
      UPDATE billing_plans SET 
        max_properties = 50,
        features = '{"properties": 50, "websites": 1, "booking_plugin": true, "theme": "standard", "blog_module": true, "attractions_module": true, "reviews_widget": false, "api_access": false, "support": "priority", "free_trial": true, "white_label": false, "features_list": ["Up to 50 properties", "1 website", "Booking plugin", "All standard themes", "Blog module", "Attractions module", "Priority support", "14-day free trial"]}'
      WHERE slug = 'business'
    `);
    
    // Update Enterprise - HAS API access
    await pool.query(`
      UPDATE billing_plans SET 
        max_properties = NULL,
        features = '{"properties": null, "websites": 10, "booking_plugin": true, "theme": "premium", "blog_module": true, "attractions_module": true, "reviews_widget": true, "api_access": true, "support": "dedicated", "free_trial": true, "white_label": true, "features_list": ["Unlimited properties", "Up to 10 websites", "Booking plugin", "All themes including premium", "Blog module", "Attractions module", "Reviews widget", "API access", "Dedicated support", "White-label option", "14-day free trial"]}'
      WHERE slug = 'enterprise'
    `);
    
    // Update extras
    await pool.query(`DELETE FROM billing_extras`);
    await pool.query(`
      INSERT INTO billing_extras (name, slug, description, credit_cost, category, icon, sort_order) VALUES
      ('Additional Website', 'additional-website', 'Add another website to your account', 20, 'Websites', 'üåê', 1),
      ('Reviews Widget', 'reviews-widget', 'Display reviews from TripAdvisor, Booking.com, Google', 15, 'Modules', '‚≠ê', 2),
      ('Attractions Module', 'attractions-module', 'Showcase nearby attractions and things to do', 10, 'Modules', 'üìç', 3),
      ('API Access', 'api-access', 'Enable API access for custom integrations', 25, 'Development', 'üîå', 4),
      ('Premium Theme', 'premium-theme', 'Access to premium website design', 25, 'Themes', '‚ú®', 5),
      ('Setup Assistance Call (30 min)', 'setup-call', 'One-on-one video call to help you get started', 5, 'Support', 'üìû', 6),
      ('We Setup For You', 'full-setup', 'We configure everything for you', 20, 'Support', 'üé®', 7),
      ('Custom Integration', 'custom-integration', 'Custom channel manager or API integration', 30, 'Development', 'üîß', 8),
      ('Training Session (1 hour)', 'training', 'Personalised training session', 10, 'Support', 'üìö', 9)
    `);
    
    // Create new tables if they don't exist
    await pool.query(`
      CREATE TABLE IF NOT EXISTS billing_deliverables (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        deliverable_type VARCHAR(50) NOT NULL,
        deliverable_id INTEGER,
        deliverable_name VARCHAR(255) NOT NULL,
        delivered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        delivered_by INTEGER,
        source VARCHAR(50) DEFAULT 'subscription',
        notes TEXT,
        UNIQUE(account_id, deliverable_type, deliverable_id)
      )
    `);
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_templates (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        slug VARCHAR(255) UNIQUE NOT NULL,
        description TEXT,
        preview_image VARCHAR(500),
        template_type VARCHAR(50) DEFAULT 'theme',
        tier VARCHAR(50) DEFAULT 'basic',
        download_url VARCHAR(500),
        version VARCHAR(20) DEFAULT '1.0.0',
        is_active BOOLEAN DEFAULT true,
        features JSONB DEFAULT '[]',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Insert default templates if empty
    const templateCheck = await pool.query('SELECT COUNT(*) FROM website_templates');
    if (parseInt(templateCheck.rows[0].count) === 0) {
      await pool.query(`
        INSERT INTO website_templates (name, slug, description, template_type, tier, version) VALUES
        ('Developer Theme', 'developer-theme', 'Clean developer-focused theme with full customization', 'theme', 'starter', '2.0.0'),
        ('GAS Booking Plugin', 'gas-booking-plugin', 'Core booking system plugin', 'plugin', 'starter', '4.0.0'),
        ('GAS Blog Plugin', 'gas-blog-plugin', 'Blog functionality with SEO', 'plugin', 'professional', '1.0.0'),
        ('GAS Attractions Plugin', 'gas-attractions-plugin', 'Nearby attractions showcase', 'plugin', 'business', '1.0.0'),
        ('GAS Reviews Plugin', 'gas-reviews-plugin', 'Reviews from multiple sources', 'plugin', 'enterprise', '1.0.0'),
        ('GAS Properties Plugin', 'gas-properties-plugin', 'Multi-property portfolio display', 'plugin', 'professional', '1.0.0')
      `);
    }
    
    res.json({ success: true, message: 'Plans, extras, and new tables updated!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get billing overview for admin (all accounts)
app.get('/api/admin/billing/overview', async (req, res) => {
  try {
    // Total active subscriptions by plan
    const subsByPlan = await pool.query(`
      SELECT p.name, p.price_monthly, COUNT(s.id) as count, SUM(p.price_monthly) as mrr
      FROM billing_subscriptions s
      JOIN billing_plans p ON s.plan_id = p.id
      WHERE s.status = 'active'
      GROUP BY p.id, p.name, p.price_monthly
      ORDER BY p.sort_order
    `);
    
    // Total MRR
    const mrrResult = await pool.query(`
      SELECT COALESCE(SUM(p.price_monthly), 0) as total_mrr
      FROM billing_subscriptions s
      JOIN billing_plans p ON s.plan_id = p.id
      WHERE s.status = 'active'
    `);
    
    // Total credits in circulation
    const creditsResult = await pool.query(`
      SELECT 
        COALESCE(SUM(balance), 0) as total_balance,
        COALESCE(SUM(lifetime_purchased), 0) as total_purchased,
        COALESCE(SUM(lifetime_spent), 0) as total_spent
      FROM billing_credits
    `);
    
    // Recent payments
    const paymentsResult = await pool.query(`
      SELECT bp.*, a.name as account_name
      FROM billing_payments bp
      JOIN accounts a ON bp.account_id = a.id
      ORDER BY bp.created_at DESC LIMIT 20
    `);
    
    res.json({
      success: true,
      subscriptions_by_plan: subsByPlan.rows,
      mrr: parseFloat(mrrResult.rows[0]?.total_mrr || 0),
      credits: creditsResult.rows[0],
      recent_payments: paymentsResult.rows
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// WEBSITE TEMPLATES MANAGEMENT
// =====================================================

// Get all templates (admin)
app.get('/api/admin/templates', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM website_templates ORDER BY template_type, tier, name');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create/update template
app.post('/api/admin/templates', async (req, res) => {
  try {
    const { id, name, slug, description, preview_image, template_type, tier, download_url, version, is_active, features } = req.body;
    
    const finalSlug = slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    
    if (id) {
      const result = await pool.query(`
        UPDATE website_templates SET
          name = $1, slug = $2, description = $3, preview_image = $4, template_type = $5,
          tier = $6, download_url = $7, version = $8, is_active = $9, features = $10
        WHERE id = $11 RETURNING *
      `, [name, finalSlug, description, preview_image, template_type, tier, download_url, version, is_active !== false, JSON.stringify(features || []), id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      const result = await pool.query(`
        INSERT INTO website_templates (name, slug, description, preview_image, template_type, tier, download_url, version, is_active, features)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *
      `, [name, finalSlug, description, preview_image, template_type, tier, download_url, version, is_active !== false, JSON.stringify(features || [])]);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete template
app.delete('/api/admin/templates/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM website_templates WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// DELIVERY TRACKING
// =====================================================

// Get deliveries for an account
app.get('/api/admin/deliveries/:accountId', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT d.*, wt.name as template_name, wt.template_type, wt.tier, wt.version
      FROM billing_deliverables d
      LEFT JOIN website_templates wt ON d.deliverable_id = wt.id AND d.deliverable_type IN ('theme', 'plugin')
      WHERE d.account_id = $1
      ORDER BY d.delivered_at DESC
    `, [req.params.accountId]);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Record a delivery
app.post('/api/admin/deliveries', async (req, res) => {
  try {
    const { account_id, deliverable_type, deliverable_id, deliverable_name, source, notes, delivered_by } = req.body;
    
    const result = await pool.query(`
      INSERT INTO billing_deliverables (account_id, deliverable_type, deliverable_id, deliverable_name, source, notes, delivered_by)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      ON CONFLICT (account_id, deliverable_type, deliverable_id) 
      DO UPDATE SET delivered_at = NOW(), notes = EXCLUDED.notes
      RETURNING *
    `, [account_id, deliverable_type, deliverable_id, deliverable_name, source || 'manual', notes, delivered_by]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Check what an account has access to (based on subscription + purchases)
app.get('/api/account/:accountId/entitlements', async (req, res) => {
  try {
    const accountId = req.params.accountId;
    
    // Get subscription plan features AND feature_overrides
    const subResult = await pool.query(`
      SELECT p.features, p.slug as plan_slug, p.name as plan_name, s.feature_overrides
      FROM billing_subscriptions s
      JOIN billing_plans p ON s.plan_id = p.id
      WHERE s.account_id = $1 AND s.status = 'active'
      ORDER BY s.created_at DESC LIMIT 1
    `, [accountId]);
    
    const planFeatures = subResult.rows[0]?.features || {};
    const featureOverrides = subResult.rows[0]?.feature_overrides || {};
    const planSlug = subResult.rows[0]?.plan_slug || 'none';
    
    // Merge plan features with overrides (overrides take precedence)
    const mergedFeatures = { ...planFeatures, ...featureOverrides };
    
    // Get delivered items
    const deliveredResult = await pool.query(`
      SELECT deliverable_type, deliverable_name, deliverable_id
      FROM billing_deliverables
      WHERE account_id = $1
    `, [accountId]);
    
    // Get available templates they can access based on tier
    const tierOrder = { 'basic': 1, 'starter': 1, 'professional': 2, 'business': 3, 'enterprise': 4 };
    const accountTier = tierOrder[planSlug] || 0;
    
    const templatesResult = await pool.query(`
      SELECT * FROM website_templates WHERE is_active = true
    `);
    
    const accessibleTemplates = templatesResult.rows.filter(t => {
      const templateTier = tierOrder[t.tier] || 0;
      return templateTier <= accountTier;
    });
    
    res.json({
      success: true,
      plan: subResult.rows[0] || null,
      features: mergedFeatures,
      feature_overrides: featureOverrides,
      delivered: deliveredResult.rows,
      accessible_templates: accessibleTemplates
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// INSTAWP INTEGRATION
// =====================================================

// Get InstaWP settings (master admin)
app.get('/api/admin/instawp/settings', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM instawp_settings ORDER BY id LIMIT 1');
    res.json({ success: true, data: result.rows[0] || null });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Save InstaWP settings (master admin)
app.post('/api/admin/instawp/settings', async (req, res) => {
  try {
    const { api_url, api_key, default_template, templates, webhook_secret, is_enabled } = req.body;
    
    // Upsert
    const existing = await pool.query('SELECT id FROM instawp_settings LIMIT 1');
    
    if (existing.rows.length > 0) {
      const result = await pool.query(`
        UPDATE instawp_settings SET
          api_url = $1, api_key = $2, default_template = $3, templates = $4, webhook_secret = $5, is_enabled = $6, updated_at = NOW()
        WHERE id = $7 RETURNING *
      `, [api_url || 'https://sites.gas.travel/gas-api.php', api_key, default_template, JSON.stringify(templates || {}), webhook_secret, is_enabled, existing.rows[0].id]);
      res.json({ success: true, data: result.rows[0] });
    } else {
      const result = await pool.query(`
        INSERT INTO instawp_settings (api_url, api_key, default_template, templates, webhook_secret, is_enabled)
        VALUES ($1, $2, $3, $4, $5, $6) RETURNING *
      `, [api_url || 'https://sites.gas.travel/gas-api.php', api_key, default_template, JSON.stringify(templates || {}), webhook_secret, is_enabled]);
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get account website
app.get('/api/account/:accountId/website', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM account_websites WHERE account_id = $1
    `, [req.params.accountId]);
    res.json({ success: true, data: result.rows[0] || null });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create website for account via InstaWP
app.post('/api/admin/instawp/create-site', async (req, res) => {
  try {
    const { account_id, site_name, template_slug } = req.body;
    
    // Get InstaWP settings
    const settingsResult = await pool.query('SELECT * FROM instawp_settings LIMIT 1');
    const settings = settingsResult.rows[0];
    
    if (!settings || !settings.api_key || !settings.is_enabled) {
      return res.json({ success: false, error: 'InstaWP not configured. Add API key in settings.' });
    }
    
    // Check if account already has a site
    const existingResult = await pool.query('SELECT * FROM account_websites WHERE account_id = $1', [account_id]);
    if (existingResult.rows.length > 0) {
      return res.json({ success: false, error: 'Account already has a website', existing: existingResult.rows[0] });
    }
    
    // Get account details for configuration
    const accountResult = await pool.query('SELECT * FROM accounts WHERE id = $1', [account_id]);
    const account = accountResult.rows[0];
    
    if (!account) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    // Determine template based on subscription
    const subResult = await pool.query(`
      SELECT p.slug FROM billing_subscriptions s
      JOIN billing_plans p ON s.plan_id = p.id
      WHERE s.account_id = $1 AND s.status = 'active'
    `, [account_id]);
    
    const planSlug = subResult.rows[0]?.slug || 'starter';
    const templates = settings.templates || {};
    const templateToUse = template_slug || templates[planSlug] || settings.default_template;
    
    // Create site via WordPress Multisite API
    const siteSlug = (site_name || account.name).toLowerCase().replace(/[^a-z0-9]/g, '');
    
    const wpResponse = await fetch(settings.api_url || 'https://sites.gas.travel/gas-api.php', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${settings.api_key}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: 'create_site',
        slug: siteSlug,
        title: account.name,
        email: account.email || 'admin@gas.travel',
        account_id: account_id
      })
    });
    
    const wpData = await wpResponse.json();
    
    if (!wpData.success) {
      return res.json({ success: false, error: 'WordPress API error', details: wpData.error });
    }
    
    // Store website record
    const websiteResult = await pool.query(`
      INSERT INTO account_websites (account_id, instawp_site_id, site_name, site_url, admin_url, template_used, status, instawp_data)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *
    `, [
      account_id,
      wpData.slug,
      site_name || account.name,
      wpData.site_url,
      wpData.admin_url,
      templateToUse,
      'active',
      JSON.stringify(wpData)
    ]);
    
    res.json({ success: true, data: websiteResult.rows[0], instawp: instawpData });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Check InstaWP site status
app.get('/api/admin/instawp/site-status/:siteId', async (req, res) => {
  try {
    const settingsResult = await pool.query('SELECT api_key FROM instawp_settings LIMIT 1');
    const settings = settingsResult.rows[0];
    
    if (!settings || !settings.api_key) {
      return res.json({ success: false, error: 'InstaWP not configured' });
    }
    
    const response = await fetch(`https://app.instawp.io/api/v2/sites/${req.params.siteId}`, {
      headers: { 'Authorization': `Bearer ${settings.api_key}` }
    });
    
    const data = await response.json();
    res.json({ success: true, data });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update website record (after site is ready)
app.put('/api/account/:accountId/website', async (req, res) => {
  try {
    const { site_url, admin_url, custom_domain, status } = req.body;
    
    const result = await pool.query(`
      UPDATE account_websites SET
        site_url = COALESCE($2, site_url),
        admin_url = COALESCE($3, admin_url),
        custom_domain = COALESCE($4, custom_domain),
        status = COALESCE($5, status),
        updated_at = NOW()
      WHERE account_id = $1
      RETURNING *
    `, [req.params.accountId, site_url, admin_url, custom_domain, status]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete website
app.delete('/api/account/:accountId/website', async (req, res) => {
  try {
    // Get website details first
    const websiteResult = await pool.query('SELECT * FROM account_websites WHERE account_id = $1', [req.params.accountId]);
    const website = websiteResult.rows[0];
    
    if (!website) {
      return res.json({ success: false, error: 'No website found' });
    }
    
    // Optionally delete from InstaWP too
    const settingsResult = await pool.query('SELECT api_key FROM instawp_settings LIMIT 1');
    const settings = settingsResult.rows[0];
    
    if (settings?.api_key && website.instawp_site_id) {
      try {
        await fetch(`https://app.instawp.io/api/v2/sites/${website.instawp_site_id}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${settings.api_key}` }
        });
      } catch (e) {
        console.log('Failed to delete from InstaWP:', e.message);
      }
    }
    
    await pool.query('DELETE FROM account_websites WHERE account_id = $1', [req.params.accountId]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// PROPERTY PAYMENT SETTINGS
// =====================================================

// Get payment settings for a property
app.get('/api/property/:propertyId/payment-settings', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM property_payment_settings WHERE property_id = $1
    `, [req.params.propertyId]);
    
    // Return defaults if no settings exist
    if (result.rows.length === 0) {
      res.json({ 
        success: true, 
        data: {
          property_id: parseInt(req.params.propertyId),
          payment_enabled: true,
          deposit_type: 'percentage',
          deposit_amount: 25,
          balance_due_days: 14,
          stripe_connected: false,
          accepted_methods: ['card'],
          currency: 'GBP'
        }
      });
    } else {
      res.json({ success: true, data: result.rows[0] });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Save payment settings for a property
app.post('/api/property/:propertyId/payment-settings', async (req, res) => {
  try {
    const propertyId = req.params.propertyId;
    const {
      payment_enabled, deposit_type, deposit_amount, balance_due_days,
      stripe_account_id, paypal_email, bank_details, accepted_methods,
      currency, cancellation_policy, refund_policy
    } = req.body;
    
    const result = await pool.query(`
      INSERT INTO property_payment_settings (
        property_id, payment_enabled, deposit_type, deposit_amount, balance_due_days,
        stripe_account_id, paypal_email, bank_details, accepted_methods,
        currency, cancellation_policy, refund_policy
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      ON CONFLICT (property_id) DO UPDATE SET
        payment_enabled = $2, deposit_type = $3, deposit_amount = $4, balance_due_days = $5,
        stripe_account_id = $6, paypal_email = $7, bank_details = $8, accepted_methods = $9,
        currency = $10, cancellation_policy = $11, refund_policy = $12, updated_at = NOW()
      RETURNING *
    `, [
      propertyId, payment_enabled, deposit_type, deposit_amount, balance_due_days,
      stripe_account_id, paypal_email, JSON.stringify(bank_details || {}),
      JSON.stringify(accepted_methods || ['card']), currency || 'GBP',
      cancellation_policy, JSON.stringify(refund_policy || {})
    ]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// GUEST PAYMENTS (for booking checkout)
// =====================================================

// Create payment intent for a booking
app.post('/api/payments/create-intent', async (req, res) => {
  try {
    const { booking_id, property_id, amount, currency, payment_type, guest_email, guest_name } = req.body;
    
    // Get property payment settings
    const settingsResult = await pool.query(`
      SELECT pps.*, p.account_id FROM property_payment_settings pps
      JOIN properties p ON pps.property_id = p.id
      WHERE pps.property_id = $1
    `, [property_id]);
    
    const settings = settingsResult.rows[0];
    
    if (!settings) {
      return res.json({ success: false, error: 'Payment not configured for this property' });
    }
    
    // For now, just record the payment intent (Stripe integration later)
    const result = await pool.query(`
      INSERT INTO guest_payments (booking_id, property_id, account_id, guest_email, guest_name, amount, currency, payment_type, status)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'pending')
      RETURNING *
    `, [booking_id, property_id, settings.account_id, guest_email, guest_name, amount, currency || settings.currency, payment_type]);
    
    res.json({ 
      success: true, 
      data: result.rows[0],
      // In future, return Stripe client_secret here
      message: 'Payment recorded. Stripe integration pending.'
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get payments for a booking
app.get('/api/booking/:bookingId/payments', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM guest_payments WHERE booking_id = $1 ORDER BY created_at DESC
    `, [req.params.bookingId]);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get all payments for a property
app.get('/api/property/:propertyId/payments', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT gp.*, b.check_in, b.check_out, bu.name as room_name
      FROM guest_payments gp
      LEFT JOIN bookings b ON gp.booking_id = b.id
      LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      WHERE gp.property_id = $1
      ORDER BY gp.created_at DESC
    `, [req.params.propertyId]);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Calculate deposit for a booking
app.post('/api/payments/calculate-deposit', async (req, res) => {
  try {
    const { property_id, total_amount } = req.body;
    
    const settingsResult = await pool.query(`
      SELECT * FROM property_payment_settings WHERE property_id = $1
    `, [property_id]);
    
    const settings = settingsResult.rows[0] || {
      deposit_type: 'percentage',
      deposit_amount: 25,
      balance_due_days: 14,
      currency: 'GBP'
    };
    
    let depositAmount;
    if (settings.deposit_type === 'percentage') {
      depositAmount = (total_amount * settings.deposit_amount) / 100;
    } else {
      depositAmount = Math.min(settings.deposit_amount, total_amount);
    }
    
    const balanceAmount = total_amount - depositAmount;
    
    res.json({
      success: true,
      data: {
        total: total_amount,
        deposit: Math.round(depositAmount * 100) / 100,
        balance: Math.round(balanceAmount * 100) / 100,
        deposit_type: settings.deposit_type,
        deposit_setting: settings.deposit_amount,
        balance_due_days: settings.balance_due_days,
        currency: settings.currency
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/auth/signup', async (req, res) => {
  const { name, email, password, company, account_type } = req.body;
  try {
    const passwordHash = Buffer.from(password).toString('base64');
    const apiKey = 'gas_' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    const result = await pool.query(`INSERT INTO users (name, email, password_hash, company, account_type, api_key) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, email, account_type, api_key`, [name, email, passwordHash, company, account_type, apiKey]);
    res.json({ success: true, user: result.rows[0], token: apiKey });
  } catch (error) {
    if (error.code === '23505') {
      res.json({ success: false, error: 'Email already registered' });
    } else {
      res.json({ success: false, error: error.message });
    }
  }
});

app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const passwordHash = Buffer.from(password).toString('base64');
    const result = await pool.query('SELECT id, name, email, account_type, api_key FROM users WHERE email = $1 AND password_hash = $2', [email, passwordHash]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid email or password' });
    }
    res.json({ success: true, user: result.rows[0], token: result.rows[0].api_key });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/db/properties', async (req, res) => {
  try {
    const clientId = req.query.client_id;
    const accountId = req.query.account_id;
    let result;
    
    // Ensure portfolio_order column exists
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS portfolio_order INTEGER DEFAULT 0').catch(() => {});
    
    if (accountId) {
      // Check if this account is an agency_admin or has sub-accounts (parent account)
      const accountCheck = await pool.query(`
        SELECT a.role, 
               (SELECT COUNT(*) FROM accounts WHERE parent_id = a.id) as sub_account_count
        FROM accounts a WHERE a.id = $1
      `, [accountId]);
      
      const isAgency = accountCheck.rows.length > 0 && accountCheck.rows[0].role === 'agency_admin';
      const hasSubAccounts = accountCheck.rows.length > 0 && parseInt(accountCheck.rows[0].sub_account_count) > 0;
      
      if (isAgency || hasSubAccounts) {
        result = await pool.query(`
          SELECT p.*, a.name as owner_account_name FROM properties p
          LEFT JOIN accounts a ON p.account_id = a.id
          WHERE p.account_id = $1 
             OR a.managed_by_id = $1
             OR a.parent_id = $1
          ORDER BY COALESCE(p.portfolio_order, 999999), p.name
        `, [accountId]);
      } else {
        result = await pool.query('SELECT * FROM properties WHERE account_id = $1 ORDER BY COALESCE(portfolio_order, 999999), name', [accountId]);
      }
    } else if (clientId) {
      result = await pool.query('SELECT * FROM properties WHERE client_id = $1 ORDER BY COALESCE(portfolio_order, 999999), name', [clientId]);
    } else {
      result = await pool.query('SELECT * FROM properties ORDER BY COALESCE(portfolio_order, 999999), name');
    }
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Reorder properties portfolio
app.put('/api/db/properties/reorder', async (req, res) => {
  try {
    const { order } = req.body; // Array of { id, portfolio_order }
    
    if (!Array.isArray(order)) {
      return res.json({ success: false, error: 'order array required' });
    }
    
    for (const item of order) {
      await pool.query(
        'UPDATE properties SET portfolio_order = $1 WHERE id = $2',
        [item.portfolio_order, item.id]
      );
    }
    
    res.json({ success: true, message: `Updated order for ${order.length} properties` });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// GET single property by ID
app.get('/api/db/properties/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query('SELECT * FROM properties WHERE id = $1', [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// GET all bookable units/rooms
app.get('/api/db/bookable-units', async (req, res) => {
  try {
    const clientId = req.query.client_id;
    const accountId = req.query.account_id;
    const propertyId = req.query.property_id;
    const includeHidden = req.query.include_hidden === 'true';
    let result;
    
    // Build hidden filter - exclude hidden rooms unless include_hidden=true
    const hiddenFilter = includeHidden ? '' : 'AND (bu.is_hidden = false OR bu.is_hidden IS NULL)';
    
    if (propertyId) {
      result = await pool.query(`
        SELECT bu.* FROM bookable_units bu
        WHERE bu.property_id = $1 ${hiddenFilter}
        ORDER BY bu.created_at
      `, [propertyId]);
    } else if (accountId) {
      result = await pool.query(`
        SELECT bu.* FROM bookable_units bu
        JOIN properties p ON bu.property_id = p.id
        WHERE p.account_id = $1 ${hiddenFilter}
        ORDER BY bu.property_id, bu.created_at
      `, [accountId]);
    } else if (clientId) {
      result = await pool.query(`
        SELECT bu.* FROM bookable_units bu
        JOIN properties p ON bu.property_id = p.id
        WHERE p.client_id = $1 ${hiddenFilter}
        ORDER BY bu.property_id, bu.created_at
      `, [clientId]);
    } else {
      result = await pool.query(`SELECT * FROM bookable_units bu WHERE 1=1 ${hiddenFilter} ORDER BY property_id, created_at`);
    }
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/db/properties', async (req, res) => {
  const { name, description, address, city, country, property_type, star_rating } = req.body;
  try {
    const result = await pool.query(`INSERT INTO properties (name, description, address, city, country, property_type, star_rating) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`, [name, description, address, city, country, property_type, star_rating]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// UPDATE property
app.put('/api/db/properties/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      name, description, address, city, country, property_type, status,
      district, state, zip_code, latitude, longitude, account_id, currency,
      display_name, show_on_portfolio, portfolio_display
    } = req.body;

    // If only account_id provided, do simple update
    if (account_id && Object.keys(req.body).length === 1) {
      const result = await pool.query(
        'UPDATE properties SET account_id = $1, updated_at = NOW() WHERE id = $2 RETURNING *',
        [account_id, id]
      );
      return res.json({ success: true, data: result.rows[0] });
    }

    // If only show_on_portfolio provided, do simple update
    if (show_on_portfolio !== undefined && Object.keys(req.body).length === 1) {
      try {
        const result = await pool.query(
          'UPDATE properties SET show_on_portfolio = $1, updated_at = NOW() WHERE id = $2 RETURNING *',
          [show_on_portfolio, id]
        );
        return res.json({ success: true, data: result.rows[0] });
      } catch (colErr) {
        if (colErr.message && colErr.message.includes('does not exist')) {
          return res.json({ success: true, data: { id }, message: 'Column not yet migrated' });
        }
        throw colErr;
      }
    }

    let result;
    try {
      result = await pool.query(
        `UPDATE properties SET 
          name = COALESCE($1, name), 
          description = COALESCE($2, description), 
          address = COALESCE($3, address), 
          city = COALESCE($4, city), 
          country = COALESCE($5, country), 
          property_type = COALESCE($6, property_type),
          status = COALESCE($7, status),
          state = COALESCE($8, state),
          latitude = COALESCE($9, latitude),
          longitude = COALESCE($10, longitude),
          account_id = COALESCE($11, account_id),
          currency = COALESCE($12, currency),
          district = COALESCE($13, district),
          zip_code = COALESCE($14, zip_code),
          display_name = $15,
          show_on_portfolio = COALESCE($16, show_on_portfolio),
          portfolio_display = COALESCE($17::jsonb, portfolio_display),
          updated_at = NOW()
        WHERE id = $18
        RETURNING *`,
        [name, description, address, city, country, property_type, status,
         state, latitude, longitude, account_id, currency, district, zip_code,
         display_name || null, show_on_portfolio,
         portfolio_display ? JSON.stringify(portfolio_display) : null, id]
      );
    } catch (queryErr) {
      // Fallback if new columns don't exist yet (pre-migration)
      if (queryErr.message && queryErr.message.includes('does not exist')) {
        console.log('Falling back to base property update (new columns not yet migrated)');
        result = await pool.query(
          `UPDATE properties SET 
            name = COALESCE($1, name), 
            description = COALESCE($2, description), 
            address = COALESCE($3, address), 
            city = COALESCE($4, city), 
            country = COALESCE($5, country), 
            property_type = COALESCE($6, property_type),
            status = COALESCE($7, status),
            state = COALESCE($8, state),
            latitude = COALESCE($9, latitude),
            longitude = COALESCE($10, longitude),
            account_id = COALESCE($11, account_id),
            currency = COALESCE($12, currency),
            district = COALESCE($13, district),
            zip_code = COALESCE($14, zip_code),
            display_name = $15,
            updated_at = NOW()
          WHERE id = $16
          RETURNING *`,
          [name, description, address, city, country, property_type, status,
           state, latitude, longitude, account_id, currency, district, zip_code,
           display_name || null, id]
        );
      } else {
        throw queryErr;
      }
    }

    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Update error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Save property Stripe settings
app.put('/api/properties/:id/stripe', async (req, res) => {
  try {
    const { id } = req.params;
    const { stripe_publishable_key, stripe_secret_key, stripe_enabled } = req.body;
    
    // Validate the keys if provided
    if (stripe_secret_key && stripe_publishable_key) {
      try {
        // Test the secret key by making a simple API call
        const testStripe = new Stripe(stripe_secret_key);
        await testStripe.balance.retrieve();
      } catch (stripeError) {
        return res.json({ success: false, error: 'Invalid Stripe keys: ' + stripeError.message });
      }
    }
    
    const result = await pool.query(`
      UPDATE properties 
      SET stripe_publishable_key = $1,
          stripe_secret_key = $2,
          stripe_enabled = $3,
          updated_at = NOW()
      WHERE id = $4
      RETURNING id, name, stripe_enabled
    `, [stripe_publishable_key || null, stripe_secret_key || null, stripe_enabled || false, id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    console.log(`‚úÖ Stripe settings saved for property ${id}`);
    res.json({ success: true, property: result.rows[0] });
  } catch (error) {
    console.error('Save Stripe settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get property Stripe settings
app.get('/api/properties/:id/stripe', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT id, name, stripe_publishable_key, stripe_enabled,
             CASE WHEN stripe_secret_key IS NOT NULL THEN true ELSE false END as has_secret_key
      FROM properties WHERE id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    res.json({ success: true, stripe: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// PAYMENT CONFIGURATIONS - Multi-provider support
// Providers: stripe, paypal, airwallex
// =====================================================

const PAYMENT_PROVIDERS = {
  stripe: {
    name: 'Stripe',
    fields: [
      { key: 'publishable_key', label: 'Publishable Key', type: 'text', required: true, prefix: 'pk_' },
      { key: 'secret_key', label: 'Secret Key', type: 'password', required: true, prefix: 'sk_' }
    ],
    helpUrl: 'https://dashboard.stripe.com/apikeys',
    testEndpoint: 'balance'
  },
  paypal: {
    name: 'PayPal',
    fields: [
      { key: 'client_id', label: 'Client ID', type: 'text', required: true },
      { key: 'client_secret', label: 'Client Secret', type: 'password', required: true }
    ],
    helpUrl: 'https://developer.paypal.com/dashboard/applications',
    testEndpoint: null // TODO: implement
  },
  airwallex: {
    name: 'Airwallex',
    fields: [
      { key: 'client_id', label: 'Client ID', type: 'text', required: true },
      { key: 'api_key', label: 'API Key', type: 'password', required: true }
    ],
    helpUrl: 'https://www.airwallex.com/docs',
    testEndpoint: null // TODO: implement
  }
};

// Get available payment providers
app.get('/api/payment/providers', (req, res) => {
  const providers = Object.entries(PAYMENT_PROVIDERS).map(([code, provider]) => ({
    code,
    name: provider.name,
    fields: provider.fields,
    helpUrl: provider.helpUrl,
    available: code === 'stripe' // Only Stripe is fully implemented
  }));
  res.json({ success: true, providers });
});

// Get payment configurations for an account
app.get('/api/accounts/:accountId/payment-configurations', async (req, res) => {
  try {
    const { accountId } = req.params;
    
    const result = await pool.query(`
      SELECT pc.*, p.name as property_name
      FROM payment_configurations pc
      LEFT JOIN properties p ON pc.property_id = p.id
      WHERE pc.account_id = $1
      ORDER BY pc.property_id NULLS FIRST, pc.provider
    `, [accountId]);
    
    // Don't expose secret credentials
    const configs = result.rows.map(c => ({
      ...c,
      credentials: {
        ...c.credentials,
        secret_key: c.credentials?.secret_key ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : null,
        client_secret: c.credentials?.client_secret ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : null,
        api_key: c.credentials?.api_key ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : null
      }
    }));
    
    res.json({ success: true, configurations: configs });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get payment configuration for a specific property (or account default)
app.get('/api/properties/:propertyId/payment-configuration', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    // First check for property-specific config
    let result = await pool.query(`
      SELECT pc.*, p.name as property_name, p.account_id
      FROM payment_configurations pc
      JOIN properties p ON pc.property_id = p.id
      WHERE pc.property_id = $1 AND pc.is_enabled = true
      ORDER BY pc.is_default DESC
      LIMIT 1
    `, [propertyId]);
    
    // Fall back to account-level config
    if (result.rows.length === 0) {
      result = await pool.query(`
        SELECT pc.*, NULL as property_name, pc.account_id
        FROM payment_configurations pc
        JOIN properties p ON pc.account_id = p.account_id
        WHERE p.id = $1 AND pc.property_id IS NULL AND pc.is_enabled = true
        ORDER BY pc.is_default DESC
        LIMIT 1
      `, [propertyId]);
    }
    
    // Also check legacy stripe fields on property
    if (result.rows.length === 0) {
      const legacyResult = await pool.query(`
        SELECT id, stripe_publishable_key, stripe_secret_key, stripe_enabled
        FROM properties WHERE id = $1 AND stripe_enabled = true
      `, [propertyId]);
      
      if (legacyResult.rows.length > 0 && legacyResult.rows[0].stripe_secret_key) {
        return res.json({
          success: true,
          configuration: {
            provider: 'stripe',
            is_enabled: true,
            is_legacy: true,
            credentials: {
              publishable_key: legacyResult.rows[0].stripe_publishable_key
            }
          }
        });
      }
    }
    
    if (result.rows.length === 0) {
      return res.json({ success: true, configuration: null });
    }
    
    const config = result.rows[0];
    res.json({
      success: true,
      configuration: {
        ...config,
        credentials: {
          publishable_key: config.credentials?.publishable_key,
          client_id: config.credentials?.client_id
          // Don't expose secrets
        }
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Save payment configuration
app.post('/api/payment-configurations', async (req, res) => {
  try {
    const { account_id, property_id, provider, name, credentials, settings, is_enabled, is_default, test_mode } = req.body;
    
    if (!account_id || !provider) {
      return res.json({ success: false, error: 'account_id and provider are required' });
    }
    
    if (!PAYMENT_PROVIDERS[provider]) {
      return res.json({ success: false, error: 'Invalid provider. Supported: ' + Object.keys(PAYMENT_PROVIDERS).join(', ') });
    }
    
    // Validate credentials for Stripe
    if (provider === 'stripe' && credentials?.secret_key) {
      try {
        const testStripe = new Stripe(credentials.secret_key);
        await testStripe.balance.retrieve();
      } catch (stripeError) {
        return res.json({ success: false, error: 'Invalid Stripe credentials: ' + stripeError.message });
      }
    }
    
    // If setting as default, unset other defaults for this scope
    if (is_default) {
      if (property_id) {
        await pool.query(`UPDATE payment_configurations SET is_default = false WHERE property_id = $1`, [property_id]);
      } else {
        await pool.query(`UPDATE payment_configurations SET is_default = false WHERE account_id = $1 AND property_id IS NULL`, [account_id]);
      }
    }
    
    // Generate payment_account_id for new configs
    const paymentAccountId = 'pa_' + require('crypto').randomBytes(8).toString('hex');
    
    const result = await pool.query(`
      INSERT INTO payment_configurations (account_id, property_id, provider, name, credentials, settings, is_enabled, is_default, test_mode, payment_account_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      ON CONFLICT (account_id, property_id, provider)
      DO UPDATE SET 
        name = EXCLUDED.name,
        credentials = EXCLUDED.credentials,
        settings = EXCLUDED.settings,
        is_enabled = EXCLUDED.is_enabled,
        is_default = EXCLUDED.is_default,
        test_mode = EXCLUDED.test_mode,
        updated_at = NOW()
      RETURNING id, account_id, property_id, provider, name, is_enabled, is_default, test_mode, payment_account_id, created_at, updated_at
    `, [account_id, property_id || null, provider, name || PAYMENT_PROVIDERS[provider].name, credentials || {}, settings || {}, is_enabled || false, is_default || false, test_mode || false, paymentAccountId]);
    
    console.log(`‚úÖ Payment configuration saved: ${provider} for ${property_id ? 'property ' + property_id : 'account ' + account_id}`);
    res.json({ success: true, configuration: result.rows[0] });
  } catch (error) {
    console.error('Save payment config error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update payment configuration
app.put('/api/payment-configurations/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, credentials, settings, is_enabled, is_default, test_mode } = req.body;
    
    // Get existing config to check provider
    const existing = await pool.query('SELECT * FROM payment_configurations WHERE id = $1', [id]);
    if (existing.rows.length === 0) {
      return res.json({ success: false, error: 'Configuration not found' });
    }
    
    const config = existing.rows[0];
    
    // Merge credentials (don't lose existing secrets if not provided)
    const mergedCredentials = {
      ...config.credentials,
      ...credentials
    };
    
    // Validate Stripe credentials if changed
    if (config.provider === 'stripe' && credentials?.secret_key && credentials.secret_key !== '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
      try {
        const testStripe = new Stripe(credentials.secret_key);
        await testStripe.balance.retrieve();
      } catch (stripeError) {
        return res.json({ success: false, error: 'Invalid Stripe credentials: ' + stripeError.message });
      }
    } else if (credentials?.secret_key === '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
      // Keep existing secret
      delete mergedCredentials.secret_key;
      mergedCredentials.secret_key = config.credentials?.secret_key;
    }
    
    // If setting as default, unset other defaults
    if (is_default) {
      if (config.property_id) {
        await pool.query(`UPDATE payment_configurations SET is_default = false WHERE property_id = $1 AND id != $2`, [config.property_id, id]);
      } else {
        await pool.query(`UPDATE payment_configurations SET is_default = false WHERE account_id = $1 AND property_id IS NULL AND id != $2`, [config.account_id, id]);
      }
    }
    
    const result = await pool.query(`
      UPDATE payment_configurations SET
        name = COALESCE($1, name),
        credentials = $2,
        settings = COALESCE($3, settings),
        is_enabled = COALESCE($4, is_enabled),
        is_default = COALESCE($5, is_default),
        test_mode = COALESCE($6, test_mode),
        updated_at = NOW()
      WHERE id = $7
      RETURNING id, account_id, property_id, provider, name, is_enabled, is_default, test_mode, updated_at
    `, [name, mergedCredentials, settings, is_enabled, is_default, test_mode, id]);
    
    res.json({ success: true, configuration: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete payment configuration
app.delete('/api/payment-configurations/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM payment_configurations WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Test payment configuration
app.post('/api/payment-configurations/:id/test', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query('SELECT * FROM payment_configurations WHERE id = $1', [id]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Configuration not found' });
    }
    
    const config = result.rows[0];
    let testResult = { success: false, message: 'Provider not supported for testing' };
    
    if (config.provider === 'stripe' && config.credentials?.secret_key) {
      try {
        const testStripe = new Stripe(config.credentials.secret_key);
        const balance = await testStripe.balance.retrieve();
        testResult = {
          success: true,
          message: 'Connection successful',
          details: {
            currency: balance.available[0]?.currency || 'unknown',
            available: balance.available[0]?.amount || 0
          }
        };
      } catch (stripeError) {
        testResult = { success: false, message: stripeError.message };
      }
    } else if (config.provider === 'paypal') {
      testResult = { success: false, message: 'PayPal testing not yet implemented' };
    } else if (config.provider === 'airwallex') {
      testResult = { success: false, message: 'Airwallex testing not yet implemented' };
    }
    
    // Save test result
    await pool.query(`
      UPDATE payment_configurations SET last_tested_at = NOW(), test_result = $1 WHERE id = $2
    `, [testResult, id]);
    
    res.json({ success: true, test_result: testResult });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// PAYMENT SETUP TOKENS - Secure links for property owners
// =====================================================

// Generate setup token for property owner
app.post('/api/payment-setup-tokens', async (req, res) => {
  try {
    const { account_id, property_id, provider, expires_hours = 72, created_by } = req.body;
    
    if (!account_id) {
      return res.json({ success: false, error: 'account_id is required' });
    }
    
    // Generate secure token
    const crypto = require('crypto');
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + expires_hours * 60 * 60 * 1000);
    
    const result = await pool.query(`
      INSERT INTO payment_setup_tokens (token, account_id, property_id, provider, expires_at, created_by)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id, token, expires_at
    `, [token, account_id, property_id || null, provider || null, expiresAt, created_by || null]);
    
    // Build setup URL
    const setupUrl = `https://admin.gas.travel/payment-setup.html?token=${token}`;
    
    res.json({
      success: true,
      token: result.rows[0].token,
      expires_at: result.rows[0].expires_at,
      setup_url: setupUrl
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get setup token info (public - for the setup page)
app.get('/api/payment-setup/:token', async (req, res) => {
  try {
    const { token } = req.params;
    
    const result = await pool.query(`
      SELECT t.*, a.name as account_name, p.name as property_name
      FROM payment_setup_tokens t
      JOIN accounts a ON t.account_id = a.id
      LEFT JOIN properties p ON t.property_id = p.id
      WHERE t.token = $1
    `, [token]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid or expired token' });
    }
    
    const tokenData = result.rows[0];
    
    if (tokenData.used_at) {
      return res.json({ success: false, error: 'This setup link has already been used' });
    }
    
    if (new Date(tokenData.expires_at) < new Date()) {
      return res.json({ success: false, error: 'This setup link has expired' });
    }
    
    res.json({
      success: true,
      setup: {
        account_name: tokenData.account_name,
        property_name: tokenData.property_name,
        provider: tokenData.provider, // null means user can choose
        providers: Object.entries(PAYMENT_PROVIDERS).map(([code, p]) => ({
          code,
          name: p.name,
          fields: p.fields,
          helpUrl: p.helpUrl,
          available: code === 'stripe'
        }))
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Complete payment setup via token (public)
app.post('/api/payment-setup/:token', async (req, res) => {
  try {
    const { token } = req.params;
    const { provider, credentials } = req.body;
    
    // Validate token
    const tokenResult = await pool.query(`
      SELECT * FROM payment_setup_tokens WHERE token = $1
    `, [token]);
    
    if (tokenResult.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid token' });
    }
    
    const tokenData = tokenResult.rows[0];
    
    if (tokenData.used_at) {
      return res.json({ success: false, error: 'This setup link has already been used' });
    }
    
    if (new Date(tokenData.expires_at) < new Date()) {
      return res.json({ success: false, error: 'This setup link has expired' });
    }
    
    const selectedProvider = tokenData.provider || provider;
    if (!selectedProvider || !PAYMENT_PROVIDERS[selectedProvider]) {
      return res.json({ success: false, error: 'Please select a valid payment provider' });
    }
    
    // Validate credentials
    if (selectedProvider === 'stripe') {
      if (!credentials?.publishable_key || !credentials?.secret_key) {
        return res.json({ success: false, error: 'Both Publishable Key and Secret Key are required' });
      }
      
      try {
        const testStripe = new Stripe(credentials.secret_key);
        await testStripe.balance.retrieve();
      } catch (stripeError) {
        return res.json({ success: false, error: 'Invalid Stripe credentials: ' + stripeError.message });
      }
    }
    
    // Save configuration
    await pool.query(`
      INSERT INTO payment_configurations (account_id, property_id, provider, credentials, is_enabled, is_default)
      VALUES ($1, $2, $3, $4, true, true)
      ON CONFLICT (account_id, property_id, provider)
      DO UPDATE SET credentials = EXCLUDED.credentials, is_enabled = true, updated_at = NOW()
    `, [tokenData.account_id, tokenData.property_id, selectedProvider, credentials]);
    
    // Mark token as used
    await pool.query(`UPDATE payment_setup_tokens SET used_at = NOW() WHERE token = $1`, [token]);
    
    console.log(`‚úÖ Payment setup completed via token for ${tokenData.property_id ? 'property ' + tokenData.property_id : 'account ' + tokenData.account_id}`);
    
    res.json({ success: true, message: 'Payment configuration saved successfully!' });
  } catch (error) {
    console.error('Payment setup error:', error);
    res.json({ success: false, error: error.message });
  }
});

// List setup tokens for an account
app.get('/api/accounts/:accountId/payment-setup-tokens', async (req, res) => {
  try {
    const { accountId } = req.params;
    
    const result = await pool.query(`
      SELECT t.*, p.name as property_name
      FROM payment_setup_tokens t
      LEFT JOIN properties p ON t.property_id = p.id
      WHERE t.account_id = $1
      ORDER BY t.created_at DESC
    `, [accountId]);
    
    res.json({ success: true, tokens: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Revoke a setup token
app.delete('/api/payment-setup-tokens/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM payment_setup_tokens WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// DELETE property - REQUIRES all rooms to be deleted first
app.delete('/api/db/properties/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if property has any rooms
    const roomsCheck = await pool.query(
      'SELECT COUNT(*) as count FROM bookable_units WHERE property_id = $1',
      [id]
    );
    
    if (parseInt(roomsCheck.rows[0].count) > 0) {
      return res.json({ 
        success: false, 
        error: 'Cannot delete property: Please delete all rooms first. This property has ' + roomsCheck.rows[0].count + ' room(s).'
      });
    }
    
    // Check if property has any bookings directly attached
    const bookingsCheck = await pool.query(
      'SELECT COUNT(*) as count FROM bookings WHERE property_id = $1',
      [id]
    );
    
    if (parseInt(bookingsCheck.rows[0].count) > 0) {
      return res.json({ 
        success: false, 
        error: 'Cannot delete property: This property has ' + bookingsCheck.rows[0].count + ' booking(s) attached.'
      });
    }
    
    // Safe to delete - remove related records first
    await pool.query('DELETE FROM property_images WHERE property_id = $1', [id]);
    await pool.query('DELETE FROM property_amenities WHERE property_id = $1', [id]);
    await pool.query('DELETE FROM property_policies WHERE property_id = $1', [id]);
    await pool.query('DELETE FROM property_cm_links WHERE property_id = $1', [id]);
    
    // Delete the property
    await pool.query('DELETE FROM properties WHERE id = $1', [id]);
    
    res.json({ success: true, message: 'Property deleted successfully' });
  } catch (error) {
    console.error('Delete error:', error);
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/db/rooms', async (req, res) => {
  const { propertyId } = req.query;
  try {
    const result = await pool.query('SELECT * FROM rooms WHERE property_id = $1 AND active = true', [propertyId]);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get single room by ID
app.get('/api/db/rooms/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Try rooms table first, then bookable_units
    let result = await pool.query('SELECT * FROM rooms WHERE id = $1', [id]);
    
    if (result.rows.length === 0) {
      // Try bookable_units table
      result = await pool.query(`
        SELECT bu.*, p.cm_property_id, p.name as property_name,
               c.external_account_id as integration_account_id,
               c.adapter_code
        FROM bookable_units bu
        JOIN properties p ON p.id = bu.property_id
        LEFT JOIN gas_sync_connections c ON c.account_id = p.account_id
        WHERE bu.id = $1
      `, [id]);
    }
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Smart units endpoint - returns units based on property type
// For multi-unit properties: returns rooms/apartments
// For single-unit properties: returns the property itself as a unit
app.get('/api/db/units', async (req, res) => {
  const { propertyId } = req.query;
  try {
    if (!propertyId) {
      // Return all units across all properties
      const result = await pool.query(`
        SELECT r.*, p.name as property_name, p.property_type
        FROM rooms r
        JOIN properties p ON r.property_id = p.id
        WHERE r.active = true
        ORDER BY p.name, r.name
      `);
      res.json({ success: true, data: result.rows });
      return;
    }
    
    // Get property type first
    const propResult = await pool.query('SELECT * FROM properties WHERE id = $1', [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const property = propResult.rows[0];
    // Normalize property type: lowercase, remove camelCase, remove special chars
    const rawType = property.property_type || '';
    const propertyType = rawType
      .replace(/([a-z])([A-Z])/g, '$1 $2')  // Convert camelCase to spaces
      .replace(/[_-]/g, ' ')                 // Convert underscores/hyphens to spaces
      .toLowerCase()
      .trim();
    
    // =====================================================
    // MULTI-UNIT PROPERTY TYPES (show individual rooms/units)
    // =====================================================
    const multiUnitKeywords = [
      // Hotels & Lodging
      'hotel', 'boutique hotel', 'lifestyle hotel', 'luxury hotel', 'budget hotel',
      'capsule hotel', 'micro hotel', 'city hotel', 'airport hotel', 'resort hotel',
      'spa hotel', 'conference hotel', 'eco hotel', 'heritage hotel', 'historic hotel',
      'themed hotel', 'smart hotel', 'tech hotel',
      // Inns, Guesthouses & Lodges
      'inn', 'country inn', 'coaching inn', 'guest house', 'guesthouse',
      'bed and breakfast', 'bed & breakfast', 'b&b', 'b and b', 'bnb', 'bandb',
      'boutique b&b', 'heritage b&b', 'farm stay b&b',
      'lodge', 'safari lodge', 'game lodge', 'mountain lodge', 'ski lodge', 'beach lodge', 'eco lodge',
      // Hostels & Shared
      'hostel', 'hostel hotel', 'youth hostel', 'backpackers', 'co living', 'coliving', 'pod hostel', 'dormitory',
      // Apartment-Style Multi-Unit
      'aparthotel', 'apart hotel', 'apartment hotel', 'serviced apartments', 'managed apartments',
      'corporate apartments', 'executive apartments', 'extended stay', 'residence hotel', 'condo hotel',
      // Resorts & Complexes
      'resort', 'holiday resort', 'golf resort', 'all inclusive', 'wellness resort',
      'island resort', 'water park resort', 'marina resort',
      // Traditional Multi-Unit
      'motel', 'motor lodge', 'roadside inn', 'ryokan', 'riad', 'pension', 'posada',
      'gite complex', 'gasthaus', 'hacienda', 'palazzo'
    ];
    
    // =====================================================
    // SINGLE-UNIT PROPERTY TYPES (property = bookable unit)
    // =====================================================
    const singleUnitKeywords = [
      // Residential & Urban
      'house', 'entire home', 'apartment', 'flat', 'loft', 'condo', 'condominium', 'duplex', 'penthouse',
      'studio apartment', 'studio flat', 'studio', 'maisonette', 'townhouse', 'brownstone',
      'bungalow', 'terrace house',
      // Luxury & Leisure
      'villa', 'beach villa', 'mountain villa', 'mansion', 'country house', 'manor house',
      'manor', 'estate', 'private island', 'chalet', 'ski chalet', 'lodge cabin',
      // Rural & Traditional
      'cottage', 'farmhouse', 'rural retreat', 'barn conversion', 'barn', 'converted mill',
      'shepherds hut', 'stone cottage', 'alpine chalet',
      'wine estate', 'finca', 'trullo', 'cortijo', 'mas', 'quinta',
      // Compact Living
      'tiny house', 'modular home', 'eco home', 'smart home', 'cube house',
      // Floating & Elevated
      'houseboat', 'floating villa', 'overwater bungalow', 'boathouse', 'boat house',
      'treehouse', 'tree house', 'canopy lodge', 'cliffside cabin',
      // Glamping & Adventure
      'yurt', 'dome', 'geodesic dome', 'safari tent', 'bell tent', 'a frame', 'a frame cabin',
      'pod cabin', 'pod', 'tipi', 'teepee', 'luxury tent', 'glamping', 'jungle lodge',
      // Cultural & Specialty
      'castle', 'chateau', 'palace', 'tower house', 'hanok', 'machiya',
      'cave house', 'cave', 'ice hotel', 'hobbit house', 'igloo'
    ];
    
    // Check property type - multi-unit takes priority
    const isMultiUnit = multiUnitKeywords.some(keyword => propertyType.includes(keyword));
    const isSingleUnit = singleUnitKeywords.some(keyword => propertyType.includes(keyword)) && !isMultiUnit;
    
    // First try to get rooms from the rooms table
    const roomsResult = await pool.query('SELECT * FROM rooms WHERE property_id = $1 AND active = true', [propertyId]);
    
    if (roomsResult.rows.length > 0) {
      // Has rooms/units defined - return them
      res.json({ success: true, data: roomsResult.rows, propertyType: propertyType, rawType: rawType, isMultiUnit: isMultiUnit });
    } else {
      // No rooms in database - return property itself as the bookable unit
      // This works for both single-unit AND multi-unit properties that haven't had rooms added yet
      res.json({ 
        success: true, 
        data: [{
          id: property.id,
          property_id: property.id,
          name: property.name,
          description: property.description,
          is_property_unit: true
        }],
        propertyType: propertyType,
        rawType: rawType,
        isMultiUnit: isMultiUnit,
        isSingleUnit: !isMultiUnit,
        message: isMultiUnit ? 'No rooms configured yet - showing property as unit. Add rooms in the Rooms section.' : 'Single unit property'
      });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/db/rooms', async (req, res) => {
  const { property_id, name, description, max_occupancy, max_adults, max_children, base_price, quantity } = req.body;
  try {
    const result = await pool.query(`INSERT INTO rooms (property_id, name, description, max_occupancy, max_adults, max_children, base_price, quantity) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING *`, [property_id, name, description, max_occupancy, max_adults, max_children, base_price, quantity]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/db/book', async (req, res) => {
  const { property_id, room_id, check_in, check_out, num_adults, num_children, guest_first_name, guest_last_name, guest_email, guest_phone, total_price, guest_address, guest_city, guest_country, guest_postcode } = req.body;
  
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // Property owner ID - hardcode to 1 for now (will need to be dynamic later)
    const propertyOwnerId = 1;
    
    // 1. Create booking in our database (using correct column names)
    const result = await client.query(`
      INSERT INTO bookings (
        property_id, property_owner_id, bookable_unit_id, 
        arrival_date, departure_date, 
        num_adults, num_children, 
        guest_first_name, guest_last_name, guest_email, guest_phone,
        accommodation_price, subtotal, grand_total, 
        status, booking_source, currency
      ) 
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $12, $12, 'confirmed', 'direct', 'USD') 
      RETURNING *
    `, [property_id, propertyOwnerId, room_id, check_in, check_out, num_adults, num_children || 0, guest_first_name, guest_last_name, guest_email, guest_phone, total_price]);
    
    const booking = result.rows[0];
    
    // 2. Get CM IDs for this room
    const roomResult = await client.query(`
      SELECT beds24_room_id, hostaway_listing_id FROM bookable_units WHERE id = $1
    `, [room_id]);
    
    const beds24RoomId = roomResult.rows[0]?.beds24_room_id;
    const hostawayListingId = roomResult.rows[0]?.hostaway_listing_id;
    
    let beds24BookingId = null;
    let hostawayReservationId = null;
    
    // 3a. If room is linked to Beds24, push the booking
    if (beds24RoomId) {
      try {
        // Use property-specific token lookup for GasSync connections
        const accessToken = await getBeds24AccessTokenForProperty(pool, property_id, room_id);
        
        // Build payments array if deposit was paid
        const payments = [];
        if (stripe_payment_intent_id && deposit_amount && parseFloat(deposit_amount) > 0) {
          payments.push({
            description: 'Deposit via Stripe (GAS)',
            amount: parseFloat(deposit_amount),
            status: 'received',
            date: new Date().toISOString().split('T')[0]
          });
        }
        
        const beds24Booking = [{
          roomId: beds24RoomId,
          status: 'confirmed',
          arrival: check_in,
          departure: check_out,
          numAdult: num_adults,
          numChild: num_children || 0,
          firstName: guest_first_name,
          lastName: guest_last_name,
          email: guest_email,
          mobile: guest_phone || '',
          address: guest_address || '',
          city: guest_city || '',
          country: guest_country || '',
          postcode: guest_postcode || '',
          referer: `GAS #${booking.id}`,
          notes: `GAS Booking ID: ${booking.id}`,
          // Price and financial info
          price: parseFloat(total_price) || 0,
          deposit: parseFloat(deposit_amount) || 0,
          // Invoice items
          invoiceItems: [{
            description: 'Accommodation',
            qty: 1,
            amount: parseFloat(total_price) || 0,
            vatRate: 0
          }],
          // Payments if deposit was collected
          ...(payments.length > 0 && { payments })
        }];
        
        console.log('Pushing booking to Beds24:', JSON.stringify(beds24Booking));
        
        const beds24Response = await axios.post('https://beds24.com/api/v2/bookings', beds24Booking, {
          headers: {
            'token': accessToken,
            'Content-Type': 'application/json'
          }
        });
        
        console.log('Beds24 booking response:', JSON.stringify(beds24Response.data));
        
        if (beds24Response.data && beds24Response.data[0]?.success) {
          beds24BookingId = beds24Response.data[0]?.new?.id;
          
          if (beds24BookingId) {
            await client.query(`
              UPDATE bookings SET beds24_booking_id = $1 WHERE id = $2
            `, [beds24BookingId, booking.id]);
            booking.beds24_booking_id = beds24BookingId;
          }
        }
        
      } catch (beds24Error) {
        console.error('Error pushing to Beds24:', beds24Error.response?.data || beds24Error.message);
      }
    }
    
    // 3b. If room is linked to Hostaway, push the booking
    if (hostawayListingId) {
      try {
        const stored = await getStoredHostawayToken(pool);
        
        if (stored && stored.accessToken) {
          const hostawayBooking = {
            listingMapId: hostawayListingId,
            channelId: 2000,  // Direct booking
            source: 'manual',
            arrivalDate: check_in,
            departureDate: check_out,
            guestFirstName: guest_first_name,
            guestLastName: guest_last_name,
            guestEmail: guest_email,
            guestPhone: guest_phone || '',
            guestAddress: guest_address || '',
            guestCity: guest_city || '',
            guestCountry: guest_country || '',
            guestZipCode: guest_postcode || '',
            numberOfGuests: num_adults + (num_children || 0),
            adults: num_adults,
            children: num_children || 0,
            totalPrice: total_price,
            isPaid: 0,
            status: 'new',
            comment: `GAS Booking ID: ${booking.id}`
          };
          
          console.log('Pushing booking to Hostaway:', JSON.stringify(hostawayBooking));
          
          const hostawayResponse = await axios.post('https://api.hostaway.com/v1/reservations', hostawayBooking, {
            headers: {
              'Authorization': `Bearer ${stored.accessToken}`,
              'Content-Type': 'application/json',
              'Cache-control': 'no-cache'
            }
          });
          
          console.log('Hostaway booking response:', JSON.stringify(hostawayResponse.data));
          
          if (hostawayResponse.data.status === 'success' && hostawayResponse.data.result) {
            hostawayReservationId = hostawayResponse.data.result.id;
            
            if (hostawayReservationId) {
              await client.query(`
                UPDATE bookings SET hostaway_reservation_id = $1 WHERE id = $2
              `, [hostawayReservationId, booking.id]);
              booking.hostaway_reservation_id = hostawayReservationId;
            }
          }
        }
        
      } catch (hostawayError) {
        console.error('Error pushing to Hostaway:', hostawayError.response?.data || hostawayError.message);
      }
    }
    
    // 4. Update room availability for these dates
    const startDate = new Date(check_in);
    const endDate = new Date(check_out);
    for (let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      await client.query(`
        INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
        VALUES ($1, $2, false, false, 'booking')
        ON CONFLICT (room_id, date) 
        DO UPDATE SET is_available = false, source = 'booking', updated_at = NOW()
      `, [room_id, dateStr]);
    }
    
    await client.query('COMMIT');
    
    res.json({ 
      success: true, 
      data: booking,
      beds24Synced: !!beds24BookingId,
      beds24BookingId,
      hostawaySynced: !!hostawayReservationId,
      hostawayReservationId
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Booking error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

app.get('/api/db/bookings', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM bookings ORDER BY created_at DESC LIMIT 100');
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check bookings table schema
app.get('/api/admin/debug/rooms-for-property/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(`
      SELECT id, name, property_id, status, beds24_room_id 
      FROM bookable_units 
      WHERE property_id = $1
    `, [id]);
    
    // Also check what property IDs exist
    const allProps = await pool.query(`
      SELECT DISTINCT property_id, COUNT(*) as count 
      FROM bookable_units 
      GROUP BY property_id
    `);
    
    res.json({ 
      success: true, 
      propertyId: id,
      rooms: result.rows,
      allPropertyIds: allProps.rows
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Detailed debug for room images and availability
app.get('/api/admin/debug/room-details/:roomId', async (req, res) => {
  try {
    const { roomId } = req.params;
    
    // Get room
    const room = await pool.query('SELECT * FROM bookable_units WHERE id = $1', [roomId]);
    
    // Get images from room_images
    const images = await pool.query('SELECT * FROM room_images WHERE room_id = $1 ORDER BY display_order', [roomId]);
    
    // Get images from gas_sync_images (if beds24_room_id exists)
    let syncImages = [];
    if (room.rows[0]?.beds24_room_id) {
      const syncImgResult = await pool.query(`
        SELECT * FROM gas_sync_images 
        WHERE room_type_external_id = $1 
        ORDER BY sort_order
      `, [String(room.rows[0].beds24_room_id)]);
      syncImages = syncImgResult.rows;
    }
    
    // Get recent availability
    const availability = await pool.query(`
      SELECT * FROM room_availability 
      WHERE room_id = $1 
      ORDER BY date DESC 
      LIMIT 10
    `, [roomId]);
    
    // Check gas_sync_room_types linkage
    let syncRoomType = null;
    if (room.rows[0]?.beds24_room_id) {
      const syncRtResult = await pool.query(`
        SELECT rt.*, sp.name as property_name, sp.connection_id
        FROM gas_sync_room_types rt
        JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
        WHERE rt.external_id = $1
      `, [String(room.rows[0].beds24_room_id)]);
      syncRoomType = syncRtResult.rows[0] || null;
    }
    
    res.json({
      success: true,
      room: room.rows[0] || null,
      images: images.rows,
      syncImages: syncImages,
      availability: availability.rows,
      syncRoomType: syncRoomType
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Fix missing is_active on room_images
app.post('/api/admin/fix-room-images', async (req, res) => {
  try {
    const result = await pool.query(`
      UPDATE room_images SET is_active = true WHERE is_active IS NULL OR is_active = false
    `);
    res.json({ success: true, updated: result.rowCount });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Copy images from gas_sync_images to room_images for a GAS property
app.post('/api/admin/properties/:propertyId/copy-sync-images', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    // Get all rooms for this property
    const roomsResult = await pool.query(`
      SELECT id, name, beds24_room_id FROM bookable_units WHERE property_id = $1
    `, [propertyId]);
    
    if (roomsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No rooms found for this property' });
    }
    
    let totalCopied = 0;
    let totalSkipped = 0;
    const roomResults = [];
    
    for (const room of roomsResult.rows) {
      // Find images in gas_sync_images matching this room's beds24_room_id
      const syncImages = await pool.query(`
        SELECT * FROM gas_sync_images 
        WHERE room_type_external_id = $1
        ORDER BY sort_order
      `, [String(room.beds24_room_id)]);
      
      let copied = 0;
      let skipped = 0;
      
      for (const img of syncImages.rows) {
        // Check if already exists
        const existing = await pool.query(`
          SELECT id FROM room_images WHERE room_id = $1 AND image_url = $2
        `, [room.id, img.original_url]);
        
        if (existing.rows.length > 0) {
          skipped++;
          continue;
        }
        
        // Insert
        await pool.query(`
          INSERT INTO room_images (room_id, image_key, image_url, thumbnail_url, caption, display_order, upload_source, is_active, is_primary, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, 'beds24_sync', true, $7, NOW())
        `, [
          room.id,
          img.external_id || `beds24-${room.beds24_room_id}-${img.sort_order || 0}`,
          img.original_url,
          img.thumbnail_url || img.original_url,
          img.caption || '',
          img.sort_order || 0,
          img.sort_order === 0
        ]);
        copied++;
      }
      
      totalCopied += copied;
      totalSkipped += skipped;
      roomResults.push({ roomId: room.id, name: room.name, copied, skipped, syncImagesFound: syncImages.rows.length });
    }
    
    res.json({ success: true, totalCopied, totalSkipped, rooms: roomResults });
  } catch (error) {
    console.error('Copy sync images error:', error);
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/admin/debug/bookings-schema', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'bookings'
      ORDER BY ordinal_position
    `);
    res.json({ success: true, columns: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.get('/api/properties', async (req, res) => {
  const result = await beds24Request('/properties');
  res.json(result);
});

app.post('/api/setup-auth', async (req, res) => {
  const { inviteCode } = req.body;
  
  if (!inviteCode) {
    return res.json({ success: false, error: 'Invite code is required' });
  }
  
  try {
    console.log('Attempting to connect to Beds24 with invite code...');
    // Beds24 expects the code as a HEADER, not a URL parameter
    const response = await axios.get('https://beds24.com/api/v2/authentication/setup', {
      headers: {
        'accept': 'application/json',
        'code': inviteCode
      }
    });
    console.log('Beds24 response:', response.data);
    
    res.json({ 
      success: true, 
      refreshToken: response.data.refreshToken,
      token: response.data.token 
    });
  } catch (error) {
    console.error('Beds24 connection error:', error.response?.data || error.message);
    res.json({ 
      success: false, 
      error: error.response?.data?.error || error.message 
    });
  }
});

// =====================================================
// CHANNEL CONNECTIONS - List and Details
// =====================================================

// Get all channel connections for an account
app.get('/api/channel-connections', async (req, res) => {
  try {
    const accountId = req.query.account || req.query.account_id;
    
    let query = `
      SELECT 
        cc.id,
        cc.status,
        cc.gas_account_id as account_id,
        cc.created_at,
        cc.updated_at,
        cm.cm_code,
        cm.cm_name,
        a.name as account_name,
        (SELECT COUNT(*) FROM properties p WHERE 
          (cm.cm_code = 'beds24' AND p.beds24_property_id IS NOT NULL AND p.account_id = cc.gas_account_id) OR
          (cm.cm_code = 'hostaway' AND p.hostaway_listing_id IS NOT NULL AND p.account_id = cc.gas_account_id) OR
          (cm.cm_code = 'smoobu' AND p.smoobu_id IS NOT NULL AND p.account_id = cc.gas_account_id)
        ) as property_count
      FROM channel_connections cc
      JOIN channel_managers cm ON cc.cm_id = cm.id
      LEFT JOIN accounts a ON a.id = cc.gas_account_id
    `;
    
    const params = [];
    if (accountId) {
      query += ' WHERE cc.gas_account_id = $1';
      params.push(parseInt(accountId));
    }
    
    query += ' ORDER BY cc.created_at DESC';
    
    const result = await pool.query(query, params);
    
    res.json({ success: true, connections: result.rows });
  } catch (error) {
    console.error('Error fetching channel connections:', error);
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check channel_connections table
app.get('/api/debug/channel-connections', async (req, res) => {
  try {
    const connections = await pool.query('SELECT * FROM channel_connections');
    const managers = await pool.query('SELECT * FROM channel_managers');
    res.json({ 
      connections: connections.rows, 
      managers: managers.rows 
    });
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Fix channel connections - update account_id and delete bad records
app.get('/api/fix/channel-connections', async (req, res) => {
  try {
    // Fix Beds24 connection (id=2) to point to GAS account 4
    await pool.query('UPDATE channel_connections SET account_id = $1 WHERE id = $2', ['4', 2]);
    
    // Delete Cloudbeds connection (id=23) - shouldn't exist
    await pool.query('DELETE FROM channel_connections WHERE id = $1', [23]);
    
    // Check if Hostaway connection exists for account 3
    const hostawayCheck = await pool.query(
      "SELECT id FROM channel_connections WHERE cm_id = (SELECT id FROM channel_managers WHERE cm_code = 'hostaway')"
    );
    
    // Check if Smoobu connection exists for account 2
    const smoobuCheck = await pool.query(
      "SELECT id FROM channel_connections WHERE cm_id = (SELECT id FROM channel_managers WHERE cm_code = 'smoobu')"
    );
    
    res.json({ 
      success: true, 
      message: 'Fixed Beds24 (account 4), deleted Cloudbeds',
      hostaway_exists: hostawayCheck.rows.length > 0,
      smoobu_exists: smoobuCheck.rows.length > 0
    });
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Fix: Link an account to Beds24 channel connection
app.get('/api/fix/link-beds24/:accountId', async (req, res) => {
  try {
    const { accountId } = req.params;
    
    // Ensure gas_account_id column exists
    await pool.query(`ALTER TABLE channel_connections ADD COLUMN IF NOT EXISTS gas_account_id INTEGER`).catch(() => {});
    
    // Get Beds24 CM ID
    const cmResult = await pool.query("SELECT id FROM channel_managers WHERE cm_code = 'beds24' LIMIT 1");
    if (cmResult.rows.length === 0) {
      return res.json({ success: false, error: 'Beds24 not found in channel_managers' });
    }
    const cmId = cmResult.rows[0].id;
    
    // Find any existing Beds24 connection
    const existing = await pool.query(
      'SELECT id FROM channel_connections WHERE cm_id = $1 LIMIT 1',
      [cmId]
    );
    
    if (existing.rows.length > 0) {
      // Update existing connection to link to this account
      await pool.query(
        'UPDATE channel_connections SET gas_account_id = $1, status = $2, updated_at = NOW() WHERE id = $3',
        [parseInt(accountId), 'active', existing.rows[0].id]
      );
      return res.json({ success: true, message: 'Updated Beds24 connection to account ' + accountId, connectionId: existing.rows[0].id });
    }
    
    // Create new connection if none exists
    const result = await pool.query(`
      INSERT INTO channel_connections (cm_id, user_id, gas_account_id, status, created_at, updated_at)
      VALUES ($1, 1, $2, 'active', NOW(), NOW())
      RETURNING id
    `, [cmId, parseInt(accountId)]);
    
    res.json({ success: true, message: 'Created Beds24 connection for account ' + accountId, connectionId: result.rows[0].id });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Fix: Merge multiple accounts into one (for Beds24 multi-property imports)
// Usage: /api/fix/merge-accounts/NewAccountName
// This will merge all accounts created today with @gas.travel emails into one
app.get('/api/fix/merge-accounts/:newName', async (req, res) => {
  try {
    const { newName } = req.params;
    const decodedName = decodeURIComponent(newName);
    
    // Find all accounts with @gas.travel emails (auto-created ones)
    const autoAccounts = await pool.query(`
      SELECT id, name, email FROM accounts 
      WHERE email LIKE '%@gas.travel' 
      AND role = 'admin'
      ORDER BY id
    `);
    
    if (autoAccounts.rows.length === 0) {
      return res.json({ success: false, error: 'No auto-created accounts found' });
    }
    
    console.log('Found ' + autoAccounts.rows.length + ' auto-created accounts to merge');
    
    // Create new master account or find existing
    let masterAccountId;
    const existingMaster = await pool.query(
      'SELECT id FROM accounts WHERE name = $1',
      [decodedName]
    );
    
    if (existingMaster.rows.length > 0) {
      masterAccountId = existingMaster.rows[0].id;
      console.log('Using existing account: ' + masterAccountId);
    } else {
      const newMaster = await pool.query(`
        INSERT INTO accounts (name, email, role, business_name, status)
        VALUES ($1, $2, 'admin', $1, 'active')
        RETURNING id
      `, [decodedName, decodedName.toLowerCase().replace(/[^a-z0-9]/g, '_') + '@client.gas.travel']);
      masterAccountId = newMaster.rows[0].id;
      console.log('Created new master account: ' + masterAccountId);
    }
    
    // Move all properties to master account
    const accountIds = autoAccounts.rows.map(a => a.id);
    const moveResult = await pool.query(`
      UPDATE properties SET account_id = $1 
      WHERE account_id = ANY($2::int[])
      RETURNING id, name
    `, [masterAccountId, accountIds]);
    
    console.log('Moved ' + moveResult.rows.length + ' properties to account ' + masterAccountId);
    
    // Move bookable_units ownership (if any have account_id)
    await pool.query(`
      UPDATE bookable_units SET account_id = $1 
      WHERE account_id = ANY($2::int[])
    `, [masterAccountId, accountIds]).catch(() => {});
    
    // Update channel connections
    await pool.query(`
      UPDATE channel_connections SET gas_account_id = $1 
      WHERE gas_account_id = ANY($2::int[])
    `, [masterAccountId, accountIds]).catch(() => {});
    
    // Delete the old auto-created accounts (except master if it was one of them)
    const deleteIds = accountIds.filter(id => id !== masterAccountId);
    if (deleteIds.length > 0) {
      await pool.query('DELETE FROM accounts WHERE id = ANY($1::int[])', [deleteIds]);
      console.log('Deleted ' + deleteIds.length + ' old accounts');
    }
    
    res.json({
      success: true,
      masterAccountId,
      masterAccountName: decodedName,
      propertiesMoved: moveResult.rows.length,
      accountsDeleted: deleteIds.length,
      properties: moveResult.rows
    });
    
  } catch (error) {
    console.error('Merge accounts error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Fix: Update account email
// Usage: /api/fix/account-email/AccountName/newemail@example.com
app.get('/api/fix/account-email/:name/:email', async (req, res) => {
  try {
    const { name, email } = req.params;
    const decodedName = decodeURIComponent(name);
    const decodedEmail = decodeURIComponent(email);
    
    const result = await pool.query(
      'UPDATE accounts SET email = $1, updated_at = NOW() WHERE LOWER(name) = LOWER($2) RETURNING id, name, email',
      [decodedEmail, decodedName]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found: ' + decodedName });
    }
    
    res.json({ success: true, account: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add Hostaway connection manually
app.get('/api/fix/add-hostaway/:token/:accountId', async (req, res) => {
  try {
    const { token, accountId } = req.params;
    const gasAccountId = '3'; // Alpine CoHosts
    
    // Get Hostaway CM ID
    const cmResult = await pool.query("SELECT id FROM channel_managers WHERE cm_code = 'hostaway'");
    const cmId = cmResult.rows[0].id;
    
    // Check if connection already exists
    const existing = await pool.query(
      'SELECT id FROM channel_connections WHERE cm_id = $1 AND account_id = $2',
      [cmId, gasAccountId]
    );
    
    if (existing.rows.length > 0) {
      // Update existing
      await pool.query(
        'UPDATE channel_connections SET access_token = $1, api_key = $2, status = $3 WHERE id = $4',
        [token, accountId, 'active', existing.rows[0].id]
      );
      res.json({ success: true, message: 'Updated Hostaway connection', id: existing.rows[0].id });
    } else {
      // Create new
      const result = await pool.query(`
        INSERT INTO channel_connections (cm_id, user_id, account_id, access_token, api_key, status, created_at, updated_at)
        VALUES ($1, 1, $2, $3, $4, 'active', NOW(), NOW())
        RETURNING id
      `, [cmId, gasAccountId, token, accountId]);
      res.json({ success: true, message: 'Created Hostaway connection', id: result.rows[0].id });
    }
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Add Smoobu connection manually
app.get('/api/fix/add-smoobu/:apiKey', async (req, res) => {
  try {
    const { apiKey } = req.params;
    const gasAccountId = '2'; // Elevate Schweiz
    
    // Get Smoobu CM ID
    const cmResult = await pool.query("SELECT id FROM channel_managers WHERE cm_code = 'smoobu'");
    const cmId = cmResult.rows[0].id;
    
    // Check if connection already exists
    const existing = await pool.query(
      'SELECT id FROM channel_connections WHERE cm_id = $1 AND account_id = $2',
      [cmId, gasAccountId]
    );
    
    if (existing.rows.length > 0) {
      // Update existing
      await pool.query(
        'UPDATE channel_connections SET api_key = $1, status = $2 WHERE id = $3',
        [apiKey, 'active', existing.rows[0].id]
      );
      res.json({ success: true, message: 'Updated Smoobu connection', id: existing.rows[0].id });
    } else {
      // Create new
      const result = await pool.query(`
        INSERT INTO channel_connections (cm_id, user_id, account_id, api_key, status, created_at, updated_at)
        VALUES ($1, 1, $2, $3, 'active', NOW(), NOW())
        RETURNING id
      `, [cmId, gasAccountId, apiKey]);
      res.json({ success: true, message: 'Created Smoobu connection', id: result.rows[0].id });
    }
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Check for any stored credentials in database
app.get('/api/debug/find-credentials', async (req, res) => {
  try {
    // Check all channel_connections for any tokens
    const connections = await pool.query(`
      SELECT id, cm_id, account_id, api_key, access_token, refresh_token 
      FROM channel_connections
    `);
    
    // Check if there's a settings or config table
    const tables = await pool.query(`
      SELECT table_name FROM information_schema.tables 
      WHERE table_schema = 'public' AND table_name LIKE '%setting%' OR table_name LIKE '%config%' OR table_name LIKE '%credential%'
    `);
    
    // Check properties for any stored connection info
    const props = await pool.query(`
      SELECT id, name, account_id, hostaway_listing_id, smoobu_id, channel_manager 
      FROM properties 
      WHERE hostaway_listing_id IS NOT NULL OR smoobu_id IS NOT NULL
    `);
    
    res.json({
      connections: connections.rows,
      config_tables: tables.rows,
      cm_properties: props.rows
    });
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Create reviews table
app.get('/api/fix/create-reviews-table', async (req, res) => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS reviews (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE SET NULL,
        external_id VARCHAR(100),
        source VARCHAR(50) NOT NULL DEFAULT 'manual',
        channel_name VARCHAR(100),
        review_type VARCHAR(50) DEFAULT 'guest-to-host',
        reservation_id VARCHAR(100),
        guest_name VARCHAR(255),
        guest_avatar VARCHAR(500),
        guest_country VARCHAR(100),
        rating DECIMAL(3,1),
        title TEXT,
        comment TEXT,
        private_feedback TEXT,
        host_reply TEXT,
        host_reply_at TIMESTAMP,
        review_date DATE,
        stay_date_start DATE,
        stay_date_end DATE,
        is_public BOOLEAN DEFAULT true,
        is_approved BOOLEAN DEFAULT true,
        language VARCHAR(10),
        sub_ratings JSONB,
        raw_data JSONB,
        synced_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(source, external_id)
      )
    `);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_account_id ON reviews(account_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_property_id ON reviews(property_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_source ON reviews(source)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_rating ON reviews(rating)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_reviews_review_date ON reviews(review_date)`);
    
    res.json({ success: true, message: 'Reviews table created successfully' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add review_type column if missing and clear bad data for resync
app.get('/api/fix/update-reviews-table', async (req, res) => {
  try {
    // Add review_type column if it doesn't exist
    await pool.query(`
      ALTER TABLE reviews ADD COLUMN IF NOT EXISTS review_type VARCHAR(50) DEFAULT 'guest-to-host'
    `);
    
    // Delete all hostaway reviews so they can be resynced with correct data
    const deleteResult = await pool.query(`DELETE FROM reviews WHERE source = 'hostaway'`);
    
    res.json({ 
      success: true, 
      message: `Reviews table updated. Deleted ${deleteResult.rowCount} hostaway reviews for resync.`
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Clean up - delete ALL reviews for fresh resync
app.get('/api/fix/delete-all-reviews', async (req, res) => {
  try {
    const deleteResult = await pool.query(`DELETE FROM reviews`);
    res.json({ 
      success: true, 
      message: `Deleted ${deleteResult.rowCount} reviews. Now resync from connection modal.`
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Check client_settings for CM credentials
app.get('/api/debug/client-settings', async (req, res) => {
  try {
    const settings = await pool.query('SELECT * FROM client_settings');
    const websiteSettings = await pool.query('SELECT * FROM website_settings');
    res.json({
      client_settings: settings.rows,
      website_settings: websiteSettings.rows
    });
  } catch (error) {
    res.json({ error: error.message });
  }
});

// Get server's outbound IP address
app.get('/api/debug/server-ip', async (req, res) => {
  try {
    const response = await axios.get('https://api.ipify.org?format=json');
    res.json({ 
      success: true, 
      ip: response.data.ip,
      note: 'Railway IPs can change - consider using a static IP proxy if Beds24 requires fixed IP'
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get single channel connection details (with token for refresh)
app.get('/api/channel-connection/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT 
        cc.*,
        cm.cm_code,
        cm.cm_name
      FROM channel_connections cc
      JOIN channel_managers cm ON cc.cm_id = cm.id
      WHERE cc.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    res.json({ success: true, connection: result.rows[0] });
  } catch (error) {
    console.error('Error fetching channel connection:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// CALRY TEST ENDPOINTS - For testing Calry integration
// =========================================================

// Test Calry connection - just checks if credentials work
app.get('/api/calry/test-connection', async (req, res) => {
  console.log('=== CALRY: TEST CONNECTION ===');
  
  try {
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.json({ 
        success: false, 
        error: 'Calry credentials not configured. Set CALRY_API_TOKEN and CALRY_WORKSPACE_ID environment variables.',
        configured: {
          hasToken: !!CALRY_API_TOKEN,
          hasWorkspaceId: !!CALRY_WORKSPACE_ID
        }
      });
    }
    
    // Test by fetching properties with limit 1
    const response = await axios.get(`${CALRY_API_BASE}/properties`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'Content-Type': 'application/json'
      },
      params: { limit: 1 }
    });
    
    res.json({ 
      success: true, 
      message: 'Calry connection successful',
      propertiesFound: response.data?.data?.length || 0
    });
    
  } catch (error) {
    console.error('Calry connection test failed:', error.response?.data || error.message);
    res.json({ 
      success: false, 
      error: error.response?.data?.message || error.message,
      status: error.response?.status
    });
  }
});

// Get properties from Calry via specific integration account (e.g., Smoobu)
app.get('/api/calry/test-properties/:integrationAccountId', async (req, res) => {
  console.log('=== CALRY: GET PROPERTIES ===');
  
  try {
    const { integrationAccountId } = req.params;
    
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.json({ 
        success: false, 
        error: 'Calry credentials not configured'
      });
    }
    
    console.log('Fetching properties for integration account:', integrationAccountId);
    
    const response = await axios.get(`${CALRY_API_BASE}/properties`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'integrationAccountId': integrationAccountId,
        'Content-Type': 'application/json'
      }
    });
    
    const properties = response.data?.data || [];
    
    console.log(`Found ${properties.length} properties`);
    
    res.json({ 
      success: true,
      integrationAccountId,
      count: properties.length,
      properties: properties.map(p => ({
        id: p.id,
        name: p.name,
        type: p.type,
        status: p.status,
        city: p.address?.city,
        country: p.address?.country,
        currency: p.currency,
        roomTypes: p.roomTypes?.length || 0
      })),
      raw: properties // Include raw data for debugging
    });
    
  } catch (error) {
    console.error('Calry get properties failed:', error.response?.data || error.message);
    res.json({ 
      success: false, 
      error: error.response?.data?.message || error.message,
      status: error.response?.status,
      details: error.response?.data
    });
  }
});

// Get room types for a specific property from Calry
app.get('/api/calry/test-room-types/:integrationAccountId/:propertyId', async (req, res) => {
  console.log('=== CALRY: GET ROOM TYPES ===');
  
  try {
    const { integrationAccountId, propertyId } = req.params;
    
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.json({ 
        success: false, 
        error: 'Calry credentials not configured'
      });
    }
    
    console.log('Fetching room types for property:', propertyId);
    
    const response = await axios.get(`${CALRY_API_BASE}/room-types/${propertyId}`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'integrationAccountId': integrationAccountId,
        'Content-Type': 'application/json'
      }
    });
    
    const roomTypes = response.data?.data || [];
    
    console.log(`Found ${roomTypes.length} room types`);
    
    res.json({ 
      success: true,
      propertyId,
      count: roomTypes.length,
      roomTypes: roomTypes.map(rt => ({
        id: rt.id,
        name: rt.name,
        description: rt.description?.substring(0, 100) + '...',
        bedrooms: rt.bedRoom?.count,
        bathrooms: rt.bathRoom?.count,
        maxOccupancy: rt.maxOccupancy,
        startPrice: rt.startPrice,
        pictures: rt.pictures?.length || 0,
        amenities: rt.amenities?.length || 0
      })),
      raw: roomTypes // Include raw data for debugging
    });
    
  } catch (error) {
    console.error('Calry get room types failed:', error.response?.data || error.message);
    res.json({ 
      success: false, 
      error: error.response?.data?.message || error.message,
      status: error.response?.status,
      details: error.response?.data
    });
  }
});

// List all integration accounts in the workspace
app.get('/api/calry/test-integration-accounts', async (req, res) => {
  console.log('=== CALRY: LIST INTEGRATION ACCOUNTS ===');
  
  try {
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.json({ 
        success: false, 
        error: 'Calry credentials not configured'
      });
    }
    
    // Note: This endpoint might be different - checking Calry docs
    const response = await axios.get('https://prod.calry.app/api/v1/integration-accounts', {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'Content-Type': 'application/json'
      }
    });
    
    res.json({ 
      success: true,
      accounts: response.data
    });
    
  } catch (error) {
    console.error('Calry list integration accounts failed:', error.response?.data || error.message);
    res.json({ 
      success: false, 
      error: error.response?.data?.message || error.message,
      status: error.response?.status
    });
  }
});

// =========================================================
// CALRY IMPORT - Import properties from Calry into GAS
// =========================================================

// Import a single property from Calry into GAS using the adapter
app.post('/api/calry/import-property', async (req, res) => {
  console.log('=== CALRY: IMPORT PROPERTY (using adapter) ===');
  
  try {
    const { 
      integrationAccountId, 
      propertyId, 
      accountId,  // GAS account to import into (optional - creates new if not provided)
      accountName,
      accountEmail 
    } = req.body;
    
    if (!integrationAccountId || !propertyId) {
      return res.status(400).json({ 
        success: false, 
        error: 'integrationAccountId and propertyId are required' 
      });
    }
    
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.json({ success: false, error: 'Calry credentials not configured' });
    }
    
    // 1. Create Calry adapter instance
    const adapter = getAdapter('calry', {
      token: CALRY_API_TOKEN,
      workspaceId: CALRY_WORKSPACE_ID,
      integrationAccountId: integrationAccountId,
      pool: pool,
      useDev: false  // Use prod
    });
    
    // 2. Fetch properties using adapter
    console.log('Fetching properties using Calry adapter');
    const propertiesResult = await adapter.getProperties();
    
    if (!propertiesResult.success) {
      return res.status(500).json({ success: false, error: propertiesResult.error });
    }
    
    const calryProperty = propertiesResult.data.find(p => String(p.externalId) === String(propertyId));
    
    if (!calryProperty) {
      return res.status(404).json({ success: false, error: 'Property not found in Calry' });
    }
    
    // 3. Fetch room types directly from Calry API (not through adapter - more reliable)
    console.log('Fetching room types from Calry');
    let roomTypes = [];
    try {
      const roomResponse = await axios.get(`${CALRY_API_BASE}/room-types/${propertyId}`, {
        headers: {
          'Authorization': `Bearer ${CALRY_API_TOKEN}`,
          'workspaceId': CALRY_WORKSPACE_ID,
          'integrationAccountId': integrationAccountId,
          'Content-Type': 'application/json'
        }
      });
      roomTypes = roomResponse.data?.data || [];
      console.log(`Found ${roomTypes.length} room types`);
    } catch (roomError) {
      console.error('Error fetching room types:', roomError.message);
      // Continue without rooms - we can still create the property
    }
    
    // 4. Create or use existing GAS account
    let gasAccountId = accountId;
    
    if (!gasAccountId) {
      const newAccountName = accountName || calryProperty.name || 'Calry Import';
      const newAccountEmail = accountEmail || `calry-${integrationAccountId}@gas.travel`;
      
      // Check if account already exists for this integration (stored in settings)
      const existingAccount = await pool.query(
        "SELECT id FROM accounts WHERE settings->>'calry_integration_id' = $1",
        [integrationAccountId]
      );
      
      if (existingAccount.rows.length > 0) {
        gasAccountId = existingAccount.rows[0].id;
        console.log('Using existing GAS account:', gasAccountId);
      } else {
        const accountResult = await pool.query(`
          INSERT INTO accounts (name, email, role, status, settings, created_at)
          VALUES ($1, $2, 'admin', 'active', $3, NOW())
          RETURNING id
        `, [newAccountName, newAccountEmail, JSON.stringify({
          calry_integration_id: integrationAccountId,
          cm_source: 'calry'
        })]);
        
        gasAccountId = accountResult.rows[0].id;
        console.log('Created new GAS account:', gasAccountId);
      }
    }
    
    // 5. Create gas_sync_connection for this adapter
    const existingConnection = await pool.query(
      "SELECT id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'calry' AND external_account_id = $2",
      [gasAccountId, integrationAccountId]
    );
    
    let connectionId;
    if (existingConnection.rows.length > 0) {
      connectionId = existingConnection.rows[0].id;
    } else {
      const connResult = await pool.query(`
        INSERT INTO gas_sync_connections (
          account_id, adapter_code, external_account_id, external_account_name,
          credentials, access_token, status, sync_enabled, created_at
        ) VALUES ($1, 'calry', $2, $3, $4, $5, 'connected', true, NOW())
        RETURNING id
      `, [
        gasAccountId,
        integrationAccountId,
        'Smoobu via Calry',
        JSON.stringify({ workspaceId: CALRY_WORKSPACE_ID, integrationAccountId }),
        CALRY_API_TOKEN
      ]);
      connectionId = connResult.rows[0].id;
      console.log('Created gas_sync_connection:', connectionId);
    }
    
    // 6. Import property to database
    const existingProp = await pool.query(
      "SELECT id FROM properties WHERE cm_property_id = $1 AND account_id = $2",
      [String(propertyId), gasAccountId]
    );
    
    let gasPropertyId;
    
    // Log the raw address from Calry for debugging
    console.log('[Calry Sync] Raw address data:', JSON.stringify(calryProperty.address), 'type:', typeof calryProperty.address);
    console.log('[Calry Sync] Raw coordinates:', JSON.stringify(calryProperty.coordinates));
    
    // Parse address - handle JSON string, object, or plain string
    // Adapter outputs: { street, street2, city, state, postalCode, country, countryCode }
    // Plus separate: coordinates: { latitude, longitude }
    let addr = calryProperty.address || {};
    if (typeof addr === 'string') {
      try { addr = JSON.parse(addr); } catch (e) { addr = { street: addr }; }
    }
    
    const parsedAddress = {
      street: addr.street || addr.line1 || addr.address1 || addr.address || '',
      line2: addr.street2 || addr.line2 || addr.address2 || '',
      city: addr.city || '',
      state: addr.state || addr.region || addr.province || '',
      country: addr.country || addr.countryCode || '',
      postal_code: addr.postalCode || addr.postal_code || addr.zipCode || addr.zip || '',
      lat: calryProperty.coordinates?.latitude || calryProperty.coordinates?.lat || addr.coordinates?.lat || calryProperty.latitude || null,
      lng: calryProperty.coordinates?.longitude || calryProperty.coordinates?.lng || calryProperty.coordinates?.lon || addr.coordinates?.lng || calryProperty.longitude || null
    };
    
    // Build full address string (combining line1 + line2)
    parsedAddress.full = [parsedAddress.street, parsedAddress.line2].filter(Boolean).join(', ');
    
    // Geocode if no coordinates provided
    if (!parsedAddress.lat || !parsedAddress.lng) {
      try {
        const geocodeQuery = [parsedAddress.full, parsedAddress.city, parsedAddress.state, parsedAddress.postal_code, parsedAddress.country].filter(Boolean).join(', ');
        console.log('[Calry Sync] Geocoding address:', geocodeQuery);
        const geoResp = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(geocodeQuery)}&format=json&limit=1`, {
          headers: { 'User-Agent': 'GAS-Platform/1.0' }
        });
        const geoData = await geoResp.json();
        if (geoData && geoData.length > 0) {
          parsedAddress.lat = parseFloat(geoData[0].lat);
          parsedAddress.lng = parseFloat(geoData[0].lon);
          console.log(`[Calry Sync] Geocoded to: ${parsedAddress.lat}, ${parsedAddress.lng}`);
        } else {
          console.log('[Calry Sync] Geocoding returned no results');
        }
      } catch (geoErr) {
        console.log('[Calry Sync] Geocoding failed:', geoErr.message);
      }
    }
    
    console.log('[Calry Sync] Parsed address:', JSON.stringify(parsedAddress));
    
    if (existingProp.rows.length > 0) {
      gasPropertyId = existingProp.rows[0].id;
      console.log('Property already exists in GAS:', gasPropertyId);
      
      // SELECTIVE UPDATE: Only update fields that have actual values from the sync
      // Never overwrite existing data with empty/null values
      // Never overwrite descriptions (those are manually curated)
      const updateParts = [];
      const updateValues = [];
      let paramIdx = 1;
      
      // Only update address fields if we have real data
      if (parsedAddress.full) { updateParts.push(`address = $${paramIdx++}`); updateValues.push(parsedAddress.full); }
      if (parsedAddress.city) { updateParts.push(`city = $${paramIdx++}`); updateValues.push(parsedAddress.city); }
      if (parsedAddress.country) { updateParts.push(`country = $${paramIdx++}`); updateValues.push(parsedAddress.country); }
      if (parsedAddress.state) { updateParts.push(`state = $${paramIdx++}`); updateValues.push(parsedAddress.state); }
      if (parsedAddress.postal_code) { updateParts.push(`postal_code = $${paramIdx++}`); updateValues.push(parsedAddress.postal_code); }
      if (parsedAddress.lat) { updateParts.push(`latitude = $${paramIdx++}`); updateValues.push(parsedAddress.lat); }
      if (parsedAddress.lng) { updateParts.push(`longitude = $${paramIdx++}`); updateValues.push(parsedAddress.lng); }
      if (calryProperty.currency) { updateParts.push(`currency = $${paramIdx++}`); updateValues.push(calryProperty.currency); }
      
      if (updateParts.length > 0) {
        updateParts.push('updated_at = NOW()');
        updateValues.push(gasPropertyId);
        await pool.query(
          `UPDATE properties SET ${updateParts.join(', ')} WHERE id = $${paramIdx}`,
          updateValues
        );
        console.log(`[Calry Sync] Updated ${updateParts.length - 1} property fields for ${gasPropertyId}`);
      } else {
        console.log('[Calry Sync] No property fields to update');
      }
    } else {
      const propResult = await pool.query(`
        INSERT INTO properties (
          account_id, user_id, name, address, city, country, state, postal_code,
          latitude, longitude, currency, cm_property_id, cm_source, status, created_at
        ) VALUES ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 'calry', 'active', NOW())
        RETURNING id
      `, [
        gasAccountId,
        calryProperty.name,
        parsedAddress.full,
        parsedAddress.city,
        parsedAddress.country,
        parsedAddress.state,
        parsedAddress.postal_code,
        parsedAddress.lat,
        parsedAddress.lng,
        calryProperty.currency || 'USD',
        String(propertyId)
      ]);
      
      gasPropertyId = propResult.rows[0].id;
      console.log('Created GAS property:', gasPropertyId);
    }
    
    // 7. Also track in gas_sync_properties
    await pool.query(`
      INSERT INTO gas_sync_properties (connection_id, gas_property_id, external_id, name, created_at)
      VALUES ($1, $2, $3, $4, NOW())
      ON CONFLICT (connection_id, external_id) DO UPDATE SET
        gas_property_id = $2, name = $4, updated_at = NOW()
    `, [connectionId, gasPropertyId, String(propertyId), calryProperty.name]);
    
    // 8. Import room types
    const importedRooms = [];
    
    for (const room of roomTypes) {
      const roomExternalId = String(room.id);
      const existingRoom = await pool.query(
        "SELECT id FROM bookable_units WHERE cm_room_id = $1 AND property_id = $2",
        [roomExternalId, gasPropertyId]
      );
      
      let gasRoomId;
      
      // Map Calry raw data to GAS fields
      const roomName = room.name || calryProperty.name;
      const maxGuests = room.maxOccupancy || 2;
      const numBedrooms = room.bedRoom?.count || 1;
      const numBathrooms = room.bathRoom?.count || 1;
      const basePrice = parseFloat(room.startPrice) || 0;
      const description = room.description || '';
      
      if (existingRoom.rows.length > 0) {
        gasRoomId = existingRoom.rows[0].id;
        
        // SELECTIVE UPDATE: Only update structural/pricing data from sync
        // NEVER overwrite full_description, short_description, or display_name
        // Those are manually curated (e.g. AI-generated descriptions)
        const roomUpdates = [];
        const roomVals = [];
        let rIdx = 1;
        
        if (roomName) { roomUpdates.push(`name = $${rIdx++}`); roomVals.push(roomName); }
        if (maxGuests) { roomUpdates.push(`max_guests = $${rIdx++}`); roomVals.push(maxGuests); }
        if (numBedrooms) { roomUpdates.push(`num_bedrooms = $${rIdx++}`); roomVals.push(numBedrooms); }
        if (numBathrooms) { roomUpdates.push(`num_bathrooms = $${rIdx++}`); roomVals.push(numBathrooms); }
        if (basePrice > 0) { roomUpdates.push(`base_price = $${rIdx++}`); roomVals.push(basePrice); }
        if (calryProperty.currency) { roomUpdates.push(`currency = $${rIdx++}`); roomVals.push(calryProperty.currency); }
        
        if (roomUpdates.length > 0) {
          roomUpdates.push('updated_at = NOW()');
          roomVals.push(gasRoomId);
          await pool.query(
            `UPDATE bookable_units SET ${roomUpdates.join(', ')} WHERE id = $${rIdx}`,
            roomVals
          );
        }
        
        console.log('Updated room (preserved descriptions):', gasRoomId);
      } else {
        const roomResult = await pool.query(`
          INSERT INTO bookable_units (
            property_id, name, max_guests, num_bedrooms, num_bathrooms,
            base_price, currency, full_description, cm_room_id, cm_source, status, created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'calry', 'active', NOW())
          RETURNING id
        `, [
          gasPropertyId,
          roomName,
          maxGuests,
          numBedrooms,
          numBathrooms,
          basePrice,
          calryProperty.currency || 'EUR',
          description,
          roomExternalId
        ]);
        
        gasRoomId = roomResult.rows[0].id;
        console.log('Created room:', gasRoomId);
      }
      
      // Import amenities from raw Calry data (skip if amenities table doesn't exist)
      try {
        const amenities = room.amenities || [];
        for (const amenity of amenities) {
          const amenityName = typeof amenity === 'string' ? amenity : (amenity.name || amenity);
          if (!amenityName) continue;
          
          let amenityResult = await pool.query(
            "SELECT id FROM amenities WHERE LOWER(name) = LOWER($1)",
            [amenityName]
          );
          
          let amenityId;
          if (amenityResult.rows.length > 0) {
            amenityId = amenityResult.rows[0].id;
          } else {
            const newAmenity = await pool.query(
              "INSERT INTO amenities (name, created_at) VALUES ($1, NOW()) RETURNING id",
              [amenityName]
            );
            amenityId = newAmenity.rows[0].id;
          }
          
          await pool.query(`
            INSERT INTO room_amenities (room_id, amenity_id)
            VALUES ($1, $2)
            ON CONFLICT DO NOTHING
          `, [gasRoomId, amenityId]);
        }
      } catch (amenityError) {
        console.log('Skipping amenities import (table may not exist):', amenityError.message);
      }
      
      importedRooms.push({
        calry_id: room.id,
        gas_id: gasRoomId,
        name: room.name
      });
    }
    
    res.json({
      success: true,
      message: 'Property imported successfully using Calry adapter',
      data: {
        gas_account_id: gasAccountId,
        gas_property_id: gasPropertyId,
        gas_connection_id: connectionId,
        calry_property_id: propertyId,
        property_name: calryProperty.name,
        rooms_imported: importedRooms.length,
        rooms: importedRooms
      }
    });
    
  } catch (error) {
    console.error('Calry import error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// CALRY LINK WIZARD - Connect PMS via Calry
// =========================================================

// TEMPORARY: Check users table schema
app.get('/api/admin/schema/users', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'users'
      ORDER BY ordinal_position
    `);
    res.json({ success: true, columns: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check Calry link status
app.get('/api/calry/link/status/:linkId', async (req, res) => {
  try {
    const { linkId } = req.params;
    const linkResponse = await axios.get(`https://prod.calry.app/api/v1/link/${linkId}`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    res.json({ success: true, data: linkResponse.data });
  } catch (error) {
    res.json({ success: false, error: error.response?.data || error.message });
  }
});

// =========================================================
// UNIFIED CHANNEL MANAGER WIZARD - Routes through Calry
// =========================================================

// List all supported channel managers
app.get('/api/cm/list', async (req, res) => {
  res.json({
    success: true,
    channel_managers: [
      { code: 'smoobu', name: 'Smoobu', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'beds24', name: 'Beds24', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'hostaway', name: 'Hostaway', auth_type: 'oauth', auth_label: 'OAuth' },
      { code: 'guesty', name: 'Guesty', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'hostfully', name: 'Hostfully', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'lodgify', name: 'Lodgify', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'ownerrez', name: 'OwnerRez', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'hospitable', name: 'Hospitable', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'cloudbeds', name: 'Cloudbeds', auth_type: 'oauth', auth_label: 'OAuth' },
      { code: 'tokeet', name: 'Tokeet', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'uplisting', name: 'Uplisting', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'hostify', name: 'Hostify', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'bookingsync', name: 'BookingSync', auth_type: 'oauth', auth_label: 'OAuth' },
      { code: 'avantio', name: 'Avantio', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'streamline', name: 'Streamline', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'track', name: 'Track', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'mews', name: 'Mews', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'apaleo', name: 'Apaleo', auth_type: 'oauth', auth_label: 'OAuth' },
      { code: 'resly', name: 'Resly', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'escapia', name: 'Escapia', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'zeevou', name: 'Zeevou', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'elina', name: 'Elina', auth_type: 'api_key', auth_label: 'API Key' },
      { code: 'fantasticstay', name: 'FantasticStay', auth_type: 'api_key', auth_label: 'API Key' }
    ]
  });
});

// Unified connect endpoint - creates account and routes to Calry Link
app.post('/api/cm/connect', async (req, res) => {
  console.log('=== UNIFIED CM WIZARD: CONNECT ===');
  
  try {
    const {
      cm_type,        // e.g., 'smoobu', 'beds24', 'guesty'
      name,
      email,
      phone,
      business_name,
      account_id      // Optional - use existing account
    } = req.body;
    
    if (!cm_type) {
      return res.status(400).json({ success: false, error: 'cm_type is required' });
    }
    
    let userId, accountId;
    
    // Use existing account or create new one
    if (account_id) {
      accountId = parseInt(account_id);
      const accountCheck = await pool.query('SELECT id, email FROM accounts WHERE id = $1', [accountId]);
      if (accountCheck.rows.length === 0) {
        return res.status(404).json({ success: false, error: 'Account not found' });
      }
      
      const userCheck = await pool.query('SELECT id FROM users WHERE account_id = $1 OR email = $2', 
        [accountId, accountCheck.rows[0].email]);
      userId = userCheck.rows[0]?.id || 1;
      
    } else {
      // Need email for new accounts
      if (!email) {
        return res.status(400).json({ success: false, error: 'email is required for new accounts' });
      }
      
      // Check if user exists
      const existingUser = await pool.query('SELECT id, account_id FROM users WHERE email = $1', [email]);
      
      if (existingUser.rows.length > 0) {
        userId = existingUser.rows[0].id;
        accountId = existingUser.rows[0].account_id;
        
        if (!accountId) {
          const existingAccount = await pool.query('SELECT id FROM accounts WHERE email = $1', [email]);
          if (existingAccount.rows.length > 0) {
            accountId = existingAccount.rows[0].id;
            await pool.query('UPDATE users SET account_id = $1 WHERE id = $2', [accountId, userId]);
          }
        }
      }
      
      // Create user if needed
      if (!userId) {
        const tempPassword = Math.random().toString(36).substring(2, 15);
        const passwordHash = Buffer.from(tempPassword).toString('base64');
        const nameParts = (name || 'User').split(' ');
        
        const newUser = await pool.query(`
          INSERT INTO users (email, password_hash, first_name, last_name, user_type, account_status, company_name, created_at)
          VALUES ($1, $2, $3, $4, 'property_owner', 'active', $5, NOW())
          RETURNING id
        `, [email, passwordHash, nameParts[0], nameParts.slice(1).join(' ') || '', business_name || '']);
        
        userId = newUser.rows[0].id;
        console.log(`[CM Wizard] Created user ${userId}`);
      }
      
      // Create account if needed
      if (!accountId) {
        const accountApiKey = 'gas_' + crypto.randomBytes(28).toString('hex');
        
        const newAccount = await pool.query(`
          INSERT INTO accounts (name, email, contact_name, phone, business_name, api_key, api_key_created_at, status, settings, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, NOW(), 'active', $7, NOW())
          RETURNING id
        `, [
          business_name || name || 'New Account',
          email,
          name || null,
          phone || null,
          business_name || name || '',
          accountApiKey,
          JSON.stringify({ cm_source: cm_type, user_id: userId, created_by: 'cm_wizard' })
        ]);
        
        accountId = newAccount.rows[0].id;
        await pool.query('UPDATE users SET account_id = $1 WHERE id = $2', [accountId, userId]);
        console.log(`[CM Wizard] Created account ${accountId}`);
      }
    }
    
    // Generate Calry Link for this CM
    const accountIdentifier = `gas-${accountId}-${Date.now()}`;
    const redirectUrl = `https://api.gas.travel/api/calry/link/callback?account=${accountIdentifier}&gas_account_id=${accountId}`;
    
    // Create link via Calry API
    const linkResponse = await axios.post('https://prod.calry.app/api/v1/link', {
      integrationDefinitionKey: cm_type,
      expiresIn: 3600,
      linkName: `GAS ${cm_type} Link ${accountIdentifier}`,
      workspaceId: CALRY_WORKSPACE_ID,
      accountIdentifier: accountIdentifier,
      redirectUrl: redirectUrl
    }, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const linkData = linkResponse.data;
    console.log(`[CM Wizard] Created Calry Link: ${linkData.linkId}`);
    
    // Store link session
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS calry_link_sessions (
          link_id VARCHAR(255) PRIMARY KEY,
          account_identifier VARCHAR(255) NOT NULL,
          gas_account_id INTEGER,
          created_at TIMESTAMP DEFAULT NOW()
        )
      `);
      await pool.query(
        'INSERT INTO calry_link_sessions (link_id, account_identifier, gas_account_id) VALUES ($1, $2, $3) ON CONFLICT (link_id) DO UPDATE SET gas_account_id = $3',
        [linkData.linkId, accountIdentifier, accountId]
      );
    } catch (dbError) {
      console.log('Could not store link session:', dbError.message);
    }
    
    const calryLinkUrl = `https://prod.calry.app/link/${linkData.linkId}`;
    
    res.json({
      success: true,
      account_id: accountId,
      user_id: userId,
      cm_type: cm_type,
      link_url: calryLinkUrl,
      link_id: linkData.linkId,
      message: `Account created. Redirect user to link_url to connect ${cm_type}.`
    });
    
  } catch (error) {
    console.error('CM Wizard connect error:', error.response?.data || error.message);
    res.status(500).json({ 
      success: false, 
      error: error.response?.data?.message || error.message 
    });
  }
});

// Check connection status
app.get('/api/cm/status/:accountId', async (req, res) => {
  try {
    const { accountId } = req.params;
    
    // Check for Calry connections
    const connections = await pool.query(`
      SELECT id, adapter_code, status, created_at, last_sync_at,
             credentials->>'integrationAccountId' as integration_account_id
      FROM gas_sync_connections 
      WHERE account_id = $1
      ORDER BY created_at DESC
    `, [accountId]);
    
    // Get property count
    const properties = await pool.query(
      'SELECT COUNT(*) as count FROM properties WHERE account_id = $1',
      [accountId]
    );
    
    res.json({
      success: true,
      account_id: parseInt(accountId),
      connections: connections.rows,
      property_count: parseInt(properties.rows[0].count)
    });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Step 1: Start the Calry Link flow - creates a link and returns URL
app.get('/api/calry/link/start', async (req, res) => {
  console.log('=== CALRY LINK: START ===');
  
  try {
    const { account_id, pms, final_redirect } = req.query;
    
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.status(500).json({ 
        success: false, 
        error: 'Calry credentials not configured' 
      });
    }
    
    // Generate a unique account identifier for this link
    const accountIdentifier = `gas-${account_id || 'new'}-${Date.now()}`;
    
    // We need the linkId in the redirect URL, but we don't have it until after creation.
    // Solution: Use accountIdentifier to look up the link on callback
    const redirectUrl = `https://api.gas.travel/api/calry/link/callback?account=${accountIdentifier}&gas_account_id=${account_id || ''}&final_redirect=${encodeURIComponent(final_redirect || '')}`;
    
    // Create link via Calry API
    const linkResponse = await axios.post('https://prod.calry.app/api/v1/link', {
      integrationDefinitionKey: pms || 'smoobu',
      expiresIn: 3600,
      linkName: `GAS Link ${accountIdentifier}`,
      workspaceId: CALRY_WORKSPACE_ID,
      accountIdentifier: accountIdentifier,
      redirectUrl: redirectUrl
    }, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const linkData = linkResponse.data;
    console.log('Calry Link created:', linkData);
    
    // Store linkId -> accountIdentifier mapping in database for callback lookup
    try {
      await pool.query(`
        CREATE TABLE IF NOT EXISTS calry_link_sessions (
          link_id VARCHAR(255) PRIMARY KEY,
          account_identifier VARCHAR(255) NOT NULL,
          gas_account_id INTEGER,
          created_at TIMESTAMP DEFAULT NOW()
        )
      `);
      await pool.query(
        'INSERT INTO calry_link_sessions (link_id, account_identifier, gas_account_id) VALUES ($1, $2, $3)',
        [linkData.linkId, accountIdentifier, account_id || null]
      );
      console.log('Stored link session:', linkData.linkId, '->', accountIdentifier);
    } catch (dbError) {
      console.log('Could not store link session:', dbError.message);
    }
    
    // User visits the link page on prod
    const calryLinkUrl = `https://prod.calry.app/link/${linkData.linkId}`;
    
    res.json({
      success: true,
      link_url: calryLinkUrl,
      link_id: linkData.linkId,
      account_identifier: accountIdentifier,
      status: linkData.status,
      expires_in: linkData.expiresIn
    });
    
  } catch (error) {
    console.error('Calry Link start error:', error.response?.data || error.message);
    res.status(500).json({ 
      success: false, 
      error: error.response?.data?.message || error.message 
    });
  }
});

// List available PMS integrations
app.get('/api/calry/integrations', async (req, res) => {
  res.json({
    success: true,
    integrations: [
      { key: 'smoobu', name: 'Smoobu' },
      { key: 'beds24', name: 'Beds24' },
      { key: 'hostaway', name: 'Hostaway' },
      { key: 'guesty', name: 'Guesty' },
      { key: 'hostfully', name: 'Hostfully' },
      { key: 'lodgify', name: 'Lodgify' },
      { key: 'ownerrez', name: 'OwnerRez' },
      { key: 'hospitable', name: 'Hospitable' },
      { key: 'cloudbeds', name: 'Cloudbeds' },
      { key: 'tokeet', name: 'Tokeet' },
      { key: 'uplisting', name: 'Uplisting' },
      { key: 'hostify', name: 'Hostify' },
      { key: 'bookingsync', name: 'BookingSync' },
      { key: 'avantio', name: 'Avantio' },
      { key: 'streamline', name: 'Streamline' },
      { key: 'track', name: 'Track' },
      { key: 'mews', name: 'Mews' },
      { key: 'apaleo', name: 'Apaleo' },
      { key: 'elina', name: 'Elina' },
      { key: 'resly', name: 'Resly' },
      { key: 'fantasticstay', name: 'FantasticStay' },
      { key: 'escapia', name: 'Escapia' },
      { key: 'zeevou', name: 'Zeevou' }
    ]
  });
});

// Step 2: Callback from Calry Link after user connects their PMS (linkId in path)
app.get('/api/calry/link/callback/:linkId', async (req, res) => {
  console.log('=== CALRY LINK: CALLBACK WITH LINK ID ===');
  const { linkId } = req.params;
  console.log('Link ID from path:', linkId);
  
  try {
    // Fetch the link to get the integrationAccountId
    const linkResponse = await axios.get(`https://prod.calry.app/api/v1/link/${linkId}`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const linkData = linkResponse.data;
    console.log('Link status:', linkData.status);
    console.log('Integration accounts:', linkData.integrationAccounts);
    
    if (linkData.status !== 'SUCCEEDED') {
      return res.redirect(`https://admin.gas.travel/connections?error=Connection not completed (status: ${linkData.status})`);
    }
    
    // Get the integrationAccountId from the link
    const integrationAccount = linkData.integrationAccounts?.[0];
    if (!integrationAccount?.integrationAccountId) {
      return res.redirect('https://admin.gas.travel/connections?error=No integration account found');
    }
    
    const intAccountId = integrationAccount.integrationAccountId;
    const pmsName = integrationAccount.integrationDefinitionName || 'PMS';
    console.log(`Integration account: ${intAccountId} (${pmsName})`);
    
    // Use adapter-based import - handles all properties in one call
    console.log(`Starting adapter import for ${pmsName}...`);
    const importResults = await importCalryPropertiesViaAdapter(intAccountId, pmsName, null);
    
    const successCount = importResults.properties_imported;
    const totalRooms = importResults.rooms_imported;
    const gasAccountId = importResults.gas_account_id;
    
    console.log(`Import complete: ${successCount} properties, ${totalRooms} rooms`);
    
    // Generate auto-login session token so user lands logged into their own account
    let autoLoginToken = '';
    try {
      autoLoginToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
      await pool.query(`
        CREATE TABLE IF NOT EXISTS account_sessions (
          id SERIAL PRIMARY KEY, account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
          token VARCHAR(255) UNIQUE NOT NULL, expires_at TIMESTAMP NOT NULL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, ip_address VARCHAR(45), user_agent TEXT
        )
      `);
      await pool.query(
        'INSERT INTO account_sessions (account_id, token, expires_at, ip_address, user_agent) VALUES ($1, $2, $3, $4, $5)',
        [gasAccountId, autoLoginToken, expiresAt, req.ip, req.get('User-Agent')]
      );
    } catch (tokenErr) { console.error('Auto-login token error:', tokenErr.message); }
    
    // Redirect to success page with auto-login token
    res.redirect(`https://admin.gas.travel/connections?calry_connected=true&pms=${encodeURIComponent(pmsName)}&properties_imported=${successCount}&rooms_imported=${totalRooms}&integration_id=${intAccountId}&account_id=${gasAccountId}&auto_token=${autoLoginToken}`);
    
  } catch (error) {
    console.error('Calry Link callback error:', error.response?.data || error.message);
    res.redirect(`https://admin.gas.travel/connections?error=${encodeURIComponent(error.message)}`);
  }
});

// Step 2 (fallback): Callback without linkId in path - use accountIdentifier
app.get('/api/calry/link/callback', async (req, res) => {
  console.log('=== CALRY LINK: CALLBACK (accountIdentifier lookup) ===');
  console.log('Query params:', req.query);
  
  try {
    const { account, gas_account_id, final_redirect } = req.query;
    
    if (!account) {
      return res.send(`
        <html>
          <head><title>Calry Connection</title></head>
          <body>
            <h1>Connection Received</h1>
            <p>Parameters received:</p>
            <pre>${JSON.stringify(req.query, null, 2)}</pre>
            <p>Missing account identifier.</p>
            <p><a href="https://admin.gas.travel/connections">Return to GAS Admin</a></p>
          </body>
        </html>
      `);
    }
    
    // Look up linkId from our stored session
    let linkId = null;
    let gasAccountId = gas_account_id ? parseInt(gas_account_id) : null;
    
    try {
      const sessionResult = await pool.query(
        'SELECT link_id, gas_account_id FROM calry_link_sessions WHERE account_identifier = $1',
        [account]
      );
      if (sessionResult.rows.length > 0) {
        linkId = sessionResult.rows[0].link_id;
        if (!gasAccountId) {
          gasAccountId = sessionResult.rows[0].gas_account_id;
        }
        console.log('Found linkId from session:', linkId, 'gas_account_id:', gasAccountId);
      }
    } catch (dbError) {
      console.log('Could not look up link session:', dbError.message);
    }
    
    if (!linkId) {
      return res.redirect(`https://admin.gas.travel/connections?error=Link session not found for ${account}`);
    }
    
    // Fetch the link details to get integrationAccountId
    const linkResponse = await axios.get(`https://prod.calry.app/api/v1/link/${linkId}`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    
    const linkData = linkResponse.data;
    console.log('Link status:', linkData.status);
    
    if (linkData.status !== 'SUCCEEDED') {
      return res.redirect(`https://admin.gas.travel/connections?error=Connection not completed (status: ${linkData.status})`);
    }
    
    // Get the integrationAccountId from the link
    const integrationAccount = linkData.integrationAccounts?.[0];
    if (!integrationAccount?.integrationAccountId) {
      return res.redirect('https://admin.gas.travel/connections?error=No integration account found in link');
    }
    
    const intAccountId = integrationAccount.integrationAccountId;
    const pmsName = integrationAccount.integrationDefinitionName || 'PMS';
    const pmsKey = integrationAccount.integrationDefinitionKey || 'unknown';
    console.log(`Integration account: ${intAccountId} (${pmsName})`);
    
    // Use adapter-based import - handles all properties in one call
    console.log(`Starting adapter import for ${pmsName}...`);
    const importResults = await importCalryPropertiesViaAdapter(intAccountId, pmsName, gasAccountId);
    
    const successCount = importResults.properties_imported;
    const totalRooms = importResults.rooms_imported;
    const finalAccountId = importResults.gas_account_id;
    
    console.log(`Import complete: ${successCount} properties, ${totalRooms} rooms`);
    if (importResults.errors.length > 0) {
      console.log('Import errors:', importResults.errors);
    }
    
    // Clean up session
    try {
      await pool.query('DELETE FROM calry_link_sessions WHERE link_id = $1', [linkId]);
    } catch (e) {}
    
    // Register webhooks for this integration account
    let webhookRegistered = false;
    try {
      const webhookResult = await registerCalryWebhooks(intAccountId, finalAccountId);
      webhookRegistered = webhookResult.success;
      console.log('Webhook registration:', webhookResult.success ? 'SUCCESS' : webhookResult.error);
    } catch (webhookError) {
      console.error('Webhook registration failed:', webhookError.message);
    }
    
    // Build redirect URL with results
    const resultParams = `calry_connected=true&pms=${encodeURIComponent(pmsName)}&properties_imported=${successCount}&rooms_imported=${totalRooms}&integration_id=${intAccountId}&account_id=${finalAccountId}&webhooks=${webhookRegistered ? 'registered' : 'pending'}`;
    
    // Generate auto-login session token so user lands logged into their own account
    let autoLoginToken = null;
    try {
      autoLoginToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
      await pool.query(`
        CREATE TABLE IF NOT EXISTS account_sessions (
          id SERIAL PRIMARY KEY,
          account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
          token VARCHAR(255) UNIQUE NOT NULL,
          expires_at TIMESTAMP NOT NULL,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          ip_address VARCHAR(45),
          user_agent TEXT
        )
      `);
      await pool.query(
        'INSERT INTO account_sessions (account_id, token, expires_at, ip_address, user_agent) VALUES ($1, $2, $3, $4, $5)',
        [finalAccountId, autoLoginToken, expiresAt, req.ip, req.get('User-Agent')]
      );
      console.log(`Auto-login token created for account ${finalAccountId}`);
    } catch (tokenErr) {
      console.error('Auto-login token error:', tokenErr.message);
    }
    
    // Use custom final_redirect if provided, otherwise default to admin
    let redirectTo;
    const tokenParam = autoLoginToken ? `&auto_token=${autoLoginToken}` : '';
    if (final_redirect) {
      const separator = final_redirect.includes('?') ? '&' : '?';
      redirectTo = `${decodeURIComponent(final_redirect)}${separator}${resultParams}${tokenParam}`;
    } else {
      redirectTo = `https://admin.gas.travel/connections?${resultParams}${tokenParam}`;
    }
    
    res.redirect(redirectTo);
    
  } catch (error) {
    console.error('Calry Link callback error:', error.response?.data || error.message);
    res.redirect(`https://admin.gas.travel/connections?error=${encodeURIComponent(error.response?.data?.message || error.message)}`);
  }
});


/**
 * Import Calry properties using the adapter pattern
 * Works for ALL Calry-based PMS: Lodgify, Guesty, Cloudbeds, Smoobu, etc.
 */
async function importCalryPropertiesViaAdapter(integrationAccountId, pmsName, existingAccountId = null) {
  console.log(`=== CALRY ADAPTER IMPORT: ${pmsName} (${integrationAccountId}) ===`);
  
  // Ensure gas_sync_properties has all required columns for adapter
  try {
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS address TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS city TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS country TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS postal_code TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS latitude DECIMAL(10,7)');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS longitude DECIMAL(10,7)');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS currency VARCHAR(3)');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS description TEXT');
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS raw_data JSONB');
    console.log('gas_sync_properties columns verified');
  } catch (migErr) {
    console.log('Column migration note:', migErr.message);
  }
  
  const results = {
    gas_account_id: null,
    gas_connection_id: null,
    properties_imported: 0,
    rooms_imported: 0,
    properties: [],
    errors: []
  };
  
  try {
    let gasAccountId = existingAccountId;
    
    if (gasAccountId) {
      const accountCheck = await pool.query('SELECT id, name FROM accounts WHERE id = $1', [gasAccountId]);
      if (accountCheck.rows.length === 0) {
        console.log(`Warning: Account ${gasAccountId} not found, will create new`);
        gasAccountId = null;
      } else {
        console.log(`Using existing account: ${gasAccountId}`);
      }
    }
    
    if (!gasAccountId) {
      const existingAccount = await pool.query(
        "SELECT id, name FROM accounts WHERE email LIKE $1",
        [`calry-${integrationAccountId}%@gas.travel`]
      );
      if (existingAccount.rows.length > 0) {
        gasAccountId = existingAccount.rows[0].id;
        console.log(`Found existing account: ${gasAccountId}`);
      }
    }
    
    let connectionId = null;
    if (gasAccountId) {
      const existingConn = await pool.query(
        "SELECT id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'calry' AND external_account_id = $2",
        [gasAccountId, integrationAccountId]
      );
      if (existingConn.rows.length > 0) {
        connectionId = existingConn.rows[0].id;
        console.log(`Using existing connection: ${connectionId}`);
      }
    }
    
    const adapter = getAdapter('calry', {
      token: CALRY_API_TOKEN,
      workspaceId: CALRY_WORKSPACE_ID,
      integrationAccountId: integrationAccountId,
      pmsType: pmsName.toLowerCase(),
      pool: pool,
      connectionId: connectionId,
      useDev: false
    });
    
    console.log('Fetching properties via adapter...');
    const propertiesResult = await adapter.getProperties();
    
    if (!propertiesResult.success) {
      throw new Error(`Failed to fetch properties: ${propertiesResult.error}`);
    }
    
    const properties = propertiesResult.data || [];
    console.log(`Found ${properties.length} properties from ${pmsName}`);
    
    if (properties.length === 0) {
      results.errors.push('No properties found');
      return results;
    }
    
    if (!gasAccountId) {
      const firstProp = properties[0];
      const accountResult = await pool.query(`
        INSERT INTO accounts (name, email, role, status, created_at)
        VALUES ($1, $2, 'admin', 'active', NOW()) RETURNING id
      `, [firstProp.name || `${pmsName} Import`, `calry-${integrationAccountId}-${Date.now()}@gas.travel`]);
      gasAccountId = accountResult.rows[0].id;
      console.log(`Created account: ${gasAccountId}`);
    }
    results.gas_account_id = gasAccountId;
    
    if (!connectionId) {
      const connResult = await pool.query(`
        INSERT INTO gas_sync_connections (
          account_id, adapter_code, external_account_id, external_account_name,
          credentials, access_token, status, sync_enabled, created_at
        ) VALUES ($1, 'calry', $2, $3, $4, $5, 'connected', true, NOW()) RETURNING id
      `, [gasAccountId, integrationAccountId, `${pmsName} via Calry`,
          JSON.stringify({ workspaceId: CALRY_WORKSPACE_ID, integrationAccountId, pmsType: pmsName }), CALRY_API_TOKEN]);
      connectionId = connResult.rows[0].id;
      console.log(`Created connection: ${connectionId}`);
    }
    results.gas_connection_id = connectionId;
    adapter.connectionId = connectionId;
    
    for (const property of properties) {
      try {
        console.log(`\nProcessing: ${property.name} (${property.externalId})`);
        
        // Fetch FULL property details (includes images, amenities, etc.)
        let fullProperty = property;
        try {
          const fullPropResult = await adapter.getProperty(property.externalId);
          if (fullPropResult.success && fullPropResult.data) {
            fullProperty = fullPropResult.data;
            console.log(`  Fetched full details: ${fullProperty.images?.length || 0} images, ${fullProperty.amenities?.length || 0} amenities`);
          }
        } catch (detailErr) {
          console.log(`  Could not fetch full details: ${detailErr.message}`);
        }
        
        const syncPropertyId = await adapter.syncPropertyToDatabase(fullProperty);
        console.log(`  Synced to staging: ${syncPropertyId}`);
        
        let roomsForProperty = 0;
        // Use direct API call - adapter has wrong URL (/vrs/properties/id/room-types vs /room-types/id)
        let roomTypesResult = { success: false, data: [] };
        try {
          const roomResponse = await axios.get(`${CALRY_API_BASE}/room-types/${property.externalId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId,
              'Content-Type': 'application/json'
            }
          });
          const rawRoomTypes = roomResponse.data?.data || [];
          
          // Log first room type to see all available fields
          if (rawRoomTypes.length > 0) {
            console.log(`  Calry room type fields: ${Object.keys(rawRoomTypes[0]).join(', ')}`);
          }
          
          roomTypesResult = {
            success: true,
            data: rawRoomTypes.map(rt => ({
              externalId: String(rt.id),
              name: rt.name,
              // Display name / internal name
              displayName: rt.displayName || rt.internalName || rt.title || '',
              // Descriptions
              shortDescription: rt.shortDescription || rt.summary || rt.tagline || '',
              description: rt.description || rt.longDescription || '',
              // Room type classification
              roomType: rt.roomType || rt.type || rt.category || '',
              // Capacity
              maxGuests: rt.maxOccupancy || rt.maxGuests || rt.capacity || 2,
              maxAdults: rt.maxAdults || rt.adultsMax || null,
              maxChildren: rt.maxChildren || rt.childrenMax || 0,
              // Layout
              bedrooms: rt.bedRoom?.count || rt.bedrooms || rt.bedroomCount || 1,
              bathrooms: rt.bathRoom?.count || rt.bathrooms || rt.bathroomCount || 1,
              beds: rt.beds || rt.bedCount || null,
              // Size
              sizeSqm: rt.size || rt.sizeSqm || rt.squareMeters || rt.area || null,
              // Pricing
              basePrice: rt.startPrice || rt.basePrice || rt.price || 0,
              currency: fullProperty.currency || rt.currency || 'EUR',
              // Images
              images: (rt.pictures || rt.images || rt.photos || []).map((pic, idx) => ({
                url: typeof pic === 'string' ? pic : (pic.url || pic.original),
                caption: typeof pic === 'object' ? (pic.description || pic.caption || '') : '',
                order: idx,
                isPrimary: idx === 0
              })),
              // Amenities
              amenities: (rt.amenities || []).map(a => typeof a === 'string' ? a : (a.name || a.title || a)),
              // Store raw data for future use
              raw: rt
            }))
          };
          console.log(`  Fetched ${roomTypesResult.data.length} room types from Calry`);
        } catch (rtErr) {
          console.log(`  Room types fetch error: ${rtErr.message}`);
        }
        
        console.log(`  getRoomTypes result: success=${roomTypesResult.success}, count=${roomTypesResult.data?.length || 0}`);
        if (roomTypesResult.success && roomTypesResult.data?.length > 0) {
          // Ensure gas_sync_room_types has all required columns and constraints
          await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS bedrooms INTEGER').catch(() => {});
          await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS bathrooms INTEGER').catch(() => {});
          await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS raw_data JSONB').catch(() => {});
          await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS max_guests INTEGER').catch(() => {});
          await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS base_price DECIMAL(10,2)').catch(() => {});
          await pool.query('ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS currency VARCHAR(3)').catch(() => {});
          // Add unique constraint for upsert
          await pool.query('CREATE UNIQUE INDEX IF NOT EXISTS gas_sync_room_types_prop_ext_idx ON gas_sync_room_types(sync_property_id, external_id)').catch(() => {});
          
          for (const roomType of roomTypesResult.data) {
            try {
              console.log(`  Syncing room type: ${roomType.name} (${roomType.externalId})`);
              
              // Check if room type already exists
              const existingRoom = await pool.query(
                'SELECT id FROM gas_sync_room_types WHERE sync_property_id = $1 AND external_id = $2',
                [syncPropertyId, roomType.externalId]
              );
              
              let roomSyncResult;
              if (existingRoom.rows.length > 0) {
                // Update existing
                roomSyncResult = await pool.query(`
                  UPDATE gas_sync_room_types SET
                    name = $1, max_guests = $2, base_price = $3, currency = $4,
                    bedrooms = $5, bathrooms = $6, raw_data = $7, updated_at = NOW()
                  WHERE sync_property_id = $8 AND external_id = $9
                  RETURNING id
                `, [
                  roomType.name,
                  roomType.maxGuests || 2,
                  roomType.basePrice || 0,
                  roomType.currency || 'EUR',
                  roomType.bedrooms || 1,
                  roomType.bathrooms || 1,
                  JSON.stringify(roomType.raw || roomType),
                  syncPropertyId,
                  roomType.externalId
                ]);
              } else {
                // Insert new
                roomSyncResult = await pool.query(`
                  INSERT INTO gas_sync_room_types (
                    sync_property_id, connection_id, external_id, name,
                    max_guests, base_price, currency,
                    bedrooms, bathrooms, raw_data, created_at
                  ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
                  RETURNING id
                `, [
                  syncPropertyId,
                  connectionId,
                  roomType.externalId,
                  roomType.name,
                  roomType.maxGuests || 2,
                  roomType.basePrice || 0,
                  roomType.currency || 'EUR',
                  roomType.bedrooms || 1,
                  roomType.bathrooms || 1,
                  JSON.stringify(roomType.raw || roomType)
                ]);
              }
              
              console.log(`  Room synced to staging: ${roomSyncResult.rows[0]?.id}`);
              roomsForProperty++;
            } catch (e) { 
              console.log(`  Room sync error: ${e.message}`); 
            }
          }
          console.log(`  Synced ${roomsForProperty} rooms`);
        } else {
          console.log(`  No room types found or fetch failed`);
        }
        
        const linkResult = await linkSyncPropertyToGasInternal(syncPropertyId, gasAccountId, fullProperty);
        
        if (linkResult.success) {
          results.properties_imported++;
          results.rooms_imported += linkResult.rooms_created || 0;
          results.properties.push({
            calry_id: property.externalId,
            name: property.name,
            gas_property_id: linkResult.gas_property_id,
            rooms: linkResult.rooms_created || 0
          });
          console.log(`  ‚úì Linked: ${linkResult.gas_property_id}`);
          
          triggerInitialCalrySyncInternal(connectionId, linkResult.gas_property_id, property.externalId, integrationAccountId)
            .catch(() => {});
        } else {
          results.errors.push(`${property.name}: ${linkResult.error}`);
        }
      } catch (propError) {
        results.errors.push(`${property.name}: ${propError.message}`);
      }
    }
    
    console.log(`\n=== COMPLETE: ${results.properties_imported}/${properties.length} properties ===`);
    return results;
  } catch (error) {
    console.error('Adapter import error:', error);
    results.errors.push(error.message);
    return results;
  }
}

async function linkSyncPropertyToGasInternal(syncPropertyId, accountId, calryProperty) {
  try {
    const syncProp = await pool.query(`
      SELECT sp.*, c.external_account_id FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id WHERE sp.id = $1
    `, [syncPropertyId]);
    
    if (syncProp.rows.length === 0) return { success: false, error: 'Not found' };
    
    const prop = syncProp.rows[0];
    const rawData = typeof prop.raw_data === 'string' ? JSON.parse(prop.raw_data) : (prop.raw_data || {});
    
    // Log what we're getting from Calry for debugging
    console.log(`linkSyncPropertyToGas: Property ${prop.name}`);
    console.log(`  calryProperty keys: ${calryProperty ? Object.keys(calryProperty).join(', ') : 'null'}`);
    console.log(`  rawData keys: ${Object.keys(rawData).join(', ')}`);
    
    let gasPropertyId;
    const existingProp = await pool.query(
      "SELECT id FROM properties WHERE cm_property_id = $1 AND account_id = $2",
      [prop.external_id, accountId]
    );
    
    // Build comprehensive property data from all available sources
    const cp = calryProperty || {};
    
    // Parse address - could be object or JSON string
    let addr = cp.address || {};
    if (typeof addr === 'string') {
      try { addr = JSON.parse(addr); } catch (e) { addr = {}; }
    }
    
    // Log exactly what we're working with
    console.log('[linkSync] cp.address type:', typeof cp.address, 'value:', JSON.stringify(cp.address));
    console.log('[linkSync] addr parsed:', JSON.stringify(addr));
    console.log('[linkSync] cp.coordinates:', JSON.stringify(cp.coordinates));
    console.log('[linkSync] prop (staging):', JSON.stringify({ address: prop.address, city: prop.city, country: prop.country, lat: prop.latitude, lng: prop.longitude }));
    
    // Map address fields - handle ALL known field names from Calry/adapter
    const propData = {
      name: prop.name || cp.name || 'Imported Property',
      display_name: cp.displayName || cp.name || prop.name || '',
      address: addr.line1 || addr.street || addr.address1 || addr.addressLine1 || prop.address || '',
      city: addr.city || prop.city || '',
      state: addr.state || addr.region || '',
      country: addr.country || addr.countryCode || prop.country || '',
      postal_code: addr.postal_code || addr.postalCode || addr.zipCode || prop.postal_code || '',
      latitude: cp.coordinates?.latitude || cp.coordinates?.lat || prop.latitude || null,
      longitude: cp.coordinates?.longitude || cp.coordinates?.lng || prop.longitude || null,
      currency: prop.currency || cp.currency || 'EUR',
      // Text fields
      short_description: cp.shortDescription || cp.summary || rawData.shortDescription || '',
      full_description: cp.description || cp.longDescription || rawData.description || '',
      house_rules: cp.houseRules || cp.rules || rawData.houseRules || '',
      cancellation_policy: cp.cancellationPolicy || rawData.cancellationPolicy || '',
      check_in_instructions: cp.checkInInstructions || cp.arrivalInstructions || '',
      check_out_instructions: cp.checkOutInstructions || cp.departureInstructions || '',
      // Times
      check_in_time: cp.checkInTime || cp.checkinTime || rawData.checkInTime || '',
      check_out_time: cp.checkOutTime || cp.checkoutTime || rawData.checkOutTime || '',
      // Capacity
      max_guests: cp.maxGuests || cp.maxOccupancy || rawData.maxGuests || null,
      bedrooms: cp.bedrooms || cp.bedroomCount || rawData.bedrooms || null,
      bathrooms: cp.bathrooms || cp.bathroomCount || rawData.bathrooms || null,
      // Type
      property_type: cp.propertyType || cp.type || rawData.propertyType || 'vacation_rental',
      // Contact
      contact_email: cp.contactEmail || cp.email || '',
      contact_phone: cp.contactPhone || cp.phone || cp.telephone || '',
      website: cp.website || cp.websiteUrl || ''
    };
    
    // Geocode if no coordinates provided
    if (!propData.latitude || !propData.longitude) {
      try {
        const geoQuery = [propData.address, propData.city, propData.state, propData.postal_code, propData.country].filter(Boolean).join(', ');
        if (geoQuery) {
          console.log(`  Geocoding: ${geoQuery}`);
          const geoResp = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(geoQuery)}&format=json&limit=1`, {
            headers: { 'User-Agent': 'GAS-Platform/1.0' }
          });
          const geoData = await geoResp.json();
          if (geoData && geoData.length > 0) {
            propData.latitude = parseFloat(geoData[0].lat);
            propData.longitude = parseFloat(geoData[0].lon);
            console.log(`  Geocoded to: ${propData.latitude}, ${propData.longitude}`);
          }
        }
      } catch (geoErr) {
        console.log(`  Geocoding failed: ${geoErr.message}`);
      }
    }
    
    console.log(`  Mapped address: ${propData.address}, ${propData.city}, ${propData.state}, ${propData.country} ${propData.postal_code}`);
    console.log(`  Mapped coords: ${propData.latitude}, ${propData.longitude}`);
    console.log(`  Mapped: ${propData.city}, ${propData.country} | ${propData.bedrooms}BR/${propData.bathrooms}BA | max ${propData.max_guests} guests`);
    
    if (existingProp.rows.length > 0) {
      gasPropertyId = existingProp.rows[0].id;
      
      // SELECTIVE UPDATE for existing properties:
      // Only update address/location/structural fields
      // NEVER overwrite descriptions, display_name, house_rules etc - those are manually curated
      const pu = [];
      const pv = [];
      let pi = 1;
      
      // Always update name from PMS
      pu.push(`name = $${pi++}`); pv.push(propData.name);
      // Address fields - only if we have data
      if (propData.address) { pu.push(`address = $${pi++}`); pv.push(propData.address); }
      if (propData.city) { pu.push(`city = $${pi++}`); pv.push(propData.city); }
      if (propData.state) { pu.push(`state = $${pi++}`); pv.push(propData.state); }
      if (propData.country) { pu.push(`country = $${pi++}`); pv.push(propData.country); }
      if (propData.postal_code) { pu.push(`postal_code = $${pi++}`); pv.push(propData.postal_code); }
      if (propData.latitude) { pu.push(`latitude = $${pi++}`); pv.push(propData.latitude); }
      if (propData.longitude) { pu.push(`longitude = $${pi++}`); pv.push(propData.longitude); }
      if (propData.currency) { pu.push(`currency = $${pi++}`); pv.push(propData.currency); }
      // Structural from PMS
      if (propData.check_in_time) { pu.push(`check_in_time = $${pi++}`); pv.push(propData.check_in_time); }
      if (propData.check_out_time) { pu.push(`check_out_time = $${pi++}`); pv.push(propData.check_out_time); }
      if (propData.property_type) { pu.push(`property_type = $${pi++}`); pv.push(propData.property_type); }
      
      pu.push('updated_at = NOW()');
      pv.push(gasPropertyId);
      await pool.query(`UPDATE properties SET ${pu.join(', ')} WHERE id = $${pi}`, pv);
      console.log(`  Updated existing property (preserved descriptions): ${gasPropertyId}`);
    } else {
      const propResult = await pool.query(`
        INSERT INTO properties (
          account_id, user_id, name, display_name, address, city, state, country, postal_code,
          latitude, longitude, currency, short_description, full_description, house_rules,
          cancellation_policy, check_in_instructions, check_out_instructions, check_in_time, check_out_time,
          max_guests, bedrooms, bathrooms, property_type, contact_email, contact_phone, website,
          cm_property_id, cm_source, status, created_at
        ) VALUES ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, 'calry', 'active', NOW()) 
        RETURNING id
      `, [accountId, propData.name, propData.display_name, propData.address, propData.city, propData.state,
          propData.country, propData.postal_code, propData.latitude, propData.longitude, propData.currency,
          propData.short_description, propData.full_description, propData.house_rules, propData.cancellation_policy,
          propData.check_in_instructions, propData.check_out_instructions, propData.check_in_time, propData.check_out_time,
          propData.max_guests, propData.bedrooms, propData.bathrooms, propData.property_type,
          propData.contact_email, propData.contact_phone, propData.website, prop.external_id]);
      gasPropertyId = propResult.rows[0].id;
      console.log(`  Created new property: ${gasPropertyId}`);
    }
    
    await pool.query('UPDATE gas_sync_properties SET gas_property_id=$1 WHERE id=$2', [gasPropertyId, syncPropertyId]);
    
    // ============ SYNC ROOMS ============
    let roomsCreated = 0;
    const syncRooms = await pool.query('SELECT * FROM gas_sync_room_types WHERE sync_property_id=$1', [syncPropertyId]);
    
    for (const room of syncRooms.rows) {
      try {
        const roomRawData = typeof room.raw_data === 'string' ? JSON.parse(room.raw_data) : (room.raw_data || {});
        
        // Build comprehensive room data from raw Calry data
        const roomData = {
          name: room.name || roomRawData.name || 'Room',
          display_name: roomRawData.displayName || roomRawData.internalName || roomRawData.title || '',
          short_description: roomRawData.shortDescription || roomRawData.summary || roomRawData.tagline || '',
          full_description: roomRawData.description || roomRawData.longDescription || '',
          room_type: roomRawData.roomType || roomRawData.type || roomRawData.category || '',
          max_guests: room.max_guests || roomRawData.maxOccupancy || roomRawData.maxGuests || roomRawData.capacity || 2,
          max_adults: roomRawData.maxAdults || roomRawData.adultsMax || null,
          max_children: roomRawData.maxChildren || roomRawData.childrenMax || 0,
          base_price: room.base_price || roomRawData.startPrice || roomRawData.basePrice || roomRawData.price || 0,
          currency: room.currency || propData.currency || 'EUR',
          bedrooms: room.bedrooms || roomRawData.bedRoom?.count || roomRawData.bedrooms || roomRawData.bedroomCount || 1,
          bathrooms: room.bathrooms || roomRawData.bathRoom?.count || roomRawData.bathrooms || roomRawData.bathroomCount || 1,
          beds: roomRawData.beds || roomRawData.bedCount || null,
          size_sqm: roomRawData.size || roomRawData.sizeSqm || roomRawData.squareMeters || roomRawData.area || null
        };
        
        console.log(`  Room: ${roomData.name} | display: ${roomData.display_name || '(none)'} | type: ${roomData.room_type || '(none)'} | ${roomData.bedrooms}BR/${roomData.bathrooms}BA, max ${roomData.max_guests}`);
        
        const existingRoom = await pool.query(
          "SELECT id FROM bookable_units WHERE cm_room_id=$1 AND property_id=$2", [room.external_id, gasPropertyId]
        );
        let gasRoomId;
        if (existingRoom.rows.length > 0) {
          gasRoomId = existingRoom.rows[0].id;
          // SELECTIVE UPDATE: Only structural/pricing data from PMS
          // NEVER overwrite display_name, short_description, full_description - those are manually curated
          await pool.query(`
            UPDATE bookable_units SET 
              name=$1, max_guests=$2, base_price=$3, currency=$4, 
              bedrooms=$5, bathrooms=$6,
              room_type=$7, max_adults=$8, max_children=$9, beds=$10, size_sqm=$11,
              updated_at=NOW() 
            WHERE id=$12`,
            [roomData.name, roomData.max_guests, roomData.base_price, roomData.currency,
             roomData.bedrooms, roomData.bathrooms,
             roomData.room_type, roomData.max_adults, roomData.max_children, roomData.beds, roomData.size_sqm, gasRoomId]);
        } else {
          const roomResult = await pool.query(`
            INSERT INTO bookable_units (
              property_id, name, display_name, max_guests, base_price, currency, 
              bedrooms, bathrooms, short_description, full_description,
              room_type, max_adults, max_children, beds, size_sqm,
              cm_room_id, cm_source, status, created_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, 'calry', 'active', NOW()) 
            RETURNING id
          `, [gasPropertyId, roomData.name, roomData.display_name, roomData.max_guests, roomData.base_price, roomData.currency,
              roomData.bedrooms, roomData.bathrooms, roomData.short_description, roomData.full_description,
              roomData.room_type, roomData.max_adults, roomData.max_children, roomData.beds, roomData.size_sqm, room.external_id]);
          gasRoomId = roomResult.rows[0].id;
        }
        await pool.query('UPDATE gas_sync_room_types SET gas_room_id=$1 WHERE id=$2', [gasRoomId, room.id]);
        
        // Sync room images
        const roomImages = roomRawData.pictures || roomRawData.images || [];
        for (let i = 0; i < Math.min(roomImages.length, 20); i++) {
          const img = roomImages[i];
          const imageUrl = typeof img === 'string' ? img : (img.url || img.original);
          if (!imageUrl) continue;
          const imageKey = `calry_${gasRoomId}_${i}`;
          try {
            // Check if image exists first
            const existingImg = await pool.query(
              'SELECT id FROM room_images WHERE room_id = $1 AND image_key = $2',
              [gasRoomId, imageKey]
            );
            if (existingImg.rows.length > 0) {
              await pool.query(
                'UPDATE room_images SET image_url = $1, updated_at = NOW() WHERE id = $2',
                [imageUrl, existingImg.rows[0].id]
              );
            } else {
              await pool.query(`
                INSERT INTO room_images (room_id, image_key, image_url, display_order, is_primary, is_active, created_at)
                VALUES ($1, $2, $3, $4, $5, true, NOW())
              `, [gasRoomId, imageKey, imageUrl, i, i === 0]);
            }
          } catch(imgErr) { 
            console.log(`  Room image error: ${imgErr.message}`);
          }
        }
        
        // Sync room amenities
        const roomAmenities = roomRawData.amenities || [];
        for (const amenity of roomAmenities) {
          const amenityName = typeof amenity === 'string' ? amenity : (amenity.name || amenity.title);
          if (!amenityName) continue;
          try {
            // Find or create amenity
            let amenityId;
            const existingAmenity = await pool.query(
              "SELECT id FROM amenities WHERE LOWER(name) = LOWER($1) LIMIT 1", [amenityName]
            );
            if (existingAmenity.rows.length > 0) {
              amenityId = existingAmenity.rows[0].id;
            } else {
              const newAmenity = await pool.query(
                "INSERT INTO amenities (name, created_at) VALUES ($1, NOW()) ON CONFLICT DO NOTHING RETURNING id", [amenityName]
              );
              if (newAmenity.rows.length > 0) {
                amenityId = newAmenity.rows[0].id;
              }
            }
            if (amenityId) {
              await pool.query(`
                INSERT INTO room_amenity_selections (room_id, amenity_id, created_at)
                VALUES ($1, $2, NOW()) ON CONFLICT DO NOTHING
              `, [gasRoomId, amenityId]);
            }
          } catch(amenErr) { /* ignore */ }
        }
        
        roomsCreated++;
      } catch(e) { console.log(`Room link error: ${e.message}`); }
    }
    
    // Create default room if none found - but check for existing first
    if (roomsCreated === 0 && (cp.maxGuests || cp.bedrooms)) {
      try {
        // Check if a default room already exists for this property
        const existingDefault = await pool.query(
          "SELECT id FROM bookable_units WHERE property_id = $1 AND (cm_room_id = $2 OR cm_room_id IS NULL) LIMIT 1",
          [gasPropertyId, prop.external_id]
        );
        
        if (existingDefault.rows.length > 0) {
          // Update existing default room
          await pool.query(`
            UPDATE bookable_units SET 
              name=$1, max_guests=$2, base_price=$3, currency=$4, bedrooms=$5, bathrooms=$6, 
              cm_room_id=$7, cm_source='calry', updated_at=NOW()
            WHERE id=$8
          `, [propData.name, cp.maxGuests || 4, cp.basePrice || 0, propData.currency, 
              cp.bedrooms || 1, cp.bathrooms || 1, prop.external_id, existingDefault.rows[0].id]);
          roomsCreated = 1;
          console.log(`  Updated existing default room: ${existingDefault.rows[0].id}`);
        } else {
          const defaultRoom = await pool.query(`
            INSERT INTO bookable_units (property_id, name, max_guests, base_price, currency, bedrooms, bathrooms, cm_room_id, cm_source, status, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'calry', 'active', NOW()) RETURNING id
          `, [gasPropertyId, propData.name, cp.maxGuests || 4, cp.basePrice || 0, propData.currency, 
              cp.bedrooms || 1, cp.bathrooms || 1, prop.external_id]);
          roomsCreated = 1;
          console.log(`  Created default room: ${defaultRoom.rows[0].id}`);
        }
      } catch(e) { console.log(`  Default room error: ${e.message}`); }
    }
    
    // ============ SYNC PROPERTY IMAGES ============
    const images = cp.images || cp.pictures || cp.photos || rawData.images || [];
    console.log(`  Syncing ${images.length} property images`);
    for (let i = 0; i < Math.min(images.length, 30); i++) {
      const img = images[i];
      const imageUrl = typeof img === 'string' ? img : (img.url || img.original || img.large);
      const caption = typeof img === 'object' ? (img.caption || img.description || img.alt || '') : '';
      if (!imageUrl) continue;
      const imageKey = `calry_${gasPropertyId}_${i}`;
      try {
        // Check if image exists first
        const existingImg = await pool.query(
          'SELECT id FROM property_images WHERE property_id = $1 AND image_key = $2',
          [gasPropertyId, imageKey]
        );
        if (existingImg.rows.length > 0) {
          await pool.query(
            'UPDATE property_images SET image_url = $1, url = $1, caption = $2, updated_at = NOW() WHERE id = $3',
            [imageUrl, caption, existingImg.rows[0].id]
          );
        } else {
          await pool.query(`
            INSERT INTO property_images (property_id, image_key, image_url, url, caption, display_order, is_primary, is_active, created_at)
            VALUES ($1, $2, $3, $3, $4, $5, $6, true, NOW())
          `, [gasPropertyId, imageKey, imageUrl, caption, i, i === 0]);
        }
      } catch(e) {
        console.log(`  Property image error: ${e.message}`);
      }
    }
    
    // ============ SYNC PROPERTY AMENITIES ============
    const propertyAmenities = cp.amenities || rawData.amenities || [];
    console.log(`  Syncing ${propertyAmenities.length} property amenities`);
    for (const amenity of propertyAmenities) {
      const amenityName = typeof amenity === 'string' ? amenity : (amenity.name || amenity.title);
      if (!amenityName) continue;
      try {
        let amenityId;
        const existingAmenity = await pool.query(
          "SELECT id FROM amenities WHERE LOWER(name) = LOWER($1) LIMIT 1", [amenityName]
        );
        if (existingAmenity.rows.length > 0) {
          amenityId = existingAmenity.rows[0].id;
        } else {
          const newAmenity = await pool.query(
            "INSERT INTO amenities (name, created_at) VALUES ($1, NOW()) ON CONFLICT DO NOTHING RETURNING id", [amenityName]
          );
          if (newAmenity.rows.length > 0) {
            amenityId = newAmenity.rows[0].id;
          }
        }
        if (amenityId) {
          await pool.query(`
            INSERT INTO property_amenities (property_id, amenity_id, created_at)
            VALUES ($1, $2, NOW()) ON CONFLICT DO NOTHING
          `, [gasPropertyId, amenityId]);
        }
      } catch(amenErr) { /* ignore */ }
    }
    
    console.log(`  ‚úì Complete: property ${gasPropertyId}, ${roomsCreated} rooms, ${images.length} images, ${propertyAmenities.length} amenities`);
    return { success: true, gas_property_id: gasPropertyId, rooms_created: roomsCreated };
  } catch (error) {
    console.error(`linkSyncPropertyToGas error:`, error);
    return { success: false, error: error.message };
  }
}

async function triggerInitialCalrySyncInternal(connectionId, gasPropertyId, calryPropertyId, integrationAccountId) {
  try {
    const roomsResult = await pool.query(
      'SELECT id, cm_room_id FROM bookable_units WHERE property_id=$1 AND cm_room_id IS NOT NULL', [gasPropertyId]
    );
    if (roomsResult.rows.length === 0) return;
    
    // Get cm_property_id for the availability calls (FIXED: need propertyId for URL path)
    const propCmResult = await pool.query('SELECT cm_property_id FROM properties WHERE id = $1', [gasPropertyId]);
    const cmPropertyId = propCmResult.rows[0]?.cm_property_id;
    if (!cmPropertyId) {
      console.log(`No cm_property_id found for property ${gasPropertyId}`);
      return;
    }
    
    const adapter = getAdapter('calry', {
      token: CALRY_API_TOKEN, workspaceId: CALRY_WORKSPACE_ID, integrationAccountId,
      pool, connectionId, useDev: false
    });
    
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    for (const room of roomsResult.rows) {
      try {
        // FIXED: Pass propertyId AND roomTypeId to adapter
        const availResult = await adapter.getAvailability(cmPropertyId, room.cm_room_id, startDate, endDate);
        if (availResult.success && availResult.data) {
          await adapter.syncAvailabilityToDatabase(room.cm_room_id, availResult.data);
        }
      } catch(e) {}
    }
    console.log(`Initial sync complete for property ${gasPropertyId}`);
  } catch (error) {
    console.log('triggerInitialCalrySyncInternal:', error.message);
  }
}

async function importCalryPropertyHelper(integrationAccountId, propertyId, existingAccountId = null) {
  console.log(`=== importCalryPropertyHelper: Using adapter pattern ===`);
  const results = await importCalryPropertiesViaAdapter(integrationAccountId, 'PMS', existingAccountId);
  
  if (results.properties.length > 0) {
    const prop = results.properties.find(p => String(p.calry_id) === String(propertyId)) || results.properties[0];
    return {
      gas_account_id: results.gas_account_id,
      gas_property_id: prop.gas_property_id,
      gas_connection_id: results.gas_connection_id,
      rooms_imported: prop.rooms || 0,
      images_imported: 0
    };
  }
  throw new Error(results.errors.join(', ') || 'No properties found');
}

// =====================================================
// CALRY ADMIN API ENDPOINTS
// =====================================================

// Get Calry credentials
app.get('/api/admin/calry/credentials', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT setting_value FROM admin_settings WHERE setting_key = 'calry_credentials'
    `);
    
    if (result.rows.length > 0) {
      const credentials = JSON.parse(result.rows[0].setting_value);
      res.json({ success: true, credentials });
    } else {
      res.json({ success: true, credentials: null });
    }
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Save Calry credentials
app.post('/api/admin/calry/credentials', async (req, res) => {
  try {
    const { api_token, workspace_id } = req.body;
    
    // Ensure admin_settings table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS admin_settings (
        id SERIAL PRIMARY KEY,
        setting_key VARCHAR(100) UNIQUE NOT NULL,
        setting_value TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const credentials = JSON.stringify({ api_token, workspace_id });
    
    await pool.query(`
      INSERT INTO admin_settings (setting_key, setting_value, updated_at)
      VALUES ('calry_credentials', $1, NOW())
      ON CONFLICT (setting_key) DO UPDATE SET setting_value = $1, updated_at = NOW()
    `, [credentials]);
    
    // Also update environment-style config
    global.CALRY_API_TOKEN = api_token;
    global.CALRY_WORKSPACE_ID = workspace_id;
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Test Calry connection
app.get('/api/admin/calry/test-connection', async (req, res) => {
  try {
    // Get credentials from admin_settings
    const credsResult = await pool.query(`
      SELECT setting_value FROM admin_settings WHERE setting_key = 'calry_credentials'
    `);
    
    if (credsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No Calry credentials configured' });
    }
    
    const creds = JSON.parse(credsResult.rows[0].setting_value);
    
    // Test connection by making a simple API call
    // We'll just verify the token works by checking the response
    const response = await axios.get('https://prod.calry.app/api/v2/vrs/properties', {
      headers: {
        'Authorization': `Bearer ${creds.api_token}`,
        'workspaceId': creds.workspace_id
      },
      timeout: 15000
    });
    
    // If we get here without error, connection works
    // Count PMS integrations we have stored
    const pmsCount = await pool.query(`SELECT COUNT(*) FROM calry_pms_integrations`).catch(() => ({ rows: [{ count: 0 }] }));
    
    res.json({ 
      success: true, 
      message: 'Calry API connection successful!',
      pms_count: parseInt(pmsCount.rows[0]?.count || 0)
    });
  } catch (error) {
    console.error('Calry test connection error:', error.response?.data || error.message);
    res.json({ success: false, error: error.response?.data?.message || error.message });
  }
});

// Get PMS integrations
app.get('/api/admin/calry/pms-integrations', async (req, res) => {
  try {
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS calry_pms_integrations (
        id SERIAL PRIMARY KEY,
        pms_type VARCHAR(50) NOT NULL,
        integration_account_id VARCHAR(100) NOT NULL UNIQUE,
        account_name VARCHAR(200),
        gas_account_id INTEGER,
        status VARCHAR(20) DEFAULT 'active',
        property_count INTEGER DEFAULT 0,
        last_sync TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const result = await pool.query(`
      SELECT * FROM calry_pms_integrations ORDER BY created_at DESC
    `);
    
    res.json({ success: true, integrations: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add PMS integration
app.post('/api/admin/calry/pms-integrations', async (req, res) => {
  try {
    const { pms_type, integration_account_id, account_name, gas_account_id } = req.body;
    
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS calry_pms_integrations (
        id SERIAL PRIMARY KEY,
        pms_type VARCHAR(50) NOT NULL,
        integration_account_id VARCHAR(100) NOT NULL UNIQUE,
        account_name VARCHAR(200),
        gas_account_id INTEGER,
        status VARCHAR(20) DEFAULT 'active',
        property_count INTEGER DEFAULT 0,
        last_sync TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const result = await pool.query(`
      INSERT INTO calry_pms_integrations (pms_type, integration_account_id, account_name, gas_account_id)
      VALUES ($1, $2, $3, $4)
      RETURNING id
    `, [pms_type, integration_account_id, account_name, gas_account_id]);
    
    // Also create a gas_sync_connection for this integration
    if (gas_account_id) {
      await pool.query(`
        INSERT INTO gas_sync_connections (account_id, adapter_code, external_account_id, status, created_at)
        VALUES ($1, 'calry', $2, 'active', NOW())
        ON CONFLICT DO NOTHING
      `, [gas_account_id, integration_account_id]);
    }
    
    res.json({ success: true, id: result.rows[0].id });
  } catch (error) {
    if (error.code === '23505') {
      res.json({ success: false, error: 'This Integration Account ID already exists' });
    } else {
      res.json({ success: false, error: error.message });
    }
  }
});

// Sync PMS integration (fetch properties from Calry)
app.post('/api/admin/calry/pms-integrations/:id/sync', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get the integration
    const integResult = await pool.query(`SELECT * FROM calry_pms_integrations WHERE id = $1`, [id]);
    if (integResult.rows.length === 0) {
      return res.json({ success: false, error: 'Integration not found' });
    }
    
    const integration = integResult.rows[0];
    
    // Get Calry credentials
    const credsResult = await pool.query(`
      SELECT setting_value FROM admin_settings WHERE setting_key = 'calry_credentials'
    `);
    
    if (credsResult.rows.length === 0) {
      return res.json({ success: false, error: 'Calry credentials not configured' });
    }
    
    const creds = JSON.parse(credsResult.rows[0].setting_value);
    
    // Fetch properties from Calry for this integration account
    const response = await axios.get('https://prod.calry.app/api/v2/vrs/properties', {
      headers: {
        'Authorization': `Bearer ${creds.api_token}`,
        'workspaceId': creds.workspace_id,
        'integrationAccountId': integration.integration_account_id
      },
      timeout: 30000
    });
    
    const properties = response.data?.data || response.data || [];
    
    // Ensure calry_properties table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS calry_properties (
        id SERIAL PRIMARY KEY,
        pms_integration_id INTEGER REFERENCES calry_pms_integrations(id),
        calry_property_id VARCHAR(100) NOT NULL,
        name VARCHAR(300),
        pms_type VARCHAR(50),
        gas_property_id INTEGER,
        raw_data JSONB,
        last_sync TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(pms_integration_id, calry_property_id)
      )
    `);
    
    // Store properties
    for (const prop of properties) {
      await pool.query(`
        INSERT INTO calry_properties (pms_integration_id, calry_property_id, name, pms_type, raw_data, last_sync)
        VALUES ($1, $2, $3, $4, $5, NOW())
        ON CONFLICT (pms_integration_id, calry_property_id) 
        DO UPDATE SET name = $3, raw_data = $5, last_sync = NOW()
      `, [id, String(prop.id), prop.name, integration.pms_type, JSON.stringify(prop)]);
    }
    
    // Update property count
    await pool.query(`
      UPDATE calry_pms_integrations SET property_count = $1, last_sync = NOW() WHERE id = $2
    `, [properties.length, id]);
    
    res.json({ success: true, properties_found: properties.length });
  } catch (error) {
    console.error('Sync PMS error:', error.response?.data || error.message);
    res.json({ success: false, error: error.response?.data?.message || error.message });
  }
});

// Delete PMS integration
app.delete('/api/admin/calry/pms-integrations/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Delete associated properties first
    await pool.query(`DELETE FROM calry_properties WHERE pms_integration_id = $1`, [id]);
    
    // Delete the integration
    await pool.query(`DELETE FROM calry_pms_integrations WHERE id = $1`, [id]);
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get Calry properties
app.get('/api/admin/calry/properties', async (req, res) => {
  try {
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS calry_properties (
        id SERIAL PRIMARY KEY,
        pms_integration_id INTEGER,
        calry_property_id VARCHAR(100) NOT NULL,
        name VARCHAR(300),
        pms_type VARCHAR(50),
        gas_property_id INTEGER,
        raw_data JSONB,
        last_sync TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `).catch(() => {});
    
    const result = await pool.query(`
      SELECT cp.*, cpi.pms_type 
      FROM calry_properties cp
      LEFT JOIN calry_pms_integrations cpi ON cpi.id = cp.pms_integration_id
      ORDER BY cp.name
    `);
    
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Sync individual Calry property (availability/pricing)
app.post('/api/admin/calry/properties/:id/sync', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get property details
    const propResult = await pool.query(`
      SELECT cp.*, cpi.integration_account_id 
      FROM calry_properties cp
      JOIN calry_pms_integrations cpi ON cpi.id = cp.pms_integration_id
      WHERE cp.id = $1
    `, [id]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const prop = propResult.rows[0];
    
    // Get Calry credentials
    const credsResult = await pool.query(`
      SELECT setting_value FROM admin_settings WHERE setting_key = 'calry_credentials'
    `);
    
    if (credsResult.rows.length === 0) {
      return res.json({ success: false, error: 'Calry credentials not configured' });
    }
    
    const creds = JSON.parse(credsResult.rows[0].setting_value);
    
    // Get room types for this property
    const roomTypesResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/room-types/${prop.calry_property_id}`, {
      headers: {
        'Authorization': `Bearer ${creds.api_token}`,
        'workspaceId': creds.workspace_id,
        'integrationAccountId': prop.integration_account_id
      },
      timeout: 30000
    });
    
    const roomTypes = roomTypesResponse.data?.data || roomTypesResponse.data || [];
    
    if (roomTypes.length === 0) {
      return res.json({ success: false, error: 'No room types found for this property' });
    }
    
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    let totalDaysUpdated = 0;
    
    for (const roomType of roomTypes) {
      // Fetch availability
      const availResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${prop.calry_property_id}`, {
        headers: {
          'Authorization': `Bearer ${creds.api_token}`,
          'workspaceId': creds.workspace_id,
          'integrationAccountId': prop.integration_account_id
        },
        params: { startDate, endDate, roomTypeId: String(roomType.id), rates: 'true' },
        timeout: 30000
      });
      
      const responseData = availResponse.data?.data || availResponse.data || {};
      const availData = responseData.dateWiseAvailability || responseData.data || [];
      
      if (prop.gas_property_id && Array.isArray(availData)) {
        // Find GAS room
        const roomResult = await pool.query(`
          SELECT id FROM bookable_units WHERE property_id = $1 LIMIT 1
        `, [prop.gas_property_id]);
        
        const gasRoomId = roomResult.rows[0]?.id;
        
        if (gasRoomId) {
          for (const day of availData) {
            if (!day.date) continue;
            
            let price = null;
            if (day.price?.amount !== undefined) {
              price = parseFloat(day.price.amount);
            }
            
            const isAvailable = day.status === 'AVAILABLE';
            const minStay = day.minimumNights || 1;
            
            await pool.query(`
              INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, min_stay, source, updated_at)
              VALUES ($1, $2, $3, $4, $5, $6, 'calry', NOW())
              ON CONFLICT (room_id, date) DO UPDATE SET
                cm_price = COALESCE(EXCLUDED.cm_price, room_availability.cm_price),
                is_available = EXCLUDED.is_available,
                is_blocked = NOT EXCLUDED.is_available,
                min_stay = EXCLUDED.min_stay,
                source = 'calry',
                updated_at = NOW()
            `, [gasRoomId, day.date, price, isAvailable, !isAvailable, minStay]);
            
            totalDaysUpdated++;
          }
        }
      }
    }
    
    // Update last sync
    await pool.query(`UPDATE calry_properties SET last_sync = NOW() WHERE id = $1`, [id]);
    
    res.json({ success: true, days_updated: totalDaysUpdated });
  } catch (error) {
    console.error('Sync property error:', error.response?.data || error.message);
    res.json({ success: false, error: error.response?.data?.message || error.message });
  }
});

// Admin endpoint to manually sync a Calry connection
app.post('/api/admin/calry/sync-connection/:connectionId', async (req, res) => {
  const { connectionId } = req.params;
  
  try {
    // Ensure gas_sync_properties has all required columns
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS address TEXT').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS city TEXT').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS country TEXT').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS postal_code TEXT').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS latitude DECIMAL(10,7)').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS longitude DECIMAL(10,7)').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS currency VARCHAR(3)').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS description TEXT').catch(() => {});
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS raw_data JSONB').catch(() => {});
    
    // Get connection details
    const connResult = await pool.query(
      'SELECT id, account_id, external_account_id, external_account_name FROM gas_sync_connections WHERE id = $1',
      [connectionId]
    );
    
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const connection = connResult.rows[0];
    const integrationAccountId = connection.external_account_id;
    const gasAccountId = connection.account_id;
    const pmsName = connection.external_account_name || 'PMS';
    
    console.log(`Admin sync: connection ${connectionId}, account ${gasAccountId}, integration ${integrationAccountId}`);
    
    // Use the adapter-based import
    const results = await importCalryPropertiesViaAdapter(integrationAccountId, pmsName, gasAccountId);
    
    // Update last sync time
    await pool.query('UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1', [connectionId]);
    
    res.json({
      success: true,
      message: `Synced ${results.properties_imported} properties, ${results.rooms_imported} rooms`,
      details: results
    });
  } catch (error) {
    console.error('Admin calry sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Debug endpoint to test Calry room type sync
// Debug: Check what's actually in the database for a room
app.get('/api/admin/debug-room/:roomId', async (req, res) => {
  const { roomId } = req.params;
  
  try {
    // Get room data
    const roomResult = await pool.query('SELECT * FROM bookable_units WHERE id = $1', [roomId]);
    
    if (roomResult.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    const room = roomResult.rows[0];
    
    // Get bedrooms
    const bedroomsResult = await pool.query(
      'SELECT * FROM property_bedrooms WHERE room_id = $1 ORDER BY display_order',
      [roomId]
    );
    
    // Get bathrooms
    const bathroomsResult = await pool.query(
      'SELECT * FROM property_bathrooms WHERE room_id = $1 ORDER BY display_order',
      [roomId]
    );
    
    // Get amenities
    const amenitiesResult = await pool.query(`
      SELECT a.id, a.name, a.category 
      FROM room_amenities ra 
      JOIN amenities a ON ra.amenity_id = a.id 
      WHERE ra.room_id = $1
    `, [roomId]);
    
    // Get images
    const imagesResult = await pool.query(
      'SELECT * FROM property_images WHERE room_id = $1 ORDER BY display_order',
      [roomId]
    );
    
    // Get calendar/pricing (sample)
    const calendarResult = await pool.query(
      'SELECT * FROM room_calendar WHERE room_id = $1 ORDER BY date LIMIT 10',
      [roomId]
    );
    
    res.json({
      success: true,
      room: {
        id: room.id,
        name: room.name,
        display_name: room.display_name,
        short_description: room.short_description,
        full_description: room.full_description,
        max_guests: room.max_guests,
        max_adults: room.max_adults,
        max_children: room.max_children,
        num_bedrooms: room.num_bedrooms,
        num_bathrooms: room.num_bathrooms,
        room_type: room.room_type,
        base_price: room.base_price,
        currency: room.currency,
        amenities_json: room.amenities,
        cm_room_id: room.cm_room_id,
        cm_source: room.cm_source
      },
      bedrooms: bedroomsResult.rows,
      bathrooms: bathroomsResult.rows,
      amenities: amenitiesResult.rows,
      images: imagesResult.rows.length,
      calendar_sample: calendarResult.rows
    });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Debug endpoint by account ID (easier to use)
app.get('/api/admin/calry/debug-by-account/:accountId', async (req, res) => {
  const { accountId } = req.params;
  const debug = { accountId, rawData: {} };
  
  try {
    // Find connection for this account
    const connResult = await pool.query(
      "SELECT id, external_account_id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'calry' ORDER BY id DESC LIMIT 1",
      [accountId]
    );
    
    if (connResult.rows.length === 0) {
      return res.json({ success: false, error: 'No Calry connection found for this account' });
    }
    
    const connection = connResult.rows[0];
    debug.connectionId = connection.id;
    debug.integrationAccountId = connection.external_account_id;
    
    const integrationAccountId = connection.external_account_id;
    
    // Fetch raw properties from Calry API
    const axios = require('axios');
    const propResponse = await axios.get('https://prod.calry.app/api/v2/vrs/properties', {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'integrationAccountId': integrationAccountId,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    const properties = propResponse.data?.data || propResponse.data || [];
    debug.rawData.propertiesCount = properties.length;
    
    if (properties.length === 0) {
      return res.json({ success: false, error: 'No properties returned from Calry', debug });
    }
    
    debug.rawData.firstPropertyKeys = Object.keys(properties[0]);
    debug.rawData.firstPropertyName = properties[0].name;
    
    const propertyId = properties[0].id;
    
    // Fetch raw room types
    const roomResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/room-types/${propertyId}`, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'integrationAccountId': integrationAccountId,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    const roomTypes = roomResponse.data?.data || roomResponse.data || [];
    debug.rawData.roomTypesCount = roomTypes.length;
    
    if (roomTypes.length > 0) {
      const rt = roomTypes[0];
      debug.rawData.firstRoomTypeKeys = Object.keys(rt);
      debug.rawData.firstRoomTypeName = rt.name;
      
      // Show ALL the raw data for the first room type
      debug.rawData.firstRoomTypeRAW = rt;
      
      // Show specific fields we need
      debug.fieldMapping = {
        // Descriptions
        description: rt.description || null,
        longDescription: rt.longDescription || null,
        shortDescription: rt.shortDescription || null,
        summary: rt.summary || null,
        
        // Occupancy
        maxOccupancy: rt.maxOccupancy || null,
        maxGuests: rt.maxGuests || null,
        capacity: rt.capacity || null,
        maxAdults: rt.maxAdults || null,
        maxChildren: rt.maxChildren || null,
        
        // Bedrooms/Bathrooms
        bedRoom: rt.bedRoom || null,
        bathRoom: rt.bathRoom || null,
        bedrooms: rt.bedrooms || null,
        bathrooms: rt.bathrooms || null,
        numberOfBedrooms: rt.numberOfBedrooms || null,
        numberOfBathrooms: rt.numberOfBathrooms || null,
        beds: rt.beds || null,
        bedTypes: rt.bedTypes || null,
        bedConfiguration: rt.bedConfiguration || null,
        
        // Room type
        roomType: rt.roomType || null,
        type: rt.type || null,
        accommodationType: rt.accommodationType || null,
        
        // Pricing
        startPrice: rt.startPrice || null,
        basePrice: rt.basePrice || null,
        price: rt.price || null,
        
        // Amenities
        amenitiesCount: rt.amenities?.length || 0,
        amenitiesType: rt.amenities ? typeof rt.amenities[0] : 'none',
        amenitiesSample: rt.amenities?.slice(0, 5) || [],
        
        // Images
        picturesCount: rt.pictures?.length || 0,
        imagesCount: rt.images?.length || 0,
        photosCount: rt.photos?.length || 0
      };
      
      // Try to get availability - try prod first, then dev
      try {
        const today = new Date().toISOString().split('T')[0];
        const endDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        let availResponse;
        let usedEnv = 'prod';
        
        // Try prod first
        try {
          // FIXED: URL uses propertyId, query param uses roomTypeId (rt.id)
          availResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${propertyId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId
            },
            params: { startDate: today, endDate: endDate, roomTypeId: rt.id, rates: true },
            timeout: 30000
          });
        } catch (prodErr) {
          // Try dev if prod fails
          console.log('Calry prod availability failed, trying dev:', prodErr.message);
          usedEnv = 'dev';
          // FIXED: URL uses propertyId, query param uses roomTypeId (rt.id)
          availResponse = await axios.get(`https://dev.calry.app/api/v2/vrs/availability/${propertyId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId
            },
            params: { startDate: today, endDate: endDate, roomTypeId: rt.id, rates: true },
            timeout: 30000
          });
        }
        
        const availability = availResponse.data?.data || availResponse.data || [];
        debug.availability = {
          environment: usedEnv,
          count: Array.isArray(availability) ? availability.length : 'not array',
          sample: Array.isArray(availability) ? availability.slice(0, 5) : availability,
          rawResponse: availResponse.data
        };
      } catch (availErr) {
        debug.availability = { error: availErr.message, triedBothEnvs: true };
      }
      
      // Try to get rates - try prod first, then dev
      try {
        const today = new Date().toISOString().split('T')[0];
        const endDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        let ratesResponse;
        let usedEnv = 'prod';
        
        try {
          // FIXED: URL uses propertyId, query param uses roomTypeId (rt.id)
          ratesResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${propertyId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId
            },
            params: { startDate: today, endDate: endDate, roomTypeId: rt.id, rates: true },
            timeout: 30000
          });
        } catch (prodErr) {
          usedEnv = 'dev';
          // FIXED: URL uses propertyId, query param uses roomTypeId (rt.id)
          ratesResponse = await axios.get(`https://dev.calry.app/api/v2/vrs/availability/${propertyId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId
            },
            params: { startDate: today, endDate: endDate, roomTypeId: rt.id, rates: true },
            timeout: 30000
          });
        }
        
        const rates = ratesResponse.data?.data || ratesResponse.data || [];
        debug.rates = {
          environment: usedEnv,
          count: Array.isArray(rates) ? rates.length : 'not array',
          sample: Array.isArray(rates) ? rates.slice(0, 5) : rates
        };
      } catch (ratesErr) {
        debug.rates = { error: ratesErr.message };
      }
    }
    
    res.json({ success: true, debug });
    
  } catch (error) {
    debug.error = error.message;
    res.status(500).json({ success: false, error: error.message, debug });
  }
});

// Re-sync Calry property by account ID
app.post('/api/admin/calry/resync-by-account/:accountId', async (req, res) => {
  const { accountId } = req.params;
  const results = { accountId, steps: [] };
  
  try {
    // Find connection
    const connResult = await pool.query(
      "SELECT id, external_account_id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'calry' ORDER BY id DESC LIMIT 1",
      [accountId]
    );
    
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'No Calry connection found for this account' });
    }
    
    const connectionId = connResult.rows[0].id;
    results.connectionId = connectionId;
    results.steps.push({ step: 'found_connection', connectionId });
    
    // Find sync properties for this connection
    const propsResult = await pool.query(
      'SELECT id, external_id, name, gas_property_id FROM gas_sync_properties WHERE connection_id = $1',
      [connectionId]
    );
    
    if (propsResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'No properties found for this connection', results });
    }
    
    results.steps.push({ step: 'found_properties', count: propsResult.rows.length });
    results.properties = [];
    
    // Re-sync each property by calling the link-to-gas endpoint logic
    for (const prop of propsResult.rows) {
      const syncPropertyId = prop.id;
      
      try {
        // Get full property data
        const propData = await pool.query(
          'SELECT * FROM gas_sync_properties WHERE id = $1',
          [syncPropertyId]
        );
        
        if (propData.rows.length === 0) continue;
        
        const syncProp = propData.rows[0];
        const rawData = syncProp.raw_data || {};
        
        // Trigger the link-to-gas logic by making internal request
        // For simplicity, we'll just mark it for manual re-link
        results.properties.push({
          syncPropertyId,
          name: prop.name,
          externalId: prop.external_id,
          gasPropertyId: prop.gas_property_id,
          relinkUrl: `/api/gas-sync/properties/${syncPropertyId}/link-to-gas`
        });
        
      } catch (propErr) {
        results.properties.push({
          syncPropertyId,
          name: prop.name,
          error: propErr.message
        });
      }
    }
    
    results.steps.push({ step: 'complete' });
    results.instructions = 'Call the relinkUrl for each property with POST to re-sync. Example: POST /api/gas-sync/properties/{syncPropertyId}/link-to-gas with body { "accountId": ' + accountId + ' }';
    
    res.json({ success: true, results });
    
  } catch (error) {
    results.error = error.message;
    res.status(500).json({ success: false, error: error.message, results });
  }
});

// Actually re-sync Calry property (full re-import)
app.post('/api/admin/calry/force-resync/:accountId', async (req, res) => {
  const { accountId } = req.params;
  const results = { accountId, synced: [] };
  
  try {
    // Find connection
    const connResult = await pool.query(
      "SELECT id, external_account_id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'calry' ORDER BY id DESC LIMIT 1",
      [accountId]
    );
    
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'No Calry connection found' });
    }
    
    const connectionId = connResult.rows[0].id;
    
    // Find sync properties
    const propsResult = await pool.query(
      'SELECT id FROM gas_sync_properties WHERE connection_id = $1',
      [connectionId]
    );
    
    // Call link-to-gas for each
    for (const prop of propsResult.rows) {
      try {
        // Simulate the link-to-gas call internally
        const linkResponse = await new Promise((resolve) => {
          const mockReq = {
            params: { syncPropertyId: prop.id },
            body: { accountId: parseInt(accountId) }
          };
          const mockRes = {
            json: (data) => resolve({ success: true, data }),
            status: (code) => ({ json: (data) => resolve({ success: false, code, data }) })
          };
          
          // We can't easily call the route handler, so just return instructions
          resolve({ syncPropertyId: prop.id, status: 'ready_for_manual_sync' });
        });
        
        results.synced.push(linkResponse);
      } catch (err) {
        results.synced.push({ syncPropertyId: prop.id, error: err.message });
      }
    }
    
    res.json({ 
      success: true, 
      message: `Found ${propsResult.rows.length} properties. Use the GAS Admin UI to re-link each property, or POST to /api/gas-sync/properties/{syncPropertyId}/link-to-gas`,
      results 
    });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

app.get('/api/admin/calry/debug-room-sync/:connectionId', async (req, res) => {
  const { connectionId } = req.params;
  const debug = { steps: [], rawData: {} };
  
  try {
    // Get connection
    const connResult = await pool.query(
      'SELECT id, account_id, external_account_id FROM gas_sync_connections WHERE id = $1',
      [connectionId]
    );
    if (connResult.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    const connection = connResult.rows[0];
    debug.steps.push({ step: 'connection', data: connection });
    
    const integrationAccountId = connection.external_account_id;
    
    // Fetch raw properties from Calry API
    try {
      const axios = require('axios');
      const propResponse = await axios.get('https://prod.calry.app/api/v2/vrs/properties', {
        headers: {
          'Authorization': `Bearer ${CALRY_API_TOKEN}`,
          'workspaceId': CALRY_WORKSPACE_ID,
          'integrationAccountId': integrationAccountId,
          'Content-Type': 'application/json'
        },
        timeout: 30000
      });
      
      const properties = propResponse.data?.data || propResponse.data || [];
      debug.rawData.propertiesCount = properties.length;
      debug.rawData.firstPropertyKeys = properties[0] ? Object.keys(properties[0]) : [];
      debug.rawData.firstProperty = properties[0] || null;
      
      if (properties.length > 0) {
        const propertyId = properties[0].id;
        
        // Fetch raw room types
        try {
          const roomResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/room-types/${propertyId}`, {
            headers: {
              'Authorization': `Bearer ${CALRY_API_TOKEN}`,
              'workspaceId': CALRY_WORKSPACE_ID,
              'integrationAccountId': integrationAccountId,
              'Content-Type': 'application/json'
            },
            timeout: 30000
          });
          
          const roomTypes = roomResponse.data?.data || roomResponse.data || [];
          debug.rawData.roomTypesCount = roomTypes.length;
          debug.rawData.firstRoomTypeKeys = roomTypes[0] ? Object.keys(roomTypes[0]) : [];
          debug.rawData.firstRoomType = roomTypes[0] || null;
          
          // Show specific fields we're looking for
          if (roomTypes[0]) {
            const rt = roomTypes[0];
            debug.rawData.fieldCheck = {
              description: rt.description || rt.longDescription || rt.summary || '(not found)',
              shortDescription: rt.shortDescription || '(not found)',
              maxOccupancy: rt.maxOccupancy || rt.maxGuests || rt.capacity || '(not found)',
              maxAdults: rt.maxAdults || '(not found)',
              maxChildren: rt.maxChildren || '(not found)',
              bedRoom: rt.bedRoom || '(not found)',
              bathRoom: rt.bathRoom || '(not found)',
              beds: rt.beds || rt.bedTypes || rt.bedConfiguration || '(not found)',
              amenities: rt.amenities ? `Array with ${rt.amenities.length} items` : '(not found)',
              amenitiesSample: rt.amenities?.slice(0, 5) || [],
              pictures: rt.pictures ? `Array with ${rt.pictures.length} items` : '(not found)',
              picturesSample: rt.pictures?.slice(0, 2) || [],
              startPrice: rt.startPrice || rt.basePrice || rt.price || '(not found)',
              roomType: rt.roomType || rt.type || rt.accommodationType || '(not found)'
            };
          }
          
          // Also try to get availability
          try {
            const today = new Date().toISOString().split('T')[0];
            const endDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const roomTypeId = roomTypes[0]?.id;
            
            // FIXED: URL uses propertyId, query param uses roomTypeId
            const availResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${propertyId}`, {
              headers: {
                'Authorization': `Bearer ${CALRY_API_TOKEN}`,
                'workspaceId': CALRY_WORKSPACE_ID,
                'integrationAccountId': integrationAccountId,
                'Content-Type': 'application/json'
              },
              params: { startDate: today, endDate: endDate, roomTypeId: roomTypeId },
              timeout: 30000
            });
            
            const availability = availResponse.data?.data || availResponse.data || [];
            debug.rawData.availabilityCount = Array.isArray(availability) ? availability.length : 'not array';
            debug.rawData.availabilitySample = Array.isArray(availability) ? availability.slice(0, 3) : availability;
          } catch (availErr) {
            debug.rawData.availabilityError = availErr.message;
          }
          
        } catch (roomErr) {
          debug.rawData.roomTypesError = roomErr.message;
        }
      }
      
    } catch (propErr) {
      debug.rawData.propertiesError = propErr.message;
    }
    
    res.json({ success: true, debug });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message, debug });
  }
});

// =====================================================
// CALRY WEBHOOKS
// =====================================================

// Webhook events we want to receive
const CALRY_WEBHOOK_EVENTS = [
  'reservation.created',
  'reservation.updated', 
  'reservation.cancelled',
  'availability.updated',
  'pricing.updated'
];

// Register webhooks for a Calry integration account
async function registerCalryWebhooks(integrationAccountId, gasAccountId) {
  if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
    return { success: false, error: 'Calry credentials not configured' };
  }
  
  const webhookUrl = `https://api.gas.travel/api/calry/webhooks/${integrationAccountId}`;
  
  try {
    // First check if webhook already exists
    const existingResponse = await axios.get('https://prod.calry.app/api/v1/webhooks', {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'Content-Type': 'application/json'
      }
    });
    
    const existingWebhooks = existingResponse.data?.data || existingResponse.data || [];
    const existingForIntegration = existingWebhooks.find(w => 
      w.url === webhookUrl || w.integrationAccountId === integrationAccountId
    );
    
    if (existingForIntegration) {
      console.log('Webhook already registered:', existingForIntegration.id);
      
      // Update webhook in database
      await pool.query(`
        INSERT INTO calry_webhooks (integration_account_id, gas_account_id, webhook_id, webhook_url, events, status, created_at)
        VALUES ($1, $2, $3, $4, $5, 'active', NOW())
        ON CONFLICT (integration_account_id) DO UPDATE SET
          webhook_id = $3, webhook_url = $4, events = $5, status = 'active', updated_at = NOW()
      `, [integrationAccountId, gasAccountId, existingForIntegration.id, webhookUrl, JSON.stringify(CALRY_WEBHOOK_EVENTS)]);
      
      return { success: true, webhookId: existingForIntegration.id, existed: true };
    }
    
    // Register new webhook
    const response = await axios.post('https://prod.calry.app/api/v1/webhooks', {
      url: webhookUrl,
      events: CALRY_WEBHOOK_EVENTS,
      integrationAccountId: integrationAccountId
    }, {
      headers: {
        'Authorization': `Bearer ${CALRY_API_TOKEN}`,
        'workspaceId': CALRY_WORKSPACE_ID,
        'Content-Type': 'application/json'
      }
    });
    
    const webhookId = response.data?.id || response.data?.webhookId;
    console.log('Webhook registered:', webhookId);
    
    // Store webhook in database
    await pool.query(`
      CREATE TABLE IF NOT EXISTS calry_webhooks (
        id SERIAL PRIMARY KEY,
        integration_account_id VARCHAR(100) UNIQUE,
        gas_account_id INTEGER,
        webhook_id VARCHAR(100),
        webhook_url TEXT,
        events JSONB,
        status VARCHAR(50) DEFAULT 'active',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP
      )
    `);
    
    await pool.query(`
      INSERT INTO calry_webhooks (integration_account_id, gas_account_id, webhook_id, webhook_url, events, status, created_at)
      VALUES ($1, $2, $3, $4, $5, 'active', NOW())
      ON CONFLICT (integration_account_id) DO UPDATE SET
        webhook_id = $3, webhook_url = $4, events = $5, status = 'active', updated_at = NOW()
    `, [integrationAccountId, gasAccountId, webhookId, webhookUrl, JSON.stringify(CALRY_WEBHOOK_EVENTS)]);
    
    return { success: true, webhookId: webhookId };
    
  } catch (error) {
    console.error('Webhook registration error:', error.response?.data || error.message);
    return { success: false, error: error.response?.data?.message || error.message };
  }
}

// Manual webhook setup endpoint (for retry from UI)
app.post('/api/calry/webhooks/register/:integrationAccountId', async (req, res) => {
  try {
    const { integrationAccountId } = req.params;
    const { gas_account_id } = req.body;
    
    // Find the GAS account ID if not provided
    let gasAccountId = gas_account_id;
    if (!gasAccountId) {
      const connResult = await pool.query(
        "SELECT account_id FROM gas_sync_connections WHERE external_account_id = $1 AND adapter_code = 'calry'",
        [integrationAccountId]
      );
      gasAccountId = connResult.rows[0]?.account_id;
    }
    
    const result = await registerCalryWebhooks(integrationAccountId, gasAccountId);
    res.json(result);
    
  } catch (error) {
    console.error('Manual webhook registration error:', error.message);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Webhook receiver endpoint - Calry sends events here
app.post('/api/calry/webhooks/:integrationAccountId', async (req, res) => {
  try {
    const { integrationAccountId } = req.params;
    const payload = req.body;
    const headers = req.headers;
    
    console.log(`üì• Calry webhook received for ${integrationAccountId}:`, payload.event || payload.type);
    
    // Log the webhook event
    await pool.query(`
      CREATE TABLE IF NOT EXISTS calry_webhook_events (
        id SERIAL PRIMARY KEY,
        integration_account_id VARCHAR(100),
        event_type VARCHAR(100),
        event_id VARCHAR(100),
        resource_id VARCHAR(100),
        payload JSONB,
        processed BOOLEAN DEFAULT false,
        processed_at TIMESTAMP,
        error TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const eventId = payload.id || payload.eventId || `evt_${Date.now()}`;
    const eventType = payload.event || payload.type;
    const resourceId = payload.data?.id || payload.resourceId;
    
    // Store the event
    const eventResult = await pool.query(`
      INSERT INTO calry_webhook_events (integration_account_id, event_type, event_id, resource_id, payload, created_at)
      VALUES ($1, $2, $3, $4, $5, NOW())
      ON CONFLICT DO NOTHING
      RETURNING id
    `, [integrationAccountId, eventType, eventId, resourceId, JSON.stringify(payload)]);
    
    // Process the event
    try {
      await processCalryWebhookEvent(integrationAccountId, eventType, payload.data || payload);
      
      // Mark as processed
      if (eventResult.rows[0]?.id) {
        await pool.query(
          'UPDATE calry_webhook_events SET processed = true, processed_at = NOW() WHERE id = $1',
          [eventResult.rows[0].id]
        );
      }
    } catch (processError) {
      console.error('Webhook processing error:', processError.message);
      if (eventResult.rows[0]?.id) {
        await pool.query(
          'UPDATE calry_webhook_events SET error = $1 WHERE id = $2',
          [processError.message, eventResult.rows[0].id]
        );
      }
    }
    
    // Always return 200 to acknowledge receipt
    res.json({ success: true, received: eventType });
    
  } catch (error) {
    console.error('Webhook receiver error:', error.message);
    // Still return 200 to prevent retries for our errors
    res.json({ success: false, error: error.message });
  }
});

// Process webhook events
async function processCalryWebhookEvent(integrationAccountId, eventType, data) {
  console.log(`Processing ${eventType} for integration ${integrationAccountId}`);
  
  // Find the GAS connection
  const connResult = await pool.query(
    "SELECT id, account_id FROM gas_sync_connections WHERE external_account_id = $1 AND adapter_code = 'calry'",
    [integrationAccountId]
  );
  
  if (connResult.rows.length === 0) {
    console.log('No GAS connection found for integration:', integrationAccountId);
    return;
  }
  
  const connectionId = connResult.rows[0].id;
  const accountId = connResult.rows[0].account_id;
  
  switch (eventType) {
    case 'reservation.created':
    case 'reservation.updated':
      await handleReservationWebhook(connectionId, accountId, data, eventType);
      break;
      
    case 'reservation.cancelled':
      await handleReservationCancellation(connectionId, data);
      break;
      
    case 'availability.updated':
      await handleAvailabilityWebhook(connectionId, data);
      break;
      
    case 'pricing.updated':
      await handlePricingWebhook(connectionId, data);
      break;
      
    default:
      console.log('Unhandled webhook event:', eventType);
  }
}

// Handle reservation created/updated
async function handleReservationWebhook(connectionId, accountId, data, eventType) {
  const reservationId = data.id || data.reservationId;
  const propertyId = data.propertyId;
  const roomTypeId = data.roomTypeId;
  
  console.log(`${eventType}: Reservation ${reservationId} for property ${propertyId}`);
  
  // Find the GAS property and room
  const propResult = await pool.query(`
    SELECT p.id as gas_property_id, bu.id as gas_room_id
    FROM properties p
    LEFT JOIN bookable_units bu ON bu.property_id = p.id AND bu.cm_room_id = $3
    WHERE p.cm_property_id = $2 AND p.account_id = $1
  `, [accountId, String(propertyId), String(roomTypeId)]);
  
  if (propResult.rows.length === 0) {
    console.log('Property not found in GAS');
    return;
  }
  
  const gasPropertyId = propResult.rows[0].gas_property_id;
  const gasRoomId = propResult.rows[0].gas_room_id;
  
  // Guest info
  const guestName = data.guest 
    ? `${data.guest.firstName || ''} ${data.guest.lastName || ''}`.trim()
    : data.guestName || 'Guest';
  
  // Upsert booking
  const upsertResult = await pool.query(`
    INSERT INTO bookings (
      account_id, property_id, room_id, external_booking_id, cm_source,
      check_in, check_out, status,
      guest_name, guest_email, guest_phone,
      adults, children, infants,
      total_price, currency, channel,
      created_at
    ) VALUES ($1, $2, $3, $4, 'calry', $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NOW())
    ON CONFLICT (account_id, external_booking_id) DO UPDATE SET
      status = EXCLUDED.status,
      check_in = EXCLUDED.check_in,
      check_out = EXCLUDED.check_out,
      guest_name = EXCLUDED.guest_name,
      guest_email = EXCLUDED.guest_email,
      guest_phone = EXCLUDED.guest_phone,
      adults = EXCLUDED.adults,
      children = EXCLUDED.children,
      total_price = EXCLUDED.total_price,
      updated_at = NOW()
    RETURNING id
  `, [
    accountId,
    gasPropertyId,
    gasRoomId,
    String(reservationId),
    data.checkIn || data.arrivalDate,
    data.checkOut || data.departureDate,
    data.status || 'confirmed',
    guestName,
    data.guest?.email || null,
    data.guest?.phone || null,
    data.adults || data.guests?.adults || 1,
    data.children || data.guests?.children || 0,
    data.infants || data.guests?.infants || 0,
    data.totalPrice || data.pricing?.total || 0,
    data.currency || data.pricing?.currency || 'EUR',
    data.channel || data.source || 'DIRECT'
  ]);
  
  console.log(`Booking ${reservationId} synced to GAS`);
  
  // ========== SEND PARTNER WEBHOOK FOR CALRY BOOKING ==========
  if (upsertResult.rows.length > 0 && eventType === 'reservation.created') {
    try {
      const gasBookingId = upsertResult.rows[0].id;
      const webhookResult = await sendPartnerBookingWebhook(gasBookingId, 'booking.created');
      if (webhookResult.sent) {
        console.log(`[Webhook] Sent booking.created for Calry booking ${gasBookingId}`);
      }
    } catch (webhookError) {
      console.error(`[Webhook] Error sending Calry booking webhook:`, webhookError.message);
      // Don't fail the booking sync if partner webhook fails
    }
  }
  // ========== END PARTNER WEBHOOK ==========
}

// Handle reservation cancellation
async function handleReservationCancellation(connectionId, data) {
  const reservationId = data.id || data.reservationId;
  
  const cancelResult = await pool.query(`
    UPDATE bookings SET status = 'cancelled', updated_at = NOW()
    WHERE external_booking_id = $1 AND cm_source = 'calry'
    RETURNING id
  `, [String(reservationId)]);
  
  console.log(`Booking ${reservationId} cancelled`);
  
  // ========== SEND PARTNER WEBHOOK FOR CALRY CANCELLATION ==========
  if (cancelResult.rowCount > 0) {
    for (const row of cancelResult.rows) {
      try {
        const webhookResult = await sendPartnerBookingWebhook(row.id, 'booking.cancelled');
        if (webhookResult.sent) {
          console.log(`[Webhook] Sent booking.cancelled for Calry-cancelled booking ${row.id}`);
        }
      } catch (webhookError) {
        console.error(`[Webhook] Error sending Calry cancellation webhook for booking ${row.id}:`, webhookError.message);
        // Don't fail the cancellation processing if partner webhook fails
      }
    }
  }
  // ========== END PARTNER WEBHOOK ==========
}

// Handle availability update
async function handleAvailabilityWebhook(connectionId, data) {
  const roomTypeId = data.roomTypeId;
  const dates = data.dates || [data]; // Could be single or array
  
  // Find GAS room
  const roomResult = await pool.query(`
    SELECT bu.id FROM bookable_units bu
    JOIN properties p ON bu.property_id = p.id
    JOIN gas_sync_connections c ON c.account_id = p.account_id
    WHERE bu.cm_room_id = $1 AND c.id = $2
  `, [String(roomTypeId), connectionId]);
  
  if (roomResult.rows.length === 0) {
    console.log('Room not found for availability update');
    return;
  }
  
  const gasRoomId = roomResult.rows[0].id;
  
  for (const day of Array.isArray(dates) ? dates : [dates]) {
    const available = day.available !== false;
    await pool.query(`
      INSERT INTO room_availability (room_id, date, is_available, is_blocked, min_stay, source, updated_at)
      VALUES ($1, $2, $3, $4, $5, 'calry', NOW())
      ON CONFLICT (room_id, date) DO UPDATE SET
        is_available = EXCLUDED.is_available,
        is_blocked = EXCLUDED.is_blocked,
        min_stay = COALESCE(EXCLUDED.min_stay, room_availability.min_stay),
        source = 'calry',
        updated_at = NOW()
    `, [gasRoomId, day.date, available, !available, day.minStay || null]);
  }
  
  console.log(`Availability updated for room ${roomTypeId}`);
}

// Handle pricing update
async function handlePricingWebhook(connectionId, data) {
  const roomTypeId = data.roomTypeId;
  const dates = data.dates || data.rates || [data];
  
  // Find GAS room
  const roomResult = await pool.query(`
    SELECT bu.id FROM bookable_units bu
    JOIN properties p ON bu.property_id = p.id
    JOIN gas_sync_connections c ON c.account_id = p.account_id
    WHERE bu.cm_room_id = $1 AND c.id = $2
  `, [String(roomTypeId), connectionId]);
  
  if (roomResult.rows.length === 0) {
    console.log('Room not found for pricing update');
    return;
  }
  
  const gasRoomId = roomResult.rows[0].id;
  
  for (const day of Array.isArray(dates) ? dates : [dates]) {
    await pool.query(`
      INSERT INTO room_availability (room_id, date, cm_price, source, updated_at)
      VALUES ($1, $2, $3, 'calry', NOW())
      ON CONFLICT (room_id, date) DO UPDATE SET
        cm_price = EXCLUDED.cm_price,
        source = 'calry',
        updated_at = NOW()
    `, [gasRoomId, day.date, parseFloat(day.price || day.rate) || null]);
  }
  
  console.log(`Pricing updated for room ${roomTypeId}`);
}

// Debug endpoint to check Calry import results
app.get('/api/debug/calry-import/:propertyId', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    // Get property data - only select columns that exist
    const propResult = await pool.query(`
      SELECT id, name, description, city, country, address, latitude, longitude, 
             currency, cm_property_id, cm_source
      FROM properties 
      WHERE id = $1 OR cm_property_id = $1::text
    `, [propertyId]);
    
    const gasPropertyId = propResult.rows[0]?.id;
    
    // Get room data
    let roomResult = { rows: [] };
    if (gasPropertyId) {
      roomResult = await pool.query(`
        SELECT id, name, description, max_guests, num_bedrooms, num_bathrooms, 
               base_price, currency, amenities, cm_room_id, cm_source
        FROM bookable_units 
        WHERE property_id = $1
      `, [gasPropertyId]);
    }
    
    // Get images
    let imageResult = { rows: [] };
    if (gasPropertyId) {
      imageResult = await pool.query(`
        SELECT id, room_id, image_key, image_url, caption, display_order, is_primary
        FROM property_images 
        WHERE property_id = $1
        ORDER BY display_order
      `, [gasPropertyId]);
    }
    
    // Get sync property raw data
    let syncResult = { rows: [] };
    if (gasPropertyId) {
      syncResult = await pool.query(`
        SELECT name, raw_data, created_at, updated_at
        FROM gas_sync_properties 
        WHERE gas_property_id = $1
      `, [gasPropertyId]);
    }
    
    // Get pricing/calendar data - create table if needed
    let calendarResult = { rows: [] };
    if (gasPropertyId && roomResult.rows.length > 0) {
      const roomId = roomResult.rows[0].id;
      
      // Ensure room_calendar table exists
      await pool.query(`
        CREATE TABLE IF NOT EXISTS room_calendar (
          id SERIAL PRIMARY KEY,
          room_id INTEGER NOT NULL,
          date DATE NOT NULL,
          price DECIMAL(10,2),
          currency VARCHAR(3) DEFAULT 'EUR',
          available BOOLEAN DEFAULT true,
          min_stay INTEGER,
          max_stay INTEGER,
          closed_to_arrival BOOLEAN DEFAULT false,
          closed_to_departure BOOLEAN DEFAULT false,
          status VARCHAR(50),
          notes TEXT,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          UNIQUE(room_id, date)
        )
      `);
      
      calendarResult = await pool.query(`
        SELECT date, price, available, min_stay, status
        FROM room_calendar 
        WHERE room_id = $1
        ORDER BY date
        LIMIT 30
      `, [roomId]);
    }
    
    res.json({
      success: true,
      property: propResult.rows[0] || null,
      rooms: roomResult.rows,
      images: imageResult.rows,
      calendar: calendarResult.rows,
      sync_data: syncResult.rows[0] ? {
        name: syncResult.rows[0].name,
        raw_data_keys: syncResult.rows[0].raw_data ? Object.keys(syncResult.rows[0].raw_data) : [],
        raw_data_sample: syncResult.rows[0].raw_data ? JSON.stringify(syncResult.rows[0].raw_data).substring(0, 500) : null,
        created_at: syncResult.rows[0].created_at,
        updated_at: syncResult.rows[0].updated_at
      } : null
    });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// CALRY PRICING/AVAILABILITY SYNC
// =====================================================

// Fetch and sync pricing from Calry for a property
app.post('/api/calry/sync-pricing/:propertyId', async (req, res) => {
  try {
    const { propertyId } = req.params;
    const { days = 30 } = req.body;  // Default to 30 days - Calry may have limits on range
    
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.status(400).json({ success: false, error: 'Calry not configured' });
    }
    
    // Get property and connection info
    const propResult = await pool.query(`
      SELECT p.id as gas_property_id, p.cm_property_id, p.name,
             c.external_account_id as integration_account_id
      FROM properties p
      JOIN gas_sync_connections c ON c.account_id = p.account_id AND c.adapter_code = 'calry'
      WHERE p.id = $1 OR p.cm_property_id = $1::text
    `, [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found or not a Calry property' });
    }
    
    const prop = propResult.rows[0];
    const integrationAccountId = prop.integration_account_id;
    const calryPropertyId = prop.cm_property_id;
    
    console.log(`[Calry Pricing v2] Fetching for property ${prop.name} (${calryPropertyId})`);
    
    // Ensure room_calendar table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_calendar (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL,
        date DATE NOT NULL,
        price DECIMAL(10,2),
        currency VARCHAR(3) DEFAULT 'EUR',
        available BOOLEAN DEFAULT true,
        min_stay INTEGER,
        max_stay INTEGER,
        closed_to_arrival BOOLEAN DEFAULT false,
        closed_to_departure BOOLEAN DEFAULT false,
        status VARCHAR(50),
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(room_id, date)
      )
    `);
    
    // Step 1: Get room types from Calry using v2 API
    console.log(`[Calry Pricing v2] Step 1: Fetching room types for property ${calryPropertyId}`);
    
    let roomTypes = [];
    try {
      const roomTypesResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/room-types/${calryPropertyId}`, {
        headers: {
          'Authorization': `Bearer ${CALRY_API_TOKEN}`,
          'workspaceId': CALRY_WORKSPACE_ID,
          'integrationAccountId': integrationAccountId,
          'Content-Type': 'application/json'
        },
        timeout: 30000
      });
      
      roomTypes = roomTypesResponse.data?.data || roomTypesResponse.data || [];
      console.log(`[Calry Pricing v2] Found ${roomTypes.length} room types`);
      
      if (roomTypes.length > 0) {
        console.log(`[Calry Pricing v2] Room types:`, roomTypes.map(rt => ({ id: rt.id, name: rt.name })));
      }
    } catch (rtErr) {
      console.error(`[Calry Pricing v2] Error fetching room types:`, rtErr.response?.status, rtErr.response?.data || rtErr.message);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch room types from Calry',
        details: rtErr.response?.data || rtErr.message
      });
    }
    
    if (roomTypes.length === 0) {
      return res.json({ success: false, error: 'No room types found for this property in Calry' });
    }
    
    // Calculate date range
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    let totalDaysSynced = 0;
    const roomResults = [];
    
    // Step 2: For each room type, get availability with rates
    for (const roomType of roomTypes) {
      const roomTypeId = String(roomType.id);
      const roomTypeName = roomType.name || `Room ${roomTypeId}`;
      
      console.log(`[Calry Pricing v2] Step 2: Fetching availability for room type ${roomTypeId} (${roomTypeName})`);
      
      try {
        // Fetch availability with rates from v2 API
        // Note: roomTypeId must be a string in params
        const headers = {
          'Authorization': `Bearer ${CALRY_API_TOKEN}`,
          'workspaceId': CALRY_WORKSPACE_ID,
          'integrationAccountId': integrationAccountId,
          'Content-Type': 'application/json'
        };
        const params = {
          startDate: startDate,
          endDate: endDate,
          roomTypeId: roomTypeId,
          rates: 'true'
        };
        console.log(`[Calry Pricing v2] Request headers:`, { workspaceId: CALRY_WORKSPACE_ID, integrationAccountId });
        console.log(`[Calry Pricing v2] Request params:`, params);
        
        // FIXED: URL uses calryPropertyId, query param uses roomTypeId
        const availResponse = await axios.get(`https://prod.calry.app/api/v2/vrs/availability/${calryPropertyId}`, {
          headers,
          params,
          timeout: 30000
        });
        
        const availData = availResponse.data?.data || availResponse.data || [];
        console.log(`[Calry Pricing v2] Room type ${roomTypeId}: ${Array.isArray(availData) ? availData.length : 'non-array'} availability records`);
        
        if (availData.length > 0) {
          console.log(`[Calry Pricing v2] Sample:`, JSON.stringify(availData[0]).substring(0, 500));
        }
        
        // Find matching GAS room by cm_room_id
        const gasRoomResult = await pool.query(`
          SELECT id, name FROM bookable_units 
          WHERE property_id = $1 AND (cm_room_id = $2 OR cm_room_id = $3)
        `, [prop.gas_property_id, roomTypeId, roomTypeId.toString()]);
        
        let gasRoomId;
        if (gasRoomResult.rows.length > 0) {
          gasRoomId = gasRoomResult.rows[0].id;
          console.log(`[Calry Pricing v2] Matched to GAS room ${gasRoomId} (${gasRoomResult.rows[0].name})`);
        } else {
          // Try to find by property if only one room
          const anyRoomResult = await pool.query(`
            SELECT id, name FROM bookable_units WHERE property_id = $1 LIMIT 1
          `, [prop.gas_property_id]);
          
          if (anyRoomResult.rows.length > 0) {
            gasRoomId = anyRoomResult.rows[0].id;
            console.log(`[Calry Pricing v2] Using first GAS room ${gasRoomId} (${anyRoomResult.rows[0].name})`);
            
            // Update the cm_room_id for future syncs
            await pool.query(`UPDATE bookable_units SET cm_room_id = $1 WHERE id = $2`, [roomTypeId, gasRoomId]);
          } else {
            console.log(`[Calry Pricing v2] No matching GAS room found, skipping`);
            roomResults.push({ roomType: roomTypeName, error: 'No matching GAS room found' });
            continue;
          }
        }
        
        // Process availability data
        let daysSynced = 0;
        
        if (Array.isArray(availData)) {
          for (const day of availData) {
            // Handle different possible response formats
            const date = day.date || day.startDate;
            if (!date) continue;
            
            const price = day.price || day.rate || day.basePrice || day.amount || null;
            const available = day.available !== false && day.isAvailable !== false && day.status !== 'blocked';
            const minStay = day.minStay || day.minimumStay || day.minNights || 1;
            
            await pool.query(`
              INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, min_stay, source, updated_at)
              VALUES ($1, $2, $3, $4, $5, $6, 'calry', NOW())
              ON CONFLICT (room_id, date) DO UPDATE SET
                cm_price = COALESCE(EXCLUDED.cm_price, room_availability.cm_price),
                is_available = EXCLUDED.is_available,
                is_blocked = NOT EXCLUDED.is_available,
                min_stay = COALESCE(EXCLUDED.min_stay, room_availability.min_stay),
                source = 'calry',
                updated_at = NOW()
            `, [gasRoomId, date, price, available, !available, minStay]);
            
            daysSynced++;
          }
        }
        
        totalDaysSynced += daysSynced;
        roomResults.push({
          roomType: roomTypeName,
          roomTypeId: roomTypeId,
          gasRoomId: gasRoomId,
          daysSynced: daysSynced,
          sample: availData.length > 0 ? availData[0] : null
        });
        
      } catch (availErr) {
        const errDetails = {
          status: availErr.response?.status,
          data: availErr.response?.data,
          message: availErr.message,
          url: availErr.config?.url,
          params: availErr.config?.params
        };
        console.error(`[Calry Pricing v2] Error fetching availability for room type ${roomTypeId}:`, JSON.stringify(errDetails, null, 2));
        roomResults.push({ 
          roomType: roomTypeName, 
          roomTypeId: roomTypeId,
          error: availErr.response?.data?.message || availErr.response?.data?.error || availErr.message 
        });
      }
    }
    
    res.json({
      success: true,
      property: prop.name,
      totalDaysSynced,
      roomTypes: roomTypes.length,
      rooms: roomResults,
      debug: {
        calryPropertyId,
        integrationAccountId,
        dateRange: { startDate, endDate },
        apiVersion: 'v2'
      }
    });
    
  } catch (error) {
    console.error('[Calry Pricing v2] Error:', error.message);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET version for easy testing
app.get('/api/calry/sync-pricing/:propertyId', async (req, res) => {
  req.body = { days: 90 };
  // Forward to POST handler
  const { propertyId } = req.params;
  
  try {
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.status(400).json({ success: false, error: 'Calry not configured' });
    }
    
    const propResult = await pool.query(`
      SELECT p.id as gas_property_id, p.cm_property_id, p.name,
             c.external_account_id as integration_account_id
      FROM properties p
      JOIN gas_sync_connections c ON c.account_id = p.account_id AND c.adapter_code = 'calry'
      WHERE p.id = $1 OR p.cm_property_id = $1::text
    `, [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found or not a Calry property' });
    }
    
    const prop = propResult.rows[0];
    
    // Redirect to a simple test response
    res.json({
      success: true,
      message: 'Use POST to sync pricing',
      property: prop.name,
      calry_property_id: prop.cm_property_id,
      integration_account_id: prop.integration_account_id,
      test_url: `curl -X POST https://api.gas.travel/api/calry/sync-pricing/${propertyId}`
    });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET version for easy browser testing
app.get('/api/calry/import-property/:integrationAccountId/:propertyId', async (req, res) => {
  // Redirect to POST handler with params as body
  req.body = {
    integrationAccountId: req.params.integrationAccountId,
    propertyId: req.params.propertyId
  };
  
  console.log('=== CALRY: IMPORT PROPERTY (GET redirect) ===');
  
  try {
    const { integrationAccountId, propertyId } = req.params;
    
    if (!CALRY_API_TOKEN || !CALRY_WORKSPACE_ID) {
      return res.json({ success: false, error: 'Calry credentials not configured' });
    }
    
    // Create Calry adapter instance
    const adapter = getAdapter('calry', {
      token: CALRY_API_TOKEN,
      workspaceId: CALRY_WORKSPACE_ID,
      integrationAccountId: integrationAccountId,
      pool: pool,
      useDev: false
    });
    
    // Fetch properties using adapter
    console.log('Fetching properties using Calry adapter');
    const propertiesResult = await adapter.getProperties();
    
    if (!propertiesResult.success) {
      return res.status(500).json({ success: false, error: propertiesResult.error });
    }
    
    const calryProperty = propertiesResult.data.find(p => String(p.externalId) === String(propertyId));
    
    if (!calryProperty) {
      return res.status(404).json({ success: false, error: 'Property not found in Calry' });
    }
    
    // Fetch room types
    const roomTypesResult = await adapter.getRoomTypes(propertyId);
    const roomTypes = roomTypesResult.success ? roomTypesResult.data : [];
    
    // Create GAS account
    const newAccountName = calryProperty.name || 'Calry Import';
    const newAccountEmail = `calry-${integrationAccountId}-${Date.now()}@gas.travel`;
    
    const existingAccount = await pool.query(
      "SELECT id FROM accounts WHERE settings->>'calry_integration_id' = $1",
      [integrationAccountId]
    );
    
    let gasAccountId;
    if (existingAccount.rows.length > 0) {
      gasAccountId = existingAccount.rows[0].id;
      console.log('Using existing GAS account:', gasAccountId);
    } else {
      const accountResult = await pool.query(`
        INSERT INTO accounts (name, email, role, status, settings, created_at)
        VALUES ($1, $2, 'admin', 'active', $3, NOW())
        RETURNING id
      `, [newAccountName, newAccountEmail, JSON.stringify({
        calry_integration_id: integrationAccountId,
        cm_source: 'calry'
      })]);
      gasAccountId = accountResult.rows[0].id;
      console.log('Created new GAS account:', gasAccountId);
    }
    
    // Create connection record
    const existingConnection = await pool.query(
      "SELECT id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'calry' AND external_account_id = $2",
      [gasAccountId, integrationAccountId]
    );
    
    let connectionId;
    if (existingConnection.rows.length > 0) {
      connectionId = existingConnection.rows[0].id;
    } else {
      const connResult = await pool.query(`
        INSERT INTO gas_sync_connections (
          account_id, adapter_code, external_account_id, external_account_name,
          credentials, access_token, status, sync_enabled, created_at
        ) VALUES ($1, 'calry', $2, $3, $4, $5, 'connected', true, NOW())
        RETURNING id
      `, [gasAccountId, integrationAccountId, 'Smoobu via Calry',
          JSON.stringify({ workspaceId: CALRY_WORKSPACE_ID, integrationAccountId }),
          CALRY_API_TOKEN]);
      connectionId = connResult.rows[0].id;
    }
    
    // Create property
    const existingProp = await pool.query(
      "SELECT id FROM properties WHERE cm_property_id = $1 AND account_id = $2",
      [String(propertyId), gasAccountId]
    );
    
    let gasPropertyId;
    
    // Parse address - handle JSON string, object, or plain string
    let addr2 = calryProperty.address || {};
    if (typeof addr2 === 'string') {
      try { addr2 = JSON.parse(addr2); } catch (e) { addr2 = { street: addr2 }; }
    }
    
    const parsedAddress2 = {
      street: addr2.street || addr2.line1 || addr2.address1 || addr2.address || '',
      line2: addr2.street2 || addr2.line2 || addr2.address2 || '',
      city: addr2.city || '',
      state: addr2.state || addr2.region || addr2.province || '',
      country: addr2.country || addr2.countryCode || '',
      postal_code: addr2.postalCode || addr2.postal_code || addr2.zipCode || addr2.zip || '',
      lat: calryProperty.coordinates?.latitude || calryProperty.coordinates?.lat || addr2.coordinates?.lat || calryProperty.latitude || null,
      lng: calryProperty.coordinates?.longitude || calryProperty.coordinates?.lng || calryProperty.coordinates?.lon || addr2.coordinates?.lng || calryProperty.longitude || null
    };
    parsedAddress2.full = [parsedAddress2.street, parsedAddress2.line2].filter(Boolean).join(', ');
    
    // Geocode if no coordinates
    if (!parsedAddress2.lat || !parsedAddress2.lng) {
      try {
        const geocodeQuery = [parsedAddress2.full, parsedAddress2.city, parsedAddress2.state, parsedAddress2.postal_code, parsedAddress2.country].filter(Boolean).join(', ');
        console.log('[Calry Sync] Geocoding:', geocodeQuery);
        const geoResp = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(geocodeQuery)}&format=json&limit=1`, {
          headers: { 'User-Agent': 'GAS-Platform/1.0' }
        });
        const geoData = await geoResp.json();
        if (geoData && geoData.length > 0) {
          parsedAddress2.lat = parseFloat(geoData[0].lat);
          parsedAddress2.lng = parseFloat(geoData[0].lon);
          console.log(`[Calry Sync] Geocoded to: ${parsedAddress2.lat}, ${parsedAddress2.lng}`);
        }
      } catch (geoErr) {
        console.log('[Calry Sync] Geocoding failed:', geoErr.message);
      }
    }
    
    if (existingProp.rows.length > 0) {
      gasPropertyId = existingProp.rows[0].id;
      
      // SELECTIVE UPDATE: Only update fields with real data, never overwrite with blanks
      const updateParts2 = [];
      const updateValues2 = [];
      let pIdx = 1;
      
      if (parsedAddress2.full) { updateParts2.push(`address = $${pIdx++}`); updateValues2.push(parsedAddress2.full); }
      if (parsedAddress2.city) { updateParts2.push(`city = $${pIdx++}`); updateValues2.push(parsedAddress2.city); }
      if (parsedAddress2.country) { updateParts2.push(`country = $${pIdx++}`); updateValues2.push(parsedAddress2.country); }
      if (parsedAddress2.state) { updateParts2.push(`state = $${pIdx++}`); updateValues2.push(parsedAddress2.state); }
      if (parsedAddress2.postal_code) { updateParts2.push(`postal_code = $${pIdx++}`); updateValues2.push(parsedAddress2.postal_code); }
      if (parsedAddress2.lat) { updateParts2.push(`latitude = $${pIdx++}`); updateValues2.push(parsedAddress2.lat); }
      if (parsedAddress2.lng) { updateParts2.push(`longitude = $${pIdx++}`); updateValues2.push(parsedAddress2.lng); }
      if (calryProperty.currency) { updateParts2.push(`currency = $${pIdx++}`); updateValues2.push(calryProperty.currency); }
      
      if (updateParts2.length > 0) {
        updateParts2.push('updated_at = NOW()');
        updateValues2.push(gasPropertyId);
        await pool.query(
          `UPDATE properties SET ${updateParts2.join(', ')} WHERE id = $${pIdx}`,
          updateValues2
        );
      }
    } else {
      const propResult = await pool.query(`
        INSERT INTO properties (
          account_id, user_id, name, address, city, country, state, postal_code,
          latitude, longitude, currency, cm_property_id, cm_source, status, created_at
        ) VALUES ($1, 1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 'calry', 'active', NOW())
        RETURNING id
      `, [gasAccountId, calryProperty.name, parsedAddress2.full,
          parsedAddress2.city, parsedAddress2.country,
          parsedAddress2.state, parsedAddress2.postal_code,
          parsedAddress2.lat, parsedAddress2.lng, 
          calryProperty.currency || 'USD',
          String(propertyId)]);
      gasPropertyId = propResult.rows[0].id;
    }
    
    // Import rooms
    const importedRooms = [];
    for (const room of roomTypes) {
      const existingRoom = await pool.query(
        "SELECT id FROM bookable_units WHERE cm_room_id = $1 AND property_id = $2",
        [String(room.externalId), gasPropertyId]
      );
      
      let gasRoomId;
      if (existingRoom.rows.length > 0) {
        gasRoomId = existingRoom.rows[0].id;
        // SELECTIVE UPDATE: Only structural/pricing data, never descriptions
        const ru2 = [];
        const rv2 = [];
        let ri2 = 1;
        if (room.name) { ru2.push(`name = $${ri2++}`); rv2.push(room.name); }
        if (room.maxGuests) { ru2.push(`max_guests = $${ri2++}`); rv2.push(room.maxGuests); }
        if (room.bedrooms) { ru2.push(`num_bedrooms = $${ri2++}`); rv2.push(room.bedrooms); }
        if (room.bathrooms) { ru2.push(`num_bathrooms = $${ri2++}`); rv2.push(room.bathrooms); }
        if (room.basePrice > 0) { ru2.push(`base_price = $${ri2++}`); rv2.push(room.basePrice); }
        if (calryProperty.currency) { ru2.push(`currency = $${ri2++}`); rv2.push(calryProperty.currency); }
        if (ru2.length > 0) {
          ru2.push('updated_at = NOW()');
          rv2.push(gasRoomId);
          await pool.query(`UPDATE bookable_units SET ${ru2.join(', ')} WHERE id = $${ri2}`, rv2);
        }
      } else {
        const roomResult = await pool.query(`
          INSERT INTO bookable_units (
            property_id, name, max_guests, num_bedrooms, num_bathrooms,
            base_price, currency, cm_room_id, cm_source, status, created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'calry', 'active', NOW())
          RETURNING id
        `, [gasPropertyId, room.name, room.maxGuests || 2, room.bedrooms || 1,
            room.bathrooms || 1, room.basePrice || 0, calryProperty.currency || 'USD',
            String(room.externalId)]);
        gasRoomId = roomResult.rows[0].id;
      }
      
      // Import amenities
      const amenities = room.amenities || [];
      for (const amenity of amenities) {
        const amenityName = typeof amenity === 'string' ? amenity : (amenity.name || amenity);
        if (!amenityName) continue;
        
        let amenityResult = await pool.query(
          "SELECT id FROM amenities WHERE LOWER(name) = LOWER($1)", [amenityName]
        );
        
        let amenityId;
        if (amenityResult.rows.length > 0) {
          amenityId = amenityResult.rows[0].id;
        } else {
          const newAmenity = await pool.query(
            "INSERT INTO amenities (name, created_at) VALUES ($1, NOW()) RETURNING id", [amenityName]
          );
          amenityId = newAmenity.rows[0].id;
        }
        
        await pool.query(`
          INSERT INTO room_amenities (room_id, amenity_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
        `, [gasRoomId, amenityId]);
      }
      
      importedRooms.push({ calry_id: room.externalId, gas_id: gasRoomId, name: room.name });
    }
    
    res.json({
      success: true,
      message: 'Property imported successfully',
      data: {
        gas_account_id: gasAccountId,
        gas_property_id: gasPropertyId,
        gas_connection_id: connectionId,
        calry_property_id: propertyId,
        property_name: calryProperty.name,
        rooms_imported: importedRooms.length,
        rooms: importedRooms
      }
    });
    
  } catch (error) {
    console.error('Calry import error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Save Beds24 tokens
app.post('/api/beds24/save-token', async (req, res) => {
  const { refreshToken, token } = req.body;
  try {
    // Save to database (you could create a settings table for this)
    // For now, we'll just acknowledge receipt
    console.log('Beds24 tokens saved:', { refreshToken: refreshToken.substring(0, 20) + '...', token: token.substring(0, 20) + '...' });
    res.json({ success: true, message: 'Tokens saved' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Helper function to get Beds24 access token from refresh token
async function getBeds24AccessToken(pool) {
  let refreshToken = null;
  
  // Try database FIRST (this is set per-user via wizard)
  const tokenResult = await pool.query(
    "SELECT refresh_token, account_id FROM channel_connections WHERE cm_id = (SELECT id FROM channel_managers WHERE cm_code = 'beds24') ORDER BY updated_at DESC LIMIT 1"
  );
  
  if (tokenResult.rows.length > 0 && tokenResult.rows[0].refresh_token) {
    refreshToken = tokenResult.rows[0].refresh_token;
    console.log('Using refresh token from database, account_id:', tokenResult.rows[0].account_id);
  }
  
  // Fallback to environment variable
  if (!refreshToken) {
    refreshToken = process.env.BEDS24_REFRESH_TOKEN;
    if (refreshToken) {
      console.log('Using refresh token from environment variable');
    }
  }
  
  if (!refreshToken) {
    throw new Error('No Beds24 refresh token configured. Please connect via Beds24 wizard.');
  }
  
  // Exchange refresh token for access token
  console.log('Getting fresh Beds24 access token...');
  const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
    headers: {
      'refreshToken': refreshToken
    }
  });
  
  if (!tokenResponse.data.token) {
    throw new Error('Failed to get access token from Beds24');
  }
  
  console.log('Got Beds24 access token');
  return tokenResponse.data.token;
}

// Helper to get Beds24 access token for a specific property via GasSync
// This looks up the correct connection based on the property/room
async function getBeds24AccessTokenForProperty(pool, propertyId, roomId) {
  try {
    // First try to find via GasSync - look up connection from room -> property -> connection
    let connectionResult;
    
    if (roomId) {
      // Look up via room's GasSync connection
      connectionResult = await pool.query(`
        SELECT gsc.id, gsc.credentials, gsc.access_token, gsc.refresh_token
        FROM gas_sync_connections gsc
        JOIN gas_sync_properties gsp ON gsp.connection_id = gsc.id
        JOIN gas_sync_room_types gsrt ON gsrt.sync_property_id = gsp.id
        JOIN bookable_units bu ON bu.id = gsrt.gas_room_id
        WHERE bu.id = $1 AND gsc.adapter_code = 'beds24'
        LIMIT 1
      `, [roomId]);
    }
    
    // If not found via room, try via property
    if ((!connectionResult || connectionResult.rows.length === 0) && propertyId) {
      connectionResult = await pool.query(`
        SELECT gsc.id, gsc.credentials, gsc.access_token, gsc.refresh_token
        FROM gas_sync_connections gsc
        JOIN gas_sync_properties gsp ON gsp.connection_id = gsc.id
        WHERE gsp.gas_property_id = $1 AND gsc.adapter_code = 'beds24'
        LIMIT 1
      `, [propertyId]);
    }
    
    if (connectionResult && connectionResult.rows.length > 0) {
      const conn = connectionResult.rows[0];
      const credentials = typeof conn.credentials === 'string' 
        ? JSON.parse(conn.credentials) 
        : conn.credentials;
      
      const refreshToken = conn.refresh_token || credentials?.refreshToken;
      
      if (refreshToken) {
        console.log('Using GasSync connection refresh token for property:', propertyId);
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': refreshToken }
        });
        
        if (tokenResponse.data.token) {
          console.log('Got Beds24 access token via GasSync connection');
          return tokenResponse.data.token;
        }
      }
    }
    
    // Fallback to global token
    console.log('No GasSync connection found, falling back to global token');
    return await getBeds24AccessToken(pool);
    
  } catch (error) {
    console.error('Error getting Beds24 token for property:', error.message);
    // Fallback to global token
    return await getBeds24AccessToken(pool);
  }
}

// Helper to get Beds24 connection info including account_id
async function getBeds24Connection(pool) {
  const result = await pool.query(
    "SELECT refresh_token, account_id FROM channel_connections WHERE cm_id = (SELECT id FROM channel_managers WHERE cm_code = 'beds24') ORDER BY updated_at DESC LIMIT 1"
  );
  
  if (result.rows.length === 0) {
    return null;
  }
  
  return {
    refreshToken: result.rows[0].refresh_token,
    accountId: result.rows[0].account_id
  };
}

// Get Beds24 properties
app.get('/api/beds24/properties', async (req, res) => {
  try {
    // Get connection from database first, fallback to env var
    const connection = await getBeds24Connection(pool);
    let refreshToken = connection?.refreshToken || process.env.BEDS24_REFRESH_TOKEN;
    const accountId = connection?.accountId;
    
    if (!refreshToken) {
      return res.json({ success: false, error: 'No Beds24 refresh token configured. Please use the Beds24 wizard to connect.' });
    }
    
    // First, get a fresh access token using the refresh token
    console.log('Getting fresh Beds24 access token...');
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
      headers: {
        'refreshToken': refreshToken
      }
    });
    
    const accessToken = tokenResponse.data.token;
    console.log('Got access token, fetching properties...');
    
    // Now fetch properties with the access token
    const response = await axios.get('https://beds24.com/api/v2/properties', {
      headers: {
        'token': accessToken,
        'accept': 'application/json'
      }
    });
    
    let properties = response.data.data || [];
    console.log('Found ' + properties.length + ' total properties');
    
    // Filter by account ID if we have one stored
    if (accountId) {
      properties = properties.filter(p => {
        const propOwnerId = p.account?.ownerId || p.ownerId;
        return String(propOwnerId) === String(accountId);
      });
      console.log('After filtering by account ' + accountId + ': ' + properties.length + ' properties');
    }
    
    res.json({ success: true, data: properties });
    
  } catch (error) {
    console.error('Error fetching Beds24 properties:', error.response?.data || error.message);
    res.json({ success: false, error: error.response?.data?.error || error.message });
  }
});

// Import property from URL with COMPLETE data extraction
app.post('/api/import-property', async (req, res) => {
  const { url } = req.body;
  
  if (!url) {
    return res.json({ success: false, error: 'URL required' });
  }
  
  try {
    // Fetch the page content
    const pageResponse = await axios.get(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      }
    });
    
    const htmlContent = pageResponse.data;
    
    // Extract text content (remove HTML tags but keep structure)
    const textContent = htmlContent
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .substring(0, 25000); // Increased to 25k for more data
    
    // Use Claude API to extract COMPLETE structured data
    const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      messages: [{
        role: 'user',
        content: `Extract ALL property information from this Airbnb/Booking.com page and return ONLY valid JSON.

CRITICAL: Extract EVERYTHING including:
- Exact latitude and longitude coordinates
- ALL image URLs from the photo gallery
- Detailed sleeping arrangements (which beds in which rooms)
- Complete amenities categorized properly
- Exact property size (number of bedrooms, beds, bathrooms)
- House rules with check-in/out times
- Review ratings breakdown
- Host information
- Pricing details

Categorize amenities into these EXACT categories:
Amenities, Business, Entertainment, Food and Drink, Internet, Kitchen, Location, Pets, Pool and Wellness, Services, Sports, Suitability

\${textContent}

Return this EXACT JSON structure:
{
  "property": {
    "name": "property name",
    "property_type": "Entire home/Private room/Hotel room/etc",
    "description": "rewritten unique description 2-3 paragraphs avoiding exact copying",
    "address": "full street address if available",
    "city": "city name",
    "state": "state/region", 
    "country": "country name",
    "postcode": "postal code if available",
    "latitude": 51.5074,
    "longitude": -0.1278,
    "bedrooms": 2,
    "beds": 3,
    "bathrooms": 1.5,
    "max_guests": 4,
    "phone": "phone if available",
    "email": "email if available",
    "website": "listing url",
    "check_in_time": "15:00",
    "check_out_time": "11:00",
    "cancellation_policy": "policy text",
    "house_rules": "all rules text",
    "currency": "GBP",
    "star_rating": 5,
    "review_rating": 4.8,
    "review_count": 127,
    "rating_breakdown": {
      "cleanliness": 4.9,
      "accuracy": 4.8,
      "communication": 5.0,
      "location": 4.7,
      "checkin": 4.9,
      "value": 4.6
    }
  },
  "amenities": {
    "Amenities": ["Heating", "Air Conditioning", "Towels"],
    "Kitchen": ["Kitchen", "Refrigerator", "Microwave"],
    "Internet": ["Wifi"],
    "Bathroom": ["Hair dryer", "Shampoo"],
    "Entertainment": ["TV", "Books"],
    "Pool and Wellness": ["Hot tub", "Pool"],
    "Services": ["Self check-in", "Keypad"],
    "Suitability": ["Family friendly", "Pets allowed"]
  },
  "images": [
    {"url": "https://image-url-1.jpg", "caption": "Living room"},
    {"url": "https://image-url-2.jpg", "caption": "Bedroom"},
    {"url": "https://image-url-3.jpg", "caption": "Kitchen"}
  ],
  "sleeping_arrangements": [
    {"room": "Bedroom 1", "beds": "1 king bed"},
    {"room": "Bedroom 2", "beds": "2 single beds"},
    {"room": "Living room", "beds": "1 sofa bed"}
  ],
  "rooms": [
    {
      "name": "Entire property",
      "room_type": "Entire place",
      "description": "Full property description",
      "quantity": 1,
      "max_adults": 4,
      "max_children": 2,
      "max_guests": 6,
      "size_sqm": 85,
      "bed_configuration": "1 king, 2 singles, 1 sofa bed",
      "base_price": 150,
      "min_stay": 2,
      "accommodation_type": "Entire home"
    }
  ],
  "pricing": {
    "nightly_rate": 150,
    "cleaning_fee": 25,
    "service_fee": 20,
    "currency": "GBP"
  }
}`
      }],
      temperature: 0.7
    }, {
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      }
    });
    
    const claudeText = claudeResponse.data.content[0].text;
    // Clean the response more aggressively
        let cleanJson = claudeText.trim();
        // Remove markdown code blocks
        cleanJson = cleanJson.replace(/```json\n?/g, '').replace(/```\n?/g, '');
        // Remove any leading/trailing text before/after JSON
        const jsonStart = cleanJson.indexOf('{');
        const jsonEnd = cleanJson.lastIndexOf('}');
        if (jsonStart !== -1 && jsonEnd !== -1) {
            cleanJson = cleanJson.substring(jsonStart, jsonEnd + 1);
        }
    const extractedData = JSON.parse(cleanJson);
    
    res.json({
      success: true,
      data: extractedData,
      message: 'Property data extracted successfully!'
    });
    
  } catch (error) {
    console.error('Import error:', error.message);
    res.json({
      success: false,
      error: 'Failed to import: ' + error.message
    });
  }
});

// =====================================================
// NEW BEDS24 IMPORT SYSTEM (Complete Property Import)
// =====================================================

// Check for existing Beds24 connection
app.get('/api/beds24/check-connection', async (req, res) => {
  try {
    // Get most recent active Beds24 connection
    const result = await pool.query(`
      SELECT 
        cc.id,
        cc.access_token,
        cc.refresh_token,
        cc.token_expires_at
      FROM channel_connections cc
      JOIN channel_managers cm ON cc.cm_id = cm.id
      WHERE cm.cm_code = 'beds24' 
        AND cc.status = 'active'
      ORDER BY cc.created_at DESC
      LIMIT 1
    `);
    
    if (result.rows.length > 0) {
      const connection = result.rows[0];
      
      // Check if token needs refresh (if expired or expiring soon)
      const expiresAt = new Date(connection.token_expires_at);
      const now = new Date();
      const needsRefresh = expiresAt <= now;
      
      if (needsRefresh && connection.refresh_token) {
        // Refresh the token
        try {
          const refreshResponse = await axios.post('https://beds24.com/api/v2/authentication/token', {
            refreshToken: connection.refresh_token
          }, {
            headers: { 'accept': 'application/json' }
          });
          
          const newToken = refreshResponse.data.token;
          
          // Update database with new token
          await pool.query(`
            UPDATE channel_connections 
            SET 
              access_token = $1,
              token_expires_at = NOW() + INTERVAL '30 days',
              updated_at = NOW()
            WHERE id = $2
          `, [newToken, connection.id]);
          
          console.log('‚úì Beds24 token refreshed automatically');
          
          res.json({
            success: true,
            hasConnection: true,
            connectionId: connection.id,
            token: newToken,
            refreshToken: connection.refresh_token
          });
        } catch (refreshError) {
          console.error('Token refresh failed:', refreshError.message);
          res.json({
            success: false,
            hasConnection: false,
            error: 'Token expired and refresh failed'
          });
        }
      } else {
        // Token is still valid
        res.json({
          success: true,
          hasConnection: true,
          connectionId: connection.id,
          token: connection.access_token,
          refreshToken: connection.refresh_token
        });
      }
    } else {
      res.json({
        success: true,
        hasConnection: false
      });
    }
  } catch (error) {
    console.error('Check connection error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Step 1: Setup Beds24 Connection (Save to channel_connections table)
app.post('/api/beds24/setup-connection', async (req, res) => {
  const { inviteCode, accountId } = req.body;
  
  if (!inviteCode) {
    return res.json({ success: false, error: 'Invite code required' });
  }
  
  try {
    console.log('üîó Setting up Beds24 connection...');
    if (accountId) {
      console.log('   Account ID specified:', accountId);
    }
    
    // Ensure we have at least one user (create default if needed)
    const userCheck = await pool.query('SELECT id FROM users LIMIT 1');
    let userId;
    
    if (userCheck.rows.length === 0) {
      console.log('üìù Creating default user...');
      const userResult = await pool.query(`
        INSERT INTO users (
          user_type,
          email,
          password_hash,
          first_name,
          last_name,
          account_status
        ) VALUES (
          'property_owner',
          'admin@gas-system.com',
          'temp_password_hash',
          'Admin',
          'User',
          'active'
        )
        RETURNING id
      `);
      userId = userResult.rows[0].id;
      console.log('‚úì Default user created with ID: ' + userId);
    } else {
      userId = userCheck.rows[0].id;
      console.log('‚úì Using existing user ID: ' + userId);
    }
    
    // Ensure Beds24 exists in channel_managers table (check first)
    const beds24Check = await pool.query(`SELECT id FROM channel_managers WHERE cm_code = 'beds24' OR LOWER(name) = 'beds24' LIMIT 1`);
    if (beds24Check.rows.length === 0) {
      await pool.query(`
        INSERT INTO channel_managers (name, cm_name, cm_code, api_base_url, auth_type)
        VALUES ('Beds24', 'Beds24', 'beds24', 'https://api.beds24.com/v2', 'bearer_token')
      `);
    }
    
    // Get tokens from Beds24
    const response = await axios.get('https://beds24.com/api/v2/authentication/setup', {
      headers: {
        'accept': 'application/json',
        'code': inviteCode
      }
    });
    
    const { token, refreshToken } = response.data;
    
    // Ensure account_id column exists
    await pool.query(`
      ALTER TABLE channel_connections ADD COLUMN IF NOT EXISTS account_id VARCHAR(50)
    `).catch(() => {});
    
    // Check if connection already exists
    const existingConn = await pool.query(
      'SELECT id FROM channel_connections WHERE user_id = $1 AND cm_id = (SELECT id FROM channel_managers WHERE cm_code = $2 LIMIT 1)',
      [userId, 'beds24']
    );
    
    let connectionId;
    if (existingConn.rows.length > 0) {
      connectionId = existingConn.rows[0].id;
      await pool.query(`
        UPDATE channel_connections SET
          api_key = $1, refresh_token = $2, access_token = $3,
          token_expires_at = NOW() + INTERVAL '30 days', status = 'active', updated_at = NOW()
        WHERE id = $4
      `, [inviteCode, refreshToken, token, connectionId]);
    } else {
      const result = await pool.query(`
        INSERT INTO channel_connections (
          user_id, cm_id, api_key, refresh_token, access_token,
          token_expires_at, status, sync_enabled, sync_interval_minutes
        ) VALUES (
          $1, (SELECT id FROM channel_managers WHERE cm_code = 'beds24' LIMIT 1),
          $2, $3, $4, NOW() + INTERVAL '30 days', 'active', true, 60
        )
        RETURNING id
      `, [userId, inviteCode, refreshToken, token]);
      connectionId = result.rows[0].id;
    }
    
    console.log('‚úì Connection saved to database');
    
    res.json({
      success: true,
      token,
      refreshToken,
      connectionId,
      message: 'Connected to Beds24 successfully'
    });
    
  } catch (error) {
    console.error('Beds24 connection error:', error.response?.data || error.message);
    res.json({
      success: false,
      error: error.response?.data?.error || error.message
    });
  }
});

// Step 2: List Properties from Beds24
app.post('/api/beds24/list-properties', async (req, res) => {
  const { token, connectionId, accountId } = req.body;
  
  try {
    console.log('üìã Fetching properties from Beds24...');
    if (accountId) {
      console.log('   Filtering by account ID:', accountId);
    }
    
    const response = await axios.get('https://beds24.com/api/v2/properties', {
      headers: {
        'token': token,
        'accept': 'application/json'
      },
      params: {
        includeTexts: 'all',
        includePictures: true,
        includeAllRooms: true
      }
    });
    
    let properties = response.data.data || [];
    console.log('Found ' + properties.length + ' total properties');
    
    // Normalize propId (Beds24 API may return id or propId)
    properties = properties.map(p => ({
      ...p,
      propId: p.propId || p.id,
      name: p.name || p.propName || 'Property'
    }));
    
    // Log first property structure for debugging
    if (properties.length > 0) {
      console.log('First property keys:', Object.keys(properties[0]));
      console.log('First property propId:', properties[0].propId);
    }
    
    // Filter by account ID if provided
    if (accountId) {
      properties = properties.filter(p => {
        const propOwnerId = p.account?.ownerId || p.ownerId;
        return String(propOwnerId) === String(accountId);
      });
      console.log('After filtering by account ' + accountId + ': ' + properties.length + ' properties');
    }
    
    res.json({
      success: true,
      properties: properties
    });
    
  } catch (error) {
    console.error('Error fetching properties:', error.message);
    res.json({
      success: false,
      error: error.message
    });
  }
});

// =====================================================
// BEDS24 REFRESH PROPERTIES - Compare CM with GAS
// =====================================================
app.post('/api/beds24/refresh-properties', async (req, res) => {
  const { token, accountId } = req.body;
  
  try {
    console.log('üîÑ Refreshing Beds24 properties for account:', accountId);
    
    // 1. Fetch all properties from Beds24
    const response = await axios.get('https://beds24.com/api/v2/properties', {
      headers: { 'token': token, 'accept': 'application/json' },
      params: { includeTexts: 'all', includePictures: true, includeAllRooms: true }
    });
    
    const cmProperties = response.data.data || [];
    console.log('Found ' + cmProperties.length + ' properties in Beds24');
    
    // 2. Get existing properties in GAS for this account
    const existingResult = await pool.query(
      'SELECT id, name, beds24_property_id FROM properties WHERE account_id = $1 AND beds24_property_id IS NOT NULL',
      [accountId]
    );
    const existingProperties = existingResult.rows;
    const existingBeds24Ids = existingProperties.map(p => String(p.beds24_property_id));
    
    // 3. Compare
    const existing = [];
    const newProps = [];
    const removed = [];
    
    // Check each CM property
    for (const cmProp of cmProperties) {
      const cmId = String(cmProp.propId);
      const existingProp = existingProperties.find(p => String(p.beds24_property_id) === cmId);
      
      if (existingProp) {
        existing.push({
          gas_id: existingProp.id,
          cm_id: cmId,
          name: cmProp.name,
          gas_name: existingProp.name
        });
      } else {
        newProps.push({
          cm_id: cmId,
          name: cmProp.name,
          city: cmProp.city || '',
          rooms: cmProp.rooms?.length || 0
        });
      }
    }
    
    // Check for removed (in GAS but not in CM)
    const cmIds = cmProperties.map(p => String(p.propId));
    for (const existingProp of existingProperties) {
      if (!cmIds.includes(String(existingProp.beds24_property_id))) {
        removed.push({
          gas_id: existingProp.id,
          cm_id: existingProp.beds24_property_id,
          name: existingProp.name
        });
      }
    }
    
    console.log(`Comparison: ${existing.length} existing, ${newProps.length} new, ${removed.length} removed`);
    
    res.json({
      success: true,
      existing,
      new: newProps,
      removed,
      channel_manager: 'beds24'
    });
    
  } catch (error) {
    console.error('Error refreshing Beds24 properties:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// ENHANCED BEDS24 IMPORT - FULL CONTENT IMPORT
// =====================================================
// Imports: Properties, Images, Amenities, Policies, Rooms, Room Images, Bed Config
// Language: Default language only (AI translates on frontend)

// Simple Beds24 import - creates account automatically (used by wizard)
app.post('/api/beds24/import-property', async (req, res) => {
  const { token, propId, accountName, accountEmail } = req.body;
  
  try {
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üöÄ BEDS24 IMPORT - Property ID: ' + propId);
    console.log('   Account: ' + (accountName || 'auto-generate'));
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    if (!propId) {
      throw new Error('Property ID is required');
    }
    
    // 1. Fetch property from Beds24
    const propResponse = await axios.get('https://beds24.com/api/v2/properties', {
      headers: { 'token': token, 'accept': 'application/json' },
      params: { id: propId, includeTexts: 'all', includeAllRooms: true }
    });
    
    const props = propResponse.data.data || propResponse.data || [];
    const prop = Array.isArray(props) ? props[0] : props;
    
    if (!prop) {
      throw new Error('Property not found in Beds24');
    }
    
    // Use propId from response or from request
    const beds24PropId = prop.propId || prop.id || propId;
    const propName = prop.name || prop.propName || 'Beds24 Property';
    console.log('   Property: ' + propName + ' (Beds24 ID: ' + beds24PropId + ')');
    
    // 2. Use provided account name, or fall back to property name
    const targetAccountName = accountName || propName;
    const targetEmail = accountEmail || `${targetAccountName.toLowerCase().replace(/[^a-z0-9]/g, '_')}_${Date.now()}@gas.travel`;
    
    let accountId;
    const existingAccount = await pool.query(
      'SELECT id FROM accounts WHERE LOWER(name) = LOWER($1)',
      [targetAccountName]
    );
    
    if (existingAccount.rows.length > 0) {
      accountId = existingAccount.rows[0].id;
      console.log('   Using existing account ID: ' + accountId);
    } else {
      const newAccount = await pool.query(`
        INSERT INTO accounts (name, email, role, business_name, status)
        VALUES ($1, $2, 'admin', $1, 'active')
        RETURNING id
      `, [targetAccountName, targetEmail]);
      accountId = newAccount.rows[0].id;
      console.log('   Created new account ID: ' + accountId + ' (' + targetAccountName + ')');
    }
    
    // 3. Check if property already exists
    const existingProp = await pool.query(
      'SELECT id FROM properties WHERE beds24_property_id::text = $1',
      [String(propId)]
    );
    
    let gasPropertyId;
    if (existingProp.rows.length > 0) {
      gasPropertyId = existingProp.rows[0].id;
      // Update account_id if needed
      await pool.query('UPDATE properties SET account_id = $1 WHERE id = $2', [accountId, gasPropertyId]);
      console.log('   Updated existing property ID: ' + gasPropertyId);
    } else {
      // 4. Create property
      console.log('   INSERT values: accountId=' + accountId + ', propId=' + propId + ', name=' + propName);
      const propResult = await pool.query(`
        INSERT INTO properties (
          account_id, user_id, beds24_property_id, name, 
          property_type, cm_source, status
        ) VALUES ($1, 1, $2, $3, 'hotel', 'beds24', 'active')
        RETURNING id
      `, [accountId, String(propId), propName]);
      gasPropertyId = propResult.rows[0].id;
      console.log('   Created property ID: ' + gasPropertyId);
    }
    
    // 5. Import rooms
    const rooms = prop.roomTypes || prop.rooms || [];
    let roomsCreated = 0;
    
    for (const room of rooms) {
      const roomId = room.id || room.roomId;
      
      // Skip if no room ID
      if (!roomId) {
        console.log('   Skipping room without ID');
        continue;
      }
      
      // Check if room exists
      const existingRoom = await pool.query(
        'SELECT id FROM bookable_units WHERE property_id = $1 AND beds24_room_id::text = $2',
        [gasPropertyId, String(roomId)]
      );
      
      if (existingRoom.rows.length === 0) {
        await pool.query(`
          INSERT INTO bookable_units (
            property_id, beds24_room_id, cm_room_id, name, 
            max_guests, base_price, status
          ) VALUES ($1, $2, $3, $4, $5, $6, 'available')
        `, [
          gasPropertyId, 
          String(roomId), 
          String(roomId), 
          room.name || room.roomName || 'Room',
          room.maxPeople || room.maxGuests || 2,
          room.rackRate || room.basePrice || 100
        ]);
        roomsCreated++;
      }
    }
    console.log('   Created ' + roomsCreated + ' rooms (of ' + rooms.length + ' total)');
    
    // 6. Save/update channel connection for this account
    const cmResult = await pool.query("SELECT id FROM channel_managers WHERE cm_code = 'beds24' LIMIT 1");
    if (cmResult.rows.length > 0) {
      const cmId = cmResult.rows[0].id;
      
      // Ensure gas_account_id column exists
      await pool.query(`ALTER TABLE channel_connections ADD COLUMN IF NOT EXISTS gas_account_id INTEGER`).catch(() => {});
      
      // Check if connection exists for this account
      const existingConn = await pool.query(
        'SELECT id FROM channel_connections WHERE gas_account_id = $1 AND cm_id = $2',
        [accountId, cmId]
      );
      
      if (existingConn.rows.length === 0) {
        await pool.query(`
          INSERT INTO channel_connections (user_id, cm_id, gas_account_id, access_token, status, created_at, updated_at)
          VALUES (1, $1, $2, $3, 'active', NOW(), NOW())
        `, [cmId, accountId, token]);
        console.log('   Created channel connection for account');
      } else {
        await pool.query(`
          UPDATE channel_connections SET access_token = $1, status = 'active', updated_at = NOW()
          WHERE id = $2
        `, [token, existingConn.rows[0].id]);
        console.log('   Updated channel connection');
      }
    }
    
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('‚úÖ IMPORT COMPLETE');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    res.json({
      success: true,
      accountId,
      propertyId: gasPropertyId,
      propertyName: propName,
      roomsCreated,
      totalRooms: rooms.length
    });
    
  } catch (error) {
    console.error('Beds24 import error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/beds24/import-complete-property', async (req, res) => {
  const { propertyId, connectionId, token } = req.body;
  
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üöÄ ENHANCED BEDS24 IMPORT - Property ID: ' + propertyId);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    // Get the user_id from the connection
    const connResult = await client.query('SELECT user_id FROM channel_connections WHERE id = $1', [connectionId]);
    if (connResult.rows.length === 0) {
      throw new Error('Connection not found');
    }
    const userId = connResult.rows[0].user_id;
    
    // =========================================================
    // 1. FETCH COMPLETE PROPERTY DATA FROM BEDS24
    // =========================================================
    console.log('\nüì° STEP 1: Fetching property from Beds24...');
    
    const propResponse = await axios.get('https://beds24.com/api/v2/properties', {
      headers: { 'token': token, 'accept': 'application/json' },
      params: {
        id: propertyId,
        includeTexts: 'all',       // Get all text fields
        includePictures: true,     // Get images
        includeAllRooms: true,     // Get all rooms
        includeUnitDetails: true   // Get room details
      }
    });
    
    const prop = propResponse.data.data?.[0] || propResponse.data[0];
    
    if (!prop) {
      throw new Error('Property not found in Beds24 response');
    }
    
    console.log('   ‚úì Property fetched: ' + (prop.name || prop.propName || 'Unknown'));
    
    // Debug: Log what we received
    console.log('   üìã Available data keys:', Object.keys(prop).join(', '));
    
    // =========================================================
    // 2. INSERT/UPDATE PROPERTY
    // =========================================================
    console.log('\nüè® STEP 2: Saving property to database...');
    
    // Extract description from texts array (default language only)
    let propertyDescription = '';
    let shortDescription = '';
    let houseRules = '';
    
    if (prop.texts && Array.isArray(prop.texts) && prop.texts.length > 0) {
      const defaultText = prop.texts[0]; // First = default language
      propertyDescription = defaultText.propertyDescription || defaultText.description || '';
      shortDescription = defaultText.propertyShortDescription || defaultText.shortDescription || '';
      houseRules = defaultText.houseRules || defaultText.propertyHouseRules || '';
    }
    
    // Check if property already exists (by beds24_property_id)
    // Cast to text to handle any type mismatches
    const existingProp = await client.query(
      'SELECT id FROM properties WHERE beds24_property_id::text = $1::text',
      [propertyId]
    );
    
    let gasPropertyId;
    let isUpdate = false;
    
    if (existingProp.rows.length > 0) {
      // UPDATE existing property
      gasPropertyId = existingProp.rows[0].id;
      isUpdate = true;
      
      await client.query(`
        UPDATE properties SET
          name = $1,
          property_type = $2,
          description = $3,
          short_description = $4,
          house_rules = $5,
          address = $6,
          city = $7,
          state = $8,
          postcode = $9,
          country = $10,
          latitude = $11,
          longitude = $12,
          check_in_from = $13,
          check_in_until = $14,
          check_out_by = $15,
          currency = $16,
          phone = $17,
          email = $18,
          fax = $19,
          website = $20,
          contact_first_name = $21,
          contact_last_name = $22,
          cm_source = 'beds24',
          updated_at = NOW()
        WHERE id = $23
      `, [
        prop.name || prop.propName || 'Property',
        prop.propertyType || prop.propType || 'hotel',
        JSON.stringify({ en: propertyDescription }),
        JSON.stringify({ en: shortDescription }),
        JSON.stringify({ en: houseRules }),
        prop.address || prop.propAddress || '',
        prop.city || prop.propCity || '',
        prop.state || prop.propState || '',
        prop.postcode || prop.propPostcode || prop.zipCode || '',
        prop.country || prop.propCountry || '',
        prop.latitude || prop.propLatitude || null,
        prop.longitude || prop.propLongitude || null,
        prop.checkInStart || prop.checkInFrom || '15:00',
        prop.checkInEnd || prop.checkInUntil || '22:00',
        prop.checkOutEnd || prop.checkOutBy || '11:00',
        prop.currency || 'USD',
        prop.phone || prop.propPhone || '',
        prop.email || prop.propEmail || '',
        prop.fax || prop.propFax || '',
        prop.website || prop.propWebsite || '',
        prop.contactFirstName || '',
        prop.contactLastName || '',
        gasPropertyId
      ]);
      
      console.log('   ‚úì Updated existing property (GAS ID: ' + gasPropertyId + ')');
    } else {
      // INSERT new property
      const propertyResult = await client.query(`
        INSERT INTO properties (
          user_id,
          beds24_property_id,
          cm_source,
          name,
          property_type,
          description,
          short_description,
          house_rules,
          address,
          city,
          state,
          postcode,
          country,
          latitude,
          longitude,
          check_in_from,
          check_in_until,
          check_out_by,
          currency,
          phone,
          email,
          fax,
          website,
          contact_first_name,
          contact_last_name,
          status
        ) VALUES (
          $1, $2, 'beds24', $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, 'active'
        )
        RETURNING id
      `, [
        userId,
        propertyId,
        prop.name || prop.propName || 'Property',
        prop.propertyType || prop.propType || 'hotel',
        JSON.stringify({ en: propertyDescription }),
        JSON.stringify({ en: shortDescription }),
        JSON.stringify({ en: houseRules }),
        prop.address || prop.propAddress || '',
        prop.city || prop.propCity || '',
        prop.state || prop.propState || '',
        prop.postcode || prop.propPostcode || prop.zipCode || '',
        prop.country || prop.propCountry || '',
        prop.latitude || prop.propLatitude || null,
        prop.longitude || prop.propLongitude || null,
        prop.checkInStart || prop.checkInFrom || '15:00',
        prop.checkInEnd || prop.checkInUntil || '22:00',
        prop.checkOutEnd || prop.checkOutBy || '11:00',
        prop.currency || 'USD',
        prop.phone || prop.propPhone || '',
        prop.email || prop.propEmail || '',
        prop.fax || prop.propFax || '',
        prop.website || prop.propWebsite || '',
        prop.contactFirstName || '',
        prop.contactLastName || ''
      ]);
      
      gasPropertyId = propertyResult.rows[0].id;
      console.log('   ‚úì Created new property (GAS ID: ' + gasPropertyId + ')');
    }
    
    console.log('   üìç Location: ' + (prop.city || 'N/A') + ', ' + (prop.country || 'N/A'));
    console.log('   üè∑Ô∏è  Type: ' + (prop.propertyType || 'N/A'));
    
    // =========================================================
    // 3. SKIP PROPERTY IMAGES - Users upload directly in GAS
    // =========================================================
    // Images are NOT imported from CM because:
    // - URL references break over time
    // - GAS needs to validate size, format, orientation
    // - Users have full control over their image content
    console.log('\nüñºÔ∏è  STEP 3: Skipping property images (users upload in GAS)');
    
    // =========================================================
    // 4. SKIP PROPERTY AMENITIES - Users select from master list in GAS
    // =========================================================
    console.log('\nüõéÔ∏è  STEP 4: Skipping property amenities (users select from master list)');
    // Property amenities will be selected by users from master_amenities table
    // and stored in property_amenity_selections
    
    // =========================================================
    // 5. IMPORT PROPERTY POLICIES
    // =========================================================
    console.log('\nüìú STEP 5: Importing property policies...');
    
    // Delete existing policies first (clean sync)
    await client.query('DELETE FROM property_policies WHERE property_id = $1', [gasPropertyId]);
    
    let policiesCount = 0;
    
    // Cancellation policy
    const cancellationPolicy = prop.cancellationPolicy || 
                               (prop.texts?.[0]?.cancellationPolicy) || 
                               prop.cancellation || '';
    if (cancellationPolicy) {
      await client.query(`
        INSERT INTO property_policies (
          property_id, policy_type, title, content, display_order, is_required
        ) VALUES ($1, 'cancellation', $2, $3, 0, true)
      `, [
        gasPropertyId,
        JSON.stringify({ en: 'Cancellation Policy' }),
        JSON.stringify({ en: cancellationPolicy })
      ]);
      policiesCount++;
    }
    
    // House rules (if not in main property)
    if (houseRules && houseRules.length > 0) {
      await client.query(`
        INSERT INTO property_policies (
          property_id, policy_type, title, content, display_order, is_required
        ) VALUES ($1, 'house_rules', $2, $3, 1, true)
      `, [
        gasPropertyId,
        JSON.stringify({ en: 'House Rules' }),
        JSON.stringify({ en: houseRules })
      ]);
      policiesCount++;
    }
    
    // Additional policies from texts
    const texts = prop.texts?.[0] || {};
    if (texts.damagePolicy) {
      await client.query(`
        INSERT INTO property_policies (
          property_id, policy_type, title, content, display_order, is_required
        ) VALUES ($1, 'damage', $2, $3, 2, false)
      `, [
        gasPropertyId,
        JSON.stringify({ en: 'Damage Policy' }),
        JSON.stringify({ en: texts.damagePolicy })
      ]);
      policiesCount++;
    }
    
    console.log('   ‚úì Imported ' + policiesCount + ' policies');
    
    // =========================================================
    // 6. IMPORT ROOMS (SMART SYNC)
    // =========================================================
    console.log('\nüõèÔ∏è  STEP 6: Importing rooms with smart sync...');
    
    let rooms = prop.roomTypes || prop.rooms || [];
    if (!Array.isArray(rooms)) rooms = [];
    
    let roomsAdded = 0;
    let roomsUpdated = 0;
    
    for (const room of rooms) {
      const beds24RoomId = String(room.id || room.roomId);
      
      // Extract room description from texts
      let roomDescription = '';
      let roomShortDesc = '';
      if (room.texts && Array.isArray(room.texts) && room.texts.length > 0) {
        const roomText = room.texts[0];
        roomDescription = roomText.roomDescription || roomText.description || '';
        roomShortDesc = roomText.roomShortDescription || roomText.shortDescription || '';
      }
      
      // Extract bed configuration from Beds24 data
      // Beds24 may provide this in multiple formats:
      // 1. room.bedTypes array: [{type: 'BED_KING', quantity: 1}, ...]
      // 2. room.bedConfiguration object
      // 3. In featureCodes string: "BED_KING,BED_SINGLE,BED_SINGLE"
      let bedConfig = null;
      
      // Try structured bedTypes first
      if (room.bedTypes && Array.isArray(room.bedTypes) && room.bedTypes.length > 0) {
        bedConfig = { 
          beds: room.bedTypes.map(b => ({
            type: b.type || b.bedType || 'BED_DOUBLE',
            quantity: b.quantity || b.count || 1,
            name: getBedName(b.type || b.bedType)
          }))
        };
      } 
      // Try bedConfiguration object
      else if (room.bedConfiguration && typeof room.bedConfiguration === 'object') {
        bedConfig = room.bedConfiguration;
      }
      // Extract from featureCodes if present
      else if (room.featureCodes && typeof room.featureCodes === 'string') {
        const bedCodes = room.featureCodes.split(',')
          .map(c => c.trim())
          .filter(c => c.startsWith('BED_'));
        
        if (bedCodes.length > 0) {
          // Count occurrences of each bed type
          const bedCounts = {};
          for (const code of bedCodes) {
            bedCounts[code] = (bedCounts[code] || 0) + 1;
          }
          
          bedConfig = {
            beds: Object.entries(bedCounts).map(([type, quantity]) => ({
              type,
              quantity,
              name: getBedName(type)
            }))
          };
        }
      }
      
      // Helper function for bed names (defined inline to avoid scope issues)
      function getBedName(code) {
        const names = {
          'BED_BUNK': 'Bunkbed', 'BED_CHILD': 'Child Bed', 'BED_CRIB': 'Cot',
          'BED_DOUBLE': 'Double Bed', 'BED_KING': 'King Bed', 'BED_MURPHY': 'Murphy Bed',
          'BED_QUEEN': 'Queen Bed', 'BED_SOFA': 'Sofa Bed', 'BED_SINGLE': 'Single Bed',
          'BED_FUTON': 'Futon', 'BED_FLOORMATTRESS': 'Floor Mattress', 'BED_TODDLER': 'Toddler Bed',
          'BED_HAMMOCK': 'Hammock', 'BED_AIRMATTRESS': 'Air Mattress', 'BED_COUCH': 'Couch'
        };
        return names[code] || code;
      }
      
      // Count bedrooms and bathrooms from featureCodes
      let bedroomCount = room.bedroomCount || room.bedrooms || null;
      let bathroomCount = room.bathroomCount || room.bathrooms || null;
      
      if (room.featureCodes && typeof room.featureCodes === 'string') {
        const codes = room.featureCodes.split(',').map(c => c.trim());
        if (!bedroomCount) {
          bedroomCount = codes.filter(c => c.startsWith('BEDROOM')).length || null;
        }
        if (!bathroomCount) {
          bathroomCount = codes.filter(c => c.startsWith('BATHROOM')).length || null;
        }
      }
      
      // Check if room exists (cast to text to handle type mismatches)
      const existingRoom = await client.query(`
        SELECT id FROM bookable_units 
        WHERE property_id = $1 AND (cm_room_id::text = $2::text OR beds24_room_id::text = $2::text)
      `, [gasPropertyId, beds24RoomId]);
      
      let unitId;
      
      if (existingRoom.rows.length > 0) {
        // UPDATE existing room
        unitId = existingRoom.rows[0].id;
        
        await client.query(`
          UPDATE bookable_units SET
            name = $1,
            unit_type = $2,
            description = $3,
            short_description = $4,
            max_guests = $5,
            max_adults = $6,
            max_children = $7,
            quantity = $8,
            base_price = $9,
            size_sqm = $10,
            bed_configuration = $11,
            bathroom_count = $12,
            bedroom_count = $13,
            min_stay = $14,
            max_stay = $15,
            beds24_room_id = $17,
            cm_room_id = $18,
            updated_at = NOW()
          WHERE id = $16
        `, [
          room.name || room.roomName || 'Room',
          room.roomType || room.unitType || 'double',
          JSON.stringify({ en: roomDescription }),
          JSON.stringify({ en: roomShortDesc }),
          room.maxPeople || room.maxGuests || 2,
          room.maxAdult || room.maxAdults || 2,
          room.maxChildren || 0,
          room.qty || room.quantity || 1,
          room.rackRate || room.basePrice || room.price || 100,
          room.size || room.sizeSqm || null,
          bedConfig ? JSON.stringify(bedConfig) : null,
          bathroomCount,
          bedroomCount,
          room.minStay || 1,
          room.maxStay || null,
          unitId,
          parseInt(beds24RoomId) || null,
          beds24RoomId
        ]);
        
        roomsUpdated++;
        console.log('   ‚úì Updated: ' + (room.name || 'Room') + ' (Beds24 ID: ' + beds24RoomId + ')');
      } else {
        // INSERT new room
        const unitResult = await client.query(`
          INSERT INTO bookable_units (
            property_id,
            beds24_room_id,
            cm_room_id,
            name,
            unit_type,
            description,
            short_description,
            max_guests,
            max_adults,
            max_children,
            quantity,
            base_price,
            size_sqm,
            bed_configuration,
            bathroom_count,
            bedroom_count,
            min_stay,
            max_stay,
            status
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, 'available'
          )
          RETURNING id
        `, [
          gasPropertyId,
          parseInt(beds24RoomId) || null,
          beds24RoomId,
          room.name || room.roomName || 'Room',
          room.roomType || room.unitType || 'double',
          JSON.stringify({ en: roomDescription }),
          JSON.stringify({ en: roomShortDesc }),
          room.maxPeople || room.maxGuests || 2,
          room.maxAdult || room.maxAdults || 2,
          room.maxChildren || 0,
          room.qty || room.quantity || 1,
          room.rackRate || room.basePrice || room.price || 100,
          room.size || room.sizeSqm || null,
          bedConfig ? JSON.stringify(bedConfig) : null,
          bathroomCount,
          bedroomCount,
          room.minStay || 1,
          room.maxStay || null
        ]);
        
        unitId = unitResult.rows[0].id;
        roomsAdded++;
        console.log('   ‚úì Added: ' + (room.name || 'Room'));
      }
      
      // =========================================================
      // 6a. SKIP ROOM IMAGES - Users upload directly in GAS
      // =========================================================
      // Room images are NOT imported - users upload in GAS for quality control
      
      // =========================================================
      // 6b. SKIP ROOM AMENITIES - Users select from master list in GAS
      // =========================================================
      // Room amenities will be selected by users from master_amenities table
      // and stored in room_amenity_selections
      // This allows proper control and consistency across all properties
    }
    
    console.log('   üìä Rooms: ' + roomsAdded + ' added, ' + roomsUpdated + ' updated');
    
    // =========================================================
    // 7. CREATE/UPDATE PROPERTY-CM LINK
    // =========================================================
    console.log('\nüîó STEP 7: Creating channel manager link...');
    
    // Check if link exists
    const existingLink = await client.query(`
      SELECT id FROM property_cm_links 
      WHERE property_id = $1 AND connection_id = $2
    `, [gasPropertyId, connectionId]);
    
    if (existingLink.rows.length > 0) {
      await client.query(`
        UPDATE property_cm_links SET
          cm_property_name = $1,
          updated_at = NOW()
        WHERE property_id = $2 AND connection_id = $3
      `, [prop.name || prop.propName, gasPropertyId, connectionId]);
      console.log('   ‚úì Updated existing link');
    } else {
      await client.query(`
        INSERT INTO property_cm_links (
          property_id,
          connection_id,
          cm_property_id,
          cm_property_name,
          sync_enabled,
          sync_availability,
          sync_rates,
          sync_bookings,
          status
        ) VALUES ($1, $2, $3, $4, true, true, true, true, 'active')
      `, [gasPropertyId, connectionId, propertyId, prop.name || prop.propName]);
      console.log('   ‚úì Created new link');
    }
    
    // =========================================================
    // COMMIT TRANSACTION
    // =========================================================
    await client.query('COMMIT');
    
    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üéâ IMPORT COMPLETE!');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    const stats = {
      propertyId: gasPropertyId,
      beds24PropertyId: propertyId,
      propertyName: prop.name || prop.propName || 'Property',
      policies: policiesCount,
      roomsAdded: roomsAdded,
      roomsUpdated: roomsUpdated,
      isUpdate: isUpdate,
      note: 'Amenities not imported - users select from master list in GAS'
    };
    
    console.log('   üìä Stats:', JSON.stringify(stats, null, 2));
    
    res.json({
      success: true,
      stats: stats,
      message: isUpdate ? 'Property & rooms updated. Select amenities in GAS.' : 'Property & rooms imported. Select amenities in GAS.'
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('\n‚ùå IMPORT FAILED:', error.message);
    if (error.response?.status) {
      console.error('   Beds24 API status:', error.response.status);
    }
    if (error.response?.data) {
      console.error('   Beds24 response:', JSON.stringify(error.response.data));
    }
    res.json({
      success: false,
      error: error.message,
      details: error.response?.data || null
    });
  } finally {
    client.release();
  }
});

// =====================================================
// HOSTAWAY CHANNEL MANAGER INTEGRATION
// =====================================================

// Helper function to get Hostaway access token
async function getHostawayAccessToken(accountId, clientSecret) {
  const response = await axios.post('https://api.hostaway.com/v1/accessTokens', 
    `grant_type=client_credentials&client_id=${accountId}&client_secret=${clientSecret}&scope=general`,
    {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Cache-control': 'no-cache'
      }
    }
  );
  
  return response.data.access_token;
}

// Helper to get stored Hostaway token from database
async function getStoredHostawayToken(pool) {
  const result = await pool.query(`
    SELECT access_token, account_id FROM channel_connections 
    WHERE cm_id = (SELECT id FROM channel_managers WHERE cm_code = 'hostaway') 
    AND status = 'active'
    ORDER BY updated_at DESC LIMIT 1
  `);
  
  if (result.rows.length === 0) {
    return null;
  }
  
  return {
    accessToken: result.rows[0].access_token,
    accountId: result.rows[0].account_id
  };
}

// Setup Hostaway connection
app.post('/api/hostaway/setup-connection', async (req, res) => {
  try {
    const { accountId, clientSecret } = req.body;
    
    if (!accountId || !clientSecret) {
      return res.json({ success: false, error: 'Account ID and Client Secret are required' });
    }
    
    console.log('Setting up Hostaway connection for account:', accountId);
    
    // Get access token from Hostaway
    const accessToken = await getHostawayAccessToken(accountId, clientSecret);
    
    if (!accessToken) {
      return res.json({ success: false, error: 'Failed to get access token from Hostaway' });
    }
    
    console.log('Got Hostaway access token');
    
    // Ensure hostaway exists in channel_managers
    const existingCM = await pool.query("SELECT id FROM channel_managers WHERE cm_code = 'hostaway'");
    let cmId;
    
    if (existingCM.rows.length === 0) {
      const newCM = await pool.query(`
        INSERT INTO channel_managers (cm_code, cm_name, api_base_url, auth_type)
        VALUES ('hostaway', 'Hostaway', 'https://api.hostaway.com/v1', 'oauth2')
        RETURNING id
      `);
      cmId = newCM.rows[0].id;
    } else {
      cmId = existingCM.rows[0].id;
    }
    
    // Store the connection - check if exists first
    const existingConn = await pool.query(
      'SELECT id FROM channel_connections WHERE cm_id = $1 AND account_id = $2',
      [cmId, accountId]
    );
    
    let connectionId;
    if (existingConn.rows.length > 0) {
      await pool.query(
        'UPDATE channel_connections SET access_token = $1, api_key = $2, status = $3, updated_at = NOW() WHERE id = $4',
        [accessToken, clientSecret, 'active', existingConn.rows[0].id]
      );
      connectionId = existingConn.rows[0].id;
    } else {
      const newConn = await pool.query(`
        INSERT INTO channel_connections (cm_id, user_id, access_token, api_key, account_id, status, created_at, updated_at)
        VALUES ($1, 1, $2, $3, $4, 'active', NOW(), NOW())
        RETURNING id
      `, [cmId, accessToken, clientSecret, accountId]);
      connectionId = newConn.rows[0].id;
    }
    
    res.json({
      success: true,
      accessToken,
      connectionId,
      message: 'Hostaway connected successfully'
    });
    
  } catch (error) {
    console.error('Hostaway setup error:', error.response?.data || error.message);
    res.json({ 
      success: false, 
      error: error.response?.data?.message || error.message 
    });
  }
});

// List Hostaway properties (listings)
app.post('/api/hostaway/list-properties', async (req, res) => {
  try {
    const { token, connectionId } = req.body;
    
    if (!token) {
      return res.json({ success: false, error: 'Access token required' });
    }
    
    console.log('Fetching Hostaway listings...');
    
    const response = await axios.get('https://api.hostaway.com/v1/listings', {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Cache-control': 'no-cache'
      },
      params: {
        limit: 100
      }
    });
    
    if (response.data.status === 'success') {
      console.log('Found ' + (response.data.result?.length || 0) + ' Hostaway listings');
      res.json({ success: true, data: response.data.result || [] });
    } else {
      res.json({ success: false, error: response.data.result || 'Failed to fetch listings' });
    }
    
  } catch (error) {
    console.error('Hostaway list error:', error.response?.data || error.message);
    res.json({ success: false, error: error.response?.data?.message || error.message });
  }
});

// =====================================================
// HOSTAWAY REFRESH PROPERTIES - Compare CM with GAS
// =====================================================
app.post('/api/hostaway/refresh-properties', async (req, res) => {
  const { token, accountId } = req.body;
  
  try {
    console.log('üîÑ Refreshing Hostaway properties for account:', accountId);
    
    // 1. Fetch all listings from Hostaway
    const response = await axios.get('https://api.hostaway.com/v1/listings', {
      headers: { 'Authorization': `Bearer ${token}`, 'Cache-control': 'no-cache' },
      params: { limit: 100 }
    });
    
    if (response.data.status !== 'success') {
      return res.json({ success: false, error: 'Failed to fetch Hostaway listings' });
    }
    
    const cmProperties = response.data.result || [];
    console.log('Found ' + cmProperties.length + ' listings in Hostaway');
    
    // 2. Get existing properties in GAS for this account
    const existingResult = await pool.query(
      'SELECT id, name, hostaway_listing_id FROM properties WHERE account_id = $1 AND hostaway_listing_id IS NOT NULL',
      [accountId]
    );
    const existingProperties = existingResult.rows;
    
    // 3. Compare
    const existing = [];
    const newProps = [];
    const removed = [];
    
    // Check each CM property
    for (const cmProp of cmProperties) {
      const cmId = String(cmProp.id);
      const existingProp = existingProperties.find(p => String(p.hostaway_listing_id) === cmId);
      
      if (existingProp) {
        existing.push({
          gas_id: existingProp.id,
          cm_id: cmId,
          name: cmProp.name,
          gas_name: existingProp.name
        });
      } else {
        newProps.push({
          cm_id: cmId,
          name: cmProp.name,
          city: cmProp.city || '',
          rooms: 1 // Hostaway listings are typically single units
        });
      }
    }
    
    // Check for removed (in GAS but not in CM)
    const cmIds = cmProperties.map(p => String(p.id));
    for (const existingProp of existingProperties) {
      if (!cmIds.includes(String(existingProp.hostaway_listing_id))) {
        removed.push({
          gas_id: existingProp.id,
          cm_id: existingProp.hostaway_listing_id,
          name: existingProp.name
        });
      }
    }
    
    console.log(`Comparison: ${existing.length} existing, ${newProps.length} new, ${removed.length} removed`);
    
    res.json({
      success: true,
      existing,
      new: newProps,
      removed,
      channel_manager: 'hostaway'
    });
    
  } catch (error) {
    console.error('Error refreshing Hostaway properties:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Import Hostaway property (listing)
app.post('/api/hostaway/import-property', async (req, res) => {
  const client = await pool.connect();
  try {
    const { property, token, connectionId } = req.body;
    
    if (!property || !property.id) {
      return res.json({ success: false, error: 'Property data required' });
    }
    
    console.log('Importing Hostaway listing:', property.name);
    
    await client.query('BEGIN');
    
    // Check if property already exists
    const existingProp = await client.query(
      'SELECT id FROM properties WHERE hostaway_listing_id = $1',
      [property.id]
    );
    
    let propertyId;
    
    if (existingProp.rows.length > 0) {
      // Update existing
      propertyId = existingProp.rows[0].id;
      await client.query(`
        UPDATE properties SET
          name = $1,
          property_type = $2,
          address = $3,
          city = $4,
          state = $5,
          postcode = $6,
          country = $7,
          latitude = $8,
          longitude = $9,
          check_in_from = $10,
          check_out_by = $11,
          currency = $12,
          cm_source = 'hostaway',
          updated_at = NOW()
        WHERE id = $13
      `, [
        property.name,
        property.roomType || 'entire_home',
        property.address || property.street || '',
        property.city || '',
        property.state || '',
        property.zipcode || '',
        property.country || '',
        property.lat || null,
        property.lng || null,
        property.checkInTimeStart ? `${property.checkInTimeStart}:00` : '15:00',
        property.checkOutTime ? `${property.checkOutTime}:00` : '11:00',
        property.currencyCode || 'USD',
        propertyId
      ]);
      
      console.log('   Updated existing property, GAS ID:', propertyId);
    } else {
      // Insert new property - truncate fields to fit column constraints
      const propertyName = property.name || `Property ${property.id}`;
      const stateValue = (property.state || '').substring(0, 50);
      const currencyValue = (property.currencyCode || 'USD').substring(0, 3);
      // Use countryCode if available, otherwise truncate country to 2 chars
      const countryValue = (property.countryCode || property.country || '').substring(0, 2);
      
      const result = await client.query(`
        INSERT INTO properties (
          user_id, name, property_type, address, city, state, postcode, country,
          latitude, longitude, check_in_from, check_out_by, currency,
          hostaway_listing_id, cm_source, created_at, updated_at
        ) VALUES (1, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'hostaway', NOW(), NOW())
        RETURNING id
      `, [
        propertyName,
        property.roomType || 'entire_home',
        property.address || property.street || '',
        property.city || '',
        stateValue,
        property.zipcode || '',
        countryValue,
        property.lat || null,
        property.lng || null,
        property.checkInTimeStart ? `${property.checkInTimeStart}:00` : '15:00',
        property.checkOutTime ? `${property.checkOutTime}:00` : '11:00',
        currencyValue,
        property.id
      ]);
      
      propertyId = result.rows[0].id;
      console.log('   Created new property, GAS ID:', propertyId);
    }
    
    // For Hostaway, each listing IS the bookable unit (not like Beds24 with rooms)
    // Create/update the bookable unit
    const existingUnit = await client.query(
      'SELECT id FROM bookable_units WHERE hostaway_listing_id = $1',
      [property.id]
    );
    
    if (existingUnit.rows.length > 0) {
      await client.query(`
        UPDATE bookable_units SET
          name = $1,
          unit_type = $2,
          max_guests = $3,
          max_adults = $4,
          bedroom_count = $5,
          bathroom_count = $6,
          base_price = $7,
          min_stay = $8,
          max_stay = $9,
          property_id = $10,
          updated_at = NOW()
        WHERE id = $11
      `, [
        property.name,
        property.roomType || 'entire_home',
        property.personCapacity || 2,
        property.personCapacity || 2,
        property.bedroomsNumber || 1,
        property.bathroomsNumber || 1,
        property.price || 100,
        property.minNights || 1,
        property.maxNights || 365,
        propertyId,
        existingUnit.rows[0].id
      ]);
      console.log('   Updated existing bookable unit');
    } else {
      await client.query(`
        INSERT INTO bookable_units (
          property_id, name, unit_type, max_guests, max_adults,
          bedroom_count, bathroom_count, base_price, min_stay, max_stay,
          hostaway_listing_id, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW())
      `, [
        propertyId,
        property.name,
        property.roomType || 'entire_home',
        property.personCapacity || 2,
        property.personCapacity || 2,
        property.bedroomsNumber || 1,
        property.bathroomsNumber || 1,
        property.price || 100,
        property.minNights || 1,
        property.maxNights || 365,
        property.id
      ]);
      console.log('   Created new bookable unit');
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      propertyId,
      hostawayListingId: property.id,
      message: 'Property imported successfully'
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Hostaway import error:', error.message);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Resync a single Hostaway property - fetch fresh from API and update GAS
app.post('/api/hostaway/resync-single-property', async (req, res) => {
  try {
    const { connectionId, listingId } = req.body;
    
    if (!connectionId || !listingId) {
      return res.json({ success: false, error: 'Connection ID and listing ID required' });
    }
    
    // Get the token from the connection
    const connResult = await pool.query(
      'SELECT access_token, account_id FROM gas_sync_connections WHERE id = $1',
      [connectionId]
    );
    
    if (connResult.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const token = connResult.rows[0].access_token;
    const accountId = connResult.rows[0].account_id;
    
    if (!token) {
      return res.json({ success: false, error: 'No access token for this connection' });
    }
    
    console.log(`üîÑ Resyncing Hostaway property ${listingId} - fetching fresh data...`);
    
    // Fetch fresh data from Hostaway API
    const response = await axios.get(`https://api.hostaway.com/v1/listings/${listingId}`, {
      headers: { 'Authorization': `Bearer ${token}` },
      timeout: 30000
    });
    
    const listing = response.data?.result || response.data;
    if (!listing) {
      return res.json({ success: false, error: 'Property not found in Hostaway' });
    }
    
    console.log(`   Hostaway returned: name="${listing.name}", externalListingName="${listing.externalListingName}"`);
    
    // Find existing property in GAS
    const existingProp = await pool.query(
      'SELECT id FROM properties WHERE hostaway_listing_id = $1',
      [listingId]
    );
    
    if (existingProp.rows.length === 0) {
      return res.json({ success: false, error: 'Property not imported to GAS yet' });
    }
    
    const propertyId = existingProp.rows[0].id;
    
    // Normalize values
    const propertyName = (listing.name || `Property ${listingId}`).substring(0, 255);
    const displayNameText = listing.externalListingName || propertyName;
    const displayNameJson = JSON.stringify({ en: displayNameText });
    const stateValue = (listing.state || '').substring(0, 50);
    const currencyValue = (listing.currencyCode || 'USD').substring(0, 3);
    const countryValue = listing.countryCode || listing.country || '';
    
    // Update property
    await pool.query(`
      UPDATE properties SET
        name = $1,
        display_name = $2,
        property_type = $3,
        address = $4,
        city = $5,
        state = $6,
        postcode = $7,
        country = $8,
        latitude = $9,
        longitude = $10,
        check_in_from = $11,
        check_out_by = $12,
        currency = $13,
        updated_at = NOW()
      WHERE id = $14
    `, [
      propertyName,
      displayNameText,
      listing.propertyType || 'entire_home',
      listing.address || listing.street || '',
      listing.city || '',
      stateValue,
      listing.zipcode || '',
      countryValue,
      listing.lat || null,
      listing.lng || null,
      listing.checkInTimeStart ? `${listing.checkInTimeStart}:00` : '15:00',
      listing.checkOutTime ? `${listing.checkOutTime}:00` : '11:00',
      currencyValue,
      propertyId
    ]);
    
    // Update bookable_unit (display_name is JSONB so needs JSON format)
    await pool.query(`
      UPDATE bookable_units SET
        name = $1,
        display_name = $2::jsonb,
        unit_type = $3,
        max_guests = $4,
        max_adults = $5,
        bedroom_count = $6,
        bathroom_count = $7,
        base_price = $8,
        min_stay = $9,
        max_stay = $10,
        updated_at = NOW()
      WHERE hostaway_listing_id = $11
    `, [
      propertyName,
      displayNameJson,
      listing.propertyType || 'entire_home',
      listing.personCapacity || 2,
      listing.personCapacity || 2,
      listing.bedroomsNumber || 1,
      listing.bathroomsNumber || 1,
      listing.price || 100,
      listing.minNights || 1,
      listing.maxNights || 365,
      listingId
    ]);
    
    // Also update gas_sync_properties raw_data so it's cached for future
    try {
      await pool.query(`
        UPDATE gas_sync_properties SET 
          raw_data = $1::jsonb,
          synced_at = NOW()
        WHERE connection_id = $2 AND external_id = $3
      `, [JSON.stringify(listing), connectionId, String(listingId)]);
    } catch (cacheErr) {
      console.log('   Note: Could not update cache:', cacheErr.message);
    }
    
    console.log(`   ‚úì Updated: "${propertyName}" / display: "${displayNameText}"`);
    
    res.json({
      success: true,
      message: `Synced: ${displayNameText}`,
      property: { id: propertyId, name: propertyName, displayName: displayNameText }
    });
    
  } catch (error) {
    console.error('Hostaway resync error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Sync availability from Hostaway for all listings
app.post('/api/admin/sync-hostaway-availability', async (req, res) => {
  const client = await pool.connect();
  try {
    const stored = await getStoredHostawayToken(pool);
    if (!stored) {
      return res.json({ success: false, error: 'No Hostaway connection found' });
    }
    
    // Get all Hostaway-linked rooms
    const roomsResult = await client.query(`
      SELECT bu.id as room_id, bu.hostaway_listing_id, bu.name
      FROM bookable_units bu
      WHERE bu.hostaway_listing_id IS NOT NULL
    `);
    
    if (roomsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No Hostaway-linked rooms found' });
    }
    
    console.log(`Syncing availability for ${roomsResult.rows.length} Hostaway listings...`);
    
    // Calculate date range (today + 90 days)
    const today = new Date();
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + 90);
    
    const startDateStr = today.toISOString().split('T')[0];
    const endDateStr = endDate.toISOString().split('T')[0];
    
    let totalPricesUpdated = 0;
    let roomsSynced = 0;
    
    for (const room of roomsResult.rows) {
      try {
        console.log(`  Fetching calendar for ${room.name} (Hostaway ID: ${room.hostaway_listing_id})`);
        
        // Add delay to respect rate limits (15 requests per 10 seconds)
        await new Promise(resolve => setTimeout(resolve, 700));
        
        const response = await axios.get(`https://api.hostaway.com/v1/listings/${room.hostaway_listing_id}/calendar`, {
          headers: {
            'Authorization': `Bearer ${stored.accessToken}`,
            'Cache-control': 'no-cache'
          },
          params: {
            startDate: startDateStr,
            endDate: endDateStr
          }
        });
        
        if (response.data.status === 'success' && response.data.result) {
          const calendarDays = response.data.result;
          
          for (const day of calendarDays) {
            // day typically has: date, price, isAvailable, minimumStay, etc.
            const dateStr = day.date;
            const price = day.price || null;
            const isAvailable = day.isAvailable === 1 || day.isAvailable === true;
            const isBlocked = day.status === 'blocked' || day.isBlocked === 1;
            const minStay = day.minimumStay || 1;
            
            await client.query(`
              INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, source, updated_at)
              VALUES ($1, $2, $3, $3, $4, $5, $6, 'hostaway', NOW())
              ON CONFLICT (room_id, date) 
              DO UPDATE SET 
                cm_price = $3, 
                direct_price = COALESCE(room_availability.direct_price, $3),
                is_available = $4, 
                is_blocked = $5, 
                min_stay = $6,
                source = 'hostaway',
                updated_at = NOW()
            `, [room.room_id, dateStr, price, isAvailable, isBlocked, minStay]);
            
            totalPricesUpdated++;
          }
          
          roomsSynced++;
          console.log(`    ‚úì Synced ${calendarDays.length} days for ${room.name}`);
        }
        
      } catch (roomError) {
        console.error(`    ‚úó Error syncing ${room.name}:`, roomError.response?.data || roomError.message);
        
        // If rate limited, wait longer
        if (roomError.response?.status === 429) {
          console.log('    Rate limited, waiting 10 seconds...');
          await new Promise(resolve => setTimeout(resolve, 10000));
        }
      }
    }
    
    res.json({
      success: true,
      roomsSynced,
      totalPricesUpdated,
      message: `Synced ${roomsSynced} Hostaway listings with ${totalPricesUpdated} price/availability records`
    });
    
  } catch (error) {
    console.error('Hostaway sync error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Get Hostaway calendar/availability
app.get('/api/hostaway/calendar/:listingId', async (req, res) => {
  try {
    const { listingId } = req.params;
    const { from, to } = req.query;
    
    const stored = await getStoredHostawayToken(pool);
    if (!stored) {
      return res.json({ success: false, error: 'No Hostaway connection found' });
    }
    
    const response = await axios.get(`https://api.hostaway.com/v1/listings/${listingId}/calendar`, {
      headers: {
        'Authorization': `Bearer ${stored.accessToken}`,
        'Cache-control': 'no-cache'
      },
      params: {
        startDate: from,
        endDate: to
      }
    });
    
    res.json({ success: true, data: response.data.result || [] });
    
  } catch (error) {
    console.error('Hostaway calendar error:', error.response?.data || error.message);
    res.json({ success: false, error: error.message });
  }
});

// Create booking in Hostaway
app.post('/api/hostaway/create-booking', async (req, res) => {
  try {
    const { listingId, booking } = req.body;
    
    const stored = await getStoredHostawayToken(pool);
    if (!stored) {
      return res.json({ success: false, error: 'No Hostaway connection found' });
    }
    
    const hostawayBooking = {
      listingMapId: listingId,
      channelId: 2000,  // Direct booking channel
      arrivalDate: booking.arrival_date,
      departureDate: booking.departure_date,
      guestFirstName: booking.guest_first_name,
      guestLastName: booking.guest_last_name,
      guestEmail: booking.guest_email,
      guestPhone: booking.guest_phone || '',
      numberOfGuests: booking.num_adults + (booking.num_children || 0),
      totalPrice: booking.grand_total,
      currency: booking.currency || 'USD',
      status: 'new'
    };
    
    console.log('Creating Hostaway reservation:', JSON.stringify(hostawayBooking));
    
    const response = await axios.post('https://api.hostaway.com/v1/reservations', hostawayBooking, {
      headers: {
        'Authorization': `Bearer ${stored.accessToken}`,
        'Content-Type': 'application/json',
        'Cache-control': 'no-cache'
      }
    });
    
    if (response.data.status === 'success') {
      res.json({ 
        success: true, 
        reservationId: response.data.result?.id,
        data: response.data.result 
      });
    } else {
      res.json({ success: false, error: response.data.result || 'Failed to create reservation' });
    }
    
  } catch (error) {
    console.error('Hostaway booking error:', error.response?.data || error.message);
    res.json({ success: false, error: error.response?.data?.message || error.message });
  }
});

// Hostaway webhook handler
app.post('/api/webhooks/hostaway', async (req, res) => {
  const client = await pool.connect();
  try {
    const webhookData = req.body;
    console.log('Hostaway webhook received:', JSON.stringify(webhookData).substring(0, 500));
    
    const eventType = webhookData.event || webhookData.type || 'unknown';
    const reservation = webhookData.data || webhookData.reservation;
    
    console.log('Hostaway webhook event:', eventType);
    
    if (eventType.includes('reservation') && reservation) {
      const listingId = reservation.listingMapId || reservation.listingId;
      const arrival = reservation.arrivalDate;
      const departure = reservation.departureDate;
      const status = reservation.status;
      const reservationId = reservation.id;
      
      // Find our room and property by hostaway_listing_id
      const roomResult = await client.query(`
        SELECT bu.id as room_id, bu.property_id, p.account_id
        FROM bookable_units bu
        JOIN properties p ON bu.property_id = p.id
        WHERE bu.hostaway_listing_id = $1
      `, [String(listingId)]);
      
      if (roomResult.rows.length > 0) {
        const room = roomResult.rows[0];
        
        await client.query('BEGIN');
        
        // Map status
        const statusMap = {
          'new': 'confirmed', 'confirmed': 'confirmed', 'modified': 'confirmed',
          'cancelled': 'cancelled', 'declined': 'cancelled', 'expired': 'cancelled'
        };
        const gasStatus = statusMap[status] || 'confirmed';
        
        // Check if booking already exists
        const existingBooking = await client.query(
          'SELECT id FROM bookings WHERE hostaway_reservation_id = $1',
          [String(reservationId)]
        );
        
        if (existingBooking.rows.length > 0) {
          // Update existing booking
          await client.query(`
            UPDATE bookings SET
              status = $1,
              check_in = $2,
              check_out = $3,
              guest_first_name = $4,
              guest_last_name = $5,
              guest_email = $6,
              num_adults = $7,
              total_price = $8,
              updated_at = NOW()
            WHERE id = $9
          `, [
            gasStatus,
            arrival,
            departure,
            reservation.guestFirstName || 'Guest',
            reservation.guestLastName || '',
            reservation.guestEmail || '',
            reservation.adults || reservation.numberOfGuests || 1,
            reservation.totalPrice || 0,
            existingBooking.rows[0].id
          ]);
          console.log(`Hostaway webhook: Updated booking ${existingBooking.rows[0].id}`);
        } else if (gasStatus !== 'cancelled') {
          // Create new booking
          const newBooking = await client.query(`
            INSERT INTO bookings (
              property_id, bookable_unit_id, account_id,
              check_in, check_out,
              guest_first_name, guest_last_name, guest_email, guest_phone,
              num_adults, total_price, currency, status,
              hostaway_reservation_id, channel_name, source,
              created_at, updated_at
            ) VALUES (
              $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 'hostaway_webhook',
              NOW(), NOW()
            )
            RETURNING id
          `, [
            room.property_id,
            room.room_id,
            room.account_id,
            arrival,
            departure,
            reservation.guestFirstName || 'Guest',
            reservation.guestLastName || '',
            reservation.guestEmail || '',
            reservation.guestPhone || '',
            reservation.adults || reservation.numberOfGuests || 1,
            reservation.totalPrice || 0,
            reservation.currency || 'USD',
            gasStatus,
            String(reservationId),
            reservation.channelName || 'Hostaway'
          ]);
          console.log(`Hostaway webhook: Created booking ${newBooking.rows[0].id}`);
        }
        
        // Update availability for booked dates
        if (arrival && departure) {
          const startDate = new Date(arrival);
          const endDate = new Date(departure);
          const isAvailable = gasStatus === 'cancelled';
          
          for (let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            await client.query(`
              INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
              VALUES ($1, $2, $3, false, 'hostaway_webhook')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET is_available = $3, source = 'hostaway_webhook', updated_at = NOW()
            `, [room.room_id, dateStr, isAvailable]);
          }
          
          console.log(`Hostaway webhook: Updated availability for room ${room.room_id}: ${arrival} to ${departure}, available: ${isAvailable}`);
        }
        
        await client.query('COMMIT');
      } else {
        console.log(`Hostaway webhook: No room found for listing ${listingId}`);
      }
    }
    
    res.status(200).json({ success: true, received: true });
    
  } catch (error) {
    await client.query('ROLLBACK').catch(() => {});
    console.error('Hostaway webhook error:', error);
    res.status(200).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

app.get('/api/webhooks/hostaway', (req, res) => {
  res.status(200).json({ 
    status: 'active',
    message: 'Hostaway webhook endpoint is ready',
    url: '/api/webhooks/hostaway'
  });
});

// =====================================================
// SMOOBU API INTEGRATION
// =====================================================

// Smoobu API Base URL
const SMOOBU_API_URL = 'https://login.smoobu.com/api';

// Test endpoint to check table structure
app.get('/api/test-smoobu-insert', async (req, res) => {
    try {
        // Try a simple property insert with user_id
        const result = await pool.query(`
            INSERT INTO properties (user_id, client_id, name, smoobu_id, channel_manager)
            VALUES (1, 3, 'Test Property', 'test123', 'smoobu')
            RETURNING id
        `);
        
        // Delete it right away
        await pool.query('DELETE FROM properties WHERE id = $1', [result.rows[0].id]);
        
        res.json({ success: true, message: 'Property insert works!' });
    } catch (error) {
        res.json({ success: false, error: error.message, detail: error.detail });
    }
});

// Setup Smoobu connection - saves API key to database
app.post('/api/smoobu/setup-connection', async (req, res) => {
    try {
        const { apiKey, clientId } = req.body;
        
        if (!apiKey) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key is required' 
            });
        }
        
        // Test the connection by getting user info
        const testResponse = await axios.get(`${SMOOBU_API_URL}/me`, {
            headers: {
                'Api-Key': apiKey,
                'Cache-Control': 'no-cache'
            }
        });
        
        if (testResponse.status !== 200) {
            return res.status(401).json({ 
                success: false, 
                error: 'Invalid API key. Please check your Smoobu API key.'
            });
        }
        
        const userData = testResponse.data;
        
        // Store the API key in database
        const targetClientId = clientId || 1;
        
        // Update or insert client settings
        await pool.query(`
            INSERT INTO client_settings (client_id, setting_key, setting_value)
            VALUES ($1, 'smoobu_api_key', $2)
            ON CONFLICT (client_id, setting_key) 
            DO UPDATE SET setting_value = $2, updated_at = NOW()
        `, [targetClientId, apiKey]);
        
        // Also store the Smoobu user ID
        await pool.query(`
            INSERT INTO client_settings (client_id, setting_key, setting_value)
            VALUES ($1, 'smoobu_user_id', $2)
            ON CONFLICT (client_id, setting_key) 
            DO UPDATE SET setting_value = $2, updated_at = NOW()
        `, [targetClientId, userData.id.toString()]);
        
        res.json({ 
            success: true, 
            message: 'Smoobu connection established successfully',
            user: {
                id: userData.id,
                firstName: userData.firstName,
                lastName: userData.lastName,
                email: userData.email
            }
        });
        
    } catch (error) {
        console.error('Smoobu setup error:', error.response?.data || error.message);
        if (error.response?.status === 401) {
            return res.status(401).json({ 
                success: false, 
                error: 'Invalid API key. Please check your Smoobu API key.'
            });
        }
        res.status(500).json({ success: false, error: error.message });
    }
});

// List all properties/apartments from Smoobu
app.post('/api/smoobu/list-properties', async (req, res) => {
    try {
        const { apiKey } = req.body;
        
        if (!apiKey) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key is required' 
            });
        }
        
        // Get apartments list
        const response = await axios.get(`${SMOOBU_API_URL}/apartments`, {
            headers: {
                'Api-Key': apiKey,
                'Cache-Control': 'no-cache'
            }
        });
        
        const apartments = response.data.apartments || [];
        
        // Get detailed info for each apartment
        const propertiesWithDetails = await Promise.all(
            apartments.map(async (apt) => {
                try {
                    const detailResponse = await axios.get(`${SMOOBU_API_URL}/apartments/${apt.id}`, {
                        headers: {
                            'Api-Key': apiKey,
                            'Cache-Control': 'no-cache'
                        }
                    });
                    return {
                        id: apt.id,
                        name: apt.name,
                        ...detailResponse.data
                    };
                } catch (e) {
                    return { id: apt.id, name: apt.name };
                }
            })
        );
        
        res.json({ 
            success: true, 
            properties: propertiesWithDetails,
            count: propertiesWithDetails.length
        });
        
    } catch (error) {
        console.error('Smoobu list properties error:', error.response?.data || error.message);
        res.status(500).json({ success: false, error: error.message });
    }
});

// =====================================================
// SMOOBU REFRESH PROPERTIES - Compare CM with GAS
// =====================================================
app.post('/api/smoobu/refresh-properties', async (req, res) => {
  const { apiKey, accountId } = req.body;
  
  try {
    console.log('üîÑ Refreshing Smoobu properties for account:', accountId);
    
    // 1. Fetch all apartments from Smoobu
    const response = await axios.get(`${SMOOBU_API_URL}/apartments`, {
      headers: { 'Api-Key': apiKey, 'Cache-Control': 'no-cache' }
    });
    
    const cmProperties = response.data.apartments || [];
    console.log('Found ' + cmProperties.length + ' apartments in Smoobu');
    
    // 2. Get existing properties in GAS for this account
    const existingResult = await pool.query(
      'SELECT id, name, smoobu_id FROM properties WHERE account_id = $1 AND smoobu_id IS NOT NULL',
      [accountId]
    );
    const existingProperties = existingResult.rows;
    
    // 3. Compare
    const existing = [];
    const newProps = [];
    const removed = [];
    
    // Check each CM property
    for (const cmProp of cmProperties) {
      const cmId = String(cmProp.id);
      const existingProp = existingProperties.find(p => String(p.smoobu_id) === cmId);
      
      if (existingProp) {
        existing.push({
          gas_id: existingProp.id,
          cm_id: cmId,
          name: cmProp.name,
          gas_name: existingProp.name
        });
      } else {
        newProps.push({
          cm_id: cmId,
          name: cmProp.name,
          city: cmProp.location?.city || '',
          rooms: 1
        });
      }
    }
    
    // Check for removed (in GAS but not in CM)
    const cmIds = cmProperties.map(p => String(p.id));
    for (const existingProp of existingProperties) {
      if (!cmIds.includes(String(existingProp.smoobu_id))) {
        removed.push({
          gas_id: existingProp.id,
          cm_id: existingProp.smoobu_id,
          name: existingProp.name
        });
      }
    }
    
    console.log(`Comparison: ${existing.length} existing, ${newProps.length} new, ${removed.length} removed`);
    
    res.json({
      success: true,
      existing,
      new: newProps,
      removed,
      channel_manager: 'smoobu'
    });
    
  } catch (error) {
    console.error('Error refreshing Smoobu properties:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Import a single property from Smoobu
app.post('/api/smoobu/import-property', async (req, res) => {
    const client = await pool.connect();
    
    try {
        const { apiKey, apartmentId, clientId } = req.body;
        
        if (!apiKey || !apartmentId) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key and apartment ID are required' 
            });
        }
        
        const targetClientId = clientId || 1;
        
        // Get apartment details
        let details, apartmentName;
        try {
            const detailResponse = await axios.get(`${SMOOBU_API_URL}/apartments/${apartmentId}`, {
                headers: {
                    'Api-Key': apiKey,
                    'Cache-Control': 'no-cache'
                }
            });
            details = detailResponse.data;
            
            const listResponse = await axios.get(`${SMOOBU_API_URL}/apartments`, {
                headers: {
                    'Api-Key': apiKey,
                    'Cache-Control': 'no-cache'
                }
            });
            const apartment = listResponse.data.apartments?.find(a => a.id === parseInt(apartmentId));
            apartmentName = apartment?.name || `Smoobu Property ${apartmentId}`;
        } catch (apiErr) {
            return res.status(500).json({ success: false, error: 'Smoobu API error: ' + apiErr.message });
        }
        
        await client.query('BEGIN');
        
        // Check if property already exists
        let propertyId;
        const existingProp = await client.query(
            'SELECT id FROM properties WHERE smoobu_id = $1',
            [apartmentId.toString()]
        );
        
        if (existingProp.rows.length > 0) {
            // Update existing
            propertyId = existingProp.rows[0].id;
            await client.query(`
                UPDATE properties SET
                    name = $1,
                    updated_at = NOW()
                WHERE id = $2
            `, [
                apartmentName,
                propertyId
            ]);
        } else {
            // Insert new - minimal columns only
            const propertyResult = await client.query(`
                INSERT INTO properties (
                    user_id,
                    client_id, 
                    name,
                    smoobu_id,
                    channel_manager
                )
                VALUES (1, $1, $2, $3, 'smoobu')
                RETURNING id
            `, [
                targetClientId,
                apartmentName,
                apartmentId.toString()
            ]);
            propertyId = propertyResult.rows[0].id;
        }
        
        // Check if bookable unit already exists
        const existingUnit = await client.query(
            'SELECT id FROM bookable_units WHERE smoobu_id = $1',
            [apartmentId.toString()]
        );
        
        let roomId;
        
        if (existingUnit.rows.length > 0) {
            // Update existing
            roomId = existingUnit.rows[0].id;
            await client.query(`
                UPDATE bookable_units SET
                    name = $1,
                    max_guests = $2,
                    bedroom_count = $3,
                    bathroom_count = $4,
                    base_price = $5,
                    updated_at = NOW()
                WHERE id = $6
            `, [
                apartmentName,
                details.rooms?.maxOccupancy || 2,
                details.rooms?.bedrooms || 1,
                details.rooms?.bathrooms || 1,
                details.price?.minimal || 100,
                roomId
            ]);
        } else {
            // Insert new
            const roomResult = await client.query(`
                INSERT INTO bookable_units (
                    property_id,
                    name,
                    max_guests,
                    bedroom_count,
                    bathroom_count,
                    base_price,
                    smoobu_id
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING id
            `, [
                propertyId,
                apartmentName,
                details.rooms?.maxOccupancy || 2,
                details.rooms?.bedrooms || 1,
                details.rooms?.bathrooms || 1,
                details.price?.minimal || 100,
                apartmentId.toString()
            ]);
            roomId = roomResult.rows[0].id;
        }
        
        await client.query('COMMIT');
        
        res.json({
            success: true,
            message: `Successfully imported "${apartmentName}"`,
            property: {
                id: propertyId,
                name: apartmentName,
                smoobu_id: apartmentId
            },
            room: {
                id: roomId,
                name: apartmentName
            }
        });
        
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Smoobu import error:', error.response?.data || error.message);
        res.status(500).json({ success: false, error: error.message, detail: error.detail, where: error.where, column: error.column, table: error.table });
    } finally {
        client.release();
    }
});

// Get availability/rates from Smoobu for a property
app.get('/api/smoobu/availability/:apartmentId', async (req, res) => {
    try {
        const { apartmentId } = req.params;
        const { apiKey, startDate, endDate } = req.query;
        
        if (!apiKey) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key is required' 
            });
        }
        
        const start = startDate || new Date().toISOString().split('T')[0];
        const end = endDate || new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const response = await axios.get(
            `${SMOOBU_API_URL}/rates?apartments[]=${apartmentId}&start_date=${start}&end_date=${end}`,
            {
                headers: {
                    'Api-Key': apiKey,
                    'Cache-Control': 'no-cache'
                }
            }
        );
        
        res.json({ 
            success: true, 
            availability: response.data.data?.[apartmentId] || {},
            apartmentId
        });
        
    } catch (error) {
        console.error('Smoobu availability error:', error.response?.data || error.message);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Check availability for booking
app.post('/api/smoobu/check-availability', async (req, res) => {
    try {
        const { apiKey, apartmentId, arrivalDate, departureDate, guests } = req.body;
        
        if (!apiKey || !apartmentId || !arrivalDate || !departureDate) {
            return res.status(400).json({ 
                success: false, 
                error: 'Missing required fields'
            });
        }
        
        // Get Smoobu user ID
        const userResponse = await axios.get(`${SMOOBU_API_URL}/me`, {
            headers: {
                'Api-Key': apiKey,
                'Cache-Control': 'no-cache'
            }
        });
        
        const userData = userResponse.data;
        
        const response = await axios.post(`https://login.smoobu.com/booking/checkApartmentAvailability`, {
            arrivalDate,
            departureDate,
            apartments: [parseInt(apartmentId)],
            customerId: userData.id,
            guests: guests || 2
        }, {
            headers: {
                'Api-Key': apiKey,
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
            }
        });
        
        const data = response.data;
        const isAvailable = data.availableApartments?.includes(parseInt(apartmentId));
        const price = data.prices?.[apartmentId]?.price;
        const currency = data.prices?.[apartmentId]?.currency;
        const errorInfo = data.errorMessages?.[apartmentId];
        
        res.json({
            success: true,
            available: isAvailable,
            price,
            currency,
            error: errorInfo
        });
        
    } catch (error) {
        console.error('Smoobu check availability error:', error.response?.data || error.message);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Create booking in Smoobu
app.post('/api/smoobu/create-booking', async (req, res) => {
    try {
        const { 
            apiKey, 
            apartmentId,
            arrivalDate,
            departureDate,
            firstName,
            lastName,
            email,
            phone,
            adults,
            children,
            price,
            notice
        } = req.body;
        
        if (!apiKey || !apartmentId || !arrivalDate || !departureDate) {
            return res.status(400).json({ 
                success: false, 
                error: 'Missing required fields'
            });
        }
        
        const response = await axios.post(`${SMOOBU_API_URL}/reservations`, {
            arrivalDate,
            departureDate,
            apartmentId: parseInt(apartmentId),
            channelId: 13, // Direct booking
            firstName: firstName || '',
            lastName: lastName || '',
            email: email || '',
            phone: phone || '',
            adults: adults || 1,
            children: children || 0,
            price: price || 0,
            notice: notice || 'Booked via GAS Booking'
        }, {
            headers: {
                'Api-Key': apiKey,
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
            }
        });
        
        res.json({
            success: true,
            bookingId: response.data.id,
            message: `Booking created successfully (ID: ${response.data.id})`
        });
        
    } catch (error) {
        console.error('Smoobu create booking error:', error.response?.data || error.message);
        const errorDetail = error.response?.data?.detail || error.response?.data?.validation_messages?.error;
        res.status(error.response?.status || 500).json({ 
            success: false, 
            error: errorDetail || error.message 
        });
    }
});

// Get bookings from Smoobu
app.get('/api/smoobu/bookings', async (req, res) => {
    try {
        const { apiKey, apartmentId, from, to } = req.query;
        
        if (!apiKey) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key is required' 
            });
        }
        
        let url = `${SMOOBU_API_URL}/reservations?`;
        if (apartmentId) url += `apartmentId=${apartmentId}&`;
        if (from) url += `from=${from}&`;
        if (to) url += `to=${to}&`;
        
        const response = await axios.get(url, {
            headers: {
                'Api-Key': apiKey,
                'Cache-Control': 'no-cache'
            }
        });
        
        const data = response.data;
        
        // Transform to standard format
        const bookings = (data.bookings || []).map(b => ({
            id: b.id,
            externalId: b['reference-id'],
            type: b.type,
            status: b.type === 'cancellation' ? 'cancelled' : 'confirmed',
            arrivalDate: b.arrival,
            departureDate: b.departure,
            createdAt: b['created-at'],
            apartment: b.apartment,
            channel: b.channel,
            guestName: b['guest-name'],
            email: b.email,
            phone: b.phone,
            adults: b.adults,
            children: b.children,
            checkIn: b['check-in'],
            checkOut: b['check-out'],
            notes: b.notice,
            price: b.price,
            pricePaid: b['price-paid'],
            language: b.language
        }));
        
        res.json({
            success: true,
            bookings,
            pagination: {
                page: data.page,
                pageSize: data.page_size,
                totalItems: data.total_items,
                pageCount: data.page_count
            }
        });
        
    } catch (error) {
        console.error('Smoobu get bookings error:', error.response?.data || error.message);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Cancel a booking in Smoobu
app.delete('/api/smoobu/bookings/:bookingId', async (req, res) => {
    try {
        const { bookingId } = req.params;
        const { apiKey } = req.query;
        
        if (!apiKey) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key is required' 
            });
        }
        
        await axios.delete(`${SMOOBU_API_URL}/reservations/${bookingId}`, {
            headers: {
                'Api-Key': apiKey,
                'Cache-Control': 'no-cache'
            }
        });
        
        res.json({
            success: true,
            message: `Booking ${bookingId} cancelled successfully`
        });
        
    } catch (error) {
        console.error('Smoobu cancel booking error:', error.response?.data || error.message);
        res.status(error.response?.status || 500).json({ 
            success: false, 
            error: error.response?.data?.detail || error.message 
        });
    }
});

// Update rates in Smoobu
app.post('/api/smoobu/update-rates', async (req, res) => {
    try {
        const { apiKey, apartmentIds, operations } = req.body;
        
        if (!apiKey || !apartmentIds || !operations) {
            return res.status(400).json({ 
                success: false, 
                error: 'Missing required fields'
            });
        }
        
        const response = await axios.post(`${SMOOBU_API_URL}/rates`, {
            apartments: apartmentIds,
            operations
        }, {
            headers: {
                'Api-Key': apiKey,
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
            }
        });
        
        res.json({
            success: true,
            message: 'Rates updated successfully'
        });
        
    } catch (error) {
        console.error('Smoobu update rates error:', error.response?.data || error.message);
        res.status(error.response?.status || 500).json({ 
            success: false, 
            error: error.response?.data?.detail || error.message 
        });
    }
});

// Sync availability from Smoobu to local database
app.post('/api/admin/sync-smoobu-availability', async (req, res) => {
    const dbClient = await pool.connect();
    
    try {
        let { apiKey, clientId } = req.body;
        
        const targetClientId = clientId || 1;
        
        // If no API key provided, get from client_settings
        if (!apiKey) {
            const keyResult = await dbClient.query(
                `SELECT setting_value FROM client_settings WHERE client_id = $1 AND setting_key = 'smoobu_api_key'`,
                [targetClientId]
            );
            if (keyResult.rows.length > 0) {
                apiKey = keyResult.rows[0].setting_value;
            }
        }
        
        if (!apiKey) {
            return res.status(400).json({ 
                success: false, 
                error: 'API key is required - none found in settings' 
            });
        }
        
        // Get all Smoobu properties for this client
        const propertiesResult = await dbClient.query(`
            SELECT bu.id as room_id, bu.smoobu_id, bu.name
            FROM bookable_units bu
            JOIN properties p ON bu.property_id = p.id
            WHERE p.client_id = $1 AND bu.smoobu_id IS NOT NULL
        `, [targetClientId]);
        
        if (propertiesResult.rows.length === 0) {
            return res.json({
                success: true,
                message: 'No Smoobu properties found to sync',
                synced: 0
            });
        }
        
        const apartmentIds = propertiesResult.rows.map(r => r.smoobu_id);
        
        // Get rates for next 365 days
        const startDate = new Date().toISOString().split('T')[0];
        const endDate = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const ratesResponse = await axios.get(
            `${SMOOBU_API_URL}/rates?${apartmentIds.map(id => `apartments[]=${id}`).join('&')}&start_date=${startDate}&end_date=${endDate}`,
            {
                headers: {
                    'Api-Key': apiKey,
                    'Cache-Control': 'no-cache'
                }
            }
        );
        
        const ratesData = ratesResponse.data;
        
        await dbClient.query('BEGIN');
        
        let totalSynced = 0;
        
        for (const room of propertiesResult.rows) {
            const apartmentRates = ratesData.data?.[room.smoobu_id];
            if (!apartmentRates) continue;
            
            // Clear existing availability
            await dbClient.query(`
                DELETE FROM room_availability 
                WHERE room_id = $1 AND date >= $2
            `, [room.room_id, startDate]);
            
            // Insert new availability
            for (const [date, info] of Object.entries(apartmentRates)) {
                await dbClient.query(`
                    INSERT INTO room_availability (room_id, date, is_available, cm_price, standard_price, min_stay, source)
                    VALUES ($1, $2, $3, $4, $4, $5, 'smoobu')
                    ON CONFLICT (room_id, date) DO UPDATE SET
                        is_available = EXCLUDED.is_available,
                        cm_price = EXCLUDED.cm_price,
                        standard_price = EXCLUDED.standard_price,
                        min_stay = EXCLUDED.min_stay,
                        source = EXCLUDED.source,
                        updated_at = NOW()
                `, [
                    room.room_id,
                    date,
                    info.available > 0,
                    info.price || null,
                    info.min_length_of_stay || null
                ]);
                totalSynced++;
            }
        }
        
        await dbClient.query('COMMIT');
        
        res.json({
            success: true,
            message: `Synced ${totalSynced} availability records from Smoobu`,
            synced: totalSynced,
            properties: propertiesResult.rows.length
        });
        
    } catch (error) {
        await dbClient.query('ROLLBACK');
        console.error('Smoobu sync error:', error.response?.data || error.message);
        res.status(500).json({ success: false, error: error.message });
    } finally {
        dbClient.release();
    }
});

// Webhook endpoint for Smoobu notifications
app.post('/api/webhooks/smoobu', async (req, res) => {
    try {
        const { action, user, data } = req.body;
        
        console.log('Smoobu webhook received:', { action, user, dataKeys: Object.keys(data || {}) });
        
        switch (action) {
            case 'newReservation':
            case 'updateReservation':
                console.log('Booking webhook:', data);
                break;
            case 'cancelReservation':
            case 'deleteReservation':
                console.log('Cancellation webhook:', data);
                break;
            case 'updateRates':
                console.log('Rates updated:', data);
                break;
            default:
                console.log('Unknown webhook action:', action);
        }
        
        res.json({ success: true, received: action });
        
    } catch (error) {
        console.error('Smoobu webhook error:', error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Webhook verification endpoint
app.get('/api/webhooks/smoobu', (req, res) => {
    res.json({ 
        status: 'active',
        message: 'Smoobu webhook endpoint is ready',
        timestamp: new Date().toISOString()
    });
});

// =====================================================
// OFFERS & VOUCHERS API ENDPOINTS
// =====================================================

// Get all offers
app.get('/api/admin/offers', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    let query = `
      SELECT o.*, p.name as property_name, bu.name as room_name
      FROM offers o
      LEFT JOIN properties p ON o.property_id = p.id
      LEFT JOIN bookable_units bu ON o.room_id = bu.id
    `;
    const params = [];
    
    // Filter by account_id if provided
    if (account_id) {
      query += ` WHERE o.account_id = $1`;
      params.push(account_id);
    }
    
    query += ` ORDER BY o.priority DESC, o.created_at DESC`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get single offer
app.get('/api/admin/offers/:id', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM offers WHERE id = $1', [req.params.id]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create offer
app.post('/api/admin/offers', async (req, res) => {
  try {
    const {
      name: rawName, description: rawDesc, property_id, room_id,
      property_ids, room_ids, account_id,
      discount_type, discount_value, applies_to,
      min_nights, max_nights, min_guests, max_guests,
      min_advance_days, max_advance_days,
      valid_from, valid_until, valid_days_of_week,
      allowed_checkin_days, allowed_checkout_days,
      stackable, priority, active, pricing_tier, price_per_night
    } = req.body;
    const name = mlStr(rawName);
    const description = mlStr(rawDesc);
    
    // CRITICAL: Get account_id from property if not provided
    // This ensures offers are always scoped to an account
    let finalAccountId = account_id;
    if (!finalAccountId && property_id) {
      const propResult = await pool.query('SELECT account_id, client_id FROM properties WHERE id = $1', [property_id]);
      if (propResult.rows[0]) {
        finalAccountId = propResult.rows[0].account_id || propResult.rows[0].client_id;
      }
    }
    
    if (!finalAccountId) {
      return res.json({ success: false, error: 'Offer must be associated with a property or account' });
    }
    
    let result;
    try {
      // Try with array columns and pricing_tier
      result = await pool.query(`
        INSERT INTO offers (
          name, description, property_id, room_id, property_ids, room_ids, account_id,
          discount_type, discount_value, price_per_night, applies_to,
          min_nights, max_nights, min_guests, max_guests,
          min_advance_days, max_advance_days,
          valid_from, valid_until, valid_days_of_week,
          allowed_checkin_days, allowed_checkout_days,
          stackable, priority, active, pricing_tier
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26)
        RETURNING *
      `, [
        name, description, property_id || null, room_id || null,
        property_ids || null, room_ids || null, finalAccountId,
        discount_type || 'percentage', discount_value || 0, price_per_night || null, applies_to || 'standard_price',
        min_nights || 1, max_nights || null, min_guests || null, max_guests || null,
        min_advance_days || null, max_advance_days || null,
        valid_from || null, valid_until || null, valid_days_of_week || null,
        allowed_checkin_days || '0,1,2,3,4,5,6', allowed_checkout_days || '0,1,2,3,4,5,6',
        stackable || false, priority || 0, active !== false, pricing_tier || 'standard'
      ]);
    } catch (colErr) {
      // Fallback without array columns
      result = await pool.query(`
        INSERT INTO offers (
          name, description, property_id, room_id, account_id,
          discount_type, discount_value, applies_to,
          min_nights, max_nights, min_guests, max_guests,
          min_advance_days, max_advance_days,
          valid_from, valid_until, valid_days_of_week,
          allowed_checkin_days, allowed_checkout_days,
          stackable, priority, active, pricing_tier
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23)
        RETURNING *
      `, [
        name, description, property_id || null, room_id || null, finalAccountId,
        discount_type || 'percentage', discount_value || 0, applies_to || 'standard_price',
        min_nights || 1, max_nights || null, min_guests || null, max_guests || null,
        min_advance_days || null, max_advance_days || null,
        valid_from || null, valid_until || null, valid_days_of_week || null,
        allowed_checkin_days || '0,1,2,3,4,5,6', allowed_checkout_days || '0,1,2,3,4,5,6',
        stackable || false, priority || 0, active !== false, pricing_tier || 'standard'
      ]);
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update offer
app.put('/api/admin/offers/:id', async (req, res) => {
  try {
    const {
      name: rawName, description: rawDesc, property_id, room_id,
      property_ids, room_ids, account_id,
      discount_type, discount_value, price_per_night, applies_to,
      min_nights, max_nights, min_guests, max_guests,
      min_advance_days, max_advance_days,
      valid_from, valid_until, valid_days_of_week,
      allowed_checkin_days, allowed_checkout_days,
      stackable, priority, active,
      available_website, available_agents, pricing_tier
    } = req.body;
    const name = mlStr(rawName);
    const description = mlStr(rawDesc);
    
    let result;
    try {
      // Try with array columns and pricing_tier
      result = await pool.query(`
        UPDATE offers SET
          name = COALESCE($1, name), 
          description = COALESCE($2, description), 
          property_id = $3, 
          room_id = $4,
          property_ids = $5,
          room_ids = $6,
          discount_type = COALESCE($7, discount_type), 
          discount_value = COALESCE($8, discount_value),
          price_per_night = $9,
          applies_to = COALESCE($10, applies_to),
          min_nights = COALESCE($11, min_nights), 
          max_nights = $12, 
          min_guests = $13, 
          max_guests = $14,
          min_advance_days = $15, 
          max_advance_days = $16,
          valid_from = $17, 
          valid_until = $18, 
          valid_days_of_week = $19,
          allowed_checkin_days = COALESCE($20, allowed_checkin_days), 
          allowed_checkout_days = COALESCE($21, allowed_checkout_days),
          stackable = COALESCE($22, stackable), 
          priority = COALESCE($23, priority), 
          active = COALESCE($24, active),
          available_website = COALESCE($25, available_website),
          available_agents = COALESCE($26, available_agents),
          pricing_tier = COALESCE($27, pricing_tier),
          account_id = COALESCE($28, account_id),
          updated_at = NOW()
        WHERE id = $29
        RETURNING *
      `, [
        name, description, property_id || null, room_id || null,
        property_ids || null, room_ids || null,
        discount_type, discount_value, price_per_night || null, applies_to,
        min_nights, max_nights || null, min_guests || null, max_guests || null,
        min_advance_days || null, max_advance_days || null,
        valid_from || null, valid_until || null, valid_days_of_week || null,
        allowed_checkin_days, allowed_checkout_days,
        stackable, priority, active,
        available_website, available_agents, pricing_tier || 'standard',
        account_id || null,
        req.params.id
      ]);
    } catch (colErr) {
      // Fallback without array columns
      result = await pool.query(`
        UPDATE offers SET
          name = COALESCE($1, name), 
          description = COALESCE($2, description), 
          property_id = $3, 
          room_id = $4,
          discount_type = COALESCE($5, discount_type), 
          discount_value = COALESCE($6, discount_value), 
          applies_to = COALESCE($7, applies_to),
          min_nights = COALESCE($8, min_nights), 
          max_nights = $9, 
          min_guests = $10, 
          max_guests = $11,
          min_advance_days = $12, 
          max_advance_days = $13,
          valid_from = $14, 
          valid_until = $15, 
          valid_days_of_week = $16,
          allowed_checkin_days = COALESCE($17, allowed_checkin_days), 
          allowed_checkout_days = COALESCE($18, allowed_checkout_days),
          stackable = COALESCE($19, stackable), 
          priority = COALESCE($20, priority), 
          active = COALESCE($21, active),
          available_website = COALESCE($22, available_website),
          available_agents = COALESCE($23, available_agents),
          pricing_tier = COALESCE($24, pricing_tier),
          account_id = COALESCE($25, account_id),
          updated_at = NOW()
        WHERE id = $26
        RETURNING *
      `, [
        name, description, property_id || null, room_id || null,
        discount_type, discount_value, applies_to,
        min_nights, max_nights || null, min_guests || null, max_guests || null,
        min_advance_days || null, max_advance_days || null,
        valid_from || null, valid_until || null, valid_days_of_week || null,
        allowed_checkin_days, allowed_checkout_days,
        stackable, priority, active,
        available_website, available_agents, pricing_tier || 'standard',
        account_id || null,
        req.params.id
      ]);
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete offer
app.delete('/api/admin/offers/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM offers WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get all vouchers
app.get('/api/admin/vouchers', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    const propertyId = req.query.property_id;
    let result;
    
    if (propertyId) {
      // Filter by specific property - check both property_id and property_ids array
      result = await pool.query(`
        SELECT v.*, vn.name as vendor_name FROM vouchers v
        LEFT JOIN vendors vn ON v.vendor_id = vn.id
        WHERE v.property_id = $1 OR $1 = ANY(v.property_ids)
        ORDER BY v.created_at DESC
      `, [propertyId]);
    } else if (accountId) {
      // Filter by account - only vouchers linked to properties owned by this account
      result = await pool.query(`
        SELECT v.*, vn.name as vendor_name FROM vouchers v
        LEFT JOIN properties p ON v.property_id = p.id
        LEFT JOIN vendors vn ON v.vendor_id = vn.id
        WHERE p.account_id = $1
        ORDER BY v.created_at DESC
      `, [accountId]);
    } else {
      result = await pool.query(`
        SELECT v.*, vn.name as vendor_name FROM vouchers v
        LEFT JOIN vendors vn ON v.vendor_id = vn.id
        ORDER BY v.created_at DESC
      `);
    }
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get single voucher
app.get('/api/admin/vouchers/:id', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT v.*, vn.name as vendor_name FROM vouchers v
      LEFT JOIN vendors vn ON v.vendor_id = vn.id
      WHERE v.id = $1
    `, [req.params.id]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create voucher
app.post('/api/admin/vouchers', async (req, res) => {
  try {
    // Ensure multilingual columns exist
    await pool.query('ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS name_ml JSONB').catch(() => {});
    await pool.query('ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS description_ml JSONB').catch(() => {});
    await pool.query('ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS terms_ml JSONB').catch(() => {});
    
    // Remove any unique constraints on voucher codes - codes are validated at booking time per property
    try {
      const constraints = await pool.query(`
        SELECT con.conname, con.contype FROM pg_constraint con
        JOIN pg_class rel ON rel.oid = con.conrelid
        JOIN pg_attribute att ON att.attrelid = con.conrelid AND att.attnum = ANY(con.conkey)
        WHERE rel.relname = 'vouchers' AND att.attname = 'code'
      `);
      for (const row of constraints.rows) {
        await pool.query(`ALTER TABLE vouchers DROP CONSTRAINT "${row.conname}"`).catch(e => console.log('Drop constraint error:', e.message));
      }
      const indexes = await pool.query(`
        SELECT indexname FROM pg_indexes 
        WHERE tablename = 'vouchers' AND indexdef ILIKE '%unique%' AND indexdef ILIKE '%code%'
      `);
      for (const row of indexes.rows) {
        await pool.query(`DROP INDEX "${row.indexname}"`).catch(e => console.log('Drop index error:', e.message));
      }
    } catch(e) { console.log('Voucher constraint cleanup:', e.message); }
    
    const {
      code, name, description, terms,
      name_ml, description_ml, terms_ml,
      discount_type, discount_value, applies_to,
      min_nights, min_total, max_uses, single_use_per_guest,
      property_ids, room_ids, property_id,
      valid_from, valid_until, active,
      is_external, vendor_id
    } = req.body;
    
    // Handle name/description being sent as objects from frontend
    const nameObj = (typeof name === 'object' && name !== null) ? name : (name_ml || (name ? { en: name } : null));
    const descObj = (typeof description === 'object' && description !== null) ? description : (description_ml || (description ? { en: description } : null));
    const termsObj = (typeof terms === 'object' && terms !== null) ? terms : (terms_ml || (terms ? { en: terms } : null));
    
    const nameJson = nameObj ? JSON.stringify(nameObj) : null;
    const descJson = descObj ? JSON.stringify(descObj) : null;
    const termsJson = termsObj ? JSON.stringify(termsObj) : null;
    const englishName = nameObj?.en || (typeof name === 'string' ? name : '') || '';
    const englishDesc = descObj?.en || (typeof description === 'string' ? description : '') || '';
    
    // Get property_id from body - try single property_id first, then first of property_ids array
    const propId = property_id || (property_ids && property_ids.length > 0 ? property_ids[0] : null) || null;
    
    const result = await pool.query(`
      INSERT INTO vouchers (
        code, name, description, name_ml, description_ml, terms_ml,
        discount_type, discount_value, applies_to,
        min_nights, min_total, max_uses, single_use_per_guest,
        property_id, property_ids, room_ids,
        valid_from, valid_until, active,
        is_external, vendor_id
      ) VALUES ($1, $2, $3, $4::jsonb, $5::jsonb, $6::jsonb, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)
      RETURNING *
    `, [
      code.toUpperCase(), englishName, englishDesc, nameJson, descJson, termsJson,
      discount_type || 'percentage', discount_value, applies_to || 'total',
      min_nights || 1, min_total || null, max_uses || null, single_use_per_guest || false,
      propId, property_ids || null, room_ids || null,
      valid_from || null, valid_until || null, active !== false,
      is_external || false, vendor_id || null
    ]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    if (error.code === '23505') {
      res.json({ success: false, error: 'Voucher code already exists' });
    } else {
      res.json({ success: false, error: error.message });
    }
  }
});

// Update voucher
app.put('/api/admin/vouchers/:id', async (req, res) => {
  try {
    // Ensure multilingual columns exist
    await pool.query('ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS name_ml JSONB').catch(() => {});
    await pool.query('ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS description_ml JSONB').catch(() => {});
    await pool.query('ALTER TABLE vouchers ADD COLUMN IF NOT EXISTS terms_ml JSONB').catch(() => {});
    
    const {
      code, name, description,
      discount_type, discount_value, applies_to,
      min_nights, min_total, max_uses, single_use_per_guest,
      property_ids, room_ids,
      valid_from, valid_until, active,
      is_external, vendor_id
    } = req.body;
    
    // Handle name/description being sent as objects from frontend
    const nameObj = (typeof name === 'object' && name !== null) ? name : (req.body.name_ml || (name ? { en: name } : null));
    const descObj = (typeof description === 'object' && description !== null) ? description : (req.body.description_ml || (description ? { en: description } : null));
    const termsObj = req.body.terms_ml || null;
    
    const nameJson = nameObj ? JSON.stringify(nameObj) : null;
    const descJson = descObj ? JSON.stringify(descObj) : null;
    const termsJson = termsObj ? JSON.stringify(termsObj) : null;
    const englishName = nameObj?.en || (typeof name === 'string' ? name : '') || '';
    const englishDesc = descObj?.en || (typeof description === 'string' ? description : '') || '';
    
    const result = await pool.query(`
      UPDATE vouchers SET
        code = $1, name = $2, description = $3,
        name_ml = $4::jsonb, description_ml = $5::jsonb, terms_ml = $6::jsonb,
        discount_type = $7, discount_value = $8, applies_to = $9,
        min_nights = $10, min_total = $11, max_uses = $12, single_use_per_guest = $13,
        property_ids = $14, room_ids = $15,
        valid_from = $16, valid_until = $17, active = $18,
        is_external = $19, vendor_id = $20,
        updated_at = NOW()
      WHERE id = $21
      RETURNING *
    `, [
      code.toUpperCase(), englishName, englishDesc,
      nameJson, descJson, termsJson,
      discount_type, discount_value, applies_to,
      min_nights, min_total || null, max_uses || null, single_use_per_guest,
      property_ids || null, room_ids || null,
      valid_from || null, valid_until || null, active,
      is_external || false, vendor_id || null,
      req.params.id
    ]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete voucher
app.delete('/api/admin/vouchers/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM vouchers WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// VENDORS API
// =====================================================

// Get all vendors for an account
app.get('/api/admin/vendors', async (req, res) => {
  try {
    // Ensure vendor_permissions columns exist
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_dates BOOLEAN DEFAULT true').catch(() => {});
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_room_details BOOLEAN DEFAULT false').catch(() => {});
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_notes BOOLEAN DEFAULT false').catch(() => {});
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_price_paid BOOLEAN DEFAULT false').catch(() => {});
    
    const accountId = req.query.account_id;
    let query = `
      SELECT v.*, 
             vp.can_see_guest_name, vp.can_see_guest_email, vp.can_see_guest_phone,
             vp.can_see_booking_dates, vp.can_see_room_details, vp.can_see_booking_notes, vp.can_see_price_paid,
             (SELECT COUNT(*) FROM vendor_service_requests WHERE vendor_id = v.id) as request_count,
             (SELECT COUNT(*) FROM vendor_service_requests WHERE vendor_id = v.id AND status = 'pending') as pending_count
      FROM vendors v
      LEFT JOIN vendor_permissions vp ON v.id = vp.vendor_id
    `;
    const params = [];
    
    if (accountId) {
      query += ' WHERE v.account_id = $1';
      params.push(accountId);
    }
    
    query += ' ORDER BY v.name';
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Get vendors error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get single vendor
app.get('/api/admin/vendors/:id', async (req, res) => {
  try {
    // Ensure vendor_permissions columns exist
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_dates BOOLEAN DEFAULT true').catch(() => {});
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_room_details BOOLEAN DEFAULT false').catch(() => {});
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_notes BOOLEAN DEFAULT false').catch(() => {});
    await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_price_paid BOOLEAN DEFAULT false').catch(() => {});
    
    const result = await pool.query(`
      SELECT v.*, 
             vp.can_see_guest_name, vp.can_see_guest_email, vp.can_see_guest_phone,
             vp.can_see_booking_dates, vp.can_see_room_details, vp.can_see_booking_notes, vp.can_see_price_paid
      FROM vendors v
      LEFT JOIN vendor_permissions vp ON v.id = vp.vendor_id
      WHERE v.id = $1
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Vendor not found' });
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create vendor
app.post('/api/admin/vendors', async (req, res) => {
  // Run DDL operations on pool (outside transaction)
  await pool.query('ALTER TABLE vendors ALTER COLUMN account_id DROP NOT NULL').catch(() => {});
  
  // Drop global unique on login_email, replace with per-account unique
  try {
    const constraints = await pool.query(`
      SELECT con.conname FROM pg_constraint con
      JOIN pg_class rel ON rel.oid = con.conrelid
      JOIN pg_attribute att ON att.attrelid = con.conrelid AND att.attnum = ANY(con.conkey)
      WHERE rel.relname = 'vendors' AND att.attname = 'login_email'
    `);
    for (const row of constraints.rows) {
      await pool.query(`ALTER TABLE vendors DROP CONSTRAINT "${row.conname}"`).catch(e => console.log('Drop vendor constraint error:', e.message));
    }
    const indexes = await pool.query(`
      SELECT indexname FROM pg_indexes 
      WHERE tablename = 'vendors' AND indexdef ILIKE '%login_email%'
      AND indexname != 'vendors_login_email_account_unique'
    `);
    for (const row of indexes.rows) {
      await pool.query(`DROP INDEX "${row.indexname}"`).catch(e => console.log('Drop vendor index error:', e.message));
    }
  } catch(e) { console.log('Vendor constraint cleanup error:', e.message); }
  await pool.query('CREATE UNIQUE INDEX IF NOT EXISTS vendors_login_email_account_unique ON vendors (login_email, COALESCE(account_id, 0))').catch(e => console.log('Create vendor index error:', e.message));
  
  // Ensure vendor_permissions columns exist
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_guest_name BOOLEAN DEFAULT true').catch(() => {});
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_guest_email BOOLEAN DEFAULT false').catch(() => {});
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_guest_phone BOOLEAN DEFAULT true').catch(() => {});
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_dates BOOLEAN DEFAULT true').catch(() => {});
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_room_details BOOLEAN DEFAULT false').catch(() => {});
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_notes BOOLEAN DEFAULT false').catch(() => {});
  await pool.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_price_paid BOOLEAN DEFAULT false').catch(() => {});
  
  const client = await pool.connect();
  try {
    const { 
      name, email, phone, address, website, contact_name, notes,
      login_email, permissions = {}
    } = req.body;
    
    // Get account_id from body, query, or header
    const account_id = req.body.account_id || req.query.account_id || req.headers['x-account-id'] || null;
    console.log('Creating vendor with account_id:', account_id, 'name:', name);
    
    await client.query('BEGIN');
    
    // Generate a random password for vendor login
    const tempPassword = Math.random().toString(36).substring(2, 10);
    const bcrypt = require('bcryptjs');
    const passwordHash = await bcrypt.hash(tempPassword, 10);
    
    const result = await client.query(`
      INSERT INTO vendors (account_id, name, email, phone, address, website, contact_name, notes, login_email, login_password_hash)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `, [account_id, name, email, phone, address, website, contact_name, notes, login_email || email, passwordHash]);
    
    const vendorId = result.rows[0].id;
    
    // Create default permissions
    await client.query(`
      INSERT INTO vendor_permissions (vendor_id, can_see_guest_name, can_see_guest_email, can_see_guest_phone, 
        can_see_booking_dates, can_see_room_details, can_see_booking_notes, can_see_price_paid)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `, [
      vendorId,
      permissions.can_see_guest_name !== false,
      permissions.can_see_guest_email || false,
      permissions.can_see_guest_phone !== false,
      permissions.can_see_booking_dates !== false,
      permissions.can_see_room_details || false,
      permissions.can_see_booking_notes || false,
      permissions.can_see_price_paid || false
    ]);
    
    await client.query('COMMIT');
    
    res.json({ 
      success: true, 
      data: result.rows[0],
      tempPassword // Return temp password so it can be shown/emailed to vendor
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Create vendor error:', error);
    if (error.code === '23505') {
      if (error.constraint && error.constraint.includes('login_email')) {
        res.json({ success: false, error: 'A vendor with this login email already exists. Please use a different email address.' });
      } else {
        res.json({ success: false, error: 'A vendor with these details already exists.' });
      }
    } else {
      res.json({ success: false, error: error.message });
    }
  } finally {
    client.release();
  }
});

// Update vendor
app.put('/api/admin/vendors/:id', async (req, res) => {
  const client = await pool.connect();
  try {
    // Ensure vendor_permissions columns exist
    await client.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_dates BOOLEAN DEFAULT true').catch(() => {});
    await client.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_room_details BOOLEAN DEFAULT false').catch(() => {});
    await client.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_booking_notes BOOLEAN DEFAULT false').catch(() => {});
    await client.query('ALTER TABLE vendor_permissions ADD COLUMN IF NOT EXISTS can_see_price_paid BOOLEAN DEFAULT false').catch(() => {});
    
    const { id } = req.params;
    const { 
      name, email, phone, address, website, contact_name, notes, login_email, is_active,
      permissions = {}
    } = req.body;
    
    await client.query('BEGIN');
    
    await client.query(`
      UPDATE vendors SET 
        name = COALESCE($1, name),
        email = COALESCE($2, email),
        phone = COALESCE($3, phone),
        address = COALESCE($4, address),
        website = COALESCE($5, website),
        contact_name = COALESCE($6, contact_name),
        notes = COALESCE($7, notes),
        login_email = COALESCE($8, login_email),
        is_active = COALESCE($9, is_active),
        updated_at = NOW()
      WHERE id = $10
    `, [name, email, phone, address, website, contact_name, notes, login_email, is_active, id]);
    
    // Update permissions
    if (Object.keys(permissions).length > 0) {
      await client.query(`
        UPDATE vendor_permissions SET
          can_see_guest_name = COALESCE($1, can_see_guest_name),
          can_see_guest_email = COALESCE($2, can_see_guest_email),
          can_see_guest_phone = COALESCE($3, can_see_guest_phone),
          can_see_booking_dates = COALESCE($4, can_see_booking_dates),
          can_see_room_details = COALESCE($5, can_see_room_details),
          can_see_booking_notes = COALESCE($6, can_see_booking_notes),
          can_see_price_paid = COALESCE($7, can_see_price_paid),
          updated_at = NOW()
        WHERE vendor_id = $8
      `, [
        permissions.can_see_guest_name,
        permissions.can_see_guest_email,
        permissions.can_see_guest_phone,
        permissions.can_see_booking_dates,
        permissions.can_see_room_details,
        permissions.can_see_booking_notes,
        permissions.can_see_price_paid,
        id
      ]);
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Delete vendor
app.delete('/api/admin/vendors/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM vendors WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Reset vendor password
app.post('/api/admin/vendors/:id/reset-password', async (req, res) => {
  try {
    const tempPassword = Math.random().toString(36).substring(2, 10);
    const bcrypt = require('bcryptjs');
    const passwordHash = await bcrypt.hash(tempPassword, 10);
    
    await pool.query(`
      UPDATE vendors SET login_password_hash = $1, updated_at = NOW() WHERE id = $2
    `, [passwordHash, req.params.id]);
    
    res.json({ success: true, tempPassword });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// VENDOR SERVICE REQUESTS API
// =====================================================

// Get service requests (for property owner dashboard)
app.get('/api/admin/vendor-requests', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    const propertyId = req.query.property_id;
    const vendorId = req.query.vendor_id;
    const status = req.query.status;
    
    let query = `
      SELECT vsr.*, 
             v.name as vendor_name, v.email as vendor_email, v.phone as vendor_phone,
             p.name as property_name,
             u.name as upsell_name
      FROM vendor_service_requests vsr
      JOIN vendors v ON vsr.vendor_id = v.id
      LEFT JOIN properties p ON vsr.property_id = p.id
      LEFT JOIN upsells u ON vsr.upsell_id = u.id
      WHERE 1=1
    `;
    const params = [];
    let paramCount = 0;
    
    if (accountId) {
      paramCount++;
      query += ` AND v.account_id = $${paramCount}`;
      params.push(accountId);
    }
    if (propertyId) {
      paramCount++;
      query += ` AND vsr.property_id = $${paramCount}`;
      params.push(propertyId);
    }
    if (vendorId) {
      paramCount++;
      query += ` AND vsr.vendor_id = $${paramCount}`;
      params.push(vendorId);
    }
    if (status) {
      paramCount++;
      query += ` AND vsr.status = $${paramCount}`;
      params.push(status);
    }
    
    query += ' ORDER BY vsr.created_at DESC';
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Get vendor requests error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Create service request (when booking with external upsell is made)
app.post('/api/admin/vendor-requests', async (req, res) => {
  try {
    const {
      vendor_id, booking_id, upsell_id, voucher_id, property_id,
      service_name, service_date, service_time, guest_name, guest_email, guest_phone,
      special_instructions, quantity
    } = req.body;
    
    const result = await pool.query(`
      INSERT INTO vendor_service_requests 
      (vendor_id, booking_id, upsell_id, voucher_id, property_id, service_name, service_date, service_time,
       guest_name, guest_email, guest_phone, special_instructions, quantity)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *
    `, [vendor_id, booking_id, upsell_id, voucher_id, property_id, service_name, service_date, service_time,
        guest_name, guest_email, guest_phone, special_instructions, quantity || 1]);
    
    // TODO: Send email notification to vendor
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Create vendor request error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update service request status
app.put('/api/admin/vendor-requests/:id/status', async (req, res) => {
  try {
    const { status, notes } = req.body;
    
    let updateFields = 'status = $1, updated_at = NOW()';
    const params = [status, req.params.id];
    
    if (status === 'confirmed') {
      updateFields += ', confirmed_at = NOW()';
    } else if (status === 'completed') {
      updateFields += ', completed_at = NOW()';
    }
    
    if (notes) {
      params.splice(1, 0, notes);
      updateFields += `, notes = $2`;
      params[params.length - 1] = req.params.id; // Move id to end
    }
    
    await pool.query(`UPDATE vendor_service_requests SET ${updateFields} WHERE id = $${params.length}`, params);
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// VENDOR PORTAL API (for vendor login/access)
// =====================================================

// Vendor login
app.post('/api/vendor/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const bcrypt = require('bcryptjs');
    
    const result = await pool.query(`
      SELECT v.*, a.name as account_name
      FROM vendors v
      JOIN accounts a ON v.account_id = a.id
      WHERE v.login_email = $1 AND v.is_active = true
    `, [email]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid credentials' });
    }
    
    const vendor = result.rows[0];
    const validPassword = await bcrypt.compare(password, vendor.login_password_hash);
    
    if (!validPassword) {
      return res.json({ success: false, error: 'Invalid credentials' });
    }
    
    // Generate session token
    const crypto = require('crypto');
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
    
    await pool.query(`
      UPDATE vendors SET login_token = $1, token_expires_at = $2 WHERE id = $3
    `, [token, expiresAt, vendor.id]);
    
    // Get permissions
    const permsResult = await pool.query(`SELECT * FROM vendor_permissions WHERE vendor_id = $1`, [vendor.id]);
    
    res.json({ 
      success: true, 
      token,
      vendor: {
        id: vendor.id,
        name: vendor.name,
        email: vendor.email,
        account_name: vendor.account_name
      },
      permissions: permsResult.rows[0] || {}
    });
  } catch (error) {
    console.error('Vendor login error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get vendor's service requests (for vendor portal)
app.get('/api/vendor/requests', async (req, res) => {
  try {
    const token = req.headers['x-vendor-token'];
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }
    
    // Validate token
    const vendorResult = await pool.query(`
      SELECT v.*, vp.*
      FROM vendors v
      LEFT JOIN vendor_permissions vp ON v.id = vp.vendor_id
      WHERE v.login_token = $1 AND v.token_expires_at > NOW() AND v.is_active = true
    `, [token]);
    
    if (vendorResult.rows.length === 0) {
      return res.status(401).json({ success: false, error: 'Invalid or expired token' });
    }
    
    const vendor = vendorResult.rows[0];
    const status = req.query.status;
    
    // Build query based on permissions
    let selectFields = 'vsr.id, vsr.service_name, vsr.service_date, vsr.service_time, vsr.quantity, vsr.status, vsr.special_instructions, vsr.created_at';
    
    if (vendor.can_see_guest_name) selectFields += ', vsr.guest_name';
    if (vendor.can_see_guest_email) selectFields += ', vsr.guest_email';
    if (vendor.can_see_guest_phone) selectFields += ', vsr.guest_phone';
    if (vendor.can_see_booking_dates) selectFields += ', b.check_in, b.check_out';
    if (vendor.can_see_room_details) selectFields += ', bu.name as room_name';
    
    let query = `
      SELECT ${selectFields}, p.name as property_name
      FROM vendor_service_requests vsr
      LEFT JOIN properties p ON vsr.property_id = p.id
      LEFT JOIN bookings b ON vsr.booking_id = b.id
      LEFT JOIN bookable_units bu ON b.room_id = bu.id
      WHERE vsr.vendor_id = $1
    `;
    const params = [vendor.id];
    
    if (status) {
      query += ' AND vsr.status = $2';
      params.push(status);
    }
    
    query += ' ORDER BY vsr.service_date ASC, vsr.created_at DESC';
    
    const result = await pool.query(query, params);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Get vendor requests error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Vendor confirm/complete request
app.put('/api/vendor/requests/:id/status', async (req, res) => {
  try {
    const token = req.headers['x-vendor-token'];
    const { status } = req.body;
    
    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }
    
    // Validate token and ownership
    const vendorResult = await pool.query(`
      SELECT v.id FROM vendors v WHERE v.login_token = $1 AND v.token_expires_at > NOW() AND v.is_active = true
    `, [token]);
    
    if (vendorResult.rows.length === 0) {
      return res.status(401).json({ success: false, error: 'Invalid or expired token' });
    }
    
    const vendorId = vendorResult.rows[0].id;
    
    // Verify request belongs to this vendor
    const requestCheck = await pool.query(`SELECT id FROM vendor_service_requests WHERE id = $1 AND vendor_id = $2`, [req.params.id, vendorId]);
    if (requestCheck.rows.length === 0) {
      return res.status(403).json({ success: false, error: 'Request not found' });
    }
    
    // Only allow confirmed or completed status from vendor
    if (!['confirmed', 'completed'].includes(status)) {
      return res.json({ success: false, error: 'Invalid status' });
    }
    
    let updateQuery = 'UPDATE vendor_service_requests SET status = $1, updated_at = NOW()';
    if (status === 'confirmed') {
      updateQuery += ', confirmed_at = NOW()';
    } else if (status === 'completed') {
      updateQuery += ', completed_at = NOW()';
    }
    updateQuery += ' WHERE id = $2';
    
    await pool.query(updateQuery, [status, req.params.id]);
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// UPSELLS API
// =====================================================

app.get('/api/admin/upsells', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    const propertyId = req.query.property_id;
    const roomId = req.query.room_id;
    let result;
    
    if (propertyId) {
      // Filter by specific property
      result = await pool.query(`
        SELECT u.*, 
               p.name as property_name,
               r.name as room_name,
               v.name as vendor_name
        FROM upsells u
        LEFT JOIN properties p ON u.property_id = p.id
        LEFT JOIN rooms r ON u.room_id = r.id
        LEFT JOIN vendors v ON u.vendor_id = v.id
        WHERE u.property_id = $1
        ORDER BY u.name
      `, [propertyId]);
    } else if (accountId) {
      result = await pool.query(`
        SELECT u.*, 
               p.name as property_name,
               r.name as room_name,
               v.name as vendor_name
        FROM upsells u
        LEFT JOIN properties p ON u.property_id = p.id
        LEFT JOIN rooms r ON u.room_id = r.id
        LEFT JOIN vendors v ON u.vendor_id = v.id
        WHERE p.account_id = $1 OR u.property_id IS NULL
        ORDER BY u.name
      `, [accountId]);
    } else {
      result = await pool.query(`
        SELECT u.*, 
               p.name as property_name,
               r.name as room_name,
               v.name as vendor_name
        FROM upsells u
        LEFT JOIN properties p ON u.property_id = p.id
        LEFT JOIN rooms r ON u.room_id = r.id
        LEFT JOIN vendors v ON u.vendor_id = v.id
        ORDER BY u.name
      `);
    }
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/admin/upsells', async (req, res) => {
  try {
    // Ensure multilingual columns exist
    await pool.query('ALTER TABLE upsells ADD COLUMN IF NOT EXISTS name_ml JSONB').catch(() => {});
    await pool.query('ALTER TABLE upsells ADD COLUMN IF NOT EXISTS description_ml JSONB').catch(() => {});
    
    const { name: rawName, description: rawDesc, name_ml, description_ml, price, charge_type, max_quantity, property_id, room_id, room_ids, active, is_external, vendor_id } = req.body;
    
    // Handle name/description being sent as objects from frontend
    const nameObj = (typeof rawName === 'object' && rawName !== null) ? rawName : (name_ml || (rawName ? { en: rawName } : null));
    const descObj = (typeof rawDesc === 'object' && rawDesc !== null) ? rawDesc : (description_ml || (rawDesc ? { en: rawDesc } : null));
    const nameJson = nameObj ? JSON.stringify(nameObj) : null;
    const descJson = descObj ? JSON.stringify(descObj) : null;
    const englishName = mlStr(rawName) || '';
    const englishDesc = mlStr(rawDesc) || '';
    
    const result = await pool.query(`
      INSERT INTO upsells (name, description, name_ml, description_ml, price, charge_type, max_quantity, property_id, room_id, room_ids, active, is_external, vendor_id)
      VALUES ($1, $2, $3::jsonb, $4::jsonb, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *
    `, [englishName, englishDesc, nameJson, descJson, price, charge_type || 'per_booking', max_quantity, property_id, room_id, room_ids, active !== false, is_external || false, vendor_id || null]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.put('/api/admin/upsells/:id', async (req, res) => {
  try {
    // Ensure multilingual columns exist
    await pool.query('ALTER TABLE upsells ADD COLUMN IF NOT EXISTS name_ml JSONB').catch(() => {});
    await pool.query('ALTER TABLE upsells ADD COLUMN IF NOT EXISTS description_ml JSONB').catch(() => {});
    
    const { name: rawName, description: rawDesc, name_ml, description_ml, price, charge_type, max_quantity, property_id, room_id, room_ids, active, is_external, vendor_id } = req.body;
    
    // Handle name/description being sent as objects from frontend
    const nameObj = (typeof rawName === 'object' && rawName !== null) ? rawName : (name_ml || (rawName ? { en: rawName } : null));
    const descObj = (typeof rawDesc === 'object' && rawDesc !== null) ? rawDesc : (description_ml || (rawDesc ? { en: rawDesc } : null));
    const nameJson = nameObj ? JSON.stringify(nameObj) : null;
    const descJson = descObj ? JSON.stringify(descObj) : null;
    const englishName = mlStr(rawName) || '';
    const englishDesc = mlStr(rawDesc) || '';
    
    const result = await pool.query(`
      UPDATE upsells SET
        name = COALESCE($1, name),
        description = COALESCE($2, description),
        name_ml = COALESCE($3::jsonb, name_ml),
        description_ml = COALESCE($4::jsonb, description_ml),
        price = COALESCE($5, price),
        charge_type = COALESCE($6, charge_type),
        max_quantity = $7,
        property_id = $8,
        room_id = $9,
        room_ids = $10,
        active = COALESCE($11, active),
        is_external = COALESCE($12, is_external),
        vendor_id = $13,
        updated_at = NOW()
      WHERE id = $14
      RETURNING *
    `, [englishName, englishDesc, nameJson, descJson, price, charge_type, max_quantity, property_id, room_id, room_ids, active, is_external, vendor_id, req.params.id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.delete('/api/admin/upsells/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM upsells WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// FEES API
// =====================================================

app.get('/api/admin/fees', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    let result;
    
    if (accountId) {
      result = await pool.query(`
        SELECT f.* FROM fees f
        LEFT JOIN properties p ON f.property_id = p.id
        WHERE p.account_id = $1 OR f.property_id IS NULL
        ORDER BY f.name
      `, [accountId]);
    } else {
      result = await pool.query('SELECT * FROM fees ORDER BY name');
    }
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/admin/fees', async (req, res) => {
  try {
    const { name, description, amount_type, amount, apply_per, is_tax, property_id, room_id, active } = req.body;
    
    const result = await pool.query(`
      INSERT INTO fees (name, description, amount_type, amount, apply_per, is_tax, property_id, room_id, active)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `, [name, description, amount_type || 'fixed', amount, apply_per || 'per_booking', is_tax || false, property_id, room_id, active !== false]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.put('/api/admin/fees/:id', async (req, res) => {
  try {
    const { name, description, amount_type, amount, apply_per, is_tax, property_id, room_id, active } = req.body;
    
    const result = await pool.query(`
      UPDATE fees SET
        name = COALESCE($1, name),
        description = COALESCE($2, description),
        amount_type = COALESCE($3, amount_type),
        amount = COALESCE($4, amount),
        apply_per = COALESCE($5, apply_per),
        is_tax = COALESCE($6, is_tax),
        property_id = $7,
        room_id = $8,
        active = COALESCE($9, active),
        updated_at = NOW()
      WHERE id = $10
      RETURNING *
    `, [name, description, amount_type, amount, apply_per, is_tax, property_id, room_id, active, req.params.id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.delete('/api/admin/fees/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM fees WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// TAXES API (Tourist/City Taxes)
// =====================================================

app.get('/api/admin/taxes', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    const propertyId = req.query.property_id;
    const roomId = req.query.room_id;
    let result;
    
    if (propertyId) {
      // Filter by specific property - show taxes assigned to this property
      result = await pool.query(`
        SELECT t.*, p.name as property_name 
        FROM taxes t
        LEFT JOIN properties p ON t.property_id = p.id
        WHERE t.property_id = $1
        ORDER BY t.name
      `, [propertyId]);
    } else if (accountId) {
      // Show taxes that:
      // 1. Have user_id matching this account, OR
      // 2. Are linked to properties owned by this account
      result = await pool.query(`
        SELECT DISTINCT t.*, p.name as property_name 
        FROM taxes t
        LEFT JOIN properties p ON t.property_id = p.id
        WHERE t.user_id = $1 
           OR p.account_id = $1
        ORDER BY t.name
      `, [accountId]);
    } else {
      result = await pool.query(`
        SELECT t.*, p.name as property_name 
        FROM taxes t
        LEFT JOIN properties p ON t.property_id = p.id
        ORDER BY t.name
      `);
    }
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/admin/taxes', async (req, res) => {
  try {
    const { name: rawName, country, amount_type, currency, amount, charge_per, max_nights, min_age, star_tier, season_start, season_end, property_id, room_id, active, account_id } = req.body;
    const name = mlStr(rawName);
    
    // user_id = creator (account_id)
    // Visibility is handled by GET which checks property ownership
    const result = await pool.query(`
      INSERT INTO taxes (name, country, amount_type, currency, amount, charge_per, max_nights, min_age, star_tier, season_start, season_end, property_id, room_id, active, user_id)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
      RETURNING *
    `, [name, country, amount_type || 'fixed', currency || 'EUR', amount, charge_per || 'per_person_per_night', max_nights, min_age, star_tier, season_start, season_end, property_id, room_id, active !== false, account_id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.put('/api/admin/taxes/:id', async (req, res) => {
  try {
    const { name: rawName, country, amount_type, currency, amount, charge_per, max_nights, min_age, star_tier, season_start, season_end, property_id, room_id, active } = req.body;
    const name = mlStr(rawName);
    
    const result = await pool.query(`
      UPDATE taxes SET
        name = COALESCE($1, name),
        country = $2,
        amount_type = COALESCE($3, amount_type),
        currency = COALESCE($4, currency),
        amount = COALESCE($5, amount),
        charge_per = COALESCE($6, charge_per),
        max_nights = $7,
        min_age = $8,
        star_tier = $9,
        season_start = $10,
        season_end = $11,
        property_id = $12,
        room_id = $13,
        active = COALESCE($14, active),
        updated_at = NOW()
      WHERE id = $15
      RETURNING *
    `, [name, country, amount_type, currency, amount, charge_per, max_nights, min_age, star_tier, season_start, season_end, property_id, room_id, active, req.params.id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.delete('/api/admin/taxes/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM taxes WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// BOOKINGS API
// =====================================================

app.get('/api/admin/bookings', async (req, res) => {
  try {
    const { account_id, property_id, room_id, status } = req.query;
    let query = `
      SELECT b.*, 
             bu.name as unit_name,
             p.name as property_name
      FROM bookings b
      LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      LEFT JOIN properties p ON b.property_id = p.id
      WHERE 1=1
    `;
    const params = [];
    let paramIndex = 1;
    
    if (property_id) {
      query += ` AND b.property_id = $${paramIndex}`;
      params.push(property_id);
      paramIndex++;
    } else if (account_id) {
      query += ` AND p.account_id = $${paramIndex}`;
      params.push(account_id);
      paramIndex++;
    }
    
    if (room_id) {
      query += ` AND b.bookable_unit_id = $${paramIndex}`;
      params.push(room_id);
      paramIndex++;
    }
    
    if (status) {
      query += ` AND b.status = $${paramIndex}`;
      params.push(status);
      paramIndex++;
    }
    
    query += ` ORDER BY b.arrival_date DESC`;
    
    const result = await pool.query(query, params);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create booking from admin (with optional CM sync)
app.post('/api/admin/bookings', async (req, res) => {
  const client = await pool.connect();
  try {
    const { 
      property_id, room_id, check_in, check_out, 
      num_adults, guest_first_name, guest_last_name, 
      guest_email, guest_phone, total_price, 
      payment_status, status, notes, sync_to_cm 
    } = req.body;
    
    if (!property_id || !room_id || !check_in || !check_out || !guest_first_name || !guest_last_name || !guest_email) {
      return res.json({ success: false, error: 'Missing required fields' });
    }
    
    await client.query('BEGIN');
    
    // Create booking
    const bookingResult = await client.query(`
      INSERT INTO bookings (
        property_id, property_owner_id, bookable_unit_id, 
        arrival_date, departure_date, 
        num_adults, num_children, 
        guest_first_name, guest_last_name, guest_email, guest_phone,
        accommodation_price, subtotal, grand_total, 
        payment_status, status, booking_source, currency, notes
      ) 
      VALUES ($1, 1, $2, $3, $4, $5, 0, $6, $7, $8, $9, $10, $10, $10, $11, $12, 'manual', 'USD', $13)
      RETURNING *
    `, [
      property_id, room_id, check_in, check_out, 
      num_adults || 1, guest_first_name, guest_last_name, 
      guest_email, guest_phone || null, total_price || 0,
      payment_status || 'pending', status || 'confirmed', notes || null
    ]);
    
    const booking = bookingResult.rows[0];
    let beds24BookingId = null;
    let hostawayReservationId = null;
    
    // Sync to channel manager if requested
    if (sync_to_cm) {
      // Get room CM IDs
      const roomResult = await client.query(`
        SELECT beds24_room_id, hostaway_listing_id, smoobu_room_id 
        FROM bookable_units WHERE id = $1
      `, [room_id]);
      
      const beds24RoomId = roomResult.rows[0]?.beds24_room_id;
      const hostawayListingId = roomResult.rows[0]?.hostaway_listing_id;
      
      // Sync to Beds24
      if (beds24RoomId) {
        try {
          const accessToken = await getBeds24AccessToken(pool);
          if (accessToken) {
            const beds24Response = await fetch('https://beds24.com/api/v2/bookings', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                roomId: beds24RoomId,
                firstNight: check_in,
                lastNight: new Date(new Date(check_out).getTime() - 24*60*60*1000).toISOString().split('T')[0],
                numAdult: num_adults || 1,
                guestFirstName: guest_first_name,
                guestName: guest_last_name,
                guestEmail: guest_email,
                guestPhone: guest_phone || '',
                price: total_price || 0,
                status: 1,
                apiSource: 'GAS Direct Booking'
              })
            });
            
            const beds24Data = await beds24Response.json();
            if (beds24Data.bookId) {
              beds24BookingId = beds24Data.bookId;
            }
          }
        } catch (err) {
          console.error('Beds24 sync error:', err);
        }
      }
      
      // Sync to Hostaway
      if (hostawayListingId) {
        try {
          const hostawayToken = process.env.HOSTAWAY_API_KEY;
          if (hostawayToken) {
            const hostawayResponse = await fetch('https://api.hostaway.com/v1/reservations', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${hostawayToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                listingMapId: hostawayListingId,
                channelId: 2000,
                arrivalDate: check_in,
                departureDate: check_out,
                guestName: `${guest_first_name} ${guest_last_name}`,
                guestEmail: guest_email,
                guestPhone: guest_phone || '',
                numberOfGuests: num_adults || 1,
                totalPrice: total_price || 0,
                isPaid: payment_status === 'fully_paid' ? 1 : 0,
                status: 'new'
              })
            });
            
            const hostawayData = await hostawayResponse.json();
            if (hostawayData.result?.id) {
              hostawayReservationId = hostawayData.result.id;
            }
          }
        } catch (err) {
          console.error('Hostaway sync error:', err);
        }
      }
      
      // Update booking with CM IDs
      if (beds24BookingId || hostawayReservationId) {
        await client.query(`
          UPDATE bookings SET 
            beds24_booking_id = COALESCE($1, beds24_booking_id),
            hostaway_reservation_id = COALESCE($2, hostaway_reservation_id)
          WHERE id = $3
        `, [beds24BookingId, hostawayReservationId, booking.id]);
      }
    }
    
    // Block availability for these dates
    const checkInDate = new Date(check_in);
    const checkOutDate = new Date(check_out);
    let current = new Date(check_in);
    
    while (current < checkOutDate) {
      const dateStr = current.toISOString().split('T')[0];
      await client.query(`
        INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
        VALUES ($1, $2, false, true, 'booking')
        ON CONFLICT (room_id, date) DO UPDATE SET is_available = false, is_blocked = true
      `, [room_id, dateStr]);
      current.setDate(current.getDate() + 1);
    }
    
    await client.query('COMMIT');
    
    res.json({ 
      success: true, 
      booking_id: booking.id,
      booking: booking,
      beds24_id: beds24BookingId,
      hostaway_id: hostawayReservationId
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Create admin booking error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Get single booking with all details
app.get('/api/bookings/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT b.*, 
             bu.name as unit_name,
             p.name as property_name,
             p.currency,
             a.stripe_account_id
      FROM bookings b
      LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      LEFT JOIN properties p ON b.property_id = p.id
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE b.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    // Get payment transactions for this booking
    const transactions = await pool.query(`
      SELECT * FROM payment_transactions 
      WHERE booking_id = $1 
      ORDER BY created_at DESC
    `, [id]);
    
    res.json({ 
      success: true, 
      booking: result.rows[0],
      transactions: transactions.rows
    });
  } catch (error) {
    console.error('Get booking error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update booking
app.put('/api/bookings/:id', async (req, res) => {
  const client = await pool.connect();
  try {
    const { id } = req.params;
    const {
      guest_first_name, guest_last_name, guest_email, guest_phone,
      arrival_date, departure_date, num_adults, num_children,
      grand_total, deposit_amount, balance_amount,
      status, payment_status, notes
    } = req.body;
    
    // Get existing booking for comparison
    const existingResult = await client.query(`
      SELECT * FROM bookings WHERE id = $1
    `, [id]);
    
    if (existingResult.rows.length === 0) {
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    const existingBooking = existingResult.rows[0];
    const datesChanged = (arrival_date !== existingBooking.arrival_date?.toISOString().split('T')[0]) ||
                         (departure_date !== existingBooking.departure_date?.toISOString().split('T')[0]);
    const wasCancelled = existingBooking.status !== 'cancelled' && status === 'cancelled';
    
    await client.query('BEGIN');
    
    // Update booking
    await client.query(`
      UPDATE bookings SET
        guest_first_name = $1,
        guest_last_name = $2,
        guest_email = $3,
        guest_phone = $4,
        arrival_date = $5,
        departure_date = $6,
        num_adults = $7,
        num_children = $8,
        grand_total = $9,
        accommodation_price = $9,
        deposit_amount = $10,
        balance_amount = $11,
        status = $12,
        payment_status = $13,
        notes = $14,
        updated_at = NOW()
      WHERE id = $15
    `, [
      guest_first_name, guest_last_name, guest_email, guest_phone,
      arrival_date, departure_date, num_adults, num_children,
      grand_total, deposit_amount, balance_amount,
      status, payment_status, notes,
      id
    ]);
    
    // Handle availability changes
    if (datesChanged || wasCancelled) {
      // Clear old dates
      await client.query(`
        DELETE FROM room_availability 
        WHERE room_id = $1 AND date >= $2 AND date < $3 AND source = 'booking'
      `, [existingBooking.bookable_unit_id, existingBooking.arrival_date, existingBooking.departure_date]);
      
      // Add new dates if not cancelled
      if (status !== 'cancelled') {
        const startDate = new Date(arrival_date);
        const endDate = new Date(departure_date);
        
        for (let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)) {
          const dateStr = d.toISOString().split('T')[0];
          await client.query(`
            INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
            VALUES ($1, $2, false, true, 'booking')
            ON CONFLICT (room_id, date) DO UPDATE SET is_available = false, is_blocked = true, source = 'booking'
          `, [existingBooking.bookable_unit_id, dateStr]);
        }
      }
    }
    
    await client.query('COMMIT');
    
    // Sync to Beds24 if linked
    let beds24Synced = false;
    if (existingBooking.beds24_booking_id) {
      try {
        const accessToken = await getBeds24AccessToken(pool);
        if (accessToken) {
          const beds24Update = [{
            id: parseInt(existingBooking.beds24_booking_id),
            status: status === 'cancelled' ? 'cancelled' : 'confirmed',
            arrival: arrival_date,
            departure: departure_date,
            numAdult: num_adults,
            numChild: num_children || 0,
            firstName: guest_first_name,
            lastName: guest_last_name,
            email: guest_email,
            mobile: guest_phone || '',
            price: parseFloat(grand_total) || 0,
            deposit: parseFloat(deposit_amount) || 0
          }];
          
          console.log('Updating Beds24 booking:', JSON.stringify(beds24Update));
          
          const beds24Response = await axios.post('https://beds24.com/api/v2/bookings', beds24Update, {
            headers: {
              'token': accessToken,
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Beds24 update response:', JSON.stringify(beds24Response.data));
          beds24Synced = beds24Response.data?.[0]?.success || false;
        }
      } catch (beds24Error) {
        console.error('Beds24 update error:', beds24Error.response?.data || beds24Error.message);
      }
    }
    
    res.json({ 
      success: true, 
      beds24_synced: beds24Synced
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Update booking error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Delete booking
app.delete('/api/bookings/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get booking info first (for Beds24 sync and date unblocking)
    const bookingResult = await pool.query(`
      SELECT beds24_booking_id, bookable_unit_id, arrival_date, departure_date 
      FROM bookings WHERE id = $1
    `, [id]);
    
    const booking = bookingResult.rows[0];
    
    // Cancel in Beds24 if linked
    if (booking?.beds24_booking_id) {
      try {
        const accessToken = await getBeds24AccessToken(pool);
        if (accessToken) {
          const cancelResponse = await axios.post('https://beds24.com/api/v2/bookings', [{
            id: parseInt(booking.beds24_booking_id),
            status: 'cancelled'
          }], {
            headers: {
              'token': accessToken,
              'Content-Type': 'application/json'
            }
          });
          console.log('Beds24 cancellation on delete:', JSON.stringify(cancelResponse.data));
        }
      } catch (err) {
        console.error('Beds24 cancel on delete error:', err.response?.data || err.message);
      }
    }
    
    // Unblock dates in availability
    if (booking?.bookable_unit_id && booking?.arrival_date && booking?.departure_date) {
      await pool.query(`
        UPDATE room_availability 
        SET is_available = true, is_blocked = false, source = 'booking_deleted', updated_at = NOW()
        WHERE room_id = $1 AND date >= $2 AND date < $3 AND source IN ('booking', 'beds24_sync', 'beds24_webhook')
      `, [booking.bookable_unit_id, booking.arrival_date, booking.departure_date]);
    }
    
    // Delete payment transactions first
    await pool.query('DELETE FROM payment_transactions WHERE booking_id = $1', [id]);
    
    // Delete the booking
    await pool.query('DELETE FROM bookings WHERE id = $1', [id]);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Delete booking error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Generate invoice for booking
app.post('/api/bookings/:id/invoice', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get booking details
    const result = await pool.query(`
      SELECT b.*, 
             bu.name as unit_name,
             p.name as property_name,
             p.address as property_address,
             p.city as property_city,
             p.country as property_country,
             a.name as account_name,
             a.email as account_email
      FROM bookings b
      LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      LEFT JOIN properties p ON b.property_id = p.id
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE b.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    const booking = result.rows[0];
    
    // Generate simple HTML invoice (could be PDF later)
    const invoiceHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>Invoice #${booking.id}</title>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 40px; }
          .header { display: flex; justify-content: space-between; margin-bottom: 40px; }
          .company { font-size: 24px; font-weight: bold; color: #4f46e5; }
          .invoice-title { font-size: 32px; color: #1e293b; margin: 0; }
          .invoice-number { color: #64748b; }
          .section { margin-bottom: 30px; }
          .section-title { font-size: 14px; text-transform: uppercase; color: #64748b; margin-bottom: 10px; letter-spacing: 0.05em; }
          .guest-name { font-size: 18px; font-weight: 600; }
          .detail-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #e2e8f0; }
          .detail-row:last-child { border-bottom: none; }
          .total-row { font-weight: bold; font-size: 18px; background: #f8fafc; padding: 15px; border-radius: 8px; }
          .footer { margin-top: 40px; text-align: center; color: #64748b; font-size: 14px; }
          @media print { body { padding: 20px; } }
        </style>
      </head>
      <body>
        <div class="header">
          <div>
            <div class="company">${booking.property_name || 'Property'}</div>
            <div style="color: #64748b; margin-top: 5px;">${booking.property_address || ''}</div>
            <div style="color: #64748b;">${[booking.property_city, booking.property_country].filter(Boolean).join(', ')}</div>
          </div>
          <div style="text-align: right;">
            <h1 class="invoice-title">Invoice</h1>
            <div class="invoice-number">#${booking.id}</div>
            <div style="color: #64748b; margin-top: 10px;">Date: ${new Date().toLocaleDateString('en-GB')}</div>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">Bill To</div>
          <div class="guest-name">${[booking.guest_first_name, booking.guest_last_name].filter(Boolean).join(' ')}</div>
          <div style="color: #64748b;">${booking.guest_email || ''}</div>
          <div style="color: #64748b;">${booking.guest_phone || ''}</div>
        </div>
        
        <div class="section">
          <div class="section-title">Reservation Details</div>
          <div class="detail-row">
            <span>Room</span>
            <span>${booking.unit_name || '-'}</span>
          </div>
          <div class="detail-row">
            <span>Check-in</span>
            <span>${booking.arrival_date ? new Date(booking.arrival_date).toLocaleDateString('en-GB') : '-'}</span>
          </div>
          <div class="detail-row">
            <span>Check-out</span>
            <span>${booking.departure_date ? new Date(booking.departure_date).toLocaleDateString('en-GB') : '-'}</span>
          </div>
          <div class="detail-row">
            <span>Guests</span>
            <span>${(booking.num_adults || 0) + (booking.num_children || 0)}</span>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">Charges</div>
          <div class="detail-row">
            <span>Accommodation</span>
            <span>$${parseFloat(booking.accommodation_price || 0).toFixed(2)}</span>
          </div>
          ${booking.upsells_total && parseFloat(booking.upsells_total) > 0 ? `
          <div class="detail-row">
            <span>Extras</span>
            <span>$${parseFloat(booking.upsells_total).toFixed(2)}</span>
          </div>
          ` : ''}
          ${booking.discount_amount && parseFloat(booking.discount_amount) > 0 ? `
          <div class="detail-row">
            <span>Discount</span>
            <span style="color: #16a34a;">-$${parseFloat(booking.discount_amount).toFixed(2)}</span>
          </div>
          ` : ''}
          ${booking.tax_amount && parseFloat(booking.tax_amount) > 0 ? `
          <div class="detail-row">
            <span>Tax</span>
            <span>$${parseFloat(booking.tax_amount).toFixed(2)}</span>
          </div>
          ` : ''}
          <div class="detail-row total-row">
            <span>Total</span>
            <span>$${parseFloat(booking.grand_total || 0).toFixed(2)}</span>
          </div>
        </div>
        
        <div class="section">
          <div class="section-title">Payment Summary</div>
          <div class="detail-row">
            <span>Deposit Paid</span>
            <span style="color: #16a34a;">$${parseFloat(booking.deposit_amount || 0).toFixed(2)}</span>
          </div>
          <div class="detail-row">
            <span>Balance Due</span>
            <span style="color: ${(parseFloat(booking.grand_total || 0) - parseFloat(booking.deposit_amount || 0)) > 0 ? '#dc2626' : '#16a34a'};">$${(parseFloat(booking.grand_total || 0) - parseFloat(booking.deposit_amount || 0)).toFixed(2)}</span>
          </div>
        </div>
        
        <div class="footer">
          <p>Thank you for your booking!</p>
          <p style="font-size: 12px;">Generated by GAS - Guest Accommodation System</p>
        </div>
        
        <script>window.print();</script>
      </body>
      </html>
    `;
    
    // For now, return the HTML directly - could save as file or convert to PDF
    res.send(invoiceHtml);
    
  } catch (error) {
    console.error('Generate invoice error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Send payment receipt email
app.post('/api/bookings/:id/send-receipt', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get booking details
    const result = await pool.query(`
      SELECT b.*, p.name as property_name
      FROM bookings b
      LEFT JOIN properties p ON b.property_id = p.id
      WHERE b.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    const booking = result.rows[0];
    
    // TODO: Implement email sending via SendGrid/Mailgun/etc
    // For now, just log and return success
    console.log(`Would send receipt email to ${booking.guest_email} for booking ${id}`);
    
    res.json({ success: true, message: 'Receipt email queued' });
    
  } catch (error) {
    console.error('Send receipt error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Process refund
app.post('/api/bookings/:id/refund', async (req, res) => {
  try {
    const { id } = req.params;
    const { amount } = req.body; // Optional - full refund if not specified
    
    // Get booking and payment details
    const result = await pool.query(`
      SELECT b.*, a.stripe_account_id
      FROM bookings b
      LEFT JOIN properties p ON b.property_id = p.id
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE b.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    const booking = result.rows[0];
    
    if (!booking.stripe_payment_intent_id) {
      return res.json({ success: false, error: 'No payment found for this booking' });
    }
    
    // Process refund via Stripe
    const refundAmount = amount ? Math.round(parseFloat(amount) * 100) : undefined; // undefined = full refund
    
    try {
      const refund = await stripe.refunds.create({
        payment_intent: booking.stripe_payment_intent_id,
        amount: refundAmount
      }, {
        stripeAccount: booking.stripe_account_id
      });
      
      // Update booking status
      await pool.query(`
        UPDATE bookings 
        SET payment_status = 'refunded', 
            refund_amount = COALESCE(refund_amount, 0) + $1
        WHERE id = $2
      `, [refund.amount / 100, id]);
      
      // Record transaction
      await pool.query(`
        INSERT INTO payment_transactions (booking_id, type, amount, currency, status, stripe_payment_intent_id, created_at)
        VALUES ($1, 'refund', $2, 'USD', 'completed', $3, NOW())
      `, [id, refund.amount / 100, refund.id]);
      
      res.json({ success: true, refund_id: refund.id, amount: refund.amount / 100 });
      
    } catch (stripeError) {
      console.error('Stripe refund error:', stripeError);
      res.json({ success: false, error: stripeError.message });
    }
    
  } catch (error) {
    console.error('Process refund error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Cancel booking
app.post('/api/bookings/:id/cancel', async (req, res) => {
  const client = await pool.connect();
  try {
    const { id } = req.params;
    
    await client.query('BEGIN');
    
    // Get booking details
    const result = await client.query(`
      SELECT b.*, bu.beds24_room_id, bu.hostaway_listing_id
      FROM bookings b
      LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      WHERE b.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    const booking = result.rows[0];
    
    // Update booking status
    await client.query(`
      UPDATE bookings SET status = 'cancelled' WHERE id = $1
    `, [id]);
    
    // Unblock availability
    await client.query(`
      DELETE FROM room_availability 
      WHERE room_id = $1 
      AND date >= $2 
      AND date < $3 
      AND source = 'booking'
    `, [booking.bookable_unit_id, booking.arrival_date, booking.departure_date]);
    
    // Cancel in Beds24
    if (booking.beds24_booking_id) {
      try {
        const accessToken = await getBeds24AccessToken(pool);
        if (accessToken) {
          // Beds24 v2 API - POST to /bookings with status update
          const cancelResponse = await axios.post('https://beds24.com/api/v2/bookings', [{
            id: parseInt(booking.beds24_booking_id),
            status: 'cancelled'
          }], {
            headers: {
              'token': accessToken,
              'Content-Type': 'application/json'
            }
          });
          console.log('Beds24 cancellation response:', JSON.stringify(cancelResponse.data));
        }
      } catch (err) {
        console.error('Beds24 cancel error:', err.response?.data || err.message);
      }
    }
    
    // Cancel in Hostaway
    if (booking.hostaway_reservation_id) {
      try {
        const hostawayToken = process.env.HOSTAWAY_API_KEY;
        if (hostawayToken) {
          await fetch(`https://api.hostaway.com/v1/reservations/${booking.hostaway_reservation_id}`, {
            method: 'PUT',
            headers: {
              'Authorization': `Bearer ${hostawayToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ status: 'cancelled' })
          });
        }
      } catch (err) {
        console.error('Hostaway cancel error:', err);
      }
    }
    
    await client.query('COMMIT');
    
    // ========== SEND PARTNER CANCELLATION WEBHOOK ==========
    try {
      const webhookResult = await sendPartnerBookingWebhook(id, 'booking.cancelled');
      if (webhookResult.sent) {
        console.log(`[Webhook] Sent booking.cancelled for booking ${id}`);
      }
    } catch (webhookError) {
      console.error(`[Webhook] Error sending cancellation webhook for booking ${id}:`, webhookError.message);
      // Don't fail the cancellation if webhook fails
    }
    // ========== END PARTNER WEBHOOK ==========
    
    res.json({ success: true, message: 'Booking cancelled' });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Cancel booking error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Validate voucher code (for booking widget)
app.post('/api/vouchers/validate', async (req, res) => {
  try {
    const { code, property_id, room_id, nights, total, guest_email } = req.body;
    
    const result = await pool.query(`
      SELECT * FROM vouchers 
      WHERE code = $1 AND active = true
      AND (valid_from IS NULL OR valid_from <= CURRENT_DATE)
      AND (valid_until IS NULL OR valid_until >= CURRENT_DATE)
      AND (max_uses IS NULL OR uses_count < max_uses)
    `, [code.toUpperCase()]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid or expired voucher code' });
    }
    
    const voucher = result.rows[0];
    
    // Check min nights
    if (voucher.min_nights && nights < voucher.min_nights) {
      return res.json({ success: false, error: `Minimum ${voucher.min_nights} nights required` });
    }
    
    // Check min total
    if (voucher.min_total && total < voucher.min_total) {
      return res.json({ success: false, error: `Minimum total of $${voucher.min_total} required` });
    }
    
    // Check property/room restrictions
    if (voucher.property_ids && property_id && !voucher.property_ids.includes(property_id)) {
      return res.json({ success: false, error: 'Voucher not valid for this property' });
    }
    if (voucher.room_ids && room_id && !voucher.room_ids.includes(room_id)) {
      return res.json({ success: false, error: 'Voucher not valid for this room' });
    }
    
    // Check single use per guest
    if (voucher.single_use_per_guest && guest_email) {
      const used = await pool.query(
        'SELECT id FROM voucher_uses WHERE voucher_id = $1 AND guest_email = $2',
        [voucher.id, guest_email]
      );
      if (used.rows.length > 0) {
        return res.json({ success: false, error: 'You have already used this voucher' });
      }
    }
    
    // Calculate discount
    let discount = 0;
    if (voucher.discount_type === 'percentage') {
      discount = total * (voucher.discount_value / 100);
    } else {
      discount = voucher.discount_value;
    }
    
    res.json({
      success: true,
      voucher: {
        id: voucher.id,
        code: voucher.code,
        name: voucher.name,
        discount_type: voucher.discount_type,
        discount_value: voucher.discount_value,
        discount_amount: Math.min(discount, total)
      }
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Calculate price with offers (for booking widget)
app.post('/api/pricing/calculate', async (req, res) => {
  try {
    const { room_id, check_in, check_out, guests, voucher_code } = req.body;
    
    // Get room availability and base prices
    const availResult = await pool.query(`
      SELECT date, cm_price, standard_price, direct_price
      FROM room_availability
      WHERE room_id = $1 AND date >= $2 AND date < $3
      ORDER BY date
    `, [room_id, check_in, check_out]);
    
    const nights = availResult.rows.length;
    
    // Get the room's property_id AND account_id for offer filtering
    const roomPropertyResult = await pool.query(`
      SELECT bu.property_id, p.account_id, p.client_id 
      FROM bookable_units bu 
      LEFT JOIN properties p ON bu.property_id = p.id 
      WHERE bu.id = $1
    `, [room_id]);
    const roomPropertyId = roomPropertyResult.rows[0]?.property_id;
    const roomAccountId = roomPropertyResult.rows[0]?.account_id || roomPropertyResult.rows[0]?.client_id;
    
    // Get applicable offers - MUST match account_id to prevent cross-account bleeding
    const offersResult = await pool.query(`
      SELECT * FROM offers
      WHERE active = true
      AND account_id = $7
      AND (property_id IS NULL OR property_id = $6)
      AND (room_id IS NULL OR room_id = $1)
      AND (min_nights IS NULL OR min_nights <= $2)
      AND (max_nights IS NULL OR max_nights >= $2)
      AND (min_guests IS NULL OR min_guests <= $3)
      AND (max_guests IS NULL OR max_guests >= $3)
      AND (valid_from IS NULL OR valid_from <= $4)
      AND (valid_until IS NULL OR valid_until >= $5)
      ORDER BY priority DESC
    `, [room_id, nights, guests, check_in, check_out, roomPropertyId, roomAccountId]);
    
    // Calculate pricing
    let baseTotal = 0;
    let standardTotal = 0;
    const dailyPrices = [];
    
    for (const day of availResult.rows) {
      const refPrice = parseFloat(day.cm_price) || 0;
      const stdPrice = parseFloat(day.standard_price) || refPrice;
      baseTotal += refPrice;
      standardTotal += stdPrice;
      dailyPrices.push({
        date: day.date,
        reference_price: refPrice,
        standard_price: stdPrice
      });
    }
    
    // Apply best offer
    let offerDiscount = 0;
    let appliedOffer = null;
    
    for (const offer of offersResult.rows) {
      let discount = 0;
      if (offer.discount_type === 'percentage') {
        discount = standardTotal * (offer.discount_value / 100);
      } else {
        discount = offer.discount_value;
      }
      
      if (discount > offerDiscount) {
        offerDiscount = discount;
        appliedOffer = offer;
      }
    }
    
    let finalTotal = standardTotal - offerDiscount;
    
    // Apply voucher if provided
    let voucherDiscount = 0;
    let appliedVoucher = null;
    
    if (voucher_code) {
      const voucherResult = await pool.query(`
        SELECT * FROM vouchers 
        WHERE code = $1 AND active = true
        AND (valid_from IS NULL OR valid_from <= CURRENT_DATE)
        AND (valid_until IS NULL OR valid_until >= CURRENT_DATE)
      `, [voucher_code.toUpperCase()]);
      
      if (voucherResult.rows.length > 0) {
        const voucher = voucherResult.rows[0];
        if (voucher.discount_type === 'percentage') {
          voucherDiscount = finalTotal * (voucher.discount_value / 100);
        } else {
          voucherDiscount = voucher.discount_value;
        }
        appliedVoucher = voucher;
        finalTotal -= voucherDiscount;
      }
    }
    
    res.json({
      success: true,
      pricing: {
        nights,
        reference_total: baseTotal,
        standard_total: standardTotal,
        offer_discount: offerDiscount,
        applied_offer: appliedOffer ? { id: appliedOffer.id, name: appliedOffer.name } : null,
        voucher_discount: voucherDiscount,
        applied_voucher: appliedVoucher ? { id: appliedVoucher.id, code: appliedVoucher.code } : null,
        final_total: Math.max(0, finalTotal),
        daily_prices: dailyPrices
      }
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// ADMIN DASHBOARD API ENDPOINTS
// =====================================================

// Get dashboard statistics
app.get('/api/admin/stats', async (req, res) => {
  try {
    const clientId = req.query.client_id;
    const accountId = req.query.account_id;
    
    console.log('Stats request - accountId:', accountId, 'clientId:', clientId);
    
    let propertiesCount, unitsCount, bookingsCount, connectionsCount;
    
    if (accountId) {
      // Check if this account has sub-accounts
      const subAccountCheck = await pool.query(
        'SELECT COUNT(*) FROM accounts WHERE parent_id = $1',
        [accountId]
      );
      const hasSubAccounts = parseInt(subAccountCheck.rows[0].count) > 0;
      
      if (hasSubAccounts) {
        // For parent accounts, include sub-account properties
        console.log('Filtering by account_id with sub-accounts:', accountId);
        propertiesCount = await pool.query(`
          SELECT COUNT(*) FROM properties p
          JOIN accounts a ON p.account_id = a.id
          WHERE p.account_id = $1 OR a.parent_id = $1
        `, [accountId]);
        unitsCount = await pool.query(`
          SELECT COUNT(*) FROM bookable_units bu 
          JOIN properties p ON bu.property_id = p.id 
          JOIN accounts a ON p.account_id = a.id
          WHERE p.account_id = $1 OR a.parent_id = $1
        `, [accountId]);
        bookingsCount = await pool.query(`
          SELECT COUNT(*) FROM bookings b
          JOIN properties p ON b.property_id = p.id
          JOIN accounts a ON p.account_id = a.id
          WHERE p.account_id = $1 OR a.parent_id = $1
        `, [accountId]);
      } else {
        // Account-specific stats (no sub-accounts)
        console.log('Filtering by account_id:', accountId);
        propertiesCount = await pool.query('SELECT COUNT(*) FROM properties WHERE account_id = $1', [accountId]);
        unitsCount = await pool.query(`
          SELECT COUNT(*) FROM bookable_units bu 
          JOIN properties p ON bu.property_id = p.id 
          WHERE p.account_id = $1
        `, [accountId]);
        bookingsCount = await pool.query(`
          SELECT COUNT(*) FROM bookings b
          JOIN properties p ON b.property_id = p.id
          WHERE p.account_id = $1
        `, [accountId]);
      }
      console.log('Properties count:', propertiesCount.rows[0].count);
      // Check both gas_account_id (INTEGER) and account_id (VARCHAR) columns
      connectionsCount = await pool.query(`
        SELECT COUNT(*) FROM channel_connections 
        WHERE (gas_account_id = $1 OR account_id = $2) AND status = 'active'
      `, [accountId, String(accountId)]);
    } else if (clientId) {
      // Client-specific stats (legacy)
      propertiesCount = await pool.query('SELECT COUNT(*) FROM properties WHERE client_id = $1', [clientId]);
      unitsCount = await pool.query(`
        SELECT COUNT(*) FROM bookable_units bu 
        JOIN properties p ON bu.property_id = p.id 
        WHERE p.client_id = $1
      `, [clientId]);
      bookingsCount = await pool.query(`
        SELECT COUNT(*) FROM bookings b
        JOIN properties p ON b.property_id = p.id
        WHERE p.client_id = $1
      `, [clientId]);
      connectionsCount = await pool.query(`
        SELECT COUNT(*) FROM channel_connections 
        WHERE (gas_account_id = $1 OR account_id = $2) AND status = 'active'
      `, [clientId, String(clientId)]);
    } else {
      // All stats (admin view)
      propertiesCount = await pool.query('SELECT COUNT(*) FROM properties');
      unitsCount = await pool.query('SELECT COUNT(*) FROM bookable_units');
      bookingsCount = await pool.query('SELECT COUNT(*) FROM bookings');
      connectionsCount = await pool.query('SELECT COUNT(*) FROM channel_connections WHERE status = $1', ['active']);
    }
    
    res.json({
      success: true,
      properties: parseInt(propertiesCount.rows[0].count),
      units: parseInt(unitsCount.rows[0].count),
      bookings: parseInt(bookingsCount.rows[0].count),
      connections: parseInt(connectionsCount.rows[0].count)
    });
  } catch (error) {
    console.error('Stats error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Debug endpoint - check what's actually in database
app.get('/api/admin/debug', async (req, res) => {
  try {
    const properties = await pool.query('SELECT id, name, beds24_property_id, created_at FROM properties ORDER BY created_at DESC');
    const units = await pool.query('SELECT id, name, property_id, created_at FROM bookable_units ORDER BY created_at DESC');
    const connections = await pool.query(`
      SELECT cc.id, cm.cm_name, cm.cm_code, cc.status, cc.created_at 
      FROM channel_connections cc
      LEFT JOIN channel_managers cm ON cc.cm_id = cm.id
      ORDER BY cc.created_at DESC
    `);
    
    res.json({
      success: true,
      properties: properties.rows,
      units: units.rows,
      connections: connections.rows,
      counts: {
        properties: properties.rows.length,
        units: units.rows.length,
        connections: connections.rows.length
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get all bookable units with property details
app.get('/api/admin/units', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    const propertyId = req.query.property_id;
    let result;
    
    if (propertyId) {
      // Filter by specific property
      result = await pool.query(`
        SELECT 
          bu.*,
          p.name as property_name,
          rt.id as room_type_id,
          rt.name as room_type_name
        FROM bookable_units bu
        LEFT JOIN properties p ON bu.property_id = p.id
        LEFT JOIN room_types rt ON bu.room_type_id = rt.id
        WHERE bu.property_id = $1
        ORDER BY bu.name
      `, [propertyId]);
    } else if (accountId) {
      result = await pool.query(`
        SELECT 
          bu.*,
          p.name as property_name,
          rt.id as room_type_id,
          rt.name as room_type_name
        FROM bookable_units bu
        LEFT JOIN properties p ON bu.property_id = p.id
        LEFT JOIN room_types rt ON bu.room_type_id = rt.id
        WHERE p.account_id = $1
        ORDER BY bu.created_at DESC
      `, [accountId]);
    } else {
      result = await pool.query(`
        SELECT 
          bu.*,
          p.name as property_name,
          rt.id as room_type_id,
          rt.name as room_type_name
        FROM bookable_units bu
        LEFT JOIN properties p ON bu.property_id = p.id
        LEFT JOIN room_types rt ON bu.room_type_id = rt.id
        ORDER BY bu.created_at DESC
      `);
    }
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    console.error('Units error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Get single unit
app.get('/api/admin/units/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query('SELECT * FROM bookable_units WHERE id = $1', [id]);
    
    if (result.rows.length > 0) {
      const unit = result.rows[0];
      console.log(`GET /api/admin/units/${id} - full_description type:`, typeof unit.full_description, 
        'value preview:', unit.full_description ? JSON.stringify(unit.full_description).substring(0, 200) : 'NULL');
      res.json({ success: true, data: unit });
    } else {
      res.json({ success: false, error: 'Unit not found' });
    }
  } catch (error) {
    console.error('Unit fetch error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Update unit
app.put('/api/admin/units/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log('PUT /api/admin/units/' + id, 'body:', JSON.stringify(req.body));
    
    const { quantity, status, room_type, max_guests, max_adults, max_children, display_name, short_description, full_description } = req.body;
    
    // Update basic fields only - no JSONB casting to avoid errors
    const result = await pool.query(`
      UPDATE bookable_units 
      SET 
        quantity = $1,
        status = $2,
        unit_type = $3,
        max_guests = $4,
        max_adults = $5,
        max_children = $6,
        updated_at = NOW()
      WHERE id = $7
      RETURNING id, name, display_name, quantity, status, unit_type, max_guests, max_adults, max_children, short_description, full_description
    `, [
      quantity || 1, 
      status || 'available', 
      room_type || 'double', 
      max_guests || 2, 
      max_adults || 2, 
      max_children || 0, 
      id
    ]);
    
    // Update display_name separately if provided (handles both string and object)
    if (display_name !== undefined) {
      try {
        let jsonValue = null;
        if (display_name && typeof display_name === 'object') {
          // Already a multilingual object
          jsonValue = JSON.stringify(display_name);
        } else if (display_name && typeof display_name === 'string' && display_name.trim()) {
          // Plain string - wrap in object
          jsonValue = JSON.stringify({ en: display_name.trim() });
        }
        await pool.query(
          `UPDATE bookable_units SET display_name = $1 WHERE id = $2`,
          [jsonValue, id]
        );
      } catch (e) {
        console.log('display_name update skipped:', e.message);
      }
    }
    
    // Update short_description separately if provided (handles both string and object)
    if (short_description !== undefined) {
      try {
        let jsonValue = null;
        if (short_description && typeof short_description === 'object') {
          jsonValue = JSON.stringify(short_description);
        } else if (short_description && typeof short_description === 'string') {
          jsonValue = JSON.stringify({ en: short_description });
        }
        await pool.query(
          `UPDATE bookable_units SET short_description = $1 WHERE id = $2`,
          [jsonValue, id]
        );
      } catch (e) {
        console.log('short_description update skipped:', e.message);
      }
    }
    
    // Update full_description separately if provided (handles both string and object)
    if (full_description !== undefined) {
      try {
        let jsonValue = null;
        if (full_description && typeof full_description === 'object') {
          jsonValue = JSON.stringify(full_description);
        } else if (full_description && typeof full_description === 'string') {
          jsonValue = JSON.stringify({ en: full_description });
        }
        await pool.query(
          `UPDATE bookable_units SET full_description = $1 WHERE id = $2`,
          [jsonValue, id]
        );
      } catch (e) {
        console.log('full_description update skipped:', e.message);
      }
    }
    
    // Update num_bedrooms if provided
    if (req.body.num_bedrooms !== undefined) {
      try {
        await pool.query(
          `UPDATE bookable_units SET num_bedrooms = $1 WHERE id = $2`,
          [req.body.num_bedrooms || 1, id]
        );
      } catch (e) {
        console.log('num_bedrooms update skipped:', e.message);
      }
    }
    
    // Update num_bathrooms if provided
    if (req.body.num_bathrooms !== undefined) {
      try {
        await pool.query(
          `UPDATE bookable_units SET num_bathrooms = $1 WHERE id = $2`,
          [req.body.num_bathrooms || 1, id]
        );
      } catch (e) {
        console.log('num_bathrooms update skipped:', e.message);
      }
    }
    
    // Fetch final result
    const finalResult = await pool.query(
      `SELECT id, name, display_name, quantity, status, unit_type, max_guests, max_adults, max_children, short_description, full_description, num_bedrooms, num_bathrooms FROM bookable_units WHERE id = $1`,
      [id]
    );
    
    console.log('Update success:', finalResult.rows[0]);
    res.json({ success: true, data: finalResult.rows[0] });
  } catch (error) {
    console.error('Unit update error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Delete unit - REQUIRES no bookings attached
app.delete('/api/admin/units/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check if unit has any bookings
    const bookingsCheck = await pool.query(
      'SELECT COUNT(*) as count FROM bookings WHERE bookable_unit_id = $1',
      [id]
    );
    
    if (parseInt(bookingsCheck.rows[0].count) > 0) {
      return res.json({ 
        success: false, 
        error: 'Cannot delete room: This room has ' + bookingsCheck.rows[0].count + ' booking(s) attached. Cancel or reassign bookings first.'
      });
    }
    
    // Safe to delete - remove related records first
    await pool.query('DELETE FROM bookable_unit_images WHERE bookable_unit_id = $1', [id]);
    await pool.query('DELETE FROM bookable_unit_amenities WHERE bookable_unit_id = $1', [id]);
    
    // Delete the unit
    await pool.query('DELETE FROM bookable_units WHERE id = $1', [id]);
    
    res.json({ success: true, message: 'Room deleted successfully' });
  } catch (error) {
    console.error('Unit delete error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Get all amenities
app.get('/api/admin/amenities', async (req, res) => {
  try {
    // Get all master amenities
    const masterAmenities = await pool.query(`
      SELECT * FROM master_amenities 
      WHERE is_active = true 
      ORDER BY category, display_order
    `);
    
    res.json({
      success: true,
      amenities: masterAmenities.rows
    });
  } catch (error) {
    console.error('Amenities error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Get amenities for a specific room
app.get('/api/admin/units/:id/amenities', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(`
      SELECT 
        ras.id as selection_id,
        ras.display_order,
        ma.id as amenity_id,
        ma.amenity_code,
        ma.amenity_name,
        ma.category,
        ma.icon
      FROM room_amenity_selections ras
      JOIN master_amenities ma ON ras.amenity_id = ma.id
      WHERE ras.room_id = $1
      ORDER BY ras.display_order
    `, [id]);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Unit amenities error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Update amenities for a room
app.put('/api/admin/units/:id/amenities', async (req, res) => {
  try {
    const { id } = req.params;
    const { amenities } = req.body; // Array of amenity IDs
    
    // Delete existing selections for this room
    await pool.query('DELETE FROM room_amenity_selections WHERE room_id = $1', [id]);
    
    // Insert new selections
    if (amenities && amenities.length > 0) {
      for (let i = 0; i < amenities.length; i++) {
        const amenityId = typeof amenities[i] === 'object' ? amenities[i].id : amenities[i];
        await pool.query(`
          INSERT INTO room_amenity_selections (room_id, amenity_id, display_order)
          VALUES ($1, $2, $3)
        `, [id, amenityId, i]);
      }
    }
    
    res.json({ success: true, message: 'Amenities updated successfully' });
  } catch (error) {
    console.error('Update unit amenities error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Create new custom amenity
app.post('/api/admin/amenities', async (req, res) => {
  try {
    const { name, category, icon } = req.body;
    
    if (!name || !category) {
      return res.json({ success: false, error: 'Name and category are required' });
    }
    
    // Generate code from name
    const code = name.toLowerCase().replace(/[^a-z0-9]/g, '_').replace(/_+/g, '_');
    
    // Check if code already exists
    const existing = await pool.query(
      'SELECT COUNT(*) as count FROM master_amenities WHERE amenity_code = $1',
      [code]
    );
    
    if (parseInt(existing.rows[0].count) > 0) {
      return res.json({ success: false, error: 'An amenity with this name already exists' });
    }
    
    // Insert into master_amenities - amenity_name must be JSONB
    const amenityNameJson = JSON.stringify({ en: name });
    const result = await pool.query(`
      INSERT INTO master_amenities (amenity_code, amenity_name, category, icon, is_system, created_by)
      VALUES ($1, $2::jsonb, $3, $4, false, 'user')
      RETURNING *
    `, [code, amenityNameJson, category, icon || '‚úì']);
    
    res.json({ 
      success: true, 
      message: 'Custom amenity created',
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Create amenity error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Delete amenity (only if unused)
app.delete('/api/admin/amenities/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Delete the amenity
    await pool.query('DELETE FROM master_amenities WHERE id = $1', [id]);
    
    res.json({ success: true, message: 'Amenity deleted' });
  } catch (error) {
    console.error('Delete amenity error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Batch translate all master amenities
app.post('/api/admin/amenities/translate-all', async (req, res) => {
  try {
    const targetLangs = req.body.languages || ['fr', 'es', 'de', 'nl'];
    
    // Get all amenities
    const amenities = await pool.query('SELECT id, amenity_code, amenity_name FROM master_amenities WHERE is_active = true');
    
    console.log(`[Translate Amenities] Starting batch translation of ${amenities.rows.length} amenities to ${targetLangs.join(', ')}`);
    
    let translated = 0;
    let skipped = 0;
    let errors = 0;
    
    for (const amenity of amenities.rows) {
      try {
        // Parse current name
        let nameObj = {};
        if (typeof amenity.amenity_name === 'object' && amenity.amenity_name !== null) {
          nameObj = amenity.amenity_name;
        } else if (typeof amenity.amenity_name === 'string') {
          try {
            nameObj = JSON.parse(amenity.amenity_name);
          } catch (e) {
            nameObj = { en: amenity.amenity_name };
          }
        }
        
        // Get English name as source
        const englishName = nameObj.en || amenity.amenity_code.replace(/_/g, ' ');
        if (!englishName) {
          skipped++;
          continue;
        }
        
        // Translate to each target language
        let updated = false;
        for (const lang of targetLangs) {
          if (!nameObj[lang]) {
            const translatedText = await translateText(englishName, 'en', lang);
            if (translatedText) {
              nameObj[lang] = translatedText;
              updated = true;
              console.log(`[Translate] ${amenity.amenity_code}: ${englishName} -> ${lang}: ${translatedText}`);
            }
            // Small delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        
        if (updated) {
          await pool.query(
            'UPDATE master_amenities SET amenity_name = $1::jsonb WHERE id = $2',
            [JSON.stringify(nameObj), amenity.id]
          );
          translated++;
        } else {
          skipped++;
        }
      } catch (e) {
        console.error(`[Translate] Error translating ${amenity.amenity_code}:`, e.message);
        errors++;
      }
    }
    
    console.log(`[Translate Amenities] Complete: ${translated} translated, ${skipped} skipped, ${errors} errors`);
    
    res.json({
      success: true,
      message: `Translated ${translated} amenities`,
      stats: { translated, skipped, errors, total: amenities.rows.length }
    });
  } catch (error) {
    console.error('Batch translate amenities error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Delete ALL amenities
app.delete('/api/admin/amenities/delete-all', async (req, res) => {
  try {
    // First clear any selections
    await pool.query('DELETE FROM room_amenity_selections');
    await pool.query('DELETE FROM property_amenity_selections');
    
    // Then delete all amenities
    const result = await pool.query('DELETE FROM master_amenities');
    
    res.json({ 
      success: true, 
      message: 'All amenities deleted',
      deleted: result.rowCount
    });
  } catch (error) {
    console.error('Delete all amenities error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/admin/amenities/normalize - Add lowercase aliases to all amenities
app.post('/api/admin/amenities/normalize', async (req, res) => {
  try {
    console.log('üîÑ Normalizing amenity codes with lowercase aliases...');
    
    // Get all amenities
    const amenities = await pool.query('SELECT id, amenity_code, aliases FROM master_amenities');
    
    let updated = 0;
    let skipped = 0;
    const changes = [];
    
    for (const amenity of amenities.rows) {
      const code = amenity.amenity_code;
      const lowercaseCode = code.toLowerCase();
      
      // Parse existing aliases
      let aliases = [];
      if (amenity.aliases) {
        if (Array.isArray(amenity.aliases)) {
          aliases = amenity.aliases;
        } else if (typeof amenity.aliases === 'string') {
          try {
            aliases = JSON.parse(amenity.aliases);
          } catch (e) {
            aliases = [amenity.aliases];
          }
        }
      }
      
      // Check if lowercase version needs to be added as alias
      const needsLowercaseAlias = code !== lowercaseCode && !aliases.map(a => a.toLowerCase()).includes(lowercaseCode);
      
      // Also add common variations
      const variations = [];
      
      // Add lowercase of code if different
      if (needsLowercaseAlias) {
        variations.push(lowercaseCode);
      }
      
      // Add specific common aliases based on code
      const commonAliases = {
        'GRILL': ['bbq', 'barbecue', 'barbeque', 'grill_bbq'],
        'DRYER': ['tumblr', 'tumbler', 'clothes_dryer'],
        'tumble_dryer': ['tumblr', 'tumbler', 'dryer'],
        'MICROWAVE': ['micro'],
        'WIFI': ['wi-fi', 'wireless', 'internet'],
        'AIR_CONDITIONING': ['ac', 'a/c', 'aircon', 'air_con'],
        'REFRIGERATOR': ['fridge', 'ref'],
        'TV': ['television', 'telly'],
        'POOL': ['swimming_pool'],
        'HOT_TUB': ['jacuzzi', 'spa', 'hot_tub'],
        'WASHER': ['washing_machine'],
        'washing_machine': ['washer'],
        'PARKING_INCLUDED': ['free_parking', 'parking'],
        'free_parking': ['parking', 'parking_included'],
        'HEATING': ['heater', 'heat'],
        'FIREPLACE': ['fire_place', 'fire'],
        'BALCONY': ['terrace'],
        'GARDEN': ['yard', 'backyard'],
        'KITCHEN': ['kitchenette'],
        'COFFEE_MAKER': ['coffee_machine', 'coffee'],
        'coffee_machine': ['coffee_maker', 'coffee'],
        'HAIR_DRYER': ['hairdryer', 'blow_dryer'],
        'SMOKE_DETECTOR': ['smoke_alarm'],
        'CO_DETECTOR': ['carbon_monoxide_detector', 'co_alarm'],
        'ELEVATOR': ['lift'],
        'SELF_CHECK_IN': ['self_checkin', 'keyless'],
        'self_check_in': ['self_checkin', 'keyless'],
        'pets_allowed': ['pet_friendly', 'dogs_allowed'],
        'CHILDREN_WELCOME': ['kids_welcome', 'family_friendly'],
        'DESK': ['workspace', 'work_desk'],
        'SAUNA': ['steam_room'],
        'GYM': ['fitness', 'workout_room'],
        'FITNESS_ROOM': ['gym', 'fitness_center']
      };
      
      if (commonAliases[code]) {
        for (const alias of commonAliases[code]) {
          if (!aliases.map(a => a.toLowerCase()).includes(alias.toLowerCase())) {
            variations.push(alias);
          }
        }
      }
      
      if (variations.length > 0) {
        // Merge with existing aliases
        const newAliases = [...new Set([...aliases, ...variations])];
        
        await pool.query(
          'UPDATE master_amenities SET aliases = $1 WHERE id = $2',
          [JSON.stringify(newAliases), amenity.id]
        );
        
        updated++;
        changes.push({
          code: code,
          added_aliases: variations,
          total_aliases: newAliases.length
        });
      } else {
        skipped++;
      }
    }
    
    console.log(`‚úÖ Normalized ${updated} amenities, skipped ${skipped}`);
    
    res.json({
      success: true,
      message: `Normalized ${updated} amenities with lowercase aliases`,
      updated,
      skipped,
      changes
    });
  } catch (error) {
    console.error('Normalize amenities error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get unmatched amenities (from partner integrations)
app.get('/api/admin/unmatched-amenities', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT ua.*, ma.amenity_name as suggested_name, ma.amenity_code as suggested_code
      FROM unmatched_amenities ua
      LEFT JOIN master_amenities ma ON ma.id = ua.suggested_match_id
      WHERE ua.mapped_to_id IS NULL
      ORDER BY ua.occurrence_count DESC, ua.last_seen DESC
      LIMIT 100
    `);
    
    res.json({ success: true, unmatched: result.rows });
  } catch (error) {
    // Table might not exist yet
    if (error.message.includes('does not exist')) {
      res.json({ success: true, unmatched: [], message: 'Run migrate-amenity-aliases first' });
    } else {
      res.status(500).json({ success: false, error: error.message });
    }
  }
});

// Manually map an unmatched amenity to a master amenity
app.post('/api/admin/map-amenity', async (req, res) => {
  try {
    const { unmatched_id, master_amenity_id, add_as_alias } = req.body;
    
    // Update the mapping
    await pool.query(`
      UPDATE unmatched_amenities 
      SET mapped_to_id = $1 
      WHERE id = $2
    `, [master_amenity_id, unmatched_id]);
    
    // Optionally add as alias for future auto-matching
    if (add_as_alias) {
      const unmatched = await pool.query('SELECT raw_name FROM unmatched_amenities WHERE id = $1', [unmatched_id]);
      if (unmatched.rows.length > 0) {
        await pool.query(`
          UPDATE master_amenities 
          SET aliases = COALESCE(aliases, '[]'::jsonb) || $1::jsonb
          WHERE id = $2
        `, [JSON.stringify([unmatched.rows[0].raw_name.toLowerCase()]), master_amenity_id]);
      }
    }
    
    res.json({ success: true, message: 'Amenity mapped successfully' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get master amenities list (for mapping dropdown)
app.get('/api/admin/master-amenities', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, amenity_code, amenity_name, category, icon, aliases
      FROM master_amenities 
      WHERE is_active = true
      ORDER BY category, amenity_code
    `);
    
    res.json({ success: true, amenities: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// ========================================
// CONTENT MANAGEMENT ENDPOINTS
// ========================================

// Get property content
app.get('/api/admin/content/property/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      `SELECT 
        CASE 
          WHEN jsonb_typeof(description) = 'object' THEN description->>'en'
          ELSE description::text
        END as description,
        location_description 
      FROM properties WHERE id = $1`,
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    res.json({ success: true, content: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Save property content
app.put('/api/admin/content/property/:id', async (req, res) => {
  try {
    const { id } = req.params;
    let { description, location_description } = req.body;
    
    // Convert description to JSONB format
    const descriptionJson = JSON.stringify({ en: description || '' });
    
    await pool.query(`
      UPDATE properties 
      SET description = $1::jsonb, 
          location_description = $2, 
          updated_at = NOW() 
      WHERE id = $3
    `, [descriptionJson, location_description || '', id]);
    
    res.json({ success: true, message: 'Property content saved' });
  } catch (error) {
    console.error('Save property content error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Get room content
app.get('/api/admin/content/room/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(`
      SELECT 
        CASE 
          WHEN short_description IS NULL THEN NULL
          WHEN jsonb_typeof(short_description::jsonb) = 'object' THEN short_description::jsonb->>'en'
          ELSE short_description::text
        END as short_description,
        CASE 
          WHEN full_description IS NULL THEN NULL
          WHEN jsonb_typeof(full_description::jsonb) = 'object' THEN full_description::jsonb->>'en'
          ELSE full_description::text
        END as full_description
      FROM bookable_units WHERE id = $1`,
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    res.json({ success: true, content: result.rows[0] });
  } catch (error) {
    // If JSONB parsing fails, try simple select
    try {
      const result = await pool.query(
        'SELECT short_description, full_description FROM bookable_units WHERE id = $1',
        [id]
      );
      res.json({ success: true, content: result.rows[0] || {} });
    } catch (e) {
      res.json({ success: false, error: error.message });
    }
  }
});

// Save room content
app.put('/api/admin/content/room/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { short_description, full_description } = req.body;
    
    // Store as JSON string - works for both TEXT and JSONB columns
    const shortVal = JSON.stringify({ en: short_description || '' });
    const fullVal = JSON.stringify({ en: full_description || '' });
    
    await pool.query(`
      UPDATE bookable_units 
      SET short_description = $1, 
          full_description = $2, 
          updated_at = NOW() 
      WHERE id = $3`,
      [shortVal, fullVal, id]
    );
    
    res.json({ success: true, message: 'Room content saved' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get policies content
app.get('/api/admin/content/policies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(`
      SELECT 
        CASE 
          WHEN house_rules IS NULL THEN NULL
          WHEN jsonb_typeof(house_rules::jsonb) = 'object' THEN house_rules::jsonb->>'en'
          ELSE house_rules::text
        END as house_rules,
        CASE 
          WHEN cancellation_policy IS NULL THEN NULL
          WHEN jsonb_typeof(cancellation_policy::jsonb) = 'object' THEN cancellation_policy::jsonb->>'en'
          ELSE cancellation_policy::text
        END as cancellation_policy,
        CASE 
          WHEN terms_conditions IS NULL THEN NULL
          WHEN jsonb_typeof(terms_conditions::jsonb) = 'object' THEN terms_conditions::jsonb->>'en'
          ELSE terms_conditions::text
        END as terms_conditions
      FROM properties WHERE id = $1`,
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    res.json({ success: true, content: result.rows[0] });
  } catch (error) {
    // If JSONB parsing fails, try simple select
    try {
      const result = await pool.query(
        'SELECT house_rules, cancellation_policy, terms_conditions FROM properties WHERE id = $1',
        [id]
      );
      res.json({ success: true, content: result.rows[0] || {} });
    } catch (e) {
      res.json({ success: false, error: error.message });
    }
  }
});

// Save policies content
app.put('/api/admin/content/policies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { house_rules, cancellation_policy, terms_conditions } = req.body;
    
    // Try as JSONB first
    try {
      await pool.query(`
        UPDATE properties 
        SET house_rules = $1::jsonb, 
            cancellation_policy = $2::jsonb, 
            terms_conditions = $3::jsonb, 
            updated_at = NOW() 
        WHERE id = $4`,
        [
          JSON.stringify({ en: house_rules || '' }), 
          JSON.stringify({ en: cancellation_policy || '' }), 
          JSON.stringify({ en: terms_conditions || '' }), 
          id
        ]
      );
    } catch (e) {
      // If JSONB fails, try as TEXT
      await pool.query(`
        UPDATE properties 
        SET house_rules = $1, 
            cancellation_policy = $2, 
            terms_conditions = $3, 
            updated_at = NOW() 
        WHERE id = $4`,
        [house_rules || '', cancellation_policy || '', terms_conditions || '', id]
      );
    }
    
    res.json({ success: true, message: 'Policies saved' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// ========================================
// AVAILABILITY & PRICING ENDPOINTS
// ========================================

// Get availability for a room (PUBLIC API)
app.get('/api/availability/:roomId', async (req, res) => {
  try {
    const { roomId } = req.params;
    const { from, to } = req.query;
    
    if (!from || !to) {
      return res.json({ success: false, error: 'from and to dates required' });
    }
    
    // Get room info including property currency
    const roomInfo = await pool.query(`
      SELECT bu.id, bu.name, bu.property_id, p.currency, p.country
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [roomId]);
    
    const currency = roomInfo.rows[0]?.currency || 'GBP';
    const currencySymbol = getCurrencySymbol(currency);
    
    // Get availability data - include standard_price and min_stay fields if they exist
    let availability;
    try {
      availability = await pool.query(`
        SELECT 
          date,
          cm_price,
          standard_price,
          direct_price,
          direct_discount_percent,
          is_available,
          is_blocked,
          min_stay,
          cm_min_stay,
          min_stay_override,
          source,
          notes
        FROM room_availability
        WHERE room_id = $1 
          AND date >= $2 
          AND date <= $3
        ORDER BY date
      `, [roomId, from, to]);
    } catch (e) {
      // Fallback if new columns don't exist
      availability = await pool.query(`
        SELECT 
          date,
          cm_price,
          cm_price as standard_price,
          direct_price,
          direct_discount_percent,
          is_available,
          is_blocked,
          min_stay,
          min_stay as cm_min_stay,
          NULL as min_stay_override,
          source,
          notes
        FROM room_availability
        WHERE room_id = $1 
          AND date >= $2 
          AND date <= $3
        ORDER BY date
      `, [roomId, from, to]);
    }
    
    // Build availability map
    const availMap = {};
    availability.rows.forEach(a => {
      const dateStr = a.date.toISOString().split('T')[0];
      // Calculate effective direct price
      let effectiveDirectPrice = a.direct_price;
      if (!effectiveDirectPrice && a.cm_price && a.direct_discount_percent) {
        effectiveDirectPrice = a.cm_price * (1 - a.direct_discount_percent / 100);
      }
      
      availMap[dateStr] = {
        date: dateStr,
        cm_price: a.cm_price,
        standard_price: a.standard_price || a.cm_price, // Use saved standard_price, fallback to cm_price
        direct_price: effectiveDirectPrice || a.cm_price,
        direct_discount_percent: a.direct_discount_percent,
        is_available: a.is_available,
        is_blocked: a.is_blocked,
        min_stay: a.min_stay,
        cm_min_stay: a.cm_min_stay,
        min_stay_override: a.min_stay_override,
        effective_min_stay: a.min_stay_override || a.cm_min_stay || a.min_stay || 1,
        source: a.source
      };
    });
    
    // Try to get bookings - but don't fail if table structure is different
    try {
      // First check what columns exist in bookings table
      const columnsResult = await pool.query(`
        SELECT column_name FROM information_schema.columns 
        WHERE table_name = 'bookings'
      `);
      
      const allCols = columnsResult.rows.map(r => r.column_name);
      
      // Find check-in column
      let checkInCol = allCols.find(c => c === 'check_in') ||
                       allCols.find(c => c === 'check_in_date') ||
                       allCols.find(c => c === 'checkin') ||
                       allCols.find(c => c === 'arrival_date') ||
                       allCols.find(c => c === 'start_date');
      
      // Find check-out column                 
      let checkOutCol = allCols.find(c => c === 'check_out') ||
                        allCols.find(c => c === 'check_out_date') ||
                        allCols.find(c => c === 'checkout') ||
                        allCols.find(c => c === 'departure_date') ||
                        allCols.find(c => c === 'end_date');
      
      // Find room ID column
      let roomIdCol = allCols.find(c => c === 'room_id') ||
                      allCols.find(c => c === 'bookable_unit_id') ||
                      allCols.find(c => c === 'unit_id');
      
      if (!checkInCol || !checkOutCol) {
        throw new Error('Booking columns not found');
      }
      
      if (!roomIdCol) {
        throw new Error('Room ID column not found');
      }
      
      const bookings = await pool.query(`
        SELECT 
          id as booking_id,
          "${checkInCol}" as check_in,
          "${checkOutCol}" as check_out,
          COALESCE(guest_first_name, '') || ' ' || COALESCE(guest_last_name, '') as guest_name,
          status
        FROM bookings
        WHERE "${roomIdCol}" = $1 
          AND status NOT IN ('cancelled', 'rejected')
          AND "${checkInCol}" <= $3
          AND "${checkOutCol}" >= $2
      `, [roomId, from, to]);
      
      // Mark booked dates
      bookings.rows.forEach(b => {
        const checkIn = new Date(b.check_in);
        const checkOut = new Date(b.check_out);
        
        for (let d = new Date(checkIn); d < checkOut; d.setDate(d.getDate() + 1)) {
          const dateStr = d.toISOString().split('T')[0];
          if (!availMap[dateStr]) {
            availMap[dateStr] = { date: dateStr };
          }
          availMap[dateStr].is_booked = true;
          availMap[dateStr].guest_name = b.guest_name;
          availMap[dateStr].booking_id = b.booking_id;
        }
      });
    } catch (bookingErr) {
      console.log('Bookings query skipped:', bookingErr.message);
      // Continue without bookings data
    }
    
    // Convert to array and fill missing dates
    const result = [];
    const startDate = new Date(from);
    const endDate = new Date(to);
    
    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      result.push(availMap[dateStr] || {
        date: dateStr,
        is_available: true,
        is_booked: false,
        is_blocked: false
      });
    }
    
    res.json({ success: true, availability: result, currency, currency_symbol: currencySymbol });
  } catch (error) {
    console.error('Availability error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check Beds24 room mappings
app.get('/api/admin/debug/beds24-rooms', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        bu.id as gas_room_id,
        bu.name as room_name,
        bu.beds24_room_id,
        p.name as property_name,
        p.beds24_property_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      ORDER BY p.name, bu.name
    `);
    
    res.json({
      success: true,
      rooms: result.rows,
      summary: {
        total_rooms: result.rows.length,
        linked_to_beds24: result.rows.filter(r => r.beds24_room_id).length
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check rooms and their Beds24 links
app.get('/api/admin/debug/rooms-beds24', async (req, res) => {
  try {
    const rooms = await pool.query(`
      SELECT bu.id, bu.name, bu.beds24_room_id, bu.property_id, p.name as property_name, p.beds24_property_id
      FROM bookable_units bu
      LEFT JOIN properties p ON bu.property_id = p.id
      ORDER BY bu.id
    `);
    
    res.json({
      success: true,
      count: rooms.rows.length,
      rooms: rooms.rows
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Test Beds24 calendar API directly
app.get('/api/admin/debug/beds24-calendar/:beds24RoomId', async (req, res) => {
  try {
    const { beds24RoomId } = req.params;
    const { propertyId } = req.query;
    
    // Get access token using helper function
    let accessToken;
    try {
      accessToken = await getBeds24AccessToken(pool);
    } catch (tokenError) {
      return res.json({ success: false, error: tokenError.message });
    }
    
    // Calculate date range
    const today = new Date();
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + 30);
    
    const fromDate = today.toISOString().split('T')[0];
    const toDate = endDate.toISOString().split('T')[0];
    
    // Try multiple API variations
    const results = {};
    
    // Try 1: /inventory/rooms/calendar with roomId
    try {
      const resp1 = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
        headers: { 'token': accessToken },
        params: { roomId: beds24RoomId, from: fromDate, to: toDate }
      });
      results.rooms_calendar = resp1.data;
    } catch (e) {
      results.rooms_calendar_error = e.response?.data || e.message;
    }
    
    // Try 2: /inventory/rooms/prices (fixed prices)
    try {
      const resp2 = await axios.get('https://beds24.com/api/v2/inventory/rooms/prices', {
        headers: { 'token': accessToken },
        params: { roomId: beds24RoomId }
      });
      results.rooms_prices = resp2.data;
    } catch (e) {
      results.rooms_prices_error = e.response?.data || e.message;
    }
    
    // Try 3: /inventory/rooms/offers (calculated prices for dates)
    // Get offers for next 30 days, one day at a time
    try {
      const offersData = [];
      // Test first 7 days to see the data structure
      for (let i = 0; i < 7; i++) {
        const arrivalDate = new Date(today);
        arrivalDate.setDate(arrivalDate.getDate() + i);
        const departDate = new Date(arrivalDate);
        departDate.setDate(departDate.getDate() + 1);
        
        const arrival = arrivalDate.toISOString().split('T')[0];
        const depart = departDate.toISOString().split('T')[0];
        
        const resp3 = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
          headers: { 'token': accessToken },
          params: { 
            roomId: beds24RoomId, 
            arrival: arrival,
            departure: departDate.toISOString().split('T')[0],
            numAdults: 2
          }
        });
        
        if (resp3.data.data && resp3.data.data.length > 0) {
          offersData.push({
            date: arrival,
            offers: resp3.data.data[0].offers
          });
        }
      }
      results.rooms_offers = { success: true, data: offersData };
    } catch (e) {
      results.rooms_offers_error = e.response?.data || e.message;
    }
    
    // Try 4: /properties with includeAllRooms to get rackRate
    try {
      const resp4 = await axios.get('https://beds24.com/api/v2/properties', {
        headers: { 'token': accessToken },
        params: { id: propertyId || 16276, includeAllRooms: true }
      });
      // Extract just room pricing info
      const rooms = resp4.data.data?.[0]?.roomTypes || [];
      results.room_rack_rates = rooms.map(r => ({
        roomId: r.id,
        name: r.name,
        rackRate: r.rackRate,
        minPrice: r.minPrice,
        cleaningFee: r.cleaningFee,
        taxPercentage: r.taxPercentage
      }));
    } catch (e) {
      results.room_rack_rates_error = e.response?.data || e.message;
    }
    
    res.json({
      success: true,
      roomId: beds24RoomId,
      propertyId: propertyId || 16276,
      dateRange: { from: fromDate, to: toDate },
      results
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Sync availability from Channel Manager (Beds24)
app.post('/api/admin/sync-availability/:roomId', async (req, res) => {
  const client = await pool.connect();
  try {
    const { roomId } = req.params;
    
    // Get the room's Beds24 ID
    const room = await client.query(`
      SELECT bu.id, bu.beds24_room_id, bu.property_id, p.beds24_property_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [roomId]);
    
    if (room.rows.length === 0) {
      client.release();
      return res.json({ success: false, error: 'Room not found' });
    }
    
    const beds24RoomId = room.rows[0].beds24_room_id;
    
    if (!beds24RoomId) {
      client.release();
      return res.json({ success: false, error: 'Room not linked to Beds24 (no beds24_room_id)' });
    }
    
    // Get access token using helper function
    let accessToken;
    try {
      accessToken = await getBeds24AccessToken(pool);
    } catch (tokenError) {
      client.release();
      return res.json({ success: false, error: tokenError.message });
    }
    
    // Calculate date range (today + 30 days to reduce API calls)
    const today = new Date();
    const numDays = 30;
    
    console.log(`Syncing Beds24 room ${beds24RoomId} for ${numDays} days using offers API`);
    
    await client.query('BEGIN');
    
    let daysSynced = 0;
    let daysWithPrice = 0;
    let daysBlocked = 0;
    
    // Call offers API for each day
    for (let i = 0; i < numDays; i++) {
      const arrivalDate = new Date(today);
      arrivalDate.setDate(arrivalDate.getDate() + i);
      const departDate = new Date(arrivalDate);
      departDate.setDate(departDate.getDate() + 1);
      
      const arrival = arrivalDate.toISOString().split('T')[0];
      const departure = departDate.toISOString().split('T')[0];
      
      try {
        const offerResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
          headers: { 'token': accessToken },
          params: { 
            roomId: beds24RoomId, 
            arrival: arrival,
            departure: departure,
            numAdults: 2
          }
        });
        
        const offerData = offerResponse.data;
        
        // Find offer 1 (Standard Price) from the response
        let price = null;
        let unitsAvailable = 0;
        
        if (offerData.data && offerData.data.length > 0) {
          const roomOffers = offerData.data[0];
          if (roomOffers.offers && roomOffers.offers.length > 0) {
            // Get offer 1 (Standard Price) or first available offer
            const offer1 = roomOffers.offers.find(o => o.offerId === 1) || roomOffers.offers[0];
            price = offer1.price;
            unitsAvailable = offer1.unitsAvailable || 0;
            daysWithPrice++;
          }
        }
        
        const isAvailable = unitsAvailable > 0;
        const isBlocked = !isAvailable && price === null;
        
        if (isBlocked) daysBlocked++;
        
        await client.query(`
          INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, source)
          VALUES ($1, $2, $3, $4, $5, 'beds24')
          ON CONFLICT (room_id, date) 
          DO UPDATE SET 
            cm_price = COALESCE($3, room_availability.cm_price),
            is_available = $4,
            is_blocked = $5,
            source = 'beds24',
            updated_at = NOW()
        `, [roomId, arrival, price, isAvailable, isBlocked]);
        
        daysSynced++;
        
      } catch (apiError) {
        // If rate limited, wait longer and retry once
        if (apiError.response?.status === 429) {
          console.log('Rate limited, waiting 5 seconds...');
          await new Promise(resolve => setTimeout(resolve, 5000));
          // Don't retry, just skip this day
        }
        console.error(`Error fetching offers for ${arrival}:`, apiError.response?.data || apiError.message);
        // Continue with next day even if one fails
      }
      
      // Delay between EVERY call to avoid rate limiting (500ms = ~2 calls/sec)
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    await client.query('COMMIT');
    client.release();
    
    console.log(`Sync complete: ${daysSynced} days, ${daysWithPrice} with prices, ${daysBlocked} blocked`);
    
    res.json({ 
      success: true, 
      roomId,
      beds24RoomId,
      daysSynced,
      daysWithPrice,
      daysBlocked,
      message: `Synced ${daysSynced} days from Beds24 (${daysWithPrice} with prices, ${daysBlocked} blocked)`
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    client.release();
    console.error('Sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// QUICK sync ALL rooms - 30 days only (faster, won't timeout)
app.post('/api/admin/sync-all-availability-quick', async (req, res) => {
  const client = await pool.connect();
  try {
    // Get all rooms with beds24_room_id
    const roomsResult = await client.query(`
      SELECT bu.id, bu.name, bu.beds24_room_id 
      FROM bookable_units bu 
      WHERE bu.beds24_room_id IS NOT NULL
    `);
    
    if (roomsResult.rows.length === 0) {
      client.release();
      return res.json({ success: false, error: 'No rooms linked to Beds24' });
    }
    
    const rooms = roomsResult.rows;
    const beds24RoomIds = rooms.map(r => r.beds24_room_id);
    
    // Create a map of beds24_room_id -> our room id
    const roomIdMap = {};
    rooms.forEach(r => {
      roomIdMap[r.beds24_room_id] = r.id;
    });
    
    // Get access token
    let accessToken;
    try {
      accessToken = await getBeds24AccessToken(pool);
    } catch (tokenError) {
      client.release();
      return res.json({ success: false, error: tokenError.message });
    }
    
    const today = new Date();
    const numDays = 30; // Just 30 days for quick sync
    
    console.log(`Quick sync: ${rooms.length} rooms for ${numDays} days`);
    console.log('Beds24 room IDs:', beds24RoomIds);
    
    await client.query('BEGIN');
    
    let totalDaysSynced = 0;
    let totalPricesFound = 0;
    let apiCallsMade = 0;
    
    // Fetch ALL rooms for each day in ONE API call
    for (let i = 0; i < numDays; i++) {
      const arrivalDate = new Date(today);
      arrivalDate.setDate(arrivalDate.getDate() + i);
      const departDate = new Date(arrivalDate);
      departDate.setDate(departDate.getDate() + 1);
      
      const arrival = arrivalDate.toISOString().split('T')[0];
      const departure = departDate.toISOString().split('T')[0];
      
      try {
        const offerResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
          headers: { 'token': accessToken },
          params: { 
            roomId: beds24RoomIds,
            arrival: arrival,
            departure: departure,
            numAdults: 2
          },
          paramsSerializer: params => {
            const parts = [];
            for (const key in params) {
              const value = params[key];
              if (Array.isArray(value)) {
                value.forEach(v => parts.push(`${key}=${v}`));
              } else {
                parts.push(`${key}=${value}`);
              }
            }
            return parts.join('&');
          }
        });
        
        apiCallsMade++;
        const offerData = offerResponse.data;
        
        // Process each room's offers
        if (offerData.data && offerData.data.length > 0) {
          for (const roomData of offerData.data) {
            const ourRoomId = roomIdMap[roomData.roomId];
            if (!ourRoomId) continue;
            
            let price = null;
            let unitsAvailable = 0;
            
            if (roomData.offers && roomData.offers.length > 0) {
              const offer1 = roomData.offers.find(o => o.offerId === 1) || roomData.offers[0];
              price = offer1.price;
              unitsAvailable = offer1.unitsAvailable || 0;
              totalPricesFound++;
            }
            
            const isAvailable = unitsAvailable > 0;
            const isBlocked = !isAvailable && price === null;
            
            await client.query(`
              INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, source)
              VALUES ($1, $2, $3, $4, $5, 'beds24')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET 
                cm_price = COALESCE($3, room_availability.cm_price),
                is_available = $4,
                is_blocked = $5,
                source = 'beds24',
                updated_at = NOW()
            `, [ourRoomId, arrival, price, isAvailable, isBlocked]);
            
            totalDaysSynced++;
          }
        }
        
      } catch (apiError) {
        if (apiError.response?.status === 429) {
          console.log(`Rate limited on day ${i}, waiting 5 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 5000));
          i--; // Retry this day
          continue;
        }
        console.error(`Error fetching offers for ${arrival}:`, apiError.response?.data || apiError.message);
      }
      
      // Small delay between calls
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    await client.query('COMMIT');
    client.release();
    
    console.log(`Quick sync complete: ${apiCallsMade} API calls, ${totalDaysSynced} records, ${totalPricesFound} prices`);
    
    res.json({ 
      success: true, 
      roomsCount: rooms.length,
      daysRequested: numDays,
      apiCallsMade,
      totalDaysSynced,
      totalPricesFound,
      message: `Synced ${rooms.length} rooms for ${numDays} days`
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    client.release();
    console.error('Quick sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// BULK sync ALL rooms - fetches all rooms in one API call per day (much faster)
app.post('/api/admin/sync-all-availability-bulk', async (req, res) => {
  const client = await pool.connect();
  try {
    // Get all rooms with beds24_room_id
    const roomsResult = await client.query(`
      SELECT bu.id, bu.name, bu.beds24_room_id 
      FROM bookable_units bu 
      WHERE bu.beds24_room_id IS NOT NULL
    `);
    
    if (roomsResult.rows.length === 0) {
      client.release();
      return res.json({ success: false, error: 'No rooms linked to Beds24' });
    }
    
    const rooms = roomsResult.rows;
    const beds24RoomIds = rooms.map(r => r.beds24_room_id);
    
    // Create a map of beds24_room_id -> our room id
    const roomIdMap = {};
    rooms.forEach(r => {
      roomIdMap[r.beds24_room_id] = r.id;
    });
    
    // Get access token
    let accessToken;
    try {
      accessToken = await getBeds24AccessToken(pool);
    } catch (tokenError) {
      client.release();
      return res.json({ success: false, error: tokenError.message });
    }
    
    const today = new Date();
    const numDays = 365; // Full year
    
    console.log(`Bulk syncing ${rooms.length} rooms for ${numDays} days`);
    
    await client.query('BEGIN');
    
    let totalDaysSynced = 0;
    let totalPricesFound = 0;
    let apiCallsMade = 0;
    
    console.log('Beds24 room IDs to sync:', beds24RoomIds);
    
    // Fetch ALL rooms for each day in ONE API call
    for (let i = 0; i < numDays; i++) {
      const arrivalDate = new Date(today);
      arrivalDate.setDate(arrivalDate.getDate() + i);
      const departDate = new Date(arrivalDate);
      departDate.setDate(departDate.getDate() + 1);
      
      const arrival = arrivalDate.toISOString().split('T')[0];
      const departure = departDate.toISOString().split('T')[0];
      
      try {
        // Pass ALL room IDs as array - axios will serialize properly
        const offerResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
          headers: { 'token': accessToken },
          params: { 
            roomId: beds24RoomIds,  // Pass as array, let axios handle it
            arrival: arrival,
            departure: departure,
            numAdults: 2
          },
          paramsSerializer: params => {
            // Custom serializer to handle array params correctly for Beds24
            const parts = [];
            for (const key in params) {
              const value = params[key];
              if (Array.isArray(value)) {
                value.forEach(v => parts.push(`${key}=${v}`));
              } else {
                parts.push(`${key}=${value}`);
              }
            }
            return parts.join('&');
          }
        });
        
        apiCallsMade++;
        const offerData = offerResponse.data;
        
        if (i === 0) {
          console.log('First API response:', JSON.stringify(offerData).substring(0, 500));
        }
        
        // Process each room's offers
        if (offerData.data && offerData.data.length > 0) {
          for (const roomData of offerData.data) {
            const ourRoomId = roomIdMap[roomData.roomId];
            if (!ourRoomId) continue;
            
            let price = null;
            let unitsAvailable = 0;
            
            if (roomData.offers && roomData.offers.length > 0) {
              const offer1 = roomData.offers.find(o => o.offerId === 1) || roomData.offers[0];
              price = offer1.price;
              unitsAvailable = offer1.unitsAvailable || 0;
              totalPricesFound++;
            }
            
            const isAvailable = unitsAvailable > 0;
            const isBlocked = !isAvailable && price === null;
            
            await client.query(`
              INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, source)
              VALUES ($1, $2, $3, $4, $5, 'beds24')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET 
                cm_price = COALESCE($3, room_availability.cm_price),
                is_available = $4,
                is_blocked = $5,
                source = 'beds24',
                updated_at = NOW()
            `, [ourRoomId, arrival, price, isAvailable, isBlocked]);
            
            totalDaysSynced++;
          }
        }
        
      } catch (apiError) {
        if (apiError.response?.status === 429) {
          console.log(`Rate limited on day ${i}, waiting 10 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 10000));
          i--; // Retry this day
          continue;
        }
        console.error(`Error fetching offers for ${arrival}:`, apiError.response?.data || apiError.message);
      }
      
      // Progress log every 30 days
      if (i > 0 && i % 30 === 0) {
        console.log(`Progress: ${i}/${numDays} days, ${apiCallsMade} API calls, ${totalDaysSynced} records`);
      }
      
      // Delay between calls (300ms = ~3 calls/sec)
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    await client.query('COMMIT');
    client.release();
    
    console.log(`Bulk sync complete: ${apiCallsMade} API calls, ${totalDaysSynced} day/room records, ${totalPricesFound} with prices`);
    
    res.json({ 
      success: true, 
      roomsCount: rooms.length,
      daysRequested: numDays,
      apiCallsMade,
      totalDaysSynced,
      totalPricesFound,
      message: `Synced ${rooms.length} rooms for ${numDays} days (${apiCallsMade} API calls)`
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    client.release();
    console.error('Bulk sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Sync ALL rooms from Beds24 (calls the single room sync for each room)
app.post('/api/admin/sync-all-availability', async (req, res) => {
  try {
    // Get all rooms with beds24_room_id
    const rooms = await pool.query(`
      SELECT bu.id, bu.name, bu.beds24_room_id 
      FROM bookable_units bu 
      WHERE bu.beds24_room_id IS NOT NULL
    `);
    
    if (rooms.rows.length === 0) {
      return res.json({ success: false, error: 'No rooms linked to Beds24' });
    }
    
    console.log(`Starting sync for ${rooms.rows.length} rooms`);
    
    const results = [];
    
    for (const room of rooms.rows) {
      try {
        // Call the single room sync endpoint internally
        const syncResult = await new Promise(async (resolve) => {
          const mockReq = { params: { roomId: room.id } };
          const mockRes = {
            json: (data) => resolve(data)
          };
          
          // We need to call the sync logic directly, not the endpoint
          // For simplicity, we'll make an internal HTTP call
          const axios = require('axios');
          const baseUrl = process.env.BASE_URL || `http://localhost:${process.env.PORT || 3000}`;
          
          try {
            const response = await axios.post(`${baseUrl}/api/admin/sync-availability/${room.id}`);
            resolve(response.data);
          } catch (err) {
            resolve({ success: false, error: err.message });
          }
        });
        
        results.push({
          roomId: room.id,
          roomName: room.name,
          beds24RoomId: room.beds24_room_id,
          ...syncResult
        });
        
        // Small delay between rooms
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (err) {
        results.push({
          roomId: room.id,
          roomName: room.name,
          success: false,
          error: err.message
        });
      }
    }
    
    const successCount = results.filter(r => r.success).length;
    
    res.json({
      success: true,
      totalRooms: rooms.rows.length,
      successfulSyncs: successCount,
      failedSyncs: rooms.rows.length - successCount,
      results
    });
    
  } catch (error) {
    console.error('Sync all error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Set availability for date range (ADMIN)
app.post('/api/admin/availability', async (req, res) => {
  const client = await pool.connect();
  try {
    const { room_id, from_date, to_date, status, price, discount_percent, standard_price } = req.body;
    
    await client.query('BEGIN');
    
    const startDate = new Date(from_date);
    const endDate = new Date(to_date);
    let daysUpdated = 0;
    
    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      
      if (standard_price !== undefined) {
        // Update standard price
        await client.query(`
          INSERT INTO room_availability (room_id, date, standard_price, is_available, is_blocked)
          VALUES ($1, $2, $3, true, false)
          ON CONFLICT (room_id, date) 
          DO UPDATE SET 
            standard_price = $3,
            updated_at = NOW()
        `, [room_id, dateStr, standard_price || null]);
      } else if (discount_percent) {
        // Apply percentage discount
        await client.query(`
          INSERT INTO room_availability (room_id, date, direct_discount_percent, is_available, is_blocked)
          VALUES ($1, $2, $3, $4, $5)
          ON CONFLICT (room_id, date) 
          DO UPDATE SET 
            direct_discount_percent = $3,
            direct_price = NULL,
            is_available = $4,
            is_blocked = $5,
            updated_at = NOW()
        `, [room_id, dateStr, discount_percent, status === 'available', status === 'blocked']);
      } else {
        // Set fixed direct price
        await client.query(`
          INSERT INTO room_availability (room_id, date, direct_price, is_available, is_blocked)
          VALUES ($1, $2, $3, $4, $5)
          ON CONFLICT (room_id, date) 
          DO UPDATE SET 
            direct_price = COALESCE($3, room_availability.direct_price),
            direct_discount_percent = NULL,
            is_available = $4,
            is_blocked = $5,
            updated_at = NOW()
        `, [room_id, dateStr, price || null, status === 'available', status === 'blocked']);
      }
      
      daysUpdated++;
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true, days_updated: daysUpdated });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Set availability error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Migration: Create room_availability table
app.post('/api/admin/migrate-availability', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    await client.query(`
      CREATE TABLE IF NOT EXISTS room_availability (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        date DATE NOT NULL,
        cm_price DECIMAL(10,2),
        direct_price DECIMAL(10,2),
        direct_discount_percent INTEGER,
        is_available BOOLEAN DEFAULT true,
        is_blocked BOOLEAN DEFAULT false,
        min_stay INTEGER DEFAULT 1,
        source VARCHAR(20) DEFAULT 'manual',
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(room_id, date)
      )
    `);
    
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_avail_room ON room_availability(room_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_avail_date ON room_availability(date)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_avail_room_date ON room_availability(room_id, date)');
    
    // Add new columns if table already exists
    try {
      await client.query('ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS cm_price DECIMAL(10,2)');
      await client.query('ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS direct_price DECIMAL(10,2)');
      await client.query('ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS direct_discount_percent INTEGER');
      await client.query('ALTER TABLE room_availability ADD COLUMN IF NOT EXISTS source VARCHAR(20) DEFAULT \'manual\'');
      // Extend source column to VARCHAR(50) if it's too short
      await client.query('ALTER TABLE room_availability ALTER COLUMN source TYPE VARCHAR(50)').catch(() => {});
      // Migrate old price column to cm_price
      await client.query('UPDATE room_availability SET cm_price = price WHERE cm_price IS NULL AND price IS NOT NULL');
    } catch (e) {
      console.log('Column migration note:', e.message);
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'room_availability table updated with cm_price and direct_price' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Migration: Add content columns to properties and rooms
app.post('/api/admin/migrate-content-columns', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // First, check if description is JSONB and convert to TEXT
    try {
      // Try to alter the column type - this will fail if it's already TEXT
      await client.query(`
        ALTER TABLE properties 
        ALTER COLUMN description TYPE TEXT 
        USING CASE 
          WHEN description IS NULL THEN NULL
          WHEN description::text LIKE '{%' THEN description::jsonb->>'en'
          ELSE description::text
        END
      `);
      console.log('   ‚úì Converted description to TEXT');
    } catch (e) {
      console.log('   - description column OK or conversion not needed');
    }
    
    // Add columns to properties table
    const propertyColumns = [
      'location_description TEXT',
      'house_rules TEXT',
      'cancellation_policy TEXT',
      'terms_conditions TEXT'
    ];
    
    for (const col of propertyColumns) {
      const colName = col.split(' ')[0];
      try {
        await client.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS ${col}`);
        console.log(`   ‚úì Added ${colName} to properties`);
      } catch (e) {
        // Column might already exist
      }
    }
    
    // Add columns to bookable_units table
    const roomColumns = [
      'short_description TEXT',
      'full_description TEXT'
    ];
    
    for (const col of roomColumns) {
      const colName = col.split(' ')[0];
      try {
        await client.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS ${col}`);
        console.log(`   ‚úì Added ${colName} to bookable_units`);
      } catch (e) {
        // Column might already exist
      }
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Content columns added successfully',
      columns: {
        properties: ['description (converted)', ...propertyColumns],
        rooms: roomColumns
      }
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Get integrations/connections
app.get('/api/admin/channels', async (req, res) => {
  try {
    const connections = await pool.query(`
      SELECT 
        cc.*,
        cm.cm_name,
        cm.cm_code
      FROM channel_connections cc
      LEFT JOIN channel_managers cm ON cc.cm_id = cm.id
      ORDER BY cc.created_at DESC
    `);
    
    res.json({
      success: true,
      data: connections.rows
    });
  } catch (error) {
    console.error('Channels error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Migration 001: Create Master Amenities System
app.post('/api/admin/migrate-001-master-amenities', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    console.log('üîÑ Running Migration 001: Master Amenities System...');
    
    // Create master_amenities table
    await client.query(`
      CREATE TABLE IF NOT EXISTS master_amenities (
        id SERIAL PRIMARY KEY,
        amenity_code VARCHAR(100) UNIQUE NOT NULL,
        amenity_name JSONB NOT NULL,
        category VARCHAR(50) NOT NULL,
        icon VARCHAR(50),
        display_order INTEGER DEFAULT 0,
        is_system BOOLEAN DEFAULT true,
        created_by VARCHAR(20) DEFAULT 'system',
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created master_amenities table');
    
    // Create indexes
    await client.query('CREATE INDEX IF NOT EXISTS idx_master_amenities_category ON master_amenities(category)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_master_amenities_active ON master_amenities(is_active)');
    
    // Create property_amenity_selections table
    await client.query(`
      CREATE TABLE IF NOT EXISTS property_amenity_selections (
        id SERIAL PRIMARY KEY,
        property_id INTEGER NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
        amenity_id INTEGER NOT NULL REFERENCES master_amenities(id) ON DELETE CASCADE,
        display_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(property_id, amenity_id)
      )
    `);
    console.log('   ‚úì Created property_amenity_selections table');
    
    await client.query('CREATE INDEX IF NOT EXISTS idx_prop_amenity_sel_property ON property_amenity_selections(property_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_prop_amenity_sel_amenity ON property_amenity_selections(amenity_id)');
    
    // Create room_amenity_selections table
    await client.query(`
      CREATE TABLE IF NOT EXISTS room_amenity_selections (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        amenity_id INTEGER NOT NULL REFERENCES master_amenities(id) ON DELETE CASCADE,
        quantity INTEGER DEFAULT 1,
        display_order INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(room_id, amenity_id)
      )
    `);
    console.log('   ‚úì Created room_amenity_selections table');
    
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_amenity_sel_room ON room_amenity_selections(room_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_amenity_sel_amenity ON room_amenity_selections(amenity_id)');
    
    // Insert standard amenities (just a subset here, full list in SQL file)
    const amenities = [
      // BEDS
      ['bed_single', '{"en": "Single"}', 'beds', 'üõèÔ∏è', 1],
      ['bed_twin', '{"en": "Twin"}', 'beds', 'üõèÔ∏è', 2],
      ['bed_double', '{"en": "Double"}', 'beds', 'üõèÔ∏è', 3],
      ['bed_queen', '{"en": "Queen"}', 'beds', 'üõèÔ∏è', 4],
      ['bed_king', '{"en": "King"}', 'beds', 'üõèÔ∏è', 5],
      ['bed_super_king', '{"en": "Super King"}', 'beds', 'üõèÔ∏è', 6],
      ['bed_sofa_single', '{"en": "Sofa Bed (Single)"}', 'beds', 'üõãÔ∏è', 7],
      ['bed_sofa_double', '{"en": "Sofa Bed (Double)"}', 'beds', 'üõãÔ∏è', 8],
      ['bed_bunk', '{"en": "Bunk Bed"}', 'beds', 'üõèÔ∏è', 9],
      ['bed_cot', '{"en": "Cot / Crib"}', 'beds', 'üë∂', 10],
      ['bed_futon', '{"en": "Futon"}', 'beds', 'üõèÔ∏è', 11],
      // BATHROOMS
      ['bathroom_full', '{"en": "Full Bathroom"}', 'bathrooms', 'üöø', 1],
      ['bathroom_shower_only', '{"en": "Shower Only"}', 'bathrooms', 'üöø', 2],
      ['bathroom_bath_only', '{"en": "Bath Only"}', 'bathrooms', 'üõÅ', 3],
      ['bathroom_shower_bath_combo', '{"en": "Shower‚ÄìBath Combo"}', 'bathrooms', 'üöø', 4],
      ['bathroom_private_ensuite', '{"en": "Private Ensuite"}', 'bathrooms', 'üö™', 5],
      ['bathroom_shared', '{"en": "Shared Bathroom"}', 'bathrooms', 'üöø', 6],
      ['bathroom_private_external', '{"en": "Private External Bathroom"}', 'bathrooms', 'üö™', 7],
      ['bathroom_jack_and_jill', '{"en": "Jack & Jill Bathroom"}', 'bathrooms', 'üö™', 8],
      ['bathroom_accessible', '{"en": "Accessible Bathroom"}', 'bathrooms', '‚ôø', 9],
      ['bathroom_wet_room', '{"en": "Wet Room"}', 'bathrooms', 'üöø', 10],
      ['bathroom_outdoor_shower', '{"en": "Outdoor Shower"}', 'bathrooms', 'üå≥', 11],
      ['bathroom_outdoor_bath', '{"en": "Outdoor Bath"}', 'bathrooms', 'üå≥', 12],
      ['bathroom_double_vanity', '{"en": "Double Vanity"}', 'bathrooms', 'üö∞', 13],
      // ESSENTIALS
      ['wifi', '{"en": "WiFi"}', 'essentials', 'üì∂', 1],
      ['air_conditioning', '{"en": "Air Conditioning"}', 'essentials', '‚ùÑÔ∏è', 2],
      ['heating', '{"en": "Heating"}', 'essentials', 'üî•', 3],
      // KITCHEN
      ['kitchen_full', '{"en": "Full Kitchen"}', 'kitchen', 'üç≥', 1],
      ['refrigerator', '{"en": "Refrigerator"}', 'kitchen', 'üßä', 2],
      ['microwave', '{"en": "Microwave"}', 'kitchen', 'üìª', 3],
      // PARKING
      ['free_parking', '{"en": "Free Parking"}', 'parking', 'üöó', 1],
      ['paid_parking', '{"en": "Paid Parking"}', 'parking', 'üöó', 2]
    ];
    
    let insertedCount = 0;
    for (const [code, name, category, icon, order] of amenities) {
      try {
        await client.query(`
          INSERT INTO master_amenities (amenity_code, amenity_name, category, icon, display_order, is_system)
          VALUES ($1, $2, $3, $4, $5, true)
          ON CONFLICT (amenity_code) DO NOTHING
        `, [code, name, category, icon, order]);
        insertedCount++;
      } catch (e) {
        // Ignore conflicts
      }
    }
    
    console.log('   ‚úì Inserted ' + insertedCount + ' standard amenities');
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Master amenities system created successfully',
      stats: {
        amenitiesCreated: insertedCount,
        tables: ['master_amenities', 'property_amenity_selections', 'room_amenity_selections']
      }
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Migration: Replace bed/bathroom amenities with clean GAS standards
app.post('/api/admin/migrate-clean-amenities', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    console.log('üßπ Cleaning up bed/bathroom amenities...');
    
    // Delete all bed amenities
    await client.query(`DELETE FROM bookable_unit_amenities WHERE category = 'beds' OR amenity_code LIKE 'bed%'`);
    console.log('   ‚úì Deleted old bed amenities');
    
    // Delete all bathroom amenities
    await client.query(`DELETE FROM bookable_unit_amenities WHERE category IN ('bathrooms', 'bathroom') OR amenity_code LIKE 'bath%'`);
    console.log('   ‚úì Deleted old bathroom amenities');
    
    // Get first room ID to add standards
    const firstRoom = await client.query('SELECT id FROM bookable_units LIMIT 1');
    if (firstRoom.rows.length === 0) {
      throw new Error('No rooms found - import a property first');
    }
    const roomId = firstRoom.rows[0].id;
    
    // Add standard bed types
    const bedTypes = [
      ['bed_single', 'Single', 1],
      ['bed_twin', 'Twin', 2],
      ['bed_double', 'Double', 3],
      ['bed_queen', 'Queen', 4],
      ['bed_king', 'King', 5],
      ['bed_super_king', 'Super King', 6],
      ['bed_sofa_single', 'Sofa Bed (Single)', 7],
      ['bed_sofa_double', 'Sofa Bed (Double)', 8],
      ['bed_bunk', 'Bunk Bed', 9],
      ['bed_cot', 'Cot / Crib', 10],
      ['bed_futon', 'Futon', 11]
    ];
    
    for (const [code, name, order] of bedTypes) {
      await client.query(`
        INSERT INTO bookable_unit_amenities (bookable_unit_id, amenity_code, amenity_name, category, display_order)
        VALUES ($1, $2, $3, 'beds', $4)
      `, [roomId, code, JSON.stringify({ en: name }), order]);
    }
    console.log('   ‚úì Added ' + bedTypes.length + ' standard bed types');
    
    // Add standard bathroom types
    const bathroomTypes = [
      ['bathroom_full', 'Full Bathroom', 1],
      ['bathroom_shower_only', 'Shower Only', 2],
      ['bathroom_bath_only', 'Bath Only', 3],
      ['bathroom_shower_bath_combo', 'Shower‚ÄìBath Combo', 4],
      ['bathroom_private_ensuite', 'Private Ensuite', 5],
      ['bathroom_shared', 'Shared Bathroom', 6],
      ['bathroom_private_external', 'Private External Bathroom', 7],
      ['bathroom_jack_and_jill', 'Jack & Jill Bathroom', 8],
      ['bathroom_accessible', 'Accessible Bathroom', 9],
      ['bathroom_wet_room', 'Wet Room', 10],
      ['bathroom_outdoor_shower', 'Outdoor Shower', 11],
      ['bathroom_outdoor_bath', 'Outdoor Bath', 12],
      ['bathroom_double_vanity', 'Double Vanity', 13]
    ];
    
    for (const [code, name, order] of bathroomTypes) {
      await client.query(`
        INSERT INTO bookable_unit_amenities (bookable_unit_id, amenity_code, amenity_name, category, display_order)
        VALUES ($1, $2, $3, 'bathrooms', $4)
      `, [roomId, code, JSON.stringify({ en: name }), order]);
    }
    console.log('   ‚úì Added ' + bathroomTypes.length + ' standard bathroom types');
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Bed and bathroom amenities replaced with clean GAS standards',
      stats: {
        beds: bedTypes.length,
        bathrooms: bathroomTypes.length
      }
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Migration: Add amenity aliases for intelligent matching
app.post('/api/admin/migrate-amenity-aliases', async (req, res) => {
  try {
    console.log('üîÑ Adding amenity aliases for intelligent matching...');
    
    // Add aliases column to master_amenities
    await pool.query(`
      ALTER TABLE master_amenities 
      ADD COLUMN IF NOT EXISTS aliases JSONB DEFAULT '[]'
    `);
    console.log('   ‚úì Added aliases column to master_amenities');
    
    // Add some default aliases for common amenities (using actual codes from database)
    const aliasUpdates = [
      { code: 'WIFI', aliases: ['wi-fi', 'wireless', 'internet', 'free wifi', 'free wi-fi', 'wifi'] },
      { code: 'INTERNET', aliases: ['broadband', 'web access'] },
      { code: 'free_parking', aliases: ['parking', 'free parking', 'car park', 'parking space'] },
      { code: 'PARKING_INCLUDED', aliases: ['parking included', 'complimentary parking'] },
      { code: 'GARAGE', aliases: ['garage parking', 'covered parking'] },
      { code: 'POOL', aliases: ['swimming pool', 'swimming', 'outdoor pool', 'pool'] },
      { code: 'POOL_INDOOR', aliases: ['indoor pool', 'inside pool'] },
      { code: 'POOL_HEATED', aliases: ['heated pool', 'warm pool'] },
      { code: 'AIR_CONDITIONING', aliases: ['air conditioning', 'air-conditioning', 'air con', 'a/c', 'climate control', 'ac', 'aircon'] },
      { code: 'KITCHEN', aliases: ['kitchenette', 'full kitchen', 'equipped kitchen', 'kitchen'] },
      { code: 'kitchen_full', aliases: ['complete kitchen', 'chef kitchen'] },
      { code: 'WASHER', aliases: ['washing machine', 'laundry', 'washer'] },
      { code: 'DRYER', aliases: ['tumble dryer', 'tumblr', 'tumbler', 'clothes dryer', 'dryer'] },
      { code: 'tumble_dryer', aliases: ['tumblr', 'tumbler', 'dryer'] },
      { code: 'washing_machine', aliases: ['washer', 'laundry machine'] },
      { code: 'TV', aliases: ['television', 'flat screen', 'tv'] },
      { code: 'smarty_tv', aliases: ['smart tv', 'smart television', 'streaming tv'] },
      { code: 'CABLE', aliases: ['cable tv', 'cable television'] },
      { code: 'SATELLITE', aliases: ['satellite tv', 'dish'] },
      { code: 'GRILL', aliases: ['barbeque', 'barbecue', 'outdoor bbq', 'grill', 'bbq grill', 'bbq', 'outdoor grill'] },
      { code: 'BEACH', aliases: ['beach access', 'near beach'] },
      { code: 'BEACH_VIEW', aliases: ['beach view', 'ocean view', 'sea view', 'beach views'] },
      { code: 'BEACH_FRONT', aliases: ['beachfront', 'oceanfront', 'beach front'] },
      { code: 'MICROWAVE', aliases: ['micro wave', 'micro-wave', 'microwave'] },
      { code: 'REFRIGERATOR', aliases: ['fridge', 'freezer', 'mini fridge', 'mini-fridge', 'refrigerator'] },
      { code: 'MINIBAR', aliases: ['minibar', 'mini bar', 'mini-bar'] },
      { code: 'HIGHCHAIR', aliases: ['high chair', 'baby chair', 'child chair', 'kids chair', 'highchair'] },
      { code: 'TOILETRIES', aliases: ['essentials', 'basic essentials', 'toiletries', 'basics'] },
      { code: 'HEATING', aliases: ['heater', 'central heating', 'radiator', 'underfloor heating', 'heating'] },
      { code: 'iron', aliases: ['ironing', 'iron and board', 'ironing board'] },
      { code: 'IRON_BOARD', aliases: ['iron', 'ironing board', 'iron & board'] },
      { code: 'HAIR_DRYER', aliases: ['hair dryer', 'blow dryer', 'hair-dryer', 'hairdryer'] },
      { code: 'COFFEE_MAKER', aliases: ['coffee machine', 'coffee', 'nespresso', 'espresso machine', 'coffee maker'] },
      { code: 'coffee_machine', aliases: ['coffee maker', 'espresso', 'nespresso'] },
      { code: 'dishwasher', aliases: ['dish washer', 'dish-washer'] },
      { code: 'BALCONY', aliases: ['terrace', 'patio', 'deck', 'outdoor space', 'balcony'] },
      { code: 'GARDEN', aliases: ['yard', 'backyard', 'outdoor garden', 'private garden', 'garden'] },
      { code: 'PRIVATE_YARD', aliases: ['backyard', 'yard', 'private yard'] },
      { code: 'GYM', aliases: ['fitness', 'fitness center', 'fitness centre', 'workout room', 'exercise room', 'gym'] },
      { code: 'FITNESS_ROOM', aliases: ['fitness room', 'exercise room', 'workout area'] },
      { code: 'HOT_TUB', aliases: ['jacuzzi', 'spa', 'whirlpool', 'hot-tub', 'hot tub'] },
      { code: 'SAUNA', aliases: ['steam room', 'sauna'] },
      { code: 'FIREPLACE', aliases: ['fire place', 'wood burner', 'log burner', 'fireplace'] },
      { code: 'WOOD_STOVE', aliases: ['wood burning stove', 'log burner'] },
      { code: 'DESK', aliases: ['workspace', 'work space', 'home office', 'dedicated workspace', 'desk'] },
      { code: 'LAPTOP_FRIENDLY', aliases: ['laptop friendly', 'work from home'] },
      { code: 'SAFE', aliases: ['safety box', 'safe box', 'security safe', 'in-room safe', 'safe'] },
      { code: 'ELEVATOR', aliases: ['lift', 'lifts', 'elevators', 'elevator'] },
      { code: 'WHEELCHAIR_YES', aliases: ['wheelchair accessible', 'accessible', 'disability access', 'disabled access', 'wheelchair'] },
      { code: 'DISABLED_ACCESSIBLE', aliases: ['accessible', 'disability friendly'] },
      { code: 'pets_allowed', aliases: ['pets allowed', 'dogs allowed', 'pet-friendly', 'pets welcome', 'pet friendly'] },
      { code: 'PETS_CONSIDERED', aliases: ['pets on request', 'pets maybe'] },
      { code: 'SMOKING_ALLOWED', aliases: ['smoking allowed', 'smoking area', 'smokers welcome'] },
      { code: 'SMOKING_NOT_ALLOWED', aliases: ['no smoking', 'smoke free', 'smoke-free', 'non smoking', 'non-smoking'] },
      { code: 'bed_cot', aliases: ['crib', 'baby cot', 'baby crib', 'infant bed', 'cot'] },
      { code: 'GAMES', aliases: ['games', 'board games'] },
      { code: 'GAME_ROOM', aliases: ['game room', 'games room', 'recreation room'] },
      { code: 'VIDEO_GAMES', aliases: ['video games', 'gaming console', 'playstation', 'xbox', 'nintendo'] },
      { code: 'DVD', aliases: ['dvd player', 'dvd'] },
      { code: 'STEREO', aliases: ['sound system', 'speakers', 'music system', 'stereo'] },
      { code: 'OCEAN_VIEW', aliases: ['ocean view', 'sea view', 'water view'] },
      { code: 'MOUNTAIN_VIEW', aliases: ['mountain view', 'mountain views'] },
      { code: 'LAKE_VIEW', aliases: ['lake view', 'lakefront'] },
      { code: 'CONCIERGE', aliases: ['concierge', 'concierge service'] },
      { code: 'ROOM_SERVICE', aliases: ['room service', 'in-room dining'] },
      { code: 'BREAKFAST_INCLUDED', aliases: ['breakfast included', 'free breakfast', 'complimentary breakfast'] },
      { code: 'CLEANING_INCLUDED', aliases: ['cleaning included', 'housekeeping', 'maid service'] },
      { code: 'self_check_in', aliases: ['self check in', 'self check-in', 'keyless entry', 'smart lock'] },
      { code: 'electronic_door_lock', aliases: ['keypad', 'smart lock', 'electronic lock'] }
    ];
    
    let updatedCount = 0;
    for (const { code, aliases } of aliasUpdates) {
      const result = await pool.query(`
        UPDATE master_amenities 
        SET aliases = $1 
        WHERE amenity_code = $2
      `, [JSON.stringify(aliases), code]);
      if (result.rowCount > 0) updatedCount++;
    }
    console.log(`   ‚úì Updated aliases for ${updatedCount} amenities`);
    
    // Create unmatched_amenities table for tracking
    await pool.query(`
      CREATE TABLE IF NOT EXISTS unmatched_amenities (
        id SERIAL PRIMARY KEY,
        source VARCHAR(50) NOT NULL,
        raw_name VARCHAR(255) NOT NULL,
        suggested_match_id INTEGER REFERENCES master_amenities(id),
        mapped_to_id INTEGER REFERENCES master_amenities(id),
        occurrence_count INTEGER DEFAULT 1,
        first_seen TIMESTAMP DEFAULT NOW(),
        last_seen TIMESTAMP DEFAULT NOW(),
        UNIQUE(source, raw_name)
      )
    `);
    console.log('   ‚úì Created unmatched_amenities table');
    
    res.json({ 
      success: true, 
      message: 'Amenity aliases migration complete',
      aliases_updated: updatedCount
    });
  } catch (error) {
    console.error('Migration error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Migration 002-FIX: Drop and recreate image tables
app.post('/api/admin/migrate-002-fix', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    console.log('üîÑ Fixing Migration 002: Dropping and recreating image tables...');
    
    // Drop existing tables if they exist
    await client.query('DROP TABLE IF EXISTS property_images CASCADE');
    console.log('   ‚úì Dropped property_images table');
    
    await client.query('DROP TABLE IF EXISTS room_images CASCADE');
    console.log('   ‚úì Dropped room_images table');
    
    // Create property_images table with correct structure
    await client.query(`
      CREATE TABLE property_images (
        id SERIAL PRIMARY KEY,
        property_id INTEGER NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
        image_key VARCHAR(500) NOT NULL,
        image_url TEXT NOT NULL,
        large_url TEXT,
        medium_url TEXT,
        thumbnail_url TEXT,
        original_filename VARCHAR(255),
        file_size INTEGER,
        width INTEGER,
        height INTEGER,
        mime_type VARCHAR(50),
        is_primary BOOLEAN DEFAULT false,
        display_order INTEGER DEFAULT 0,
        caption TEXT,
        alt_text TEXT,
        uploaded_by INTEGER,
        upload_source VARCHAR(50) DEFAULT 'manual',
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created property_images table');
    
    // Create indexes for property_images
    await client.query('CREATE INDEX idx_property_images_property ON property_images(property_id)');
    await client.query('CREATE UNIQUE INDEX idx_property_images_primary_unique ON property_images(property_id) WHERE is_primary = true');
    await client.query('CREATE INDEX idx_property_images_order ON property_images(property_id, display_order)');
    console.log('   ‚úì Created property_images indexes');
    
    // Create room_images table
    await client.query(`
      CREATE TABLE room_images (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        image_key VARCHAR(500) NOT NULL,
        image_url TEXT NOT NULL,
        large_url TEXT,
        medium_url TEXT,
        thumbnail_url TEXT,
        original_filename VARCHAR(255),
        file_size INTEGER,
        width INTEGER,
        height INTEGER,
        mime_type VARCHAR(50),
        is_primary BOOLEAN DEFAULT false,
        display_order INTEGER DEFAULT 0,
        caption TEXT,
        alt_text TEXT,
        uploaded_by INTEGER,
        upload_source VARCHAR(50) DEFAULT 'manual',
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created room_images table');
    
    // Create indexes for room_images
    await client.query('CREATE INDEX idx_room_images_room ON room_images(room_id)');
    await client.query('CREATE UNIQUE INDEX idx_room_images_primary_unique ON room_images(room_id) WHERE is_primary = true');
    await client.query('CREATE INDEX idx_room_images_order ON room_images(room_id, display_order)');
    console.log('   ‚úì Created room_images indexes');
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Image tables fixed and recreated successfully',
      tables: ['property_images', 'room_images']
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Migration 002: Create Image Management System
app.post('/api/admin/migrate-002-image-management', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    console.log('üîÑ Running Migration 002: Image Management System...');
    
    // Create property_images table
    await client.query(`
      CREATE TABLE IF NOT EXISTS property_images (
        id SERIAL PRIMARY KEY,
        property_id INTEGER NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
        image_key VARCHAR(500) NOT NULL,
        image_url TEXT NOT NULL,
        large_url TEXT,
        medium_url TEXT,
        thumbnail_url TEXT,
        original_filename VARCHAR(255),
        file_size INTEGER,
        width INTEGER,
        height INTEGER,
        mime_type VARCHAR(50),
        is_primary BOOLEAN DEFAULT false,
        display_order INTEGER DEFAULT 0,
        caption TEXT,
        alt_text TEXT,
        uploaded_by INTEGER,
        upload_source VARCHAR(50) DEFAULT 'manual',
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created property_images table');
    
    // Create indexes for property_images
    await client.query('CREATE INDEX IF NOT EXISTS idx_property_images_property ON property_images(property_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_property_images_primary ON property_images(property_id, is_primary) WHERE is_primary = true');
    await client.query('CREATE INDEX IF NOT EXISTS idx_property_images_order ON property_images(property_id, display_order)');
    
    // Create room_images table
    await client.query(`
      CREATE TABLE IF NOT EXISTS room_images (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        image_key VARCHAR(500) NOT NULL,
        image_url TEXT NOT NULL,
        large_url TEXT,
        medium_url TEXT,
        thumbnail_url TEXT,
        original_filename VARCHAR(255),
        file_size INTEGER,
        width INTEGER,
        height INTEGER,
        mime_type VARCHAR(50),
        is_primary BOOLEAN DEFAULT false,
        display_order INTEGER DEFAULT 0,
        caption TEXT,
        alt_text TEXT,
        uploaded_by INTEGER,
        upload_source VARCHAR(50) DEFAULT 'manual',
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created room_images table');
    
    // Create indexes for room_images
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_images_room ON room_images(room_id)');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_images_primary ON room_images(room_id, is_primary) WHERE is_primary = true');
    await client.query('CREATE INDEX IF NOT EXISTS idx_room_images_order ON room_images(room_id, display_order)');
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: 'Image management system created successfully',
      tables: ['property_images', 'room_images']
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Cleanup duplicate imports
app.post('/api/admin/cleanup-duplicates', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    console.log('üßπ Cleaning up duplicates...');
    
    // Delete duplicate properties (keep most recent)
    const propsDeleted = await client.query(`
      DELETE FROM properties 
      WHERE id NOT IN (
        SELECT MAX(id) 
        FROM properties 
        GROUP BY name, address, city
      )
    `);
    
    // Delete orphaned units
    await client.query(`
      DELETE FROM bookable_units
      WHERE property_id NOT IN (SELECT id FROM properties)
    `);
    
    // Delete duplicate units (keep most recent)
    const unitsDeleted = await client.query(`
      DELETE FROM bookable_units
      WHERE id NOT IN (
        SELECT MAX(id)
        FROM bookable_units
        GROUP BY property_id, name
      )
    `);
    
    // Clean up orphaned images
    await client.query('DELETE FROM property_images WHERE property_id NOT IN (SELECT id FROM properties)');
    await client.query('DELETE FROM bookable_unit_images WHERE bookable_unit_id NOT IN (SELECT id FROM bookable_units)');
    
    // Clean up orphaned amenities
    await client.query('DELETE FROM property_amenities WHERE property_id NOT IN (SELECT id FROM properties)');
    await client.query('DELETE FROM bookable_unit_amenities WHERE bookable_unit_id NOT IN (SELECT id FROM bookable_units)');
    
    // Clean up orphaned links
    await client.query('DELETE FROM property_cm_links WHERE property_id NOT IN (SELECT id FROM properties)');
    
    await client.query('COMMIT');
    
    // Get final counts
    const counts = await pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM properties) as properties,
        (SELECT COUNT(*) FROM bookable_units) as units
    `);
    
    console.log('‚úì Cleanup complete');
    
    res.json({
      success: true,
      message: 'Duplicates removed successfully',
      counts: counts.rows[0]
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Cleanup error:', error.message);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Add cm_room_id column migration
app.post('/api/admin/add-cm-room-id', async (req, res) => {
  try {
    console.log('üìù Adding cm_room_id column...');
    
    await pool.query(`
      ALTER TABLE bookable_units 
      ADD COLUMN IF NOT EXISTS cm_room_id VARCHAR(100)
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_bookable_units_cm_room_id 
      ON bookable_units(cm_room_id)
    `);
    
    console.log('‚úì Column added successfully');
    
    res.json({
      success: true,
      message: 'cm_room_id column added successfully'
    });
  } catch (error) {
    console.error('Migration error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// IMAGE PROCESSING HELPER FUNCTIONS
// =========================================================

/**
 * Validate image meets minimum aspect ratio (1.2:1 or wider)
 * Allows images that are at least 20% wider than tall
 */
async function validateLandscape(buffer) {
  const metadata = await sharp(buffer).metadata();
  const ratio = metadata.width / metadata.height;
  
  if (ratio < 1.2) {
    throw new Error('Images must be at least 1.2:1 ratio (width:height). Portrait and square images are not accepted.');
  }
  
  return metadata;
}

/**
 * Process and upload image to R2 in multiple sizes
 * Returns URLs for all variants
 */
async function processAndUploadImage(buffer, type, entityId, filename) {
  const ext = path.extname(filename).toLowerCase();
  const baseFilename = path.basename(filename, ext);
  const uniqueId = uuidv4();
  
  const sizes = {
    large: { width: 1920, quality: 85 },
    medium: { width: 1200, quality: 85 },
    thumbnail: { width: 400, quality: 80 }
  };
  
  const results = {
    original: null,
    large: null,
    medium: null,
    thumbnail: null
  };
  
  // Convert to WebP and upload each size
  for (const [sizeName, config] of Object.entries(sizes)) {
    const key = `${type}/${entityId}/${sizeName}/${uniqueId}-${baseFilename}.webp`;
    
    const processedBuffer = await sharp(buffer)
      .resize(config.width, null, { 
        fit: 'inside',
        withoutEnlargement: true 
      })
      .webp({ quality: config.quality })
      .toBuffer();
    
    // Upload to R2
    await r2Client.send(new PutObjectCommand({
      Bucket: R2_BUCKET,
      Key: key,
      Body: processedBuffer,
      ContentType: 'image/webp',
      CacheControl: 'public, max-age=31536000' // 1 year cache
    }));
    
    results[sizeName] = `${R2_PUBLIC_URL}/${key}`;
  }
  
  // Also create JPG fallback for original
  const originalKey = `${type}/${entityId}/original/${uniqueId}-${baseFilename}.jpg`;
  const jpgBuffer = await sharp(buffer)
    .jpeg({ quality: 90 })
    .toBuffer();
  
  await r2Client.send(new PutObjectCommand({
    Bucket: R2_BUCKET,
    Key: originalKey,
    Body: jpgBuffer,
    ContentType: 'image/jpeg',
    CacheControl: 'public, max-age=31536000'
  }));
  
  results.original = `${R2_PUBLIC_URL}/${originalKey}`;
  results.imageKey = originalKey;
  
  return results;
}

/**
 * Delete image and all variants from R2
 */
async function deleteImageFromR2(imageKey) {
  try {
    // Extract base path
    const parts = imageKey.split('/');
    const type = parts[0];
    const entityId = parts[1];
    const filename = parts[3];
    const baseFilename = path.basename(filename, path.extname(filename));
    
    // Delete all variants
    const keys = [
      imageKey, // original
      `${type}/${entityId}/large/${baseFilename}.webp`,
      `${type}/${entityId}/medium/${baseFilename}.webp`,
      `${type}/${entityId}/thumbnail/${baseFilename}.webp`
    ];
    
    for (const key of keys) {
      await r2Client.send(new DeleteObjectCommand({
        Bucket: R2_BUCKET,
        Key: key
      }));
    }
  } catch (error) {
    console.error('Error deleting from R2:', error);
    // Don't throw - image might already be deleted
  }
}

// =========================================================
// IMAGE UPLOAD ENDPOINTS
// =========================================================

// Upload property images
// Get rooms for a property
app.get('/api/admin/properties/:id/rooms', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT * FROM bookable_units 
      WHERE property_id = $1
      ORDER BY name
    `, [id]);
    
    res.json({ success: true, rooms: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

app.post('/api/admin/properties/:id/images', upload.array('images', 10), async (req, res) => {
  const client = await pool.connect();
  try {
    const { id } = req.params;
    const files = req.files;
    
    if (!files || files.length === 0) {
      return res.json({ success: false, error: 'No files uploaded' });
    }
    
    await client.query('BEGIN');
    
    const uploadedImages = [];
    
    for (const file of files) {
      // Validate landscape
      try {
        const metadata = await validateLandscape(file.buffer);
        
        // Process and upload
        const urls = await processAndUploadImage(
          file.buffer,
          'properties',
          id,
          file.originalname
        );
        
        // Get current max display_order
        const maxOrder = await client.query(
          'SELECT COALESCE(MAX(display_order), -1) as max FROM property_images WHERE property_id = $1',
          [id]
        );
        const nextOrder = maxOrder.rows[0].max + 1;
        
        // Insert into database
        const result = await client.query(`
          INSERT INTO property_images (
            property_id, image_key, image_url, large_url, medium_url, thumbnail_url,
            original_filename, file_size, width, height, mime_type, display_order
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          RETURNING *
        `, [
          id, urls.imageKey, urls.original, urls.large, urls.medium, urls.thumbnail,
          file.originalname, file.size, metadata.width, metadata.height, 'image/webp', nextOrder
        ]);
        
        uploadedImages.push(result.rows[0]);
        
      } catch (error) {
        console.error(`Error processing ${file.originalname}:`, error.message);
        // Continue with next file
      }
    }
    
    await client.query('COMMIT');
    
    res.json({
      success: true,
      message: `${uploadedImages.length} of ${files.length} images uploaded successfully`,
      images: uploadedImages
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Upload error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Upload room images
app.post('/api/admin/rooms/:id/images', upload.array('images', 10), async (req, res) => {
  const client = await pool.connect();
  try {
    const { id } = req.params;
    const files = req.files;
    
    console.log(`üì∏ Room ${id} image upload started - ${files?.length || 0} files`);
    
    if (!files || files.length === 0) {
      return res.json({ success: false, error: 'No files uploaded' });
    }
    
    await client.query('BEGIN');
    
    const uploadedImages = [];
    
    for (const file of files) {
      try {
        console.log(`  Processing ${file.originalname}...`);
        
        const metadata = await validateLandscape(file.buffer);
        console.log(`  ‚úì Validated: ${metadata.width}x${metadata.height}`);
        
        const urls = await processAndUploadImage(
          file.buffer,
          'rooms',
          id,
          file.originalname
        );
        console.log(`  ‚úì Uploaded to R2`);
        
        const maxOrder = await client.query(
          'SELECT COALESCE(MAX(display_order), -1) as max FROM room_images WHERE room_id = $1',
          [id]
        );
        const nextOrder = maxOrder.rows[0].max + 1;
        
        const result = await client.query(`
          INSERT INTO room_images (
            room_id, image_key, image_url, large_url, medium_url, thumbnail_url,
            original_filename, file_size, width, height, mime_type, display_order
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          RETURNING *
        `, [
          id, urls.imageKey, urls.original, urls.large, urls.medium, urls.thumbnail,
          file.originalname, file.size, metadata.width, metadata.height, 'image/webp', nextOrder
        ]);
        
        uploadedImages.push(result.rows[0]);
        console.log(`  ‚úì Saved to database`);
        
      } catch (error) {
        console.error(`  ‚úó Error processing ${file.originalname}:`, error.message);
      }
    }
    
    await client.query('COMMIT');
    
    console.log(`‚úÖ Upload complete: ${uploadedImages.length}/${files.length} succeeded`);
    
    res.json({
      success: true,
      message: `${uploadedImages.length} of ${files.length} images uploaded successfully`,
      images: uploadedImages
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('‚ùå Room image upload error:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Get property images
app.get('/api/admin/properties/:id/images', async (req, res) => {
  try {
    const { id } = req.params;
    
    // First check property_images table
    const result = await pool.query(
      'SELECT * FROM property_images WHERE property_id = $1 AND is_active = true ORDER BY is_primary DESC, display_order ASC',
      [id]
    );
    
    let images = result.rows;
    
    // If no images, check gas_sync_images for PROPERTY-level images only (not room images)
    if (images.length === 0) {
      const syncResult = await pool.query(`
        SELECT 
          gsi.id, 
          gsi.original_url as url, 
          gsi.thumbnail_url,
          gsi.caption,
          gsi.sort_order as display_order,
          gsi.image_type,
          gsi.width,
          gsi.height,
          true as is_active,
          CASE WHEN gsi.sort_order = 0 THEN true ELSE false END as is_primary
        FROM gas_sync_images gsi
        JOIN gas_sync_properties gsp ON gsi.sync_property_id = gsp.id
        WHERE gsp.gas_property_id = $1
          AND (gsi.room_type_external_id IS NULL OR gsi.image_type = 'property')
        ORDER BY gsi.sort_order, gsi.id
      `, [id]);
      
      images = syncResult.rows;
    }
    
    res.json({ success: true, images });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get room images
app.get('/api/admin/rooms/:id/images', async (req, res) => {
  try {
    const { id } = req.params;
    
    // First check room_images table
    const result = await pool.query(
      'SELECT * FROM room_images WHERE room_id = $1 AND is_active = true ORDER BY is_primary DESC, display_order ASC',
      [id]
    );
    
    let images = result.rows;
    
    // If no images, check gas_sync_images (for synced rooms)
    if (images.length === 0) {
      // Get the room name and property_id to find matching gas_sync_room_type
      const roomResult = await pool.query(
        'SELECT name, property_id FROM bookable_units WHERE id = $1',
        [id]
      );
      
      if (roomResult.rows.length > 0) {
        const { name: roomName, property_id } = roomResult.rows[0];
        
        // Find images by matching room name through gas_sync_room_types
        const syncResult = await pool.query(`
          SELECT 
            gsi.id,
            gsi.original_url as url,
            gsi.thumbnail_url,
            gsi.caption,
            gsi.sort_order as display_order,
            gsi.image_type,
            gsi.width,
            gsi.height,
            true as is_active,
            CASE WHEN gsi.sort_order = 0 THEN true ELSE false END as is_primary
          FROM gas_sync_images gsi
          JOIN gas_sync_room_types gsrt ON gsi.room_type_external_id = gsrt.external_id 
            AND gsi.connection_id = gsrt.connection_id
          JOIN gas_sync_properties gsp ON gsrt.sync_property_id = gsp.id
          WHERE gsp.gas_property_id = $1 
            AND gsrt.name = $2
          ORDER BY gsi.sort_order, gsi.id
        `, [property_id, roomName]);
        
        images = syncResult.rows;
      }
    }
    
    res.json({ success: true, images });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Simple test endpoint - check ALL room images in database
app.get('/api/admin/all-images', async (req, res) => {
  try {
    const roomImages = await pool.query('SELECT * FROM room_images');
    const propertyImages = await pool.query('SELECT * FROM property_images');
    res.json({ 
      success: true, 
      roomImages: roomImages.rows,
      propertyImages: propertyImages.rows,
      counts: {
        room: roomImages.rows.length,
        property: propertyImages.rows.length
      }
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete property image
app.delete('/api/admin/properties/images/:imageId', async (req, res) => {
  const client = await pool.connect();
  try {
    const { imageId } = req.params;
    
    // Get image details
    const image = await client.query(
      'SELECT * FROM property_images WHERE id = $1',
      [imageId]
    );
    
    if (image.rows.length === 0) {
      return res.json({ success: false, error: 'Image not found' });
    }
    
    await client.query('BEGIN');
    
    // Delete from R2
    await deleteImageFromR2(image.rows[0].image_key);
    
    // Delete from database
    await client.query('DELETE FROM property_images WHERE id = $1', [imageId]);
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Image deleted' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Delete room image
app.delete('/api/admin/rooms/images/:imageId', async (req, res) => {
  const client = await pool.connect();
  try {
    const { imageId } = req.params;
    
    // Try room_images first
    let image = await client.query(
      'SELECT *, \'room_images\' as source_table FROM room_images WHERE id = $1',
      [imageId]
    );
    
    // If not found, try gas_sync_images
    if (image.rows.length === 0) {
      image = await client.query(
        'SELECT *, \'gas_sync_images\' as source_table FROM gas_sync_images WHERE id = $1',
        [imageId]
      );
    }
    
    if (image.rows.length === 0) {
      return res.json({ success: false, error: 'Image not found' });
    }
    
    await client.query('BEGIN');
    
    const sourceTable = image.rows[0].source_table;
    
    // Only try R2 delete for room_images (sync images are external URLs)
    if (sourceTable === 'room_images' && image.rows[0].image_key) {
      await deleteImageFromR2(image.rows[0].image_key);
    }
    
    await client.query(`DELETE FROM ${sourceTable} WHERE id = $1`, [imageId]);
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Image deleted' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Set primary property image
app.put('/api/admin/properties/:propertyId/images/:imageId/primary', async (req, res) => {
  const client = await pool.connect();
  try {
    const { propertyId, imageId } = req.params;
    
    await client.query('BEGIN');
    
    // Remove primary from all images for this property
    await client.query(
      'UPDATE property_images SET is_primary = false WHERE property_id = $1',
      [propertyId]
    );
    
    // Set new primary
    await client.query(
      'UPDATE property_images SET is_primary = true WHERE id = $1',
      [imageId]
    );
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Primary image updated' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Set primary room image
app.put('/api/admin/rooms/:roomId/images/:imageId/primary', async (req, res) => {
  const client = await pool.connect();
  try {
    const { roomId, imageId } = req.params;
    
    await client.query('BEGIN');
    
    await client.query(
      'UPDATE room_images SET is_primary = false WHERE room_id = $1',
      [roomId]
    );
    
    await client.query(
      'UPDATE room_images SET is_primary = true WHERE id = $1',
      [imageId]
    );
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Primary image updated' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Update image display order
app.put('/api/admin/properties/:propertyId/images/reorder', async (req, res) => {
  const client = await pool.connect();
  try {
    const { propertyId } = req.params;
    const { imageIds } = req.body; // Array of image IDs in new order
    
    await client.query('BEGIN');
    
    for (let i = 0; i < imageIds.length; i++) {
      await client.query(
        'UPDATE property_images SET display_order = $1 WHERE id = $2 AND property_id = $3',
        [i, imageIds[i], propertyId]
      );
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Image order updated' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Update room image display order
app.put('/api/admin/rooms/:roomId/images/reorder', async (req, res) => {
  const client = await pool.connect();
  try {
    const { roomId } = req.params;
    const { imageIds } = req.body;
    
    await client.query('BEGIN');
    
    for (let i = 0; i < imageIds.length; i++) {
      await client.query(
        'UPDATE room_images SET display_order = $1 WHERE id = $2 AND room_id = $3',
        [i, imageIds[i], roomId]
      );
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Image order updated' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Toggle room visibility (hide/show on calendar)
app.put('/api/admin/rooms/:roomId/visibility', async (req, res) => {
  try {
    const { roomId } = req.params;
    const { is_hidden } = req.body;
    
    await pool.query(
      'UPDATE bookable_units SET is_hidden = $1 WHERE id = $2',
      [is_hidden, roomId]
    );
    
    res.json({ success: true, is_hidden });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Bulk toggle room visibility
app.put('/api/admin/rooms/bulk-visibility', async (req, res) => {
  try {
    const { room_ids, is_hidden } = req.body;
    
    if (!room_ids || !Array.isArray(room_ids) || room_ids.length === 0) {
      return res.json({ success: false, error: 'No room IDs provided' });
    }
    
    await pool.query(
      'UPDATE bookable_units SET is_hidden = $1 WHERE id = ANY($2)',
      [is_hidden, room_ids]
    );
    
    res.json({ success: true, updated: room_ids.length, is_hidden });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// IMAGE ASSIGNMENT TOOL API
// =========================================================

// GET all images for a property (from all sources) with room assignments
app.get('/api/admin/properties/:id/all-images', async (req, res) => {
  try {
    const propertyId = req.params.id;
    
    // Get property info
    const propResult = await pool.query('SELECT id, name, account_id FROM properties WHERE id = $1', [propertyId]);
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    // Get rooms for this property
    const rooms = await pool.query(
      'SELECT id, name, display_name, max_guests FROM bookable_units WHERE property_id = $1 ORDER BY name',
      [propertyId]
    );
    
    // Get gas_sync_images (the main source for synced properties)
    const syncImages = await pool.query(`
      SELECT 
        gsi.id, gsi.original_url as url, gsi.thumbnail_url, gsi.caption,
        gsi.sort_order, gsi.image_type, gsi.room_type_external_id,
        gsi.external_id, gsi.width, gsi.height,
        'gas_sync' as source
      FROM gas_sync_images gsi
      JOIN gas_sync_properties gsp ON gsi.sync_property_id = gsp.id
      WHERE gsp.gas_property_id = $1
      ORDER BY gsi.sort_order, gsi.id
    `, [propertyId]);
    
    // Get property_images 
    const propImages = await pool.query(`
      SELECT id, url, caption, sort_order, is_primary, room_id, external_id,
        'property_images' as source
      FROM property_images 
      WHERE property_id = $1
      ORDER BY sort_order, id
    `, [propertyId]);
    
    // Get existing room_images for each room
    const roomImages = await pool.query(`
      SELECT ri.id, ri.room_id, ri.image_url as url, ri.thumbnail_url, ri.caption, 
        ri.display_order, ri.is_primary, ri.is_active, ri.image_key
      FROM room_images ri
      JOIN bookable_units bu ON ri.room_id = bu.id
      WHERE bu.property_id = $1 AND ri.is_active = true
      ORDER BY ri.room_id, ri.display_order
    `, [propertyId]);
    
    // Group room images by room_id
    const roomImageMap = {};
    for (const img of roomImages.rows) {
      if (!roomImageMap[img.room_id]) roomImageMap[img.room_id] = [];
      roomImageMap[img.room_id].push(img);
    }
    
    res.json({
      success: true,
      property: propResult.rows[0],
      rooms: rooms.rows,
      sync_images: syncImages.rows,
      property_images: propImages.rows,
      room_images: roomImageMap
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// POST assign images to a room (from any source URL)
app.post('/api/admin/rooms/:roomId/assign-images', async (req, res) => {
  try {
    const { roomId } = req.params;
    const { images } = req.body; // Array of { url, thumbnail_url, caption }
    
    if (!images || !Array.isArray(images) || images.length === 0) {
      return res.json({ success: false, error: 'No images provided' });
    }
    
    // Verify room exists
    const roomCheck = await pool.query('SELECT id, name, property_id FROM bookable_units WHERE id = $1', [roomId]);
    if (roomCheck.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    // Get current max display_order
    const maxOrder = await pool.query(
      'SELECT COALESCE(MAX(display_order), -1) as max FROM room_images WHERE room_id = $1',
      [roomId]
    );
    let nextOrder = maxOrder.rows[0].max + 1;
    
    let added = 0;
    let skipped = 0;
    
    for (const img of images) {
      // Check if already exists
      const existing = await pool.query(
        'SELECT id FROM room_images WHERE room_id = $1 AND image_url = $2',
        [roomId, img.url]
      );
      
      if (existing.rows.length > 0) {
        skipped++;
        continue;
      }
      
      await pool.query(`
        INSERT INTO room_images (room_id, image_key, image_url, thumbnail_url, caption, display_order, upload_source, is_active, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, 'assigned', true, NOW())
      `, [
        roomId,
        'assign-' + Date.now() + '-' + nextOrder,
        img.url,
        img.thumbnail_url || img.url,
        img.caption || '',
        nextOrder++
      ]);
      added++;
    }
    
    // Set first image as primary if no primary exists
    if (added > 0) {
      const hasPrimary = await pool.query(
        'SELECT id FROM room_images WHERE room_id = $1 AND is_primary = true',
        [roomId]
      );
      if (hasPrimary.rows.length === 0) {
        const firstImg = await pool.query(
          'SELECT id FROM room_images WHERE room_id = $1 AND is_active = true ORDER BY display_order LIMIT 1',
          [roomId]
        );
        if (firstImg.rows.length > 0) {
          await pool.query('UPDATE room_images SET is_primary = true WHERE id = $1', [firstImg.rows[0].id]);
        }
      }
    }
    
    res.json({ success: true, added, skipped, room: roomCheck.rows[0].name });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// DELETE clear all room images for a room
app.delete('/api/admin/rooms/:roomId/clear-images', async (req, res) => {
  try {
    const { roomId } = req.params;
    
    const result = await pool.query(
      'DELETE FROM room_images WHERE room_id = $1',
      [roomId]
    );
    
    res.json({ success: true, deleted: result.rowCount });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// PROPERTY TERMS & POLICIES API
// =========================================================

// GET /api/admin/properties/:id/terms - Load property terms and beds
app.get('/api/admin/properties/:id/terms', async (req, res) => {
  try {
    const propertyId = req.params.id;
    
    // Get terms from property_terms table
    const termsResult = await pool.query(
      'SELECT * FROM property_terms WHERE property_id = $1',
      [propertyId]
    );
    
    // Get cancellation_policy from properties table
    const propertyResult = await pool.query(
      'SELECT cancellation_policy FROM properties WHERE id = $1',
      [propertyId]
    );
    
    // Get beds
    const bedsResult = await pool.query(
      'SELECT bed_type, quantity, room_id FROM property_beds WHERE property_id = $1 AND room_id IS NULL ORDER BY display_order',
      [propertyId]
    );
    
    // Get bathrooms
    const bathroomsResult = await pool.query(
      'SELECT bathroom_type, quantity FROM property_bathrooms WHERE property_id = $1 AND room_id IS NULL ORDER BY display_order',
      [propertyId]
    );
    
    // Merge terms with cancellation_policy
    const terms = termsResult.rows[0] || {};
    if (propertyResult.rows[0]?.cancellation_policy) {
      terms.cancellation_policy = propertyResult.rows[0].cancellation_policy;
    }
    
    res.json({
      success: true,
      data: {
        terms: terms,
        beds: bedsResult.rows || [],
        bathrooms: bathroomsResult.rows || []
      }
    });
  } catch (error) {
    console.error('Error loading property terms:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/admin/properties/:id/terms - Save property terms and beds
app.put('/api/admin/properties/:id/terms', async (req, res) => {
  const client = await pool.connect();
  try {
    const propertyId = req.params.id;
    const { terms, beds, bathrooms, bathroom_features } = req.body;
    
    await client.query('BEGIN');
    
    // Upsert terms (insert or update)
    await client.query(`
      INSERT INTO property_terms (
        property_id,
        checkin_from, checkin_until, checkout_by, late_checkout_fee,
        self_checkin, checkin_24hr,
        smoking_policy, smoking_fine,
        pet_policy, pet_deposit, pet_fee_per_night,
        dogs_allowed, cats_allowed, small_pets_only, max_pets,
        children_policy, cots_available, highchairs_available, cot_fee_per_night,
        events_policy,
        wheelchair_accessible, step_free_access, accessible_bathroom,
        grab_rails, roll_in_shower, elevator_access, ground_floor_available,
        quiet_hours_from, quiet_hours_until, no_outside_guests, id_required,
        additional_rules, bathroom_features, additional_rules_ml, cancellation_policy_ml
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)
      ON CONFLICT (property_id) DO UPDATE SET
        checkin_from = EXCLUDED.checkin_from,
        checkin_until = EXCLUDED.checkin_until,
        checkout_by = EXCLUDED.checkout_by,
        late_checkout_fee = EXCLUDED.late_checkout_fee,
        self_checkin = EXCLUDED.self_checkin,
        checkin_24hr = EXCLUDED.checkin_24hr,
        smoking_policy = EXCLUDED.smoking_policy,
        smoking_fine = EXCLUDED.smoking_fine,
        pet_policy = EXCLUDED.pet_policy,
        pet_deposit = EXCLUDED.pet_deposit,
        pet_fee_per_night = EXCLUDED.pet_fee_per_night,
        dogs_allowed = EXCLUDED.dogs_allowed,
        cats_allowed = EXCLUDED.cats_allowed,
        small_pets_only = EXCLUDED.small_pets_only,
        max_pets = EXCLUDED.max_pets,
        children_policy = EXCLUDED.children_policy,
        cots_available = EXCLUDED.cots_available,
        highchairs_available = EXCLUDED.highchairs_available,
        cot_fee_per_night = EXCLUDED.cot_fee_per_night,
        events_policy = EXCLUDED.events_policy,
        wheelchair_accessible = EXCLUDED.wheelchair_accessible,
        step_free_access = EXCLUDED.step_free_access,
        accessible_bathroom = EXCLUDED.accessible_bathroom,
        grab_rails = EXCLUDED.grab_rails,
        roll_in_shower = EXCLUDED.roll_in_shower,
        elevator_access = EXCLUDED.elevator_access,
        ground_floor_available = EXCLUDED.ground_floor_available,
        quiet_hours_from = EXCLUDED.quiet_hours_from,
        quiet_hours_until = EXCLUDED.quiet_hours_until,
        no_outside_guests = EXCLUDED.no_outside_guests,
        id_required = EXCLUDED.id_required,
        additional_rules = EXCLUDED.additional_rules,
        bathroom_features = EXCLUDED.bathroom_features,
        additional_rules_ml = EXCLUDED.additional_rules_ml,
        cancellation_policy_ml = EXCLUDED.cancellation_policy_ml,
        updated_at = CURRENT_TIMESTAMP
    `, [
      propertyId,
      terms.checkin_from || '15:00',
      terms.checkin_until || '22:00',
      terms.checkout || '11:00',
      terms.late_checkout_fee || null,
      terms.self_checkin || false,
      terms.checkin_24hr || false,
      terms.smoking_policy || 'no',
      terms.smoking_fine || null,
      terms.pet_policy || 'no',
      terms.pet_deposit || null,
      terms.pet_fee || null,
      terms.dogs_allowed || false,
      terms.cats_allowed || false,
      terms.small_pets_only || false,
      terms.max_pets || 2,
      terms.children_policy || 'all',
      terms.cots_available || false,
      terms.highchairs_available || false,
      terms.cot_fee || null,
      terms.events_policy || 'no',
      terms.wheelchair_accessible || false,
      terms.step_free || false,
      terms.accessible_bathroom || false,
      terms.grab_rails || false,
      terms.roll_in_shower || false,
      terms.elevator_access || false,
      terms.ground_floor || false,
      terms.quiet_hours_from || '22:00',
      terms.quiet_hours_until || '08:00',
      terms.no_outside_guests || false,
      terms.id_required || false,
      terms.additional_rules || null,
      bathroom_features ? JSON.stringify(bathroom_features) : null,
      terms.additional_rules_ml ? JSON.stringify(terms.additional_rules_ml) : null,
      terms.cancellation_policy_ml ? JSON.stringify(terms.cancellation_policy_ml) : null
    ]);
    
    // Update beds - delete existing property-level beds and insert new
    if (beds && Array.isArray(beds)) {
      await client.query('DELETE FROM property_beds WHERE property_id = $1 AND room_id IS NULL', [propertyId]);
      
      for (let i = 0; i < beds.length; i++) {
        const bed = beds[i];
        if (bed.type) {
          await client.query(
            'INSERT INTO property_beds (property_id, bed_type, quantity, display_order) VALUES ($1, $2, $3, $4)',
            [propertyId, bed.type, bed.quantity || 1, i]
          );
        }
      }
    }
    
    // Update bathrooms - only if using OLD format (no name field)
    // Skip if bathrooms have names (new detailed format is handled by separate API)
    if (bathrooms && Array.isArray(bathrooms) && bathrooms.length > 0) {
      // Check if these are old-style bathrooms (no name, just type/quantity)
      const isOldFormat = bathrooms.every(b => !b.name && b.type);
      
      if (isOldFormat) {
        // Delete only old-format bathrooms (those without names)
        await client.query('DELETE FROM property_bathrooms WHERE property_id = $1 AND room_id IS NULL AND name IS NULL', [propertyId]);
        
        let totalBathrooms = 0;
        for (let i = 0; i < bathrooms.length; i++) {
          const bathroom = bathrooms[i];
          if (bathroom.type) {
            const qty = parseInt(bathroom.quantity) || 1;
            totalBathrooms += qty;
            await client.query(
              'INSERT INTO property_bathrooms (property_id, bathroom_type, quantity, display_order) VALUES ($1, $2, $3, $4)',
              [propertyId, bathroom.type, qty, i]
            );
          }
        }
        
        // Update num_bathrooms on all bookable_units for this property
        // But also count new-style bathrooms
        const newStyleCount = await client.query(
          'SELECT COALESCE(SUM(quantity), 0) as count FROM property_bathrooms WHERE property_id = $1 AND room_id IS NULL AND name IS NOT NULL',
          [propertyId]
        );
        totalBathrooms += parseInt(newStyleCount.rows[0]?.count || 0);
        
        if (totalBathrooms > 0) {
          await client.query(
            'UPDATE bookable_units SET num_bathrooms = $1 WHERE property_id = $2',
            [totalBathrooms, propertyId]
          );
        }
      }
    } else if (!bathrooms || bathrooms.length === 0) {
      // No old-style bathrooms provided - just update count from new-style
      const newStyleCount = await client.query(
        'SELECT COALESCE(SUM(quantity), 0) as count FROM property_bathrooms WHERE property_id = $1 AND room_id IS NULL AND name IS NOT NULL',
        [propertyId]
      );
      const totalBathrooms = parseInt(newStyleCount.rows[0]?.count || 0);
      if (totalBathrooms > 0) {
        await client.query(
          'UPDATE bookable_units SET num_bathrooms = $1 WHERE property_id = $2',
          [totalBathrooms, propertyId]
        );
      }
    }
    
    // Update cancellation_policy on properties table
    if (terms.cancellation_policy !== undefined) {
      await client.query(
        'UPDATE properties SET cancellation_policy = $1 WHERE id = $2',
        [terms.cancellation_policy || null, propertyId]
      );
    }
    
    await client.query('COMMIT');
    
    res.json({ success: true, message: 'Terms saved successfully' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error saving property terms:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// =========================================================
// BEDROOM CONFIGURATION API
// =========================================================

// GET /api/admin/properties/:id/bedrooms - Get all bedrooms for property
app.get('/api/admin/properties/:id/bedrooms', async (req, res) => {
  try {
    const propertyId = req.params.id;
    const roomId = req.query.room_id;
    
    let query = `
      SELECT pb.*, 
        bu.name as room_name,
        (SELECT name FROM property_bathrooms WHERE id = pb.ensuite_bathroom_id) as ensuite_bathroom_name
      FROM property_bedrooms pb
      LEFT JOIN bookable_units bu ON pb.room_id = bu.id
      WHERE pb.property_id = $1
    `;
    const params = [propertyId];
    
    if (roomId) {
      query += ` AND pb.room_id = $2`;
      params.push(roomId);
    }
    // Removed: else { query += ` AND pb.room_id IS NULL`; }
    // Now returns ALL bedrooms for the property (both property-level and room-level)
    
    query += ` ORDER BY pb.room_id NULLS FIRST, pb.display_order, pb.id`;
    
    const result = await pool.query(query, params);
    
    // Also get bedroom amenities from property_terms
    const termsResult = await pool.query(
      'SELECT bedroom_amenities FROM property_terms WHERE property_id = $1',
      [propertyId]
    );
    
    res.json({ 
      success: true, 
      bedrooms: result.rows,
      bedroom_amenities: termsResult.rows[0]?.bedroom_amenities || {}
    });
  } catch (error) {
    console.error('Error fetching bedrooms:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/admin/properties/:id/bedrooms - Create a bedroom
app.post('/api/admin/properties/:id/bedrooms', async (req, res) => {
  try {
    const propertyId = req.params.id;
    const { room_id, name, bed_config, has_ensuite, ensuite_bathroom_id, description, display_order } = req.body;
    
    const result = await pool.query(`
      INSERT INTO property_bedrooms (property_id, room_id, name, bed_config, has_ensuite, ensuite_bathroom_id, description, display_order)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *
    `, [
      propertyId,
      room_id || null,
      name,
      JSON.stringify(bed_config || []),
      has_ensuite || false,
      ensuite_bathroom_id || null,
      description || null,
      display_order || 0
    ]);
    
    // Update num_bedrooms count on bookable_units
    await updateBedroomCount(propertyId, room_id);
    
    res.json({ success: true, bedroom: result.rows[0] });
  } catch (error) {
    console.error('Error creating bedroom:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/admin/bedrooms/:id - Update a bedroom
app.put('/api/admin/bedrooms/:id', async (req, res) => {
  try {
    const bedroomId = req.params.id;
    const { name, bed_config, has_ensuite, ensuite_bathroom_id, description, display_order } = req.body;
    
    const result = await pool.query(`
      UPDATE property_bedrooms 
      SET name = $1, bed_config = $2, has_ensuite = $3, ensuite_bathroom_id = $4, description = $5, display_order = $6, updated_at = CURRENT_TIMESTAMP
      WHERE id = $7
      RETURNING *
    `, [
      name,
      JSON.stringify(bed_config || []),
      has_ensuite || false,
      ensuite_bathroom_id || null,
      description || null,
      display_order || 0,
      bedroomId
    ]);
    
    if (result.rows.length > 0) {
      await updateBedroomCount(result.rows[0].property_id, result.rows[0].room_id);
    }
    
    res.json({ success: true, bedroom: result.rows[0] });
  } catch (error) {
    console.error('Error updating bedroom:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/admin/bedrooms/:id - Delete a bedroom
app.delete('/api/admin/bedrooms/:id', async (req, res) => {
  try {
    const bedroomId = req.params.id;
    
    // Get property_id before deleting
    const existing = await pool.query('SELECT property_id, room_id FROM property_bedrooms WHERE id = $1', [bedroomId]);
    
    await pool.query('DELETE FROM property_bedrooms WHERE id = $1', [bedroomId]);
    
    if (existing.rows.length > 0) {
      await updateBedroomCount(existing.rows[0].property_id, existing.rows[0].room_id);
    }
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting bedroom:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/admin/properties/:id/bedroom-amenities - Save bedroom amenities
app.put('/api/admin/properties/:id/bedroom-amenities', async (req, res) => {
  try {
    const propertyId = req.params.id;
    const { bedroom_amenities } = req.body;
    
    await pool.query(`
      INSERT INTO property_terms (property_id, bedroom_amenities)
      VALUES ($1, $2)
      ON CONFLICT (property_id) DO UPDATE SET bedroom_amenities = $2, updated_at = CURRENT_TIMESTAMP
    `, [propertyId, JSON.stringify(bedroom_amenities)]);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error saving bedroom amenities:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Helper function to update bedroom count
async function updateBedroomCount(propertyId, roomId) {
  try {
    let query, params;
    if (roomId) {
      query = 'SELECT COUNT(*) as count FROM property_bedrooms WHERE property_id = $1 AND room_id = $2';
      params = [propertyId, roomId];
    } else {
      query = 'SELECT COUNT(*) as count FROM property_bedrooms WHERE property_id = $1 AND room_id IS NULL';
      params = [propertyId];
    }
    
    const countResult = await pool.query(query, params);
    const count = parseInt(countResult.rows[0]?.count || 0);
    
    if (roomId) {
      await pool.query('UPDATE bookable_units SET num_bedrooms = $1 WHERE id = $2', [count, roomId]);
    } else {
      // Update all rooms for this property that don't have room-specific bedrooms
      await pool.query('UPDATE bookable_units SET num_bedrooms = $1 WHERE property_id = $2', [count, propertyId]);
    }
  } catch (e) {
    console.log('Error updating bedroom count:', e.message);
  }
}

// =========================================================
// ENHANCED BATHROOM CONFIGURATION API
// =========================================================

// GET /api/admin/properties/:id/bathrooms-detailed - Get detailed bathrooms for property
app.get('/api/admin/properties/:id/bathrooms-detailed', async (req, res) => {
  try {
    const propertyId = req.params.id;
    const roomId = req.query.room_id;
    
    let query = `
      SELECT pb.*,
        bu.name as room_name,
        (SELECT name FROM property_bedrooms WHERE id = pb.linked_bedroom_id) as linked_bedroom_name
      FROM property_bathrooms pb
      LEFT JOIN bookable_units bu ON pb.room_id = bu.id
      WHERE pb.property_id = $1
    `;
    const params = [propertyId];
    
    if (roomId) {
      query += ` AND pb.room_id = $2`;
      params.push(roomId);
    }
    // Removed: else { query += ` AND pb.room_id IS NULL`; }
    // Now returns ALL bathrooms for the property (both property-level and room-level)
    
    query += ` ORDER BY pb.room_id NULLS FIRST, pb.display_order, pb.id`;
    
    const result = await pool.query(query, params);
    
    // Also get bathroom amenities from property_terms
    const termsResult = await pool.query(
      'SELECT bathroom_features FROM property_terms WHERE property_id = $1',
      [propertyId]
    );
    
    res.json({ 
      success: true, 
      bathrooms: result.rows,
      bathroom_amenities: termsResult.rows[0]?.bathroom_features || {}
    });
  } catch (error) {
    console.error('Error fetching detailed bathrooms:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/admin/properties/:id/bathrooms-detailed - Create a detailed bathroom
app.post('/api/admin/properties/:id/bathrooms-detailed', async (req, res) => {
  try {
    const propertyId = req.params.id;
    const { room_id, name, bathroom_type, location, is_ensuite, linked_bedroom_id, features, description, quantity, display_order } = req.body;
    
    const result = await pool.query(`
      INSERT INTO property_bathrooms (property_id, room_id, name, bathroom_type, location, is_ensuite, linked_bedroom_id, features, description, quantity, display_order)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `, [
      propertyId,
      room_id || null,
      name || null,
      bathroom_type,
      location || null,
      is_ensuite || false,
      linked_bedroom_id || null,
      JSON.stringify(features || {}),
      description || null,
      quantity || 1,
      display_order || 0
    ]);
    
    // Update num_bathrooms count on bookable_units
    await updateBathroomCount(propertyId, room_id);
    
    res.json({ success: true, bathroom: result.rows[0] });
  } catch (error) {
    console.error('Error creating bathroom:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/admin/bathrooms/:id - Update a bathroom
app.put('/api/admin/bathrooms/:id', async (req, res) => {
  try {
    const bathroomId = req.params.id;
    const { name, bathroom_type, location, is_ensuite, linked_bedroom_id, features, description, quantity, display_order } = req.body;
    
    const result = await pool.query(`
      UPDATE property_bathrooms 
      SET name = $1, bathroom_type = $2, location = $3, is_ensuite = $4, linked_bedroom_id = $5, features = $6, description = $7, quantity = $8, display_order = $9
      WHERE id = $10
      RETURNING *
    `, [
      name || null,
      bathroom_type,
      location || null,
      is_ensuite || false,
      linked_bedroom_id || null,
      JSON.stringify(features || {}),
      description || null,
      quantity || 1,
      display_order || 0,
      bathroomId
    ]);
    
    if (result.rows.length > 0) {
      await updateBathroomCount(result.rows[0].property_id, result.rows[0].room_id);
    }
    
    res.json({ success: true, bathroom: result.rows[0] });
  } catch (error) {
    console.error('Error updating bathroom:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/admin/bathrooms/:id - Delete a bathroom
app.delete('/api/admin/bathrooms/:id', async (req, res) => {
  try {
    const bathroomId = req.params.id;
    
    // Get property_id before deleting
    const existing = await pool.query('SELECT property_id, room_id FROM property_bathrooms WHERE id = $1', [bathroomId]);
    
    await pool.query('DELETE FROM property_bathrooms WHERE id = $1', [bathroomId]);
    
    if (existing.rows.length > 0) {
      await updateBathroomCount(existing.rows[0].property_id, existing.rows[0].room_id);
    }
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting bathroom:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Helper function to update bathroom count
async function updateBathroomCount(propertyId, roomId) {
  try {
    let query, params;
    if (roomId) {
      query = 'SELECT SUM(quantity) as count FROM property_bathrooms WHERE property_id = $1 AND room_id = $2';
      params = [propertyId, roomId];
    } else {
      query = 'SELECT SUM(quantity) as count FROM property_bathrooms WHERE property_id = $1 AND room_id IS NULL';
      params = [propertyId];
    }
    
    const countResult = await pool.query(query, params);
    const count = parseInt(countResult.rows[0]?.count || 0);
    
    if (roomId) {
      await pool.query('UPDATE bookable_units SET num_bathrooms = $1 WHERE id = $2', [count, roomId]);
    } else {
      // Update all rooms for this property
      await pool.query('UPDATE bookable_units SET num_bathrooms = $1 WHERE property_id = $2', [count, propertyId]);
    }
  } catch (e) {
    console.log('Error updating bathroom count:', e.message);
  }
}

// =========================================================
// MARKETING FEATURES API (Property & Room Level)
// =========================================================

// GET /api/properties/:id/features - Load property-wide features
app.get('/api/properties/:id/features', async (req, res) => {
  try {
    const propertyId = req.params.id;
    
    const result = await pool.query(`
      SELECT pf.*, 
             COALESCE(
               (SELECT json_agg(room_id) FROM property_feature_exclusions WHERE feature_id = pf.id),
               '[]'
             ) as excluded_room_ids
      FROM property_features pf
      WHERE pf.property_id = $1 AND pf.room_id IS NULL
      ORDER BY pf.category, pf.feature_name
    `, [propertyId]);
    
    res.json({ success: true, features: result.rows });
  } catch (error) {
    console.error('Error loading property features:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/properties/:id/features - Save property-wide features
app.post('/api/properties/:id/features', async (req, res) => {
  const client = await pool.connect();
  try {
    const propertyId = req.params.id;
    const { features } = req.body;
    const applyToRooms = req.query.apply_to_rooms === 'true';
    
    await client.query('BEGIN');
    
    // Delete existing property-level features
    await client.query('DELETE FROM property_features WHERE property_id = $1 AND room_id IS NULL', [propertyId]);
    
    // Insert new features
    for (const feature of features) {
      const result = await client.query(`
        INSERT INTO property_features (property_id, room_id, feature_name, category, is_custom)
        VALUES ($1, NULL, $2, $3, $4)
        RETURNING id
      `, [propertyId, feature.feature_name, feature.category, feature.is_custom || false]);
      
      // Handle room exclusions
      if (feature.excluded_room_ids && feature.excluded_room_ids.length > 0) {
        for (const roomId of feature.excluded_room_ids) {
          await client.query(
            'INSERT INTO property_feature_exclusions (feature_id, room_id) VALUES ($1, $2)',
            [result.rows[0].id, roomId]
          );
        }
      }
    }
    
    // If apply_to_rooms, copy to all rooms
    if (applyToRooms) {
      const rooms = await client.query(
        'SELECT id FROM bookable_units WHERE property_id = $1',
        [propertyId]
      );
      
      for (const room of rooms.rows) {
        // Clear existing room features
        await client.query('DELETE FROM property_features WHERE room_id = $1', [room.id]);
        
        // Copy property features to room
        for (const feature of features) {
          await client.query(`
            INSERT INTO property_features (property_id, room_id, feature_name, category, is_custom)
            VALUES ($1, $2, $3, $4, $5)
          `, [propertyId, room.id, feature.feature_name, feature.category, feature.is_custom || false]);
        }
      }
    }
    
    await client.query('COMMIT');
    res.json({ success: true, message: 'Features saved successfully' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error saving property features:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// GET /api/rooms/:id/features - Load room-specific features
app.get('/api/rooms/:id/features', async (req, res) => {
  try {
    const roomId = req.params.id;
    
    // First try to get room-specific features
    let result = await pool.query(`
      SELECT * FROM property_features
      WHERE room_id = $1
      ORDER BY category, feature_name
    `, [roomId]);
    
    // If no room-specific features, fall back to property features
    if (result.rows.length === 0) {
      result = await pool.query(`
        SELECT pf.*, 
               COALESCE(
                 (SELECT json_agg(room_id) FROM property_feature_exclusions WHERE feature_id = pf.id),
                 '[]'
               ) as excluded_room_ids
        FROM property_features pf
        JOIN bookable_units bu ON bu.property_id = pf.property_id
        WHERE bu.id = $1 AND pf.room_id IS NULL
          AND NOT EXISTS (
            SELECT 1 FROM property_feature_exclusions pfe 
            WHERE pfe.feature_id = pf.id AND pfe.room_id = $1
          )
        ORDER BY pf.category, pf.feature_name
      `, [roomId]);
    }
    
    res.json({ success: true, features: result.rows });
  } catch (error) {
    console.error('Error loading room features:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/rooms/:id/features - Save room-specific features
app.post('/api/rooms/:id/features', async (req, res) => {
  const client = await pool.connect();
  try {
    const roomId = req.params.id;
    const { features, property_id } = req.body;
    
    await client.query('BEGIN');
    
    // Delete existing room-specific features
    await client.query('DELETE FROM property_features WHERE room_id = $1', [roomId]);
    
    // Insert new features
    for (const feature of features) {
      await client.query(`
        INSERT INTO property_features (property_id, room_id, feature_name, category, is_custom)
        VALUES ($1, $2, $3, $4, $5)
      `, [property_id, roomId, feature.feature_name, feature.category, feature.is_custom || false]);
    }
    
    await client.query('COMMIT');
    res.json({ success: true, message: 'Room features saved successfully' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error saving room features:', error);
    res.status(500).json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// =====================================================
// OCCUPANCY PRICING - Per-room settings
// =====================================================

// GET /api/rooms/:id/occupancy-settings - Get occupancy pricing settings
app.get('/api/rooms/:id/occupancy-settings', async (req, res) => {
  try {
    const roomId = req.params.id;
    
    const result = await pool.query(`
      SELECT 
        bu.id,
        bu.name,
        bu.max_guests,
        bu.pricing_mode,
        bu.base_occupancy,
        bu.extra_adult_type,
        bu.extra_adult_charge,
        bu.single_discount_type,
        bu.single_discount_value,
        bu.child_charge_type,
        bu.child_charge,
        bu.children_allowed,
        p.child_max_age
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [roomId]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Error getting occupancy settings:', error);
    res.json({ success: false, error: error.message });
  }
});

// PUT /api/rooms/:id/occupancy-settings - Save occupancy pricing settings
app.put('/api/rooms/:id/occupancy-settings', async (req, res) => {
  try {
    const roomId = req.params.id;
    const {
      pricing_mode,
      base_occupancy,
      extra_adult_type,
      extra_adult_charge,
      single_discount_type,
      single_discount_value,
      child_charge_type,
      child_charge,
      children_allowed
    } = req.body;
    
    const result = await pool.query(`
      UPDATE bookable_units SET
        pricing_mode = COALESCE($1, pricing_mode),
        base_occupancy = COALESCE($2, base_occupancy),
        extra_adult_type = COALESCE($3, extra_adult_type),
        extra_adult_charge = COALESCE($4, extra_adult_charge),
        single_discount_type = COALESCE($5, single_discount_type),
        single_discount_value = COALESCE($6, single_discount_value),
        child_charge_type = COALESCE($7, child_charge_type),
        child_charge = COALESCE($8, child_charge),
        children_allowed = COALESCE($9, children_allowed),
        updated_at = NOW()
      WHERE id = $10
      RETURNING *
    `, [
      pricing_mode,
      base_occupancy,
      extra_adult_type,
      extra_adult_charge,
      single_discount_type,
      single_discount_value,
      child_charge_type,
      child_charge,
      children_allowed,
      roomId
    ]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    console.log(`‚úÖ Occupancy settings saved for room ${roomId}`);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Error saving occupancy settings:', error);
    res.json({ success: false, error: error.message });
  }
});

// PUT /api/properties/:id/child-max-age - Set property-level child max age
app.put('/api/properties/:id/child-max-age', async (req, res) => {
  try {
    const { id } = req.params;
    const { child_max_age } = req.body;
    
    const result = await pool.query(`
      UPDATE properties SET child_max_age = $1, updated_at = NOW()
      WHERE id = $2
      RETURNING id, name, child_max_age
    `, [child_max_age || 12, id]);
    
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// MIN STAY - Per-date settings
// =====================================================

// GET /api/rooms/:id/min-stay - Get min stay settings for date range
app.get('/api/rooms/:id/min-stay', async (req, res) => {
  try {
    const roomId = req.params.id;
    const { start_date, end_date } = req.query;
    
    const result = await pool.query(`
      SELECT date, cm_min_stay, min_stay_override,
             COALESCE(min_stay_override, cm_min_stay, 1) as effective_min_stay
      FROM room_availability
      WHERE room_id = $1 
        AND date >= $2 
        AND date <= $3
      ORDER BY date
    `, [roomId, start_date, end_date]);
    
    res.json({ success: true, data: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// PUT /api/rooms/:id/min-stay - Save min stay overrides for date range
app.put('/api/rooms/:id/min-stay', async (req, res) => {
  try {
    const roomId = req.params.id;
    const { start_date, end_date, min_stay_override } = req.body;
    
    // Update or insert for each date in range
    const startDate = new Date(start_date);
    const endDate = new Date(end_date);
    
    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0];
      
      await pool.query(`
        INSERT INTO room_availability (room_id, date, min_stay_override)
        VALUES ($1, $2, $3)
        ON CONFLICT (room_id, date) 
        DO UPDATE SET min_stay_override = $3, updated_at = NOW()
      `, [roomId, dateStr, min_stay_override || null]);
    }
    
    console.log(`‚úÖ Min stay override set to ${min_stay_override} for room ${roomId} from ${start_date} to ${end_date}`);
    res.json({ success: true, message: 'Min stay updated' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// OCCUPANCY PRICE CALCULATOR - Helper endpoint
// =====================================================

// POST /api/rooms/:id/calculate-occupancy-price - Calculate price for specific occupancy
app.post('/api/rooms/:id/calculate-occupancy-price', async (req, res) => {
  try {
    const roomId = req.params.id;
    const { standard_price, adults, children } = req.body;
    
    // Get room occupancy settings
    const roomResult = await pool.query(`
      SELECT 
        bu.*,
        p.child_max_age
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [roomId]);
    
    if (roomResult.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    const room = roomResult.rows[0];
    const basePrice = parseFloat(standard_price) || 0;
    
    // If per_room mode, just return standard price
    if (room.pricing_mode === 'per_room') {
      return res.json({
        success: true,
        price: basePrice,
        breakdown: {
          standard_price: basePrice,
          adjustments: [],
          final_price: basePrice
        }
      });
    }
    
    // Calculate occupancy-adjusted price
    const baseOccupancy = room.base_occupancy || 2;
    const numAdults = parseInt(adults) || 1;
    const numChildren = parseInt(children) || 0;
    
    let adjustedPrice = basePrice;
    const adjustments = [];
    
    // Single occupancy discount
    if (numAdults === 1 && numChildren === 0 && parseFloat(room.single_discount_value) > 0) {
      let discount = 0;
      if (room.single_discount_type === 'percent') {
        discount = basePrice * (parseFloat(room.single_discount_value) / 100);
      } else {
        discount = parseFloat(room.single_discount_value);
      }
      adjustedPrice -= discount;
      adjustments.push({
        type: 'single_discount',
        description: 'Single occupancy discount',
        amount: -discount
      });
    }
    
    // Extra adults charge
    const extraAdults = Math.max(0, numAdults - baseOccupancy);
    if (extraAdults > 0 && parseFloat(room.extra_adult_charge) > 0) {
      let extraCharge = 0;
      if (room.extra_adult_type === 'percent') {
        extraCharge = basePrice * (parseFloat(room.extra_adult_charge) / 100) * extraAdults;
      } else {
        extraCharge = parseFloat(room.extra_adult_charge) * extraAdults;
      }
      adjustedPrice += extraCharge;
      adjustments.push({
        type: 'extra_adults',
        description: `${extraAdults} extra adult(s)`,
        amount: extraCharge
      });
    }
    
    // Children charge
    if (numChildren > 0 && room.child_charge_type !== 'free' && parseFloat(room.child_charge) > 0) {
      let childCharge = 0;
      if (room.child_charge_type === 'percent') {
        childCharge = basePrice * (parseFloat(room.child_charge) / 100) * numChildren;
      } else {
        childCharge = parseFloat(room.child_charge) * numChildren;
      }
      adjustedPrice += childCharge;
      adjustments.push({
        type: 'children',
        description: `${numChildren} child(ren)`,
        amount: childCharge
      });
    }
    
    res.json({
      success: true,
      price: Math.round(adjustedPrice * 100) / 100,
      breakdown: {
        standard_price: basePrice,
        base_occupancy: baseOccupancy,
        adults: numAdults,
        children: numChildren,
        adjustments,
        final_price: Math.round(adjustedPrice * 100) / 100
      }
    });
  } catch (error) {
    console.error('Error calculating occupancy price:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// BEDS24 WEBHOOK - Receive real-time updates
// =========================================================
// Configure this URL in Beds24: Settings > Account > Webhooks
// URL: https://your-domain.railway.app/api/webhooks/beds24

app.post('/api/webhooks/beds24', async (req, res) => {
  // Log EVERYTHING that comes in
  console.log('=== BEDS24 WEBHOOK RECEIVED ===');
  console.log('Headers:', JSON.stringify(req.headers));
  console.log('Body:', JSON.stringify(req.body));
  console.log('Query:', JSON.stringify(req.query));
  console.log('===============================');
  
  // Always respond 200 OK immediately so Beds24 doesn't retry
  res.status(200).json({ success: true, received: true });
  
  const client = await pool.connect();
  try {
    const webhookData = req.body;
    
    // Beds24 v2 webhook format may have booking data directly or nested
    const booking = webhookData.booking || webhookData;
    
    const eventType = webhookData.action || webhookData.type || webhookData.event || 'unknown';
    const bookingId = booking.id || booking.bookingId || webhookData.bookingId;
    const roomId = booking.roomId || webhookData.roomId;
    const propertyId = booking.propertyId || webhookData.propertyId;
    const status = booking.status || webhookData.status;
    
    console.log(`Webhook parsed - event: ${eventType}, bookingId: ${bookingId}, roomId: ${roomId}, status: ${status}`);
    
    // Handle different scenarios
    // If status is cancelled, re-open dates. Otherwise block them.
    const isCancelled = status === 'cancelled' || status === 'Cancelled' || 
                        eventType === 'cancel' || eventType === 'delete' || eventType === 'cancelled';
    
    if (roomId) {
      // Find our room by beds24_room_id
      const roomResult = await client.query(`
        SELECT id FROM bookable_units WHERE beds24_room_id = $1
      `, [roomId]);
      
      if (roomResult.rows.length > 0) {
        const ourRoomId = roomResult.rows[0].id;
        const arrival = booking.arrival || booking.firstNight || webhookData.arrival;
        const departure = booking.departure || booking.lastNight || webhookData.departure;
        
        console.log(`Found our room ${ourRoomId}, arrival: ${arrival}, departure: ${departure}, cancelled: ${isCancelled}`);
        
        if (arrival && departure) {
          const startDate = new Date(arrival);
          const endDate = new Date(departure);
          
          await client.query('BEGIN');
          
          // If cancelled, update the GAS booking status
          if (isCancelled && bookingId) {
            const updateResult = await client.query(`
              UPDATE bookings 
              SET status = 'cancelled', cancelled_time = NOW(), updated_at = NOW()
              WHERE beds24_booking_id = $1 AND status != 'cancelled'
              RETURNING id
            `, [bookingId.toString()]);
            
            if (updateResult.rowCount > 0) {
              console.log(`‚úÖ Cancelled GAS booking ${updateResult.rows[0].id} via webhook (Beds24 booking ${bookingId})`);
            }
          }
          
          for (let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            
            if (isCancelled) {
              // Re-open the dates (include 'booking' source from GAS bookings)
              await client.query(`
                UPDATE room_availability 
                SET is_available = true, is_blocked = false, source = 'beds24_cancel', updated_at = NOW()
                WHERE room_id = $1 AND date = $2 AND source IN ('booking', 'beds24_sync', 'beds24_webhook', 'beds24_inventory', 'beds24_cancel')
              `, [ourRoomId, dateStr]);
            } else {
              // Block the dates
              await client.query(`
                INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
                VALUES ($1, $2, false, false, 'beds24_webhook')
                ON CONFLICT (room_id, date) 
                DO UPDATE SET is_available = false, source = 'beds24_webhook', updated_at = NOW()
              `, [ourRoomId, dateStr]);
            }
          }
          
          await client.query('COMMIT');
          console.log(`‚úÖ Webhook processed: ${isCancelled ? 'UNBLOCKED' : 'BLOCKED'} room ${ourRoomId} from ${arrival} to ${departure}`);
          
          // ========== SEND PARTNER WEBHOOK FOR BEDS24 CANCELLATION ==========
          if (isCancelled && updateResult && updateResult.rowCount > 0) {
            try {
              const gasBookingId = updateResult.rows[0].id;
              const webhookResult = await sendPartnerBookingWebhook(gasBookingId, 'booking.cancelled');
              if (webhookResult.sent) {
                console.log(`[Webhook] Sent booking.cancelled for Beds24-cancelled booking ${gasBookingId}`);
              }
            } catch (webhookError) {
              console.error(`[Webhook] Error sending Beds24 cancellation webhook:`, webhookError.message);
              // Don't fail the webhook processing if partner webhook fails
            }
          }
          // ========== END PARTNER WEBHOOK ==========
        }
      } else {
        console.log(`‚ö†Ô∏è No matching room found for beds24_room_id: ${roomId}`);
      }
    } else {
      console.log('‚ö†Ô∏è No roomId in webhook payload');
    }
    
  } catch (error) {
    console.error('Webhook processing error:', error);
  } finally {
    client.release();
  }
});

// Webhook verification endpoint (some systems send a GET to verify)
app.get('/api/webhooks/beds24', (req, res) => {
  res.status(200).json({ 
    status: 'active',
    message: 'Beds24 webhook endpoint is ready',
    url: '/api/webhooks/beds24'
  });
});

// =========================================================
// ELEVATE PMS PARTNER API
// =========================================================
// Elevate is a partner (account 92) who manages multiple client sub-accounts
// All partner API calls use: /api/elevate/:apiKey/...

const ELEVATE_MASTER_ACCOUNT_ID = 92;

// Validate Elevate Partner API key (master account level)
async function validateElevatePartnerKey(apiKey) {
  // Check if this API key belongs to the Elevate master account
  const result = await pool.query(
    'SELECT id, api_key FROM accounts WHERE id = $1 AND api_key = $2 AND status = $3',
    [ELEVATE_MASTER_ACCOUNT_ID, apiKey, 'active']
  );
  
  if (result.rows.length > 0) {
    return { valid: true, accountId: ELEVATE_MASTER_ACCOUNT_ID };
  }
  
  // Fallback format check
  if (apiKey && apiKey.startsWith('gas_') && apiKey.length > 20) {
    const accountCheck = await pool.query(
      'SELECT id FROM accounts WHERE id = $1 AND api_key = $2',
      [ELEVATE_MASTER_ACCOUNT_ID, apiKey]
    );
    if (accountCheck.rows.length > 0) {
      return { valid: true, accountId: ELEVATE_MASTER_ACCOUNT_ID };
    }
  }
  
  console.log('[Elevate Partner] API key validation failed');
  return { valid: false };
}

// =====================================================
// AMENITY MATCHING HELPER FUNCTION
// =====================================================

// Amenity matching helper function - matches incoming amenities to master_amenities
async function matchAmenity(rawName, source = 'unknown') {
  const normalized = rawName.toLowerCase().trim();
  
  // 1. Exact match on amenity_code
  let match = await pool.query(`
    SELECT id, amenity_code, amenity_name, category, icon 
    FROM master_amenities 
    WHERE LOWER(amenity_code) = $1 AND is_active = true
  `, [normalized]);
  
  if (match.rows.length > 0) {
    return { matched: true, amenity: match.rows[0], match_type: 'exact_code' };
  }
  
  // 2. Exact match on amenity_name (JSONB contains)
  match = await pool.query(`
    SELECT id, amenity_code, amenity_name, category, icon 
    FROM master_amenities 
    WHERE LOWER(amenity_name::text) LIKE $1 AND is_active = true
  `, [`%${normalized}%`]);
  
  if (match.rows.length > 0) {
    return { matched: true, amenity: match.rows[0], match_type: 'exact_name' };
  }
  
  // 3. Alias match
  match = await pool.query(`
    SELECT id, amenity_code, amenity_name, category, icon 
    FROM master_amenities 
    WHERE aliases IS NOT NULL 
    AND aliases::text ILIKE $1 
    AND is_active = true
  `, [`%${normalized}%`]);
  
  if (match.rows.length > 0) {
    return { matched: true, amenity: match.rows[0], match_type: 'alias' };
  }
  
  // 4. Fuzzy match using similarity (if pg_trgm extension is available)
  try {
    match = await pool.query(`
      SELECT id, amenity_code, amenity_name, category, icon,
             similarity(LOWER(amenity_code), $1) as code_sim,
             similarity(LOWER(amenity_name::text), $1) as name_sim
      FROM master_amenities 
      WHERE is_active = true
      AND (similarity(LOWER(amenity_code), $1) > 0.3 
           OR similarity(LOWER(amenity_name::text), $1) > 0.3)
      ORDER BY GREATEST(similarity(LOWER(amenity_code), $1), similarity(LOWER(amenity_name::text), $1)) DESC
      LIMIT 1
    `, [normalized]);
    
    if (match.rows.length > 0) {
      return { matched: true, amenity: match.rows[0], match_type: 'fuzzy', confidence: Math.max(match.rows[0].code_sim, match.rows[0].name_sim) };
    }
  } catch (e) {
    // pg_trgm extension not installed, skip fuzzy matching
  }
  
  // 5. No match - log for manual mapping
  try {
    await pool.query(`
      INSERT INTO unmatched_amenities (source, raw_name, last_seen) 
      VALUES ($1, $2, NOW())
      ON CONFLICT (source, raw_name) DO UPDATE SET 
        occurrence_count = unmatched_amenities.occurrence_count + 1,
        last_seen = NOW()
    `, [source, rawName]);
  } catch (e) {
    // Table might not exist yet, ignore
  }
  
  return { matched: false, raw_name: rawName };
}

// =====================================================
// PARTNER API - TENANT MANAGEMENT
// =====================================================
// New Partner API for Elevate to manage tenants (Sub Masters)
// Base URL: /api/partner/...
// Authentication: X-API-Key header with Elevate's API key

// Validate Partner API key from header
async function validatePartnerApiKey(req) {
  const apiKey = req.headers['x-api-key'];
  if (!apiKey) {
    return { valid: false, error: 'Missing X-API-Key header' };
  }
  
  // Check if this API key belongs to an agency_admin account
  const result = await pool.query(
    `SELECT id, name, role, booking_webhook_url, webhook_secret FROM accounts 
     WHERE api_key = $1 AND status = 'active' AND role = 'agency_admin'`,
    [apiKey]
  );
  
  if (result.rows.length > 0) {
    return { 
      valid: true, 
      partnerId: result.rows[0].id, 
      partnerName: result.rows[0].name,
      webhookUrl: result.rows[0].booking_webhook_url,
      webhookSecret: result.rows[0].webhook_secret
    };
  }
  
  return { valid: false, error: 'Invalid API key' };
}

// =====================================================
// PARTNER API - WEBHOOK CONFIGURATION
// =====================================================

// PUT /api/partner/webhooks - Configure webhook URL for booking notifications
app.put('/api/partner/webhooks', async (req, res) => {
  console.log('=== PARTNER API: CONFIGURE WEBHOOKS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { booking_created, booking_cancelled } = req.body;
    
    // For now, we use one URL for all events
    const webhookUrl = booking_created || booking_cancelled;
    
    if (!webhookUrl) {
      return res.status(400).json({ 
        success: false, 
        error: 'At least one webhook URL required (booking_created or booking_cancelled)' 
      });
    }
    
    // Validate URL format
    try {
      new URL(webhookUrl);
    } catch (e) {
      return res.status(400).json({ success: false, error: 'Invalid webhook URL format' });
    }
    
    // Generate webhook secret if not exists
    let webhookSecret = auth.webhookSecret;
    if (!webhookSecret) {
      webhookSecret = 'whsec_' + require('crypto').randomBytes(24).toString('hex');
    }
    
    // Update partner account with webhook config
    await pool.query(`
      UPDATE accounts 
      SET booking_webhook_url = $1, 
          webhook_secret = $2,
          updated_at = NOW()
      WHERE id = $3
    `, [webhookUrl, webhookSecret, auth.partnerId]);
    
    console.log(`‚úÖ Webhook configured for partner ${auth.partnerName}`);
    
    res.json({ 
      success: true, 
      message: 'Webhook configured successfully',
      webhook_url: webhookUrl,
      webhook_secret: webhookSecret,
      events: ['booking.created', 'booking.cancelled']
    });
    
  } catch (error) {
    console.error('Partner API configure webhooks error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/webhooks - Get current webhook configuration
app.get('/api/partner/webhooks', async (req, res) => {
  console.log('=== PARTNER API: GET WEBHOOKS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const result = await pool.query(`
      SELECT booking_webhook_url, webhook_secret 
      FROM accounts WHERE id = $1
    `, [auth.partnerId]);
    
    const config = result.rows[0];
    
    res.json({
      success: true,
      configured: !!config.booking_webhook_url,
      webhook_url: config.booking_webhook_url || null,
      webhook_secret: config.webhook_secret || null,
      events: config.booking_webhook_url ? ['booking.created', 'booking.cancelled'] : []
    });
    
  } catch (error) {
    console.error('Partner API get webhooks error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/partner/webhooks - Remove webhook configuration
app.delete('/api/partner/webhooks', async (req, res) => {
  console.log('=== PARTNER API: DELETE WEBHOOKS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    await pool.query(`
      UPDATE accounts 
      SET booking_webhook_url = NULL, 
          webhook_secret = NULL,
          updated_at = NOW()
      WHERE id = $1
    `, [auth.partnerId]);
    
    res.json({ success: true, message: 'Webhook configuration removed' });
    
  } catch (error) {
    console.error('Partner API delete webhooks error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER WEBHOOK SENDER FUNCTION
// =====================================================

async function sendPartnerBookingWebhook(bookingId, eventType = 'booking.created') {
  const crypto = require('crypto');
  const axios = require('axios');
  
  try {
    // Get booking details with tenant/partner info
    // JOIN on bookable_unit_id (main bookings) OR room_id (Calry CM bookings)
    const bookingResult = await pool.query(`
      SELECT 
        b.*,
        bu.id as room_id,
        bu.name as room_name,
        bu.external_id as external_room_id,
        p.id as property_id,
        p.name as property_name,
        p.external_id as external_property_id,
        p.account_id,
        ptm.external_tenant_id as tenant_id,
        ptm.partner_account_id,
        pa.booking_webhook_url,
        pa.webhook_secret,
        pa.name as partner_name
      FROM bookings b
      LEFT JOIN bookable_units bu ON bu.id = COALESCE(b.bookable_unit_id, b.room_id)
      JOIN properties p ON b.property_id = p.id
      LEFT JOIN partner_tenant_mapping ptm ON p.account_id = ptm.gas_account_id
      LEFT JOIN accounts pa ON ptm.partner_account_id = pa.id
      WHERE b.id = $1
    `, [bookingId]);
    
    if (bookingResult.rows.length === 0) {
      console.log(`[Webhook] Booking ${bookingId} not found`);
      return { sent: false, reason: 'booking_not_found' };
    }
    
    const booking = bookingResult.rows[0];
    
    // Check if this booking belongs to a partner tenant with webhook configured
    if (!booking.partner_account_id || !booking.booking_webhook_url) {
      console.log(`[Webhook] No webhook configured for booking ${bookingId}`);
      return { sent: false, reason: 'no_webhook_configured' };
    }
    
    // Build webhook payload
    const timestamp = new Date().toISOString();
    const payload = {
      event: eventType,
      timestamp: timestamp,
      data: {
        booking_id: booking.id,
        group_booking_id: booking.group_booking_id || null,
        tenant_id: booking.tenant_id,
        property: {
          gas_id: booking.property_id,
          external_id: booking.external_property_id,
          name: booking.property_name
        },
        room: {
          gas_id: booking.room_id,
          external_id: booking.external_room_id,
          name: booking.room_name
        },
        dates: {
          check_in: booking.arrival_date,
          check_out: booking.departure_date,
          nights: Math.ceil((new Date(booking.departure_date) - new Date(booking.arrival_date)) / (1000 * 60 * 60 * 24))
        },
        guest: {
          first_name: booking.guest_first_name,
          last_name: booking.guest_last_name,
          email: booking.guest_email,
          phone: booking.guest_phone || null
        },
        guests: {
          adults: booking.num_adults || 1,
          children: booking.num_children || 0,
          total: (booking.num_adults || 1) + (booking.num_children || 0)
        },
        payment: {
          total: parseFloat(booking.grand_total) || 0,
          deposit: parseFloat(booking.deposit_amount) || null,
          currency: booking.currency || 'USD',
          status: booking.payment_status || 'pending',
          method: booking.stripe_payment_intent_id ? 'card' : 'property'
        },
        status: booking.status,
        source: booking.booking_source || 'direct',
        created_at: booking.created_at
      }
    };
    
    // Generate HMAC signature
    const signature = crypto
      .createHmac('sha256', booking.webhook_secret)
      .update(JSON.stringify(payload))
      .digest('hex');
    
    // Send webhook with retries
    let lastError = null;
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        console.log(`[Webhook] Sending ${eventType} to ${booking.booking_webhook_url} (attempt ${attempt})`);
        
        const response = await axios.post(booking.booking_webhook_url, payload, {
          headers: {
            'Content-Type': 'application/json',
            'X-GAS-Signature': 'sha256=' + signature,
            'X-GAS-Timestamp': timestamp,
            'X-GAS-Event': eventType,
            'User-Agent': 'GAS-Webhook/1.0'
          },
          timeout: 10000
        });
        
        console.log(`[Webhook] ‚úÖ Sent successfully to ${booking.partner_name}, status: ${response.status}`);
        
        // Log successful webhook
        await pool.query(`
          INSERT INTO webhook_logs (booking_id, partner_id, event_type, webhook_url, status, response_code, created_at)
          VALUES ($1, $2, $3, $4, 'success', $5, NOW())
        `, [bookingId, booking.partner_account_id, eventType, booking.booking_webhook_url, response.status]).catch(() => {});
        
        return { sent: true, status: response.status };
        
      } catch (err) {
        lastError = err;
        console.error(`[Webhook] Attempt ${attempt} failed:`, err.message);
        
        if (attempt < 3) {
          // Wait before retry (exponential backoff)
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    }
    
    // Log failed webhook
    await pool.query(`
      INSERT INTO webhook_logs (booking_id, partner_id, event_type, webhook_url, status, error_message, created_at)
      VALUES ($1, $2, $3, $4, 'failed', $5, NOW())
    `, [bookingId, booking.partner_account_id, eventType, booking.booking_webhook_url, lastError?.message || 'Unknown error']).catch(() => {});
    
    console.error(`[Webhook] ‚ùå All attempts failed for booking ${bookingId}`);
    return { sent: false, reason: 'all_attempts_failed', error: lastError?.message };
    
  } catch (error) {
    console.error('[Webhook] Error sending partner webhook:', error);
    return { sent: false, reason: 'error', error: error.message };
  }
}

// Migration: Create partner_tenant_mapping table and partner columns
app.post('/api/admin/migrate-partner-tenant-mapping', async (req, res) => {
  try {
    console.log('üîÑ Creating partner_tenant_mapping table...');
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS partner_tenant_mapping (
        id SERIAL PRIMARY KEY,
        partner_account_id INTEGER NOT NULL REFERENCES accounts(id),
        external_tenant_id VARCHAR(100) NOT NULL,
        gas_account_id INTEGER NOT NULL REFERENCES accounts(id),
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(partner_account_id, external_tenant_id)
      )
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_partner_tenant_partner 
      ON partner_tenant_mapping(partner_account_id)
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_partner_tenant_external 
      ON partner_tenant_mapping(external_tenant_id)
    `);
    
    console.log('   ‚úì Created partner_tenant_mapping table');
    
    // Add partner_external_id columns to properties and bookable_units
    // These are separate from cm_property_id/cm_room_id to avoid conflicts with other CMs
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS partner_external_id VARCHAR(255)`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS partner_source VARCHAR(50)`);
    await pool.query(`ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS partner_external_id VARCHAR(255)`);
    
    console.log('   ‚úì Added partner_external_id columns');
    
    // Add webhook columns to accounts for partner webhooks
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS booking_webhook_url TEXT`);
    await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS webhook_secret VARCHAR(64)`);
    
    console.log('   ‚úì Added webhook columns to accounts');
    
    // Create webhook_logs table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS webhook_logs (
        id SERIAL PRIMARY KEY,
        booking_id INTEGER REFERENCES bookings(id),
        partner_id INTEGER REFERENCES accounts(id),
        event_type VARCHAR(50) NOT NULL,
        webhook_url TEXT,
        status VARCHAR(20) NOT NULL,
        response_code INTEGER,
        error_message TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_webhook_logs_booking 
      ON webhook_logs(booking_id)
    `);
    
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_webhook_logs_partner 
      ON webhook_logs(partner_id)
    `);
    
    console.log('   ‚úì Created webhook_logs table');
    
    res.json({ success: true, message: 'Partner tenant mapping table created with webhook support' });
  } catch (error) {
    console.error('Migration error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/partner/tenants - Create a new tenant (Sub Master)
app.post('/api/partner/tenants', async (req, res) => {
  console.log('=== PARTNER API: CREATE TENANT ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenant_id, business_name, contact_email, contact_phone, country, timezone } = req.body;
    
    // Validate required fields
    if (!tenant_id) {
      return res.status(400).json({ success: false, error: 'tenant_id is required' });
    }
    if (!business_name) {
      return res.status(400).json({ success: false, error: 'business_name is required' });
    }
    
    // Check if tenant already exists
    const existingMapping = await pool.query(
      `SELECT ptm.*, a.name, a.status 
       FROM partner_tenant_mapping ptm
       JOIN accounts a ON a.id = ptm.gas_account_id
       WHERE ptm.partner_account_id = $1 AND ptm.external_tenant_id = $2`,
      [auth.partnerId, tenant_id]
    );
    
    if (existingMapping.rows.length > 0) {
      // Return existing tenant
      const existing = existingMapping.rows[0];
      return res.json({
        success: true,
        created: false,
        tenant: {
          id: existing.gas_account_id,
          tenant_id: existing.external_tenant_id,
          business_name: existing.name,
          status: existing.status,
          created_at: existing.created_at
        }
      });
    }
    
    // Create new Sub Master account
    // Use placeholder email if not provided (required field in accounts table)
    const accountEmail = contact_email || `${tenant_id}@partner.gas.travel`;
    
    const newAccount = await pool.query(
      `INSERT INTO accounts (name, email, phone, country, timezone, parent_id, role, status, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, 'submaster_admin', 'active', NOW())
       RETURNING id, name, status, created_at`,
      [business_name, accountEmail, contact_phone || null, country || null, timezone || null, auth.partnerId]
    );
    
    const newAccountId = newAccount.rows[0].id;
    
    // Create mapping
    await pool.query(
      `INSERT INTO partner_tenant_mapping (partner_account_id, external_tenant_id, gas_account_id)
       VALUES ($1, $2, $3)`,
      [auth.partnerId, tenant_id, newAccountId]
    );
    
    console.log(`[Partner API] Created tenant: ${tenant_id} -> account ${newAccountId}`);
    
    res.json({
      success: true,
      created: true,
      tenant: {
        id: newAccountId,
        tenant_id: tenant_id,
        business_name: business_name,
        status: 'active',
        created_at: newAccount.rows[0].created_at
      }
    });
    
  } catch (error) {
    console.error('Partner API create tenant error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/tenants - List all tenants for this partner
app.get('/api/partner/tenants', async (req, res) => {
  console.log('=== PARTNER API: LIST TENANTS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const result = await pool.query(
      `SELECT ptm.external_tenant_id as tenant_id, a.id, a.name as business_name, 
              a.email as contact_email, a.phone as contact_phone, a.status, a.created_at
       FROM partner_tenant_mapping ptm
       JOIN accounts a ON a.id = ptm.gas_account_id
       WHERE ptm.partner_account_id = $1
       ORDER BY a.created_at DESC`,
      [auth.partnerId]
    );
    
    res.json({
      success: true,
      tenants: result.rows.map(row => ({
        id: row.id,
        tenant_id: row.tenant_id,
        business_name: row.business_name,
        contact_email: row.contact_email,
        contact_phone: row.contact_phone,
        status: row.status,
        created_at: row.created_at
      }))
    });
    
  } catch (error) {
    console.error('Partner API list tenants error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/tenants/:tenantId - Get single tenant details
app.get('/api/partner/tenants/:tenantId', async (req, res) => {
  console.log('=== PARTNER API: GET TENANT ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    
    const result = await pool.query(
      `SELECT ptm.external_tenant_id as tenant_id, a.id, a.name as business_name, 
              a.email as contact_email, a.phone as contact_phone, a.country, a.timezone,
              a.status, a.created_at,
              (SELECT COUNT(*) FROM properties WHERE account_id = a.id) as property_count
       FROM partner_tenant_mapping ptm
       JOIN accounts a ON a.id = ptm.gas_account_id
       WHERE ptm.partner_account_id = $1 AND ptm.external_tenant_id = $2`,
      [auth.partnerId, tenantId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const row = result.rows[0];
    res.json({
      success: true,
      tenant: {
        id: row.id,
        tenant_id: row.tenant_id,
        business_name: row.business_name,
        contact_email: row.contact_email,
        contact_phone: row.contact_phone,
        country: row.country,
        timezone: row.timezone,
        status: row.status,
        created_at: row.created_at,
        property_count: parseInt(row.property_count)
      }
    });
    
  } catch (error) {
    console.error('Partner API get tenant error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/tenants/:tenantId - Update tenant details
app.put('/api/partner/tenants/:tenantId', async (req, res) => {
  console.log('=== PARTNER API: UPDATE TENANT ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    const { business_name, contact_email, contact_phone, country, timezone } = req.body;
    
    // Find the tenant
    const mapping = await pool.query(
      `SELECT gas_account_id FROM partner_tenant_mapping 
       WHERE partner_account_id = $1 AND external_tenant_id = $2`,
      [auth.partnerId, tenantId]
    );
    
    if (mapping.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const accountId = mapping.rows[0].gas_account_id;
    
    // Build update query
    const updates = [];
    const values = [];
    let paramIndex = 1;
    
    if (business_name !== undefined) {
      updates.push(`name = $${paramIndex++}`);
      values.push(business_name);
    }
    if (contact_email !== undefined) {
      updates.push(`email = $${paramIndex++}`);
      values.push(contact_email);
    }
    if (contact_phone !== undefined) {
      updates.push(`phone = $${paramIndex++}`);
      values.push(contact_phone);
    }
    if (country !== undefined) {
      updates.push(`country = $${paramIndex++}`);
      values.push(country);
    }
    if (timezone !== undefined) {
      updates.push(`timezone = $${paramIndex++}`);
      values.push(timezone);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ success: false, error: 'No fields to update' });
    }
    
    updates.push(`updated_at = NOW()`);
    values.push(accountId);
    
    await pool.query(
      `UPDATE accounts SET ${updates.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    
    // Also update mapping timestamp
    await pool.query(
      `UPDATE partner_tenant_mapping SET updated_at = NOW() 
       WHERE partner_account_id = $1 AND external_tenant_id = $2`,
      [auth.partnerId, tenantId]
    );
    
    res.json({ success: true, message: 'Tenant updated' });
    
  } catch (error) {
    console.error('Partner API update tenant error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER API - STRIPE CONFIGURATION (Property Level)
// =====================================================

// PUT /api/partner/properties/:propertyId/stripe - Configure Stripe credentials for a property
app.put('/api/partner/properties/:propertyId/stripe', async (req, res) => {
  console.log('=== PARTNER API: CONFIGURE PROPERTY STRIPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { propertyId } = req.params;
    const { stripe_publishable_key, stripe_secret_key } = req.body;
    
    // Validate required fields
    if (!stripe_publishable_key || !stripe_secret_key) {
      return res.status(400).json({ 
        success: false, 
        error: 'Both stripe_publishable_key and stripe_secret_key are required' 
      });
    }
    
    // Validate key formats
    if (!stripe_publishable_key.startsWith('pk_')) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid publishable key format. Must start with pk_' 
      });
    }
    
    if (!stripe_secret_key.startsWith('sk_') && !stripe_secret_key.startsWith('rk_')) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid secret key format. Must start with sk_ or rk_' 
      });
    }
    
    // Find the property - can be GAS ID or external_id
    let property;
    const numericId = parseInt(propertyId);
    
    if (!isNaN(numericId)) {
      // Try as GAS property ID first
      const result = await pool.query(
        `SELECT p.id, p.account_id, p.name, a.id as account_id
         FROM properties p
         JOIN accounts a ON p.account_id = a.id
         JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
         WHERE p.id = $1 AND ptm.partner_account_id = $2`,
        [numericId, auth.partnerId]
      );
      property = result.rows[0];
    }
    
    if (!property) {
      // Try as external_id
      const result = await pool.query(
        `SELECT p.id, p.account_id, p.name
         FROM properties p
         JOIN accounts a ON p.account_id = a.id
         JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
         WHERE p.external_id = $1 AND ptm.partner_account_id = $2`,
        [propertyId, auth.partnerId]
      );
      property = result.rows[0];
    }
    
    if (!property) {
      return res.status(404).json({ success: false, error: 'Property not found or not owned by your tenant' });
    }
    
    // Validate the Stripe keys by testing them
    try {
      const testStripe = new Stripe(stripe_secret_key);
      await testStripe.balance.retrieve();
      console.log('‚úÖ Stripe keys validated successfully');
    } catch (stripeError) {
      console.error('Stripe validation error:', stripeError.message);
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid Stripe keys. Please check and try again.',
        details: stripeError.message
      });
    }
    
    // Generate payment_account_id for new configs
    const paymentAccountId = 'pa_' + require('crypto').randomBytes(8).toString('hex');
    
    // Store in payment_configurations table at property level
    const result = await pool.query(`
      INSERT INTO payment_configurations (account_id, property_id, provider, name, is_enabled, credentials, is_default, payment_account_id, updated_at)
      VALUES ($1, $2, 'stripe', 'Stripe', true, $3, true, $4, NOW())
      ON CONFLICT ON CONSTRAINT unique_provider_per_scope 
      DO UPDATE SET 
        credentials = $3,
        is_enabled = true,
        updated_at = NOW()
      RETURNING id, payment_account_id
    `, [
      property.account_id,
      property.id,
      JSON.stringify({
        publishable_key: stripe_publishable_key,
        secret_key: stripe_secret_key
      }),
      paymentAccountId
    ]);
    
    console.log(`‚úÖ Stripe configured for property ${property.id} (${property.name})`);
    
    res.json({ 
      success: true, 
      message: 'Stripe credentials configured successfully',
      property_id: property.id,
      property_name: property.name,
      stripe_configured: true,
      configuration_id: result.rows[0].id
    });
    
  } catch (error) {
    console.error('Partner API configure property Stripe error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/properties/:propertyId/stripe - Check Stripe configuration status
app.get('/api/partner/properties/:propertyId/stripe', async (req, res) => {
  console.log('=== PARTNER API: GET PROPERTY STRIPE STATUS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { propertyId } = req.params;
    
    // Find the property
    let property;
    const numericId = parseInt(propertyId);
    
    if (!isNaN(numericId)) {
      const result = await pool.query(
        `SELECT p.id, p.account_id, p.name
         FROM properties p
         JOIN accounts a ON p.account_id = a.id
         JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
         WHERE p.id = $1 AND ptm.partner_account_id = $2`,
        [numericId, auth.partnerId]
      );
      property = result.rows[0];
    }
    
    if (!property) {
      const result = await pool.query(
        `SELECT p.id, p.account_id, p.name
         FROM properties p
         JOIN accounts a ON p.account_id = a.id
         JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
         WHERE p.external_id = $1 AND ptm.partner_account_id = $2`,
        [propertyId, auth.partnerId]
      );
      property = result.rows[0];
    }
    
    if (!property) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    // Check for Stripe configuration at property level
    const config = await pool.query(`
      SELECT id, is_enabled, credentials, updated_at
      FROM payment_configurations
      WHERE property_id = $1 AND provider = 'stripe'
    `, [property.id]);
    
    if (config.rows.length === 0) {
      return res.json({
        success: true,
        property_id: property.id,
        property_name: property.name,
        stripe_configured: false,
        message: 'Stripe not configured for this property'
      });
    }
    
    const stripeConfig = config.rows[0];
    const hasPublishableKey = !!stripeConfig.credentials?.publishable_key;
    const hasSecretKey = !!stripeConfig.credentials?.secret_key;
    
    res.json({
      success: true,
      property_id: property.id,
      property_name: property.name,
      stripe_configured: hasPublishableKey && hasSecretKey,
      stripe_enabled: stripeConfig.is_enabled,
      has_publishable_key: hasPublishableKey,
      has_secret_key: hasSecretKey,
      last_updated: stripeConfig.updated_at
    });
    
  } catch (error) {
    console.error('Partner API get property Stripe status error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/partner/properties/:propertyId/stripe - Remove Stripe configuration
app.delete('/api/partner/properties/:propertyId/stripe', async (req, res) => {
  console.log('=== PARTNER API: REMOVE PROPERTY STRIPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { propertyId } = req.params;
    
    // Find the property
    let property;
    const numericId = parseInt(propertyId);
    
    if (!isNaN(numericId)) {
      const result = await pool.query(
        `SELECT p.id, p.name
         FROM properties p
         JOIN accounts a ON p.account_id = a.id
         JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
         WHERE p.id = $1 AND ptm.partner_account_id = $2`,
        [numericId, auth.partnerId]
      );
      property = result.rows[0];
    }
    
    if (!property) {
      const result = await pool.query(
        `SELECT p.id, p.name
         FROM properties p
         JOIN accounts a ON p.account_id = a.id
         JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
         WHERE p.external_id = $1 AND ptm.partner_account_id = $2`,
        [propertyId, auth.partnerId]
      );
      property = result.rows[0];
    }
    
    if (!property) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    // Delete Stripe configuration
    await pool.query(`
      DELETE FROM payment_configurations
      WHERE property_id = $1 AND provider = 'stripe'
    `, [property.id]);
    
    console.log(`‚úÖ Stripe configuration removed for property ${property.id}`);
    
    res.json({ 
      success: true, 
      message: 'Stripe configuration removed',
      property_id: property.id,
      property_name: property.name,
      stripe_configured: false
    });
    
  } catch (error) {
    console.error('Partner API remove property Stripe error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/tenants/:tenantId/stripe-status - Get Stripe status for all tenant properties
app.get('/api/partner/tenants/:tenantId/stripe-status', async (req, res) => {
  console.log('=== PARTNER API: GET TENANT STRIPE STATUS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    
    // Find the tenant
    const mapping = await pool.query(
      `SELECT gas_account_id FROM partner_tenant_mapping 
       WHERE partner_account_id = $1 AND external_tenant_id = $2`,
      [auth.partnerId, tenantId]
    );
    
    if (mapping.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const accountId = mapping.rows[0].gas_account_id;
    
    // Get all properties with their Stripe status
    const properties = await pool.query(`
      SELECT 
        p.id,
        p.name,
        p.external_id,
        pc.id as stripe_config_id,
        pc.is_enabled as stripe_enabled,
        CASE WHEN pc.credentials->>'publishable_key' IS NOT NULL THEN true ELSE false END as has_publishable_key,
        CASE WHEN pc.credentials->>'secret_key' IS NOT NULL THEN true ELSE false END as has_secret_key,
        pc.updated_at as stripe_updated_at
      FROM properties p
      LEFT JOIN payment_configurations pc ON p.id = pc.property_id AND pc.provider = 'stripe'
      WHERE p.account_id = $1
      ORDER BY p.name
    `, [accountId]);
    
    const propertiesWithStripe = properties.rows.filter(p => p.has_publishable_key && p.has_secret_key);
    const uniqueStripeAccounts = new Set();
    
    // Count unique Stripe accounts (by checking if keys are different)
    for (const prop of propertiesWithStripe) {
      if (prop.stripe_config_id) {
        uniqueStripeAccounts.add(prop.stripe_config_id);
      }
    }
    
    res.json({
      success: true,
      tenant_id: tenantId,
      total_properties: properties.rows.length,
      properties_with_stripe: propertiesWithStripe.length,
      multi_unit_booking_enabled: uniqueStripeAccounts.size <= 1,
      properties: properties.rows.map(p => ({
        property_id: p.id,
        property_name: p.name,
        external_id: p.external_id,
        stripe_configured: p.has_publishable_key && p.has_secret_key,
        stripe_enabled: p.stripe_enabled || false,
        last_updated: p.stripe_updated_at
      }))
    });
    
  } catch (error) {
    console.error('Partner API get tenant Stripe status error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER API - HELPER FUNCTIONS
// =====================================================

// Helper function to get tenant's GAS account ID
async function getTenantAccountId(partnerId, tenantId) {
  const result = await pool.query(
    `SELECT gas_account_id FROM partner_tenant_mapping 
     WHERE partner_account_id = $1 AND external_tenant_id = $2`,
    [partnerId, tenantId]
  );
  return result.rows.length > 0 ? result.rows[0].gas_account_id : null;
}

// =====================================================
// PARTNER API - ROOM TYPES (Grouping)
// =====================================================
// Room Types allow grouping multiple properties/rooms for website display
// e.g., "Studio Apartment" group containing Room 1, 2, 3

// Migration: Create room_types table
app.post('/api/admin/migrate-room-types', async (req, res) => {
  try {
    console.log('üîÑ Creating room_types table...');
    
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_types (
        id SERIAL PRIMARY KEY,
        account_id INTEGER NOT NULL REFERENCES accounts(id),
        name VARCHAR(255) NOT NULL,
        description TEXT,
        display_order INTEGER DEFAULT 0,
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created room_types table');
    
    // Add room_type_id to bookable_units (optional grouping)
    await pool.query(`
      ALTER TABLE bookable_units 
      ADD COLUMN IF NOT EXISTS room_type_id INTEGER REFERENCES room_types(id)
    `);
    console.log('   ‚úì Added room_type_id to bookable_units');
    
    // Add room_type_id to properties (optional grouping)
    await pool.query(`
      ALTER TABLE properties 
      ADD COLUMN IF NOT EXISTS room_type_id INTEGER REFERENCES room_types(id)
    `);
    console.log('   ‚úì Added room_type_id to properties');
    
    // Create index
    await pool.query(`
      CREATE INDEX IF NOT EXISTS idx_room_types_account 
      ON room_types(account_id)
    `);
    
    res.json({ success: true, message: 'Room types table created' });
  } catch (error) {
    console.error('Migration error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/partner/tenants/:tenantId/room-types - Create room type
app.post('/api/partner/tenants/:tenantId/room-types', async (req, res) => {
  console.log('=== PARTNER API: CREATE ROOM TYPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    const { name, description, display_order } = req.body;
    
    if (!name) {
      return res.status(400).json({ success: false, error: 'name is required' });
    }
    
    const accountId = await getTenantAccountId(auth.partnerId, tenantId);
    if (!accountId) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const result = await pool.query(`
      INSERT INTO room_types (account_id, name, description, display_order)
      VALUES ($1, $2, $3, $4)
      RETURNING id, name, description, display_order, is_active, created_at
    `, [accountId, name, description || null, display_order || 0]);
    
    const roomType = result.rows[0];
    
    res.json({
      success: true,
      room_type: {
        id: roomType.id,
        name: roomType.name,
        description: roomType.description,
        display_order: roomType.display_order,
        property_count: 0,
        status: roomType.is_active ? 'active' : 'inactive'
      }
    });
    
  } catch (error) {
    console.error('Partner API create room type error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/tenants/:tenantId/room-types - List room types
app.get('/api/partner/tenants/:tenantId/room-types', async (req, res) => {
  console.log('=== PARTNER API: LIST ROOM TYPES ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    
    const accountId = await getTenantAccountId(auth.partnerId, tenantId);
    if (!accountId) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const result = await pool.query(`
      SELECT 
        rt.id, rt.name, rt.description, rt.display_order, rt.is_active, rt.created_at,
        COUNT(DISTINCT bu.id) as unit_count,
        COUNT(DISTINCT p.id) as property_count
      FROM room_types rt
      LEFT JOIN bookable_units bu ON bu.room_type_id = rt.id
      LEFT JOIN properties p ON p.room_type_id = rt.id
      WHERE rt.account_id = $1
      GROUP BY rt.id
      ORDER BY rt.display_order, rt.name
    `, [accountId]);
    
    res.json({
      success: true,
      room_types: result.rows.map(row => ({
        id: row.id,
        name: row.name,
        description: row.description,
        display_order: row.display_order,
        unit_count: parseInt(row.unit_count),
        property_count: parseInt(row.property_count),
        status: row.is_active ? 'active' : 'inactive',
        created_at: row.created_at
      }))
    });
    
  } catch (error) {
    console.error('Partner API list room types error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/room-types/:roomTypeId - Get single room type with assigned units
app.get('/api/partner/room-types/:roomTypeId', async (req, res) => {
  console.log('=== PARTNER API: GET ROOM TYPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { roomTypeId } = req.params;
    
    // Get room type (verify it belongs to partner's tenant)
    const rtResult = await pool.query(`
      SELECT rt.*, a.parent_id
      FROM room_types rt
      JOIN accounts a ON a.id = rt.account_id
      WHERE rt.id = $1 AND a.parent_id = $2
    `, [roomTypeId, auth.partnerId]);
    
    if (rtResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room type not found' });
    }
    
    const rt = rtResult.rows[0];
    
    // Get assigned units
    const units = await pool.query(`
      SELECT bu.id, bu.name, bu.partner_external_id as elevate_id, 
             bu.max_guests, bu.num_bedrooms as bedrooms, bu.num_bathrooms as bathrooms,
             p.id as property_id, p.name as property_name
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      WHERE bu.room_type_id = $1
      ORDER BY bu.name
    `, [roomTypeId]);
    
    res.json({
      success: true,
      room_type: {
        id: rt.id,
        name: rt.name,
        description: rt.description,
        display_order: rt.display_order,
        status: rt.is_active ? 'active' : 'inactive',
        created_at: rt.created_at,
        units: units.rows.map(u => ({
          id: u.id,
          elevate_id: u.elevate_id,
          name: u.name,
          property_id: u.property_id,
          property_name: u.property_name,
          max_guests: u.max_guests,
          bedrooms: u.bedrooms,
          bathrooms: u.bathrooms
        }))
      }
    });
    
  } catch (error) {
    console.error('Partner API get room type error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/room-types/:roomTypeId - Update room type
app.put('/api/partner/room-types/:roomTypeId', async (req, res) => {
  console.log('=== PARTNER API: UPDATE ROOM TYPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { roomTypeId } = req.params;
    const { name, description, display_order, is_active } = req.body;
    
    // Verify room type belongs to partner's tenant
    const rtCheck = await pool.query(`
      SELECT rt.id FROM room_types rt
      JOIN accounts a ON a.id = rt.account_id
      WHERE rt.id = $1 AND a.parent_id = $2
    `, [roomTypeId, auth.partnerId]);
    
    if (rtCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room type not found' });
    }
    
    const updates = [];
    const values = [];
    let idx = 1;
    
    if (name !== undefined) { updates.push(`name = $${idx++}`); values.push(name); }
    if (description !== undefined) { updates.push(`description = $${idx++}`); values.push(description); }
    if (display_order !== undefined) { updates.push(`display_order = $${idx++}`); values.push(display_order); }
    if (is_active !== undefined) { updates.push(`is_active = $${idx++}`); values.push(is_active); }
    
    if (updates.length === 0) {
      return res.status(400).json({ success: false, error: 'No fields to update' });
    }
    
    updates.push(`updated_at = NOW()`);
    values.push(roomTypeId);
    
    await pool.query(
      `UPDATE room_types SET ${updates.join(', ')} WHERE id = $${idx}`,
      values
    );
    
    res.json({ success: true, message: 'Room type updated' });
    
  } catch (error) {
    console.error('Partner API update room type error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/room-types/:roomTypeId/units - Assign units to room type
app.put('/api/partner/room-types/:roomTypeId/units', async (req, res) => {
  console.log('=== PARTNER API: ASSIGN UNITS TO ROOM TYPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { roomTypeId } = req.params;
    const { unit_ids } = req.body; // Array of bookable_unit IDs
    
    if (!unit_ids || !Array.isArray(unit_ids)) {
      return res.status(400).json({ success: false, error: 'unit_ids array is required' });
    }
    
    // Verify room type belongs to partner's tenant
    const rtCheck = await pool.query(`
      SELECT rt.id, rt.account_id FROM room_types rt
      JOIN accounts a ON a.id = rt.account_id
      WHERE rt.id = $1 AND a.parent_id = $2
    `, [roomTypeId, auth.partnerId]);
    
    if (rtCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room type not found' });
    }
    
    const accountId = rtCheck.rows[0].account_id;
    
    // Clear existing assignments for this room type
    await pool.query(`UPDATE bookable_units SET room_type_id = NULL WHERE room_type_id = $1`, [roomTypeId]);
    
    // Assign new units (verify they belong to the same account)
    let assigned = 0;
    for (const unitId of unit_ids) {
      const result = await pool.query(`
        UPDATE bookable_units bu
        SET room_type_id = $1
        FROM properties p
        WHERE bu.id = $2 
        AND bu.property_id = p.id 
        AND p.account_id = $3
      `, [roomTypeId, unitId, accountId]);
      
      if (result.rowCount > 0) assigned++;
    }
    
    res.json({ 
      success: true, 
      message: `Assigned ${assigned} units to room type`,
      assigned_count: assigned
    });
    
  } catch (error) {
    console.error('Partner API assign units error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/partner/room-types/:roomTypeId - Delete room type
app.delete('/api/partner/room-types/:roomTypeId', async (req, res) => {
  console.log('=== PARTNER API: DELETE ROOM TYPE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { roomTypeId } = req.params;
    
    // Verify room type belongs to partner's tenant
    const rtCheck = await pool.query(`
      SELECT rt.id FROM room_types rt
      JOIN accounts a ON a.id = rt.account_id
      WHERE rt.id = $1 AND a.parent_id = $2
    `, [roomTypeId, auth.partnerId]);
    
    if (rtCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room type not found' });
    }
    
    // Clear unit assignments first
    await pool.query(`UPDATE bookable_units SET room_type_id = NULL WHERE room_type_id = $1`, [roomTypeId]);
    await pool.query(`UPDATE properties SET room_type_id = NULL WHERE room_type_id = $1`, [roomTypeId]);
    
    // Delete room type
    await pool.query(`DELETE FROM room_types WHERE id = $1`, [roomTypeId]);
    
    res.json({ success: true, message: 'Room type deleted' });
    
  } catch (error) {
    console.error('Partner API delete room type error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER API - WEBSITES
// =====================================================
// Websites allow tenants to have multiple booking sites
// Each site can display different rooms/units

// Migration: Add turbine_campaigns columns
app.post('/api/admin/migrate-turbines', async (req, res) => {
  try {
    console.log('üîÑ Adding turbine_campaigns columns...');
    await pool.query(`ALTER TABLE turbine_campaigns ADD COLUMN IF NOT EXISTS offer_code VARCHAR(20) UNIQUE`);
    await pool.query(`ALTER TABLE turbine_campaigns ADD COLUMN IF NOT EXISTS hero_image_url TEXT`);
    console.log('   ‚úì Added offer_code and hero_image_url columns');
    res.json({ success: true, message: 'Turbines migration complete' });
  } catch (error) {
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Migration: Create travellers tables
app.post('/api/admin/migrate-travellers', async (req, res) => {
  try {
    console.log('üîÑ Creating travellers tables...');
    
    // Travellers table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS travellers (
        id SERIAL PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        phone VARCHAR(50),
        phone_verified BOOLEAN DEFAULT false,
        first_name VARCHAR(100),
        last_name VARCHAR(100),
        address TEXT,
        city VARCHAR(100),
        country VARCHAR(100),
        postal_code VARCHAR(20),
        password_hash VARCHAR(255),
        avatar_url TEXT,
        preferred_currency VARCHAR(10) DEFAULT 'USD',
        preferred_language VARCHAR(10) DEFAULT 'en',
        location_preferences JSONB DEFAULT '[]',
        interests JSONB DEFAULT '[]',
        status VARCHAR(20) DEFAULT 'lead',
        marketing_opt_in BOOLEAN DEFAULT false,
        last_login_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created travellers table');
    
    // Traveller-Account links
    await pool.query(`
      CREATE TABLE IF NOT EXISTS traveller_property_links (
        id SERIAL PRIMARY KEY,
        traveller_id INTEGER REFERENCES travellers(id) ON DELETE CASCADE,
        account_id INTEGER REFERENCES accounts(id) ON DELETE CASCADE,
        property_id INTEGER REFERENCES properties(id) ON DELETE SET NULL,
        first_booking_id INTEGER,
        total_bookings INTEGER DEFAULT 1,
        total_spent DECIMAL(10,2) DEFAULT 0,
        last_stay_date DATE,
        source VARCHAR(50),
        tags JSONB DEFAULT '[]',
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(traveller_id, account_id)
      )
    `);
    console.log('   ‚úì Created traveller_property_links table');
    
    // Traveller experiences (UGC)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS traveller_experiences (
        id SERIAL PRIMARY KEY,
        traveller_id INTEGER REFERENCES travellers(id) ON DELETE CASCADE,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE SET NULL,
        booking_id INTEGER,
        media_type VARCHAR(20),
        media_url TEXT,
        thumbnail_url TEXT,
        caption TEXT,
        rating INTEGER,
        qr_code_used VARCHAR(50),
        status VARCHAR(20) DEFAULT 'pending',
        approved_by INTEGER,
        approved_at TIMESTAMP,
        view_count INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    console.log('   ‚úì Created traveller_experiences table');
    
    res.json({ success: true, message: 'Travellers tables created' });
  } catch (error) {
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Migration: Sync existing bookings to travellers
app.post('/api/admin/sync-bookings-to-travellers', async (req, res) => {
  try {
    console.log('üîÑ Syncing bookings to travellers...');
    
    // Get all bookings with guest email
    const bookings = await pool.query(`
      SELECT b.id, b.guest_email, b.guest_phone, b.guest_first_name, b.guest_last_name,
             b.guest_address, b.guest_country, b.grand_total,
             p.account_id, b.property_id, b.arrival_date
      FROM bookings b
      JOIN properties p ON p.id = b.property_id
      WHERE b.guest_email IS NOT NULL AND b.guest_email != ''
      ORDER BY b.created_at ASC
    `);
    
    let created = 0;
    let linked = 0;
    
    for (const booking of bookings.rows) {
      const result = await findOrCreateTraveller(pool, {
        email: booking.guest_email,
        phone: booking.guest_phone,
        first_name: booking.guest_first_name,
        last_name: booking.guest_last_name,
        address: booking.guest_address,
        country: booking.guest_country
      }, booking.account_id, booking.property_id, booking.id, booking.grand_total);
      
      if (result) {
        if (result.created_at && new Date(result.created_at) > new Date(Date.now() - 5000)) {
          created++;
        }
        linked++;
      }
    }
    
    console.log(`   ‚úì Processed ${bookings.rows.length} bookings, created ${created} travellers, ${linked} links`);
    
    res.json({ 
      success: true, 
      message: `Synced ${bookings.rows.length} bookings`,
      travellers_created: created,
      links_created: linked
    });
  } catch (error) {
    console.error('Sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Migration: Create websites tables
app.post('/api/admin/migrate-websites', async (req, res) => {
  try {
    console.log('üîÑ Creating websites tables...');
    
    // Extend existing columns that might be too short
    await pool.query(`ALTER TABLE websites ALTER COLUMN name TYPE VARCHAR(255)`).catch(() => {});
    await pool.query(`ALTER TABLE websites ALTER COLUMN subdomain TYPE VARCHAR(100)`).catch(() => {});
    await pool.query(`ALTER TABLE websites ALTER COLUMN primary_color TYPE VARCHAR(50)`).catch(() => {});
    await pool.query(`ALTER TABLE websites ALTER COLUMN secondary_color TYPE VARCHAR(50)`).catch(() => {});
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS deployed_site_id INTEGER REFERENCES deployed_sites(id)`);
    console.log('   ‚úì Extended column sizes');
    
    // Add columns if they don't exist
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS account_id INTEGER REFERENCES accounts(id)`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS subdomain VARCHAR(100)`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS custom_domain VARCHAR(255)`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS description TEXT`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS logo_url VARCHAR(500)`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS primary_color VARCHAR(50) DEFAULT '#3B82F6'`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS secondary_color VARCHAR(50) DEFAULT '#1E40AF'`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS settings JSONB DEFAULT '{}'`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT NOW()`);
    await pool.query(`ALTER TABLE websites ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP DEFAULT NOW()`);
    console.log('   ‚úì Added columns to websites table');
    
    // Website rooms - many-to-many link
    await pool.query(`
      CREATE TABLE IF NOT EXISTS website_rooms (
        id SERIAL PRIMARY KEY,
        website_id INTEGER NOT NULL REFERENCES websites(id) ON DELETE CASCADE,
        bookable_unit_id INTEGER NOT NULL REFERENCES bookable_units(id) ON DELETE CASCADE,
        display_order INTEGER DEFAULT 0,
        is_featured BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(website_id, bookable_unit_id)
      )
    `);
    console.log('   ‚úì Created website_rooms table');
    
    // Indexes
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_websites_account ON websites(account_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_rooms_website ON website_rooms(website_id)`);
    await pool.query(`CREATE INDEX IF NOT EXISTS idx_website_rooms_unit ON website_rooms(bookable_unit_id)`);
    
    res.json({ success: true, message: 'Websites tables created/updated' });
  } catch (error) {
    console.error('Migration error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/partner/tenants/:tenantId/websites - Create website
app.post('/api/partner/tenants/:tenantId/websites', async (req, res) => {
  console.log('=== PARTNER API: CREATE WEBSITE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    const { name, subdomain, custom_domain, description, logo_url, primary_color, secondary_color, settings } = req.body;
    
    if (!name) {
      return res.status(400).json({ success: false, error: 'name is required' });
    }
    
    const accountId = await getTenantAccountId(auth.partnerId, tenantId);
    if (!accountId) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    // Check subdomain uniqueness if provided
    if (subdomain) {
      const existing = await pool.query('SELECT id FROM websites WHERE subdomain = $1', [subdomain]);
      if (existing.rows.length > 0) {
        return res.status(400).json({ success: false, error: 'Subdomain already in use' });
      }
    }
    
    // Generate public_id (keep it short - max 20 chars)
    const publicId = `EL${accountId}-${Date.now().toString(36)}`;
    
    const result = await pool.query(`
      INSERT INTO websites (public_id, owner_type, owner_id, account_id, name, subdomain, custom_domain, description, logo_url, primary_color, secondary_color, settings, status)
      VALUES ($1, 'account', $2, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'active')
      RETURNING id, name, subdomain, custom_domain, description, logo_url, primary_color, secondary_color, is_active, created_at
    `, [
      publicId,
      accountId, 
      name, 
      subdomain || null, 
      custom_domain || null, 
      description || null, 
      logo_url || null,
      primary_color || '#3B82F6',
      secondary_color || '#1E40AF',
      JSON.stringify(settings || {})
    ]);
    
    const website = result.rows[0];
    
    res.json({
      success: true,
      website: {
        id: website.id,
        name: website.name,
        subdomain: website.subdomain,
        custom_domain: website.custom_domain,
        url: website.subdomain ? `https://${website.subdomain}.gas.travel` : null,
        description: website.description,
        logo_url: website.logo_url,
        primary_color: website.primary_color,
        secondary_color: website.secondary_color,
        room_count: 0,
        status: website.is_active ? 'active' : 'inactive',
        created_at: website.created_at
      }
    });
    
  } catch (error) {
    console.error('Partner API create website error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/tenants/:tenantId/websites - List websites
app.get('/api/partner/tenants/:tenantId/websites', async (req, res) => {
  console.log('=== PARTNER API: LIST WEBSITES ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    
    const accountId = await getTenantAccountId(auth.partnerId, tenantId);
    if (!accountId) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const result = await pool.query(`
      SELECT 
        w.id, w.name, w.subdomain, w.custom_domain, w.description,
        w.logo_url, w.primary_color, w.secondary_color, w.is_active, w.created_at,
        w.site_url, w.admin_url, w.status, w.template_code,
        COUNT(wr.id) as room_count
      FROM websites w
      LEFT JOIN website_rooms wr ON wr.website_id = w.id
      WHERE w.account_id = $1
      GROUP BY w.id
      ORDER BY w.created_at DESC
    `, [accountId]);
    
    res.json({
      success: true,
      websites: result.rows.map(w => ({
        id: w.id,
        name: w.name,
        subdomain: w.subdomain,
        custom_domain: w.custom_domain,
        site_url: w.site_url || (w.subdomain ? `https://${w.subdomain}.sites.gas.travel` : null),
        admin_url: w.admin_url,
        description: w.description,
        logo_url: w.logo_url,
        primary_color: w.primary_color,
        secondary_color: w.secondary_color,
        room_count: parseInt(w.room_count),
        status: w.status || (w.is_active ? 'active' : 'inactive'),
        template: w.template_code,
        created_at: w.created_at
      }))
    });
    
  } catch (error) {
    console.error('Partner API list websites error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/websites/:websiteId - Get website with rooms
app.get('/api/partner/websites/:websiteId', async (req, res) => {
  console.log('=== PARTNER API: GET WEBSITE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    
    // Get website (verify it belongs to partner's tenant)
    const wResult = await pool.query(`
      SELECT w.*, a.parent_id
      FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const w = wResult.rows[0];
    
    // Get assigned rooms
    const rooms = await pool.query(`
      SELECT 
        wr.id as assignment_id,
        wr.display_order,
        wr.is_featured,
        bu.id as room_id,
        bu.name as room_name,
        bu.partner_external_id as elevate_id,
        bu.max_guests,
        bu.num_bedrooms as bedrooms,
        bu.num_bathrooms as bathrooms,
        p.id as property_id,
        p.name as property_name,
        rt.id as room_type_id,
        rt.name as room_type_name
      FROM website_rooms wr
      JOIN bookable_units bu ON bu.id = wr.bookable_unit_id
      JOIN properties p ON p.id = bu.property_id
      LEFT JOIN room_types rt ON rt.id = bu.room_type_id
      WHERE wr.website_id = $1
      ORDER BY wr.display_order, bu.name
    `, [websiteId]);
    
    res.json({
      success: true,
      website: {
        id: w.id,
        name: w.name,
        subdomain: w.subdomain,
        custom_domain: w.custom_domain,
        url: w.subdomain ? `https://${w.subdomain}.gas.travel` : (w.custom_domain || null),
        description: w.description,
        logo_url: w.logo_url,
        primary_color: w.primary_color,
        secondary_color: w.secondary_color,
        settings: w.settings || {},
        status: w.is_active ? 'active' : 'inactive',
        created_at: w.created_at,
        rooms: rooms.rows.map(r => ({
          assignment_id: r.assignment_id,
          room_id: r.room_id,
          elevate_id: r.elevate_id,
          room_name: r.room_name,
          property_id: r.property_id,
          property_name: r.property_name,
          room_type_id: r.room_type_id,
          room_type_name: r.room_type_name,
          max_guests: r.max_guests,
          bedrooms: r.bedrooms,
          bathrooms: r.bathrooms,
          display_order: r.display_order,
          is_featured: r.is_featured
        }))
      }
    });
    
  } catch (error) {
    console.error('Partner API get website error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/websites/:websiteId - Update website
app.put('/api/partner/websites/:websiteId', async (req, res) => {
  console.log('=== PARTNER API: UPDATE WEBSITE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { name, subdomain, custom_domain, description, logo_url, primary_color, secondary_color, settings, is_active } = req.body;
    
    // Verify website belongs to partner's tenant
    const wCheck = await pool.query(`
      SELECT w.id FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    // Check subdomain uniqueness if changing
    if (subdomain) {
      const existing = await pool.query('SELECT id FROM websites WHERE subdomain = $1 AND id != $2', [subdomain, websiteId]);
      if (existing.rows.length > 0) {
        return res.status(400).json({ success: false, error: 'Subdomain already in use' });
      }
    }
    
    const updates = [];
    const values = [];
    let idx = 1;
    
    if (name !== undefined) { updates.push(`name = $${idx++}`); values.push(name); }
    if (subdomain !== undefined) { updates.push(`subdomain = $${idx++}`); values.push(subdomain); }
    if (custom_domain !== undefined) { updates.push(`custom_domain = $${idx++}`); values.push(custom_domain); }
    if (description !== undefined) { updates.push(`description = $${idx++}`); values.push(description); }
    if (logo_url !== undefined) { updates.push(`logo_url = $${idx++}`); values.push(logo_url); }
    if (primary_color !== undefined) { updates.push(`primary_color = $${idx++}`); values.push(primary_color); }
    if (secondary_color !== undefined) { updates.push(`secondary_color = $${idx++}`); values.push(secondary_color); }
    if (settings !== undefined) { updates.push(`settings = $${idx++}`); values.push(JSON.stringify(settings)); }
    if (is_active !== undefined) { updates.push(`is_active = $${idx++}`); values.push(is_active); }
    
    if (updates.length === 0) {
      return res.status(400).json({ success: false, error: 'No fields to update' });
    }
    
    updates.push(`updated_at = NOW()`);
    values.push(websiteId);
    
    await pool.query(
      `UPDATE websites SET ${updates.join(', ')} WHERE id = $${idx}`,
      values
    );
    
    res.json({ success: true, message: 'Website updated' });
    
  } catch (error) {
    console.error('Partner API update website error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/websites/:websiteId/rooms - Assign rooms to website
app.put('/api/partner/websites/:websiteId/rooms', async (req, res) => {
  console.log('=== PARTNER API: ASSIGN ROOMS TO WEBSITE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { rooms } = req.body; // Array of { room_id, display_order?, is_featured? }
    
    if (!rooms || !Array.isArray(rooms)) {
      return res.status(400).json({ success: false, error: 'rooms array is required' });
    }
    
    // Verify website belongs to partner's tenant
    const wCheck = await pool.query(`
      SELECT w.id, w.account_id FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const accountId = wCheck.rows[0].account_id;
    
    // Clear existing room assignments
    await pool.query(`DELETE FROM website_rooms WHERE website_id = $1`, [websiteId]);
    
    // Add new room assignments
    let assigned = 0;
    for (const room of rooms) {
      const roomId = room.room_id || room;
      const displayOrder = room.display_order || 0;
      const isFeatured = room.is_featured || false;
      
      // Verify room belongs to the same account
      const roomCheck = await pool.query(`
        SELECT bu.id FROM bookable_units bu
        JOIN properties p ON p.id = bu.property_id
        WHERE bu.id = $1 AND p.account_id = $2
      `, [roomId, accountId]);
      
      if (roomCheck.rows.length > 0) {
        await pool.query(`
          INSERT INTO website_rooms (website_id, bookable_unit_id, display_order, is_featured)
          VALUES ($1, $2, $3, $4)
          ON CONFLICT (website_id, bookable_unit_id) DO UPDATE SET display_order = $3, is_featured = $4
        `, [websiteId, roomId, displayOrder, isFeatured]);
        assigned++;
      }
    }
    
    res.json({
      success: true,
      message: `Assigned ${assigned} rooms to website`,
      assigned_count: assigned
    });
    
  } catch (error) {
    console.error('Partner API assign rooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/websites/:websiteId/rooms - Get room activation status
app.get('/api/partner/websites/:websiteId/rooms', async (req, res) => {
  console.log('=== PARTNER API: GET WEBSITE ROOMS STATUS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    
    // Verify website belongs to partner's tenant
    const wCheck = await pool.query(`
      SELECT w.id, w.account_id FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const accountId = wCheck.rows[0].account_id;
    
    // Get ALL rooms for all properties in this account
    const allRooms = await pool.query(`
      SELECT bu.id as unit_id, bu.name, bu.partner_external_id as external_id,
             bu.max_guests, bu.num_bedrooms as bedrooms, bu.num_bathrooms as bathrooms,
             p.id as property_id, p.name as property_name
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      WHERE p.account_id = $1
      ORDER BY p.name, bu.name
    `, [accountId]);
    
    // Get rooms currently assigned to this website
    const assignedRooms = await pool.query(`
      SELECT wr.bookable_unit_id, wr.display_order, wr.is_featured
      FROM website_rooms wr
      WHERE wr.website_id = $1
    `, [websiteId]);
    
    const assignedMap = {};
    assignedRooms.rows.forEach(r => {
      assignedMap[r.bookable_unit_id] = { display_order: r.display_order, is_featured: r.is_featured };
    });
    
    // Group by property with active status
    const propertyMap = {};
    let totalRooms = 0;
    let activeRooms = 0;
    
    allRooms.rows.forEach(r => {
      if (!propertyMap[r.property_id]) {
        propertyMap[r.property_id] = {
          property_id: r.property_id,
          property_name: r.property_name,
          rooms: []
        };
      }
      const isActive = !!assignedMap[r.unit_id];
      propertyMap[r.property_id].rooms.push({
        unit_id: r.unit_id,
        external_id: r.external_id,
        name: r.name,
        active: isActive,
        display_order: isActive ? (assignedMap[r.unit_id].display_order || 0) : 0,
        is_featured: isActive ? (assignedMap[r.unit_id].is_featured || false) : false,
        max_guests: r.max_guests,
        bedrooms: r.bedrooms,
        bathrooms: r.bathrooms
      });
      totalRooms++;
      if (isActive) activeRooms++;
    });
    
    res.json({
      success: true,
      website_id: parseInt(websiteId),
      properties: Object.values(propertyMap),
      summary: {
        total_rooms: totalRooms,
        active_rooms: activeRooms
      }
    });
    
  } catch (error) {
    console.error('Partner API get website rooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PATCH /api/partner/websites/:websiteId/rooms - Toggle individual room activation
app.patch('/api/partner/websites/:websiteId/rooms', async (req, res) => {
  console.log('=== PARTNER API: TOGGLE ROOM ACTIVATION ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { changes } = req.body;
    
    if (!changes || !Array.isArray(changes) || changes.length === 0) {
      return res.status(400).json({ success: false, error: 'changes array is required with at least one entry' });
    }
    
    // Verify website belongs to partner's tenant
    const wCheck = await pool.query(`
      SELECT w.id, w.account_id FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const accountId = wCheck.rows[0].account_id;
    let activated = 0;
    let deactivated = 0;
    const activeRooms = [];
    
    for (const change of changes) {
      const { unit_id, active, display_order, is_featured } = change;
      
      if (!unit_id || typeof active !== 'boolean') {
        continue; // Skip invalid entries
      }
      
      // Verify room belongs to the same account
      const roomCheck = await pool.query(`
        SELECT bu.id, bu.name FROM bookable_units bu
        JOIN properties p ON p.id = bu.property_id
        WHERE bu.id = $1 AND p.account_id = $2
      `, [unit_id, accountId]);
      
      if (roomCheck.rows.length === 0) {
        continue; // Skip rooms that don't belong to this account
      }
      
      if (active) {
        // Add to website (or update if already there)
        await pool.query(`
          INSERT INTO website_rooms (website_id, bookable_unit_id, display_order, is_featured)
          VALUES ($1, $2, $3, $4)
          ON CONFLICT (website_id, bookable_unit_id) DO UPDATE SET
            display_order = COALESCE($3, website_rooms.display_order),
            is_featured = COALESCE($4, website_rooms.is_featured)
        `, [websiteId, unit_id, display_order || 0, is_featured || false]);
        activated++;
        activeRooms.push({ unit_id, name: roomCheck.rows[0].name });
      } else {
        // Remove from website
        await pool.query(`
          DELETE FROM website_rooms WHERE website_id = $1 AND bookable_unit_id = $2
        `, [websiteId, unit_id]);
        deactivated++;
      }
    }
    
    // Also get remaining active rooms for the response
    if (deactivated > 0 || activated > 0) {
      const remaining = await pool.query(`
        SELECT bu.id as unit_id, bu.name
        FROM website_rooms wr
        JOIN bookable_units bu ON bu.id = wr.bookable_unit_id
        WHERE wr.website_id = $1
        ORDER BY wr.display_order, bu.name
      `, [websiteId]);
      
      res.json({
        success: true,
        message: `Updated ${activated + deactivated} rooms`,
        activated,
        deactivated,
        active_rooms: remaining.rows
      });
    } else {
      res.json({
        success: true,
        message: 'No valid changes applied',
        activated: 0,
        deactivated: 0,
        active_rooms: []
      });
    }
    
  } catch (error) {
    console.error('Partner API toggle room activation error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/partner/websites/:websiteId - Delete website
app.delete('/api/partner/websites/:websiteId', async (req, res) => {
  console.log('=== PARTNER API: DELETE WEBSITE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    
    // Verify website belongs to partner's tenant
    const wCheck = await pool.query(`
      SELECT w.id FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    // Delete website (cascade will delete website_rooms)
    await pool.query(`DELETE FROM websites WHERE id = $1`, [websiteId]);
    
    res.json({ success: true, message: 'Website deleted' });
    
  } catch (error) {
    console.error('Partner API delete website error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/partner/websites/:websiteId/deploy - Deploy website to VPS
app.post('/api/partner/websites/:websiteId/deploy', async (req, res) => {
  console.log('=== PARTNER API: DEPLOY WEBSITE ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { template, admin_email } = req.body;
    
    // Validate template
    const validTemplates = ['light', 'dark', 'developer-light', 'developer-dark'];
    const selectedTemplate = template === 'dark' ? 'developer-dark' : 'developer-light';
    
    // Get website with account verification
    const wResult = await pool.query(`
      SELECT w.*, a.parent_id, a.email as account_email, a.name as account_name
      FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const website = wResult.rows[0];
    
    // Check if already deployed
    if (website.site_url) {
      return res.status(400).json({ 
        success: false, 
        error: 'Website already deployed',
        site_url: website.site_url,
        admin_url: website.admin_url
      });
    }
    
    // Get assigned rooms
    const roomsResult = await pool.query(`
      SELECT 
        bu.id as room_id,
        bu.name as room_name,
        bu.max_guests,
        bu.num_bedrooms as bedrooms,
        bu.num_bathrooms as bathrooms,
        p.id as property_id,
        p.name as property_name
      FROM website_rooms wr
      JOIN bookable_units bu ON bu.id = wr.bookable_unit_id
      JOIN properties p ON p.id = bu.property_id
      WHERE wr.website_id = $1
      ORDER BY wr.display_order, bu.name
    `, [websiteId]);
    
    if (roomsResult.rows.length === 0) {
      return res.status(400).json({ success: false, error: 'No rooms assigned to website. Assign rooms first.' });
    }
    
    const rooms = roomsResult.rows;
    const roomIds = rooms.map(r => r.room_id);
    const propertyIds = [...new Set(rooms.map(r => r.property_id))];
    
    // Generate slug from subdomain or website name
    const slug = website.subdomain || website.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
    const siteAdminEmail = admin_email || website.account_email || 'admin@gas.travel';
    
    // Determine WordPress theme
    const wpTheme = selectedTemplate === 'developer-dark' ? 'gas-theme-developer-dark' : 'gas-theme-developer-light';
    
    console.log(`[Partner Deploy] Creating site "${website.name}" for account ${website.account_id} with template ${selectedTemplate}`);
    
    // Call VPS to create site
    const vpsResponse = await fetch(`${VPS_DEPLOY_URL}?action=create-site`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        site_name: website.name,
        slug: slug,
        admin_email: siteAdminEmail,
        room_ids: roomIds,
        rooms: rooms,
        property_ids: propertyIds,
        account_id: website.account_id,
        use_theme: true,
        use_plugin: true,
        theme: wpTheme,
        template: selectedTemplate,
        enable_blog: false,
        enable_attractions: false
      })
    });
    
    const vpsData = await vpsResponse.json();
    
    console.log('[Partner Deploy] VPS response:', JSON.stringify(vpsData, null, 2));
    console.log('[Partner Deploy] Credentials from VPS:', vpsData.credentials);
    
    if (!vpsData.success) {
      console.error('[Partner Deploy] VPS deployment failed:', vpsData.error);
      return res.status(500).json({ success: false, error: vpsData.error || 'VPS deployment failed' });
    }
    
    // Update website with deployment info
    await pool.query(`
      UPDATE websites SET 
        site_url = $1,
        admin_url = $2,
        slug = $3,
        status = 'deployed',
        template_code = $4,
        updated_at = NOW()
      WHERE id = $5
    `, [vpsData.site.url, vpsData.site.admin_url, vpsData.site.slug, selectedTemplate, websiteId]);
    
    // Store in deployed_sites table for GAS Admin visibility
    const deployedResult = await pool.query(`
      INSERT INTO deployed_sites 
      (property_id, property_ids, room_ids, account_id, blog_id, site_url, admin_url, slug, site_name, status, wp_username, wp_password_temp, template, deployed_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, NOW())
      RETURNING id
    `, [
      propertyIds[0],
      JSON.stringify(propertyIds),
      JSON.stringify(roomIds),
      website.account_id,
      vpsData.site.blog_id,
      vpsData.site.url,
      vpsData.site.admin_url,
      vpsData.site.slug,
      website.name,
      'deployed',
      vpsData.credentials?.username || 'admin',
      vpsData.credentials?.password || null,
      selectedTemplate
    ]);
    
    const deployedSiteId = deployedResult.rows[0].id;
    
    // Link websites table to deployed_sites
    await pool.query(`
      UPDATE websites SET deployed_site_id = $1 WHERE id = $2
    `, [deployedSiteId, websiteId]);
    
    // Update rooms with site URL
    for (const roomId of roomIds) {
      await pool.query(
        'UPDATE bookable_units SET website_url = $1 WHERE id = $2',
        [vpsData.site.url, roomId]
      );
    }
    
    console.log(`[Partner Deploy] Site "${website.name}" deployed successfully: ${vpsData.site.url}`);
    
    res.json({
      success: true,
      website: {
        id: websiteId,
        name: website.name,
        site_url: vpsData.site.url,
        admin_url: vpsData.site.admin_url,
        slug: vpsData.site.slug,
        template: selectedTemplate,
        room_count: roomIds.length,
        status: 'deployed'
      },
      credentials: vpsData.credentials
    });
    
  } catch (error) {
    console.error('Partner API deploy website error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER API - ANALYTICS
// =====================================================

// GET /api/partner/tenants/:tenantId/analytics - Get booking analytics for a tenant
app.get('/api/partner/tenants/:tenantId/analytics', async (req, res) => {
  console.log('=== PARTNER API: GET TENANT ANALYTICS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { tenantId } = req.params;
    const { period = '30d', from_date, to_date } = req.query;
    
    // Find the tenant
    const mapping = await pool.query(
      `SELECT gas_account_id FROM partner_tenant_mapping 
       WHERE partner_account_id = $1 AND external_tenant_id = $2`,
      [auth.partnerId, tenantId]
    );
    
    if (mapping.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Tenant not found' });
    }
    
    const accountId = mapping.rows[0].gas_account_id;
    
    // Calculate date range
    let startDate, endDate;
    if (from_date && to_date) {
      startDate = from_date;
      endDate = to_date;
    } else {
      endDate = new Date().toISOString().split('T')[0];
      const days = parseInt(period) || 30;
      const start = new Date();
      start.setDate(start.getDate() - days);
      startDate = start.toISOString().split('T')[0];
    }
    
    // Get booking stats
    const bookingStats = await pool.query(`
      SELECT 
        COUNT(*) as total_bookings,
        COUNT(CASE WHEN b.status = 'confirmed' THEN 1 END) as confirmed_bookings,
        COUNT(CASE WHEN b.status = 'cancelled' THEN 1 END) as cancelled_bookings,
        COUNT(CASE WHEN b.status = 'pending' THEN 1 END) as pending_bookings,
        COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN grand_total ELSE 0 END), 0) as total_revenue,
        COALESCE(AVG(CASE WHEN b.status = 'confirmed' THEN grand_total END), 0) as avg_booking_value,
        COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN 
          DATE_PART('day', departure_date::timestamp - arrival_date::timestamp) 
        ELSE 0 END), 0) as total_nights
      FROM bookings b
      JOIN properties p ON b.property_id = p.id
      WHERE p.account_id = $1 
      AND b.created_at >= $2 
      AND b.created_at <= $3::date + INTERVAL '1 day'
    `, [accountId, startDate, endDate]);
    
    // Get bookings by property
    const bookingsByProperty = await pool.query(`
      SELECT 
        p.id as property_id,
        p.name as property_name,
        COUNT(*) as bookings,
        COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN b.grand_total ELSE 0 END), 0) as revenue
      FROM bookings b
      JOIN properties p ON b.property_id = p.id
      WHERE p.account_id = $1 
      AND b.created_at >= $2 
      AND b.created_at <= $3::date + INTERVAL '1 day'
      GROUP BY p.id, p.name
      ORDER BY revenue DESC
    `, [accountId, startDate, endDate]);
    
    // Get bookings by room
    const bookingsByRoom = await pool.query(`
      SELECT 
        bu.id as room_id,
        bu.name as room_name,
        p.name as property_name,
        COUNT(*) as bookings,
        COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN b.grand_total ELSE 0 END), 0) as revenue
      FROM bookings b
      JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      JOIN properties p ON b.property_id = p.id
      WHERE p.account_id = $1 
      AND b.created_at >= $2 
      AND b.created_at <= $3::date + INTERVAL '1 day'
      GROUP BY bu.id, bu.name, p.name
      ORDER BY bookings DESC
      LIMIT 20
    `, [accountId, startDate, endDate]);
    
    // Get daily booking trend
    const dailyTrend = await pool.query(`
      SELECT 
        DATE(b.created_at) as date,
        COUNT(*) as bookings,
        COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN b.grand_total ELSE 0 END), 0) as revenue
      FROM bookings b
      JOIN properties p ON b.property_id = p.id
      WHERE p.account_id = $1 
      AND b.created_at >= $2 
      AND b.created_at <= $3::date + INTERVAL '1 day'
      GROUP BY DATE(b.created_at)
      ORDER BY date
    `, [accountId, startDate, endDate]);
    
    // Get booking sources
    const bookingSources = await pool.query(`
      SELECT 
        COALESCE(b.booking_source, 'direct') as source,
        COUNT(*) as bookings,
        COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN b.grand_total ELSE 0 END), 0) as revenue
      FROM bookings b
      JOIN properties p ON b.property_id = p.id
      WHERE p.account_id = $1 
      AND b.created_at >= $2 
      AND b.created_at <= $3::date + INTERVAL '1 day'
      GROUP BY COALESCE(b.booking_source, 'direct')
      ORDER BY bookings DESC
    `, [accountId, startDate, endDate]);
    
    const stats = bookingStats.rows[0];
    
    res.json({
      success: true,
      tenant_id: tenantId,
      period: {
        from: startDate,
        to: endDate
      },
      summary: {
        total_bookings: parseInt(stats.total_bookings) || 0,
        confirmed_bookings: parseInt(stats.confirmed_bookings) || 0,
        cancelled_bookings: parseInt(stats.cancelled_bookings) || 0,
        pending_bookings: parseInt(stats.pending_bookings) || 0,
        total_revenue: parseFloat(stats.total_revenue) || 0,
        average_booking_value: parseFloat(stats.avg_booking_value) || 0,
        total_nights: parseInt(stats.total_nights) || 0,
        cancellation_rate: stats.total_bookings > 0 
          ? ((stats.cancelled_bookings / stats.total_bookings) * 100).toFixed(1) + '%'
          : '0%'
      },
      by_property: bookingsByProperty.rows.map(p => ({
        property_id: p.property_id,
        property_name: p.property_name,
        bookings: parseInt(p.bookings),
        revenue: parseFloat(p.revenue)
      })),
      by_room: bookingsByRoom.rows.map(r => ({
        room_id: r.room_id,
        room_name: r.room_name,
        property_name: r.property_name,
        bookings: parseInt(r.bookings),
        revenue: parseFloat(r.revenue)
      })),
      daily_trend: dailyTrend.rows.map(d => ({
        date: d.date,
        bookings: parseInt(d.bookings),
        revenue: parseFloat(d.revenue)
      })),
      by_source: bookingSources.rows.map(s => ({
        source: s.source,
        bookings: parseInt(s.bookings),
        revenue: parseFloat(s.revenue)
      }))
    });
    
  } catch (error) {
    console.error('Partner API get analytics error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/websites/:websiteId/analytics - Get website-specific analytics
app.get('/api/partner/websites/:websiteId/analytics', async (req, res) => {
  console.log('=== PARTNER API: GET WEBSITE ANALYTICS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { period = '30d' } = req.query;
    
    // Find the website
    const website = await pool.query(`
      SELECT w.*, a.id as tenant_account_id
      FROM websites w
      JOIN accounts a ON w.account_id = a.id
      JOIN partner_tenant_mapping ptm ON a.id = ptm.gas_account_id
      WHERE w.id = $1 AND ptm.partner_account_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (website.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const site = website.rows[0];
    const accountId = site.tenant_account_id;
    
    // Get rooms assigned to this website
    const roomIds = site.room_ids || [];
    
    // Calculate date range
    const days = parseInt(period) || 30;
    const endDate = new Date().toISOString().split('T')[0];
    const start = new Date();
    start.setDate(start.getDate() - days);
    const startDate = start.toISOString().split('T')[0];
    
    // Get booking stats for this website's rooms
    let bookingStats;
    if (roomIds.length > 0) {
      bookingStats = await pool.query(`
        SELECT 
          COUNT(*) as total_bookings,
          COUNT(CASE WHEN b.status = 'confirmed' THEN 1 END) as confirmed_bookings,
          COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN b.grand_total ELSE 0 END), 0) as total_revenue
        FROM bookings b
        WHERE b.bookable_unit_id = ANY($1::int[])
        AND b.created_at >= $2 
        AND b.created_at <= $3::date + INTERVAL '1 day'
      `, [roomIds, startDate, endDate]);
    } else {
      // If no specific rooms, get all bookings for this account
      bookingStats = await pool.query(`
        SELECT 
          COUNT(*) as total_bookings,
          COUNT(CASE WHEN b.status = 'confirmed' THEN 1 END) as confirmed_bookings,
          COALESCE(SUM(CASE WHEN b.status = 'confirmed' THEN b.grand_total ELSE 0 END), 0) as total_revenue
        FROM bookings b
        JOIN properties p ON b.property_id = p.id
        WHERE p.account_id = $1
        AND b.created_at >= $2 
        AND b.created_at <= $3::date + INTERVAL '1 day'
      `, [accountId, startDate, endDate]);
    }
    
    const stats = bookingStats.rows[0];
    
    res.json({
      success: true,
      website_id: parseInt(websiteId),
      website_name: site.name,
      site_url: site.site_url,
      period: {
        from: startDate,
        to: endDate,
        days: days
      },
      summary: {
        total_bookings: parseInt(stats.total_bookings) || 0,
        confirmed_bookings: parseInt(stats.confirmed_bookings) || 0,
        total_revenue: parseFloat(stats.total_revenue) || 0
      }
    });
    
  } catch (error) {
    console.error('Partner API get website analytics error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// PARTNER API - WEBSITE CONTENT
// =====================================================
// These endpoints allow Elevate to update website content
// Changes are saved to GAS and pushed to WordPress

// Helper: Get deployed_site_id for a partner website
async function getPartnerDeployedSiteId(partnerId, websiteId) {
  const result = await pool.query(`
    SELECT w.deployed_site_id, w.site_url, ds.id as ds_id
    FROM websites w
    LEFT JOIN deployed_sites ds ON ds.site_url = w.site_url
    JOIN accounts a ON a.id = w.account_id
    WHERE w.id = $1 AND a.parent_id = $2 AND w.site_url IS NOT NULL
  `, [websiteId, partnerId]);
  
  if (result.rows.length === 0) return null;
  
  // Return deployed_site_id or fall back to ds.id from join
  return result.rows[0].deployed_site_id || result.rows[0].ds_id;
}

// GET /api/partner/websites/:websiteId/credentials - Get WP credentials
app.get('/api/partner/websites/:websiteId/credentials', async (req, res) => {
  console.log('=== PARTNER API: GET CREDENTIALS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    
    // Get website with deployed site info
    const result = await pool.query(`
      SELECT w.id, w.name, w.site_url, w.admin_url, w.account_id, ds.wp_username, ds.wp_password_temp
      FROM websites w
      JOIN accounts a ON a.id = w.account_id
      LEFT JOIN deployed_sites ds ON ds.site_url = w.site_url
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const website = result.rows[0];
    
    if (!website.site_url) {
      return res.status(400).json({ success: false, error: 'Website not yet deployed' });
    }
    
    let password = website.wp_password_temp;
    
    // If password is null for this site, look it up from the first deployed site 
    // for the same account (password is shared across all WordPress sites for same user)
    if (!password && website.account_id) {
      const passwordLookup = await pool.query(`
        SELECT wp_password_temp FROM deployed_sites 
        WHERE account_id = $1 AND wp_password_temp IS NOT NULL 
        ORDER BY deployed_at ASC LIMIT 1
      `, [website.account_id]);
      
      if (passwordLookup.rows.length > 0) {
        password = passwordLookup.rows[0].wp_password_temp;
      }
    }
    
    res.json({
      success: true,
      website: {
        id: website.id,
        name: website.name,
        site_url: website.site_url,
        admin_url: website.admin_url
      },
      credentials: {
        username: website.wp_username,
        password: password
      }
    });
    
  } catch (error) {
    console.error('Partner API get credentials error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/partner/websites/:websiteId/domain - Get domain status and DNS records
app.get('/api/partner/websites/:websiteId/domain', async (req, res) => {
  console.log('=== PARTNER API: GET DOMAIN STATUS ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    
    // Get website and deployed site info
    const result = await pool.query(`
      SELECT w.id, w.name, w.subdomain, ds.id as deployed_site_id, 
             ds.site_url, ds.custom_domain, ds.status
      FROM websites w
      LEFT JOIN deployed_sites ds ON ds.id = w.deployed_site_id
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const website = result.rows[0];
    const VPS_IP = '72.61.207.109';
    
    res.json({
      success: true,
      website_id: website.id,
      website_name: website.name,
      deployed: !!website.deployed_site_id,
      current_url: website.site_url || `https://${website.subdomain}.sites.gas.travel`,
      custom_domain: website.custom_domain || null,
      custom_domain_configured: !!website.custom_domain,
      dns_records: {
        description: 'Add these DNS records to your domain before connecting',
        records: [
          { type: 'A', name: '@', value: VPS_IP },
          { type: 'A', name: 'www', value: VPS_IP }
        ],
        note: 'Delete any existing AAAA (IPv6) records for your domain'
      }
    });
    
  } catch (error) {
    console.error('Partner API get domain error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/websites/:websiteId/domain - Connect custom domain
app.put('/api/partner/websites/:websiteId/domain', async (req, res) => {
  console.log('=== PARTNER API: CONNECT CUSTOM DOMAIN ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { domain } = req.body;
    
    if (!domain) {
      return res.status(400).json({ success: false, error: 'domain is required' });
    }
    
    // Clean domain
    const cleanDomain = domain.toLowerCase().replace(/^(https?:\/\/)?(www\.)?/, '').replace(/\/$/, '');
    
    // Get website and deployed site info
    const result = await pool.query(`
      SELECT w.id, w.name, ds.id as deployed_site_id, ds.blog_id
      FROM websites w
      LEFT JOIN deployed_sites ds ON ds.id = w.deployed_site_id
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const website = result.rows[0];
    
    if (!website.deployed_site_id) {
      return res.status(400).json({ success: false, error: 'Website must be deployed before connecting a custom domain' });
    }
    
    console.log(`[Partner API] Connecting domain ${cleanDomain} to website ${websiteId} (deployed_site: ${website.deployed_site_id})`);
    
    // Call the VPS API to set up Nginx, SSL, and WordPress
    const SITES_VPS_URL = 'https://sites.gas.travel/gas-api.php';
    
    const vpsResponse = await fetch(SITES_VPS_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': process.env.VPS_DEPLOY_API_KEY || 'GAS-DEPLOY-SECRET-2024'
      },
      body: JSON.stringify({
        action: 'connect-custom-domain',
        blog_id: website.blog_id,
        domain: cleanDomain
      })
    });
    
    const vpsData = await vpsResponse.json();
    console.log(`[Partner API] VPS response:`, vpsData);
    
    if (vpsData.success) {
      // Update the deployed_sites table
      await pool.query(`
        UPDATE deployed_sites 
        SET custom_domain = $1, updated_at = NOW()
        WHERE id = $2
      `, [cleanDomain, website.deployed_site_id]);
      
      res.json({ 
        success: true, 
        website_id: websiteId,
        domain: cleanDomain,
        url: `https://${cleanDomain}`,
        message: 'Custom domain connected successfully. SSL certificate will be provisioned automatically.'
      });
    } else {
      res.json({ success: false, error: vpsData.error || 'Failed to connect domain on VPS' });
    }
    
  } catch (error) {
    console.error('Partner API connect domain error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// DELETE /api/partner/websites/:websiteId/domain - Remove custom domain
app.delete('/api/partner/websites/:websiteId/domain', async (req, res) => {
  console.log('=== PARTNER API: REMOVE CUSTOM DOMAIN ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    
    // Get website and deployed site info
    const result = await pool.query(`
      SELECT w.id, ds.id as deployed_site_id, ds.blog_id, ds.custom_domain
      FROM websites w
      LEFT JOIN deployed_sites ds ON ds.id = w.deployed_site_id
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const website = result.rows[0];
    
    if (!website.custom_domain) {
      return res.json({ success: true, message: 'No custom domain configured' });
    }
    
    console.log(`[Partner API] Removing domain ${website.custom_domain} from website ${websiteId}`);
    
    // Call the VPS API to remove domain
    const SITES_VPS_URL = 'https://sites.gas.travel/gas-api.php';
    
    const vpsResponse = await fetch(SITES_VPS_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': process.env.VPS_DEPLOY_API_KEY || 'GAS-DEPLOY-SECRET-2024'
      },
      body: JSON.stringify({
        action: 'remove-custom-domain',
        blog_id: website.blog_id,
        domain: website.custom_domain
      })
    });
    
    const vpsData = await vpsResponse.json();
    console.log(`[Partner API] VPS response:`, vpsData);
    
    // Update database regardless of VPS response
    await pool.query(`
      UPDATE deployed_sites 
      SET custom_domain = NULL, updated_at = NOW()
      WHERE id = $1
    `, [website.deployed_site_id]);
    
    res.json({ 
      success: true, 
      website_id: websiteId,
      message: 'Custom domain removed'
    });
    
  } catch (error) {
    console.error('Partner API remove domain error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// PUT /api/partner/websites/:websiteId/content/:section - Update website content section
app.put('/api/partner/websites/:websiteId/content/:section', async (req, res) => {
  console.log('=== PARTNER API: UPDATE CONTENT ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId, section } = req.params;
    const { settings } = req.body;
    
    // Validate section
    const validSections = [
      'header', 'hero', 'intro', 'featured', 'about', 'reviews', 'cta', 'footer', 'styles', 'seo',
      'page-rooms', 'page-about', 'page-gallery', 'page-contact', 'page-blog', 'page-attractions',
      'page-dining', 'page-offers', 'page-properties', 'page-reviews', 'page-terms', 'page-privacy'
    ];
    if (!validSections.includes(section)) {
      return res.status(400).json({ success: false, error: `Invalid section. Valid: ${validSections.join(', ')}` });
    }
    
    if (!settings || typeof settings !== 'object') {
      return res.status(400).json({ success: false, error: 'settings object required' });
    }
    
    // Get deployed site ID
    const deployedSiteId = await getPartnerDeployedSiteId(auth.partnerId, websiteId);
    if (!deployedSiteId) {
      return res.status(400).json({ success: false, error: 'Website not deployed or not found' });
    }
    
    // Get site info for WordPress push
    const siteResult = await pool.query(
      'SELECT id, account_id, template, site_name, site_url FROM deployed_sites WHERE id = $1',
      [deployedSiteId]
    );
    
    if (siteResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Deployed site not found' });
    }
    
    const site = siteResult.rows[0];
    
    console.log(`[Partner Content] Saving ${section} for site ${deployedSiteId} (${site.site_name})`);
    
    // UPSERT settings
    const updateResult = await pool.query(`
      UPDATE website_settings 
      SET settings = $1, updated_at = CURRENT_TIMESTAMP, sync_source = 'partner'
      WHERE deployed_site_id = $2 AND section = $3
    `, [JSON.stringify(settings), deployedSiteId, section]);
    
    if (updateResult.rowCount === 0) {
      await pool.query(`
        INSERT INTO website_settings (deployed_site_id, account_id, section, settings, sync_source, updated_at)
        VALUES ($1, $2, $3, $4, 'partner', CURRENT_TIMESTAMP)
      `, [deployedSiteId, site.account_id, section, JSON.stringify(settings)]);
    }
    
    // Push to WordPress
    let wpPushResult = null;
    if (site.site_url) {
      wpPushResult = await pushSettingsToWordPress(site.site_url, section, settings);
    }
    
    res.json({
      success: true,
      message: `${section} content updated`,
      deployed_site_id: deployedSiteId,
      section,
      wordpress_push: wpPushResult
    });
    
  } catch (error) {
    console.error('Partner API update content error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Default settings for each website content section
// Returns full schema with defaults when no settings have been saved yet
const SECTION_DEFAULTS = {
  header: {
    'site-name': '',
    'tagline-en': '',
    'logo-image-url': '',
    'bg-color': '#ffffff',
    'text-color': '#1e293b',
    'logo-color': '#0f172a',
    'underline-color': '',
    'cta-button-text-en': 'Book Now',
    'cta-bg': '#2563eb',
    'cta-text-color': '#ffffff',
    'border-color': '#e5e7eb',
    'font': '',
    'font-size': '',
    'font-weight': '',
    'text-transform': '',
    'layout': 'logo-left',
    'sticky': true,
    'transparent': true,
    'border': false
  },
  hero: {
    'headline-en': '',
    'subheadline-en': '',
    'button-text-en': 'Book Now',
    'button-link': '/book',
    'image-url': '',
    'mobile-image-url': '',
    'video-url': '',
    'video-mobile': '',
    'overlay-color': '#0f172a',
    'overlay': '30',
    'height': '80',
    'background-type': 'image',
    'slide-1-url': '',
    'slide-2-url': '',
    'slide-3-url': '',
    'slide-4-url': '',
    'slider-duration': '5000',
    'slider-transition': 'fade',
    'badge-bg': '',
    'badge-text': '',
    'badge-border': '',
    'trust-1-en': '',
    'trust-2-en': '',
    'trust-3-en': '',
    'trust-text-color': '#ffffff',
    'search-btn-bg': '',
    'search-btn-text': '',
    'search-label-color': '',
    'search-max-guests': '4',
    'search-bg': '',
    'search-opacity': '100',
    'search-radius': '8',
    'search-padding': '20',
    'search-scale': '100',
    'search-max-width': '900',
    'search-btn-label-en': 'Search',
    'search-checkin-label-en': 'Check In',
    'search-checkout-label-en': 'Check Out',
    'search-guests-label-en': 'Guests',
    'search-date-placeholder-en': 'Select date',
    'search-guest-singular-en': 'Guest',
    'meta-title': '',
    'meta-description': '',
    'menu-title-en': 'Home',
    'faq-enabled': false
  },
  intro: {
    'enabled': true,
    'title-en': '',
    'text-en': '',
    'bg': '#ffffff',
    'text-color': '#1e293b',
    'title-size': '',
    'text-size': '',
    'max-width': '',
    'btn-text-en': '',
    'btn-url': '',
    'btn-bg': '',
    'btn-text-color': ''
  },
  featured: {
    'enabled': true,
    'title-en': 'Our Rooms',
    'subtitle-en': '',
    'bg': '#f8fafc',
    'title-color': '',
    'subtitle-color': '',
    'count': '6',
    'columns': '3',
    'layout-style': 'cards',
    'mode': 'auto',
    'ids': '',
    'btn-enabled': false,
    'btn-text': '',
    'btn-url': '',
    'btn-bg': '',
    'btn-text-color': ''
  },
  about: {
    'enabled': true,
    'title-en': 'About Us',
    'text-en': '',
    'image-url': '',
    'bg': '#ffffff',
    'text-color': '#1e293b',
    'title-color': '',
    'title-size': '',
    'text-size': '',
    'layout': 'image-left',
    'feature-1-en': '',
    'feature-2-en': '',
    'feature-3-en': '',
    'feature-4-en': '',
    'feature-5-en': '',
    'feature-6-en': '',
    'btn-text-en': '',
    'btn-url': '',
    'btn-bg': '',
    'btn-text-color': ''
  },
  reviews: {
    'enabled': true,
    'title-en': 'Guest Reviews',
    'subtitle-en': '',
    'bg': '#f8fafc',
    'card-bg': '',
    'text-color': '',
    'star-color': '',
    'use-app': false,
    'app-code': '',
    'review1-name': '',
    'review1-text': '',
    'review1-source': '',
    'review2-name': '',
    'review2-text': '',
    'review2-source': '',
    'review3-name': '',
    'review3-text': '',
    'review3-source': ''
  },
  cta: {
    'enabled': true,
    'title-en': '',
    'text-en': '',
    'background': '',
    'text-color': '#ffffff',
    'title-size': '',
    'text-size': '',
    'btn-text-en': 'Book Now',
    'btn-url': '/book',
    'btn-bg': '',
    'btn-text-color': ''
  },
  footer: {
    'bg': '#0f172a',
    'text': '#ffffff',
    'address': '',
    'phone': '',
    'email': '',
    'copyright-en': '',
    'layout': 'standard',
    'social-facebook': '',
    'social-instagram': '',
    'social-twitter': '',
    'social-youtube': '',
    'social-linkedin': '',
    'social-pinterest': '',
    'social-tiktok': '',
    'social-tripadvisor': ''
  },
  styles: {
    'primary-color': '#2563eb',
    'secondary-color': '#0f172a',
    'accent-color': '#f59e0b',
    'link-color': '#2563eb',
    'heading-font': 'Inter',
    'body-font': 'Inter',
    'title-size': '',
    'body-size': '',
    'btn-primary-bg': '#2563eb',
    'btn-primary-text': '#ffffff',
    'btn-radius': '8',
    'featured-bg': '',
    'about-bg': '',
    'testimonials-bg': '',
    'cta-bg': '',
    'custom-css': ''
  },
  seo: {
    'enabled': false,
    'meta-title': '',
    'meta-description': '',
    'og-image': '',
    'google-analytics-id': '',
    'google-tag-manager-id': '',
    'google-site-verification': '',
    'facebook-pixel-id': '',
    'include-schema': true,
    'include-faqs': true
  },
  'page-rooms': {
    'enabled': true,
    'title-en': 'Our Rooms',
    'subtitle-en': '',
    'menu-title-en': 'Book Now',
    'bg': '',
    'bg-color': '',
    'text-color': '',
    'columns': '3',
    'layout-style': 'cards',
    'show-search': true,
    'show-amenity-filter': true,
    'show-location-filter': false,
    'show-map': false,
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-about': {
    'enabled': false,
    'title-en': 'About Us',
    'subtitle-en': '',
    'menu-title-en': 'About',
    'content-title-en': '',
    'content-en': '',
    'content-image': '',
    'hero-image': '',
    'bg': '',
    'text-color': '',
    'title-color': '',
    'header-bg': '',
    'header-text': '',
    'image-position': 'right',
    'menu-order': '',
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-gallery': {
    'enabled': false,
    'menu-title-en': 'Gallery',
    'menu-order': '',
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-blog': {
    'enabled': false,
    'menu-title-en': 'Blog',
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-attractions': {
    'enabled': false,
    'menu-title-en': 'Things To Do',
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-dining': {
    'enabled': false,
    'menu-title-en': 'Dining',
    'menu-order': '',
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-offers': {
    'enabled': false,
    'title-en': 'Special Offers',
    'subtitle-en': '',
    'menu-title-en': 'Offers',
    'menu-order': '',
    'meta-title': '',
    'meta-description': '',
    'content': ''
  },
  'page-properties': {
    'enabled': false,
    'title-en': 'Our Properties',
    'subtitle-en': '',
    'menu-title-en': 'Properties',
    'menu-order': '',
    'meta-title': '',
    'meta-description': '',
    'content': ''
  },
  'page-reviews': {
    'enabled': false,
    'title': 'Reviews',
    'subtitle': '',
    'menu-title-en': 'Reviews',
    'meta-title': '',
    'meta-description': '',
    'content': ''
  },
  'page-contact': {
    'enabled': false,
    'menu-title-en': 'Contact',
    'menu-order': '',
    'meta-title': '',
    'meta-description': '',
    'faq-enabled': false
  },
  'page-terms': {
    'title': 'Terms & Conditions',
    'updated': '',
    'menu-title-en': 'Terms',
    'meta-title': '',
    'meta-description': '',
    'checkin-enabled': true,
    'checkin-title': 'Check-in / Check-out',
    'checkin-time': '15:00',
    'checkout-time': '11:00',
    'checkin-details': '',
    'cancellation-enabled': true,
    'cancellation-title': 'Cancellation Policy',
    'cancellation': '',
    'payment-enabled': true,
    'payment-title': 'Payment Terms',
    'payment': '',
    'house-rules-enabled': true,
    'house-rules-title': 'House Rules',
    'house-rules': '',
    'booking-enabled': true,
    'booking-title': 'Booking Conditions',
    'booking': '',
    'liability-enabled': true,
    'liability-title': 'Liability',
    'liability': '',
    'additional-enabled': false,
    'additional-title': 'Additional Terms',
    'additional': '',
    'faq-enabled': false
  },
  'page-privacy': {
    'title': 'Privacy Policy',
    'updated': '',
    'effective': '',
    'menu-title-en': 'Privacy',
    'meta-title': '',
    'meta-description': '',
    'intro-enabled': true,
    'intro-title': 'Introduction',
    'intro': '',
    'intro-sub': '',
    'collection-enabled': true,
    'collection-title': 'Information We Collect',
    'collection': '',
    'collection-sub1': '',
    'how-collect': '',
    'how-collect-sub': '',
    'usage-enabled': true,
    'usage-title': 'How We Use Your Information',
    'usage': '',
    'usage-sub': '',
    'sharing-enabled': true,
    'sharing-title': 'Information Sharing',
    'sharing': '',
    'sharing-sub': '',
    'cookies-enabled': true,
    'cookies-title': 'Cookies',
    'cookies': '',
    'cookies-sub': '',
    'retention-enabled': true,
    'retention-title': 'Data Retention',
    'retention': '',
    'retention-sub': '',
    'rights-enabled': true,
    'rights-title': 'Your Rights',
    'rights': '',
    'rights-sub': '',
    'contact-enabled': true,
    'contact-title': 'Contact Us',
    'contact': '',
    'contact-sub': '',
    'faq-enabled': false
  }
};

// GET /api/partner/websites/:websiteId/content/:section - Get website content section
app.get('/api/partner/websites/:websiteId/content/:section', async (req, res) => {
  console.log('=== PARTNER API: GET CONTENT ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId, section } = req.params;
    
    // Validate section
    if (!SECTION_DEFAULTS[section]) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid section. Valid sections: ${Object.keys(SECTION_DEFAULTS).join(', ')}` 
      });
    }
    
    // Get deployed site ID
    const deployedSiteId = await getPartnerDeployedSiteId(auth.partnerId, websiteId);
    if (!deployedSiteId) {
      return res.status(400).json({ success: false, error: 'Website not deployed or not found' });
    }
    
    // Get saved settings
    const result = await pool.query(`
      SELECT settings FROM website_settings 
      WHERE deployed_site_id = $1 AND section = $2
    `, [deployedSiteId, section]);
    
    const savedSettings = result.rows.length > 0 ? result.rows[0].settings : {};
    const defaults = SECTION_DEFAULTS[section] || {};
    
    // Merge: defaults first, then saved settings override
    const mergedSettings = { ...defaults, ...savedSettings };
    
    res.json({
      success: true,
      section,
      settings: mergedSettings
    });
    
  } catch (error) {
    console.error('Partner API get content error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/partner/websites/:websiteId/upload - Upload image/video
app.post('/api/partner/websites/:websiteId/upload', async (req, res) => {
  console.log('=== PARTNER API: UPLOAD MEDIA ===');
  
  try {
    const auth = await validatePartnerApiKey(req);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: auth.error });
    }
    
    const { websiteId } = req.params;
    const { file_data, file_name, file_type, section } = req.body;
    
    // Validate required fields with clear messages
    if (!file_data) {
      return res.status(400).json({ success: false, error: 'file_data is required (base64-encoded image data)' });
    }
    if (!file_name) {
      return res.status(400).json({ success: false, error: 'file_name is required (e.g. "hero-image.jpg")' });
    }
    
    // Strip data URI prefix if present (e.g. "data:image/jpeg;base64,/9j/4AAQ...")
    let cleanBase64 = file_data;
    if (cleanBase64.startsWith('data:')) {
      cleanBase64 = cleanBase64.split(',')[1] || cleanBase64;
    }
    
    // Validate base64 is not empty/truncated
    if (cleanBase64.length < 100) {
      return res.status(400).json({ success: false, error: 'file_data appears to be empty or truncated' });
    }
    
    // Detect file_type from data URI prefix or base64 header if not provided
    let detectedType = file_type || 'image/jpeg';
    if (!file_type && file_data.startsWith('data:')) {
      const match = file_data.match(/^data:([^;]+);/);
      if (match) detectedType = match[1];
    }
    
    // Log upload attempt details
    const base64SizeKB = Math.round(cleanBase64.length / 1024);
    console.log(`[Upload] file_name=${file_name}, type=${detectedType}, section=${section || 'none'}, base64_size=${base64SizeKB}KB`);
    
    // Verify website belongs to partner
    const wResult = await pool.query(`
      SELECT w.id, w.site_url, w.account_id
      FROM websites w
      JOIN accounts a ON a.id = w.account_id
      WHERE w.id = $1 AND a.parent_id = $2
    `, [websiteId, auth.partnerId]);
    
    if (wResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Website not found' });
    }
    
    const website = wResult.rows[0];
    
    if (!website.site_url) {
      return res.status(400).json({ success: false, error: 'Website not yet deployed' });
    }
    
    // Upload to WordPress media library
    const wpApiKey = 'GAS_SECRET_KEY_2024!';
    let uploadResponse;
    try {
      uploadResponse = await fetch(`${website.site_url}wp-json/developer-theme/v1/upload-media`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-GAS-API-Key': wpApiKey
        },
        body: JSON.stringify({
          file_data: cleanBase64,  // Base64 encoded (no data URI prefix)
          file_name: file_name,
          file_type: detectedType,
          section: section || null
        })
      });
    } catch (fetchError) {
      console.error('[Upload] WordPress fetch failed:', fetchError.message);
      return res.status(502).json({ 
        success: false, 
        error: 'Could not connect to WordPress site',
        detail: fetchError.message
      });
    }
    
    // Handle non-JSON WordPress responses (e.g. 413 entity too large, nginx errors)
    const contentType = uploadResponse.headers.get('content-type') || '';
    if (!contentType.includes('application/json')) {
      const rawText = await uploadResponse.text();
      console.error(`[Upload] WordPress returned non-JSON (status ${uploadResponse.status}):`, rawText.substring(0, 500));
      return res.status(502).json({ 
        success: false, 
        error: `WordPress returned HTTP ${uploadResponse.status}`,
        detail: rawText.substring(0, 200)
      });
    }
    
    const uploadData = await uploadResponse.json();
    
    if (!uploadData.success) {
      console.error('[Upload] WordPress upload failed:', JSON.stringify(uploadData));
      return res.status(500).json({ 
        success: false, 
        error: uploadData.error || 'Upload failed',
        wp_status: uploadResponse.status,
        detail: uploadData.message || uploadData.data || null
      });
    }
    
    console.log(`[Upload] Success: ${uploadData.url} (media_id: ${uploadData.media_id})`);
    
    res.json({
      success: true,
      message: 'Media uploaded',
      url: uploadData.url,
      media_id: uploadData.media_id,
      file_name: file_name,
      section: section || null
    });
    
  } catch (error) {
    console.error('Partner API upload error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// TEMPORARY CLEANUP ENDPOINT - REMOVE AFTER USE
// =====================================================
app.get('/api/elevate/cleanup-test-data-xK9mP2nL', async (req, res) => {
  try {
    const results = [];
    const deleteAccount92Props = req.query.delete92 === 'true';
    const updateRole = req.query.role === 'agency_admin';
    const fixCounts = req.query.fixcounts === 'true';
    const checkRooms = req.query.checkrooms === 'true';
    
    // Check which accounts have rooms and their bedroom/bathroom counts
    if (checkRooms) {
      const roomsByAccount = await pool.query(`
        SELECT 
          p.account_id,
          a.name as account_name,
          COUNT(bu.id) as room_count,
          SUM(CASE WHEN bu.num_bedrooms > 0 THEN 1 ELSE 0 END) as rooms_with_bedrooms,
          SUM(CASE WHEN bu.num_bathrooms > 0 THEN 1 ELSE 0 END) as rooms_with_bathrooms
        FROM bookable_units bu
        JOIN properties p ON bu.property_id = p.id
        LEFT JOIN accounts a ON p.account_id = a.id
        GROUP BY p.account_id, a.name
        ORDER BY room_count DESC
        LIMIT 20
      `);
      
      // Check property_bedrooms table
      const bedroomRecords = await pool.query(`
        SELECT COUNT(*) as total_bedroom_records FROM property_bedrooms
      `);
      
      const bathroomRecords = await pool.query(`
        SELECT COUNT(*) as total_bathroom_records FROM property_bathrooms
      `);
      
      const sampleBedrooms = await pool.query(`
        SELECT pb.*, bu.name as room_name, p.name as property_name
        FROM property_bedrooms pb
        JOIN bookable_units bu ON pb.room_id = bu.id
        JOIN properties p ON pb.property_id = p.id
        LIMIT 5
      `);
      
      return res.json({
        success: true,
        accounts_with_rooms: roomsByAccount.rows,
        bedroom_records_total: bedroomRecords.rows[0].total_bedroom_records,
        bathroom_records_total: bathroomRecords.rows[0].total_bathroom_records,
        sample_bedroom_records: sampleBedrooms.rows
      });
    }
    
    // Fix bedroom/bathroom counts on bookable_units from existing records
    if (fixCounts) {
      const recalculate = req.query.recalc === 'true';
      
      if (recalculate) {
        // Recalculate from feature_codes - count only BEDROOM and BATHROOM codes
        const rooms = await pool.query(`
          SELECT id, name, feature_codes FROM bookable_units WHERE feature_codes IS NOT NULL
        `);
        
        let bedroomUpdates = 0;
        let bathroomUpdates = 0;
        const samples = [];
        
        for (const room of rooms.rows) {
          const codes = room.feature_codes.split(',').map(c => c.trim().toUpperCase());
          
          // Count BEDROOM codes only (not BED_KING etc)
          const bedroomCount = codes.filter(c => c.startsWith('BEDROOM')).length;
          
          // Count BATHROOM codes only (not BATH_TUB etc)
          const bathroomCount = codes.filter(c => c.startsWith('BATHROOM') || c === 'FULLBATH' || c === 'HALFBATH').length;
          
          if (bedroomCount > 0 || bathroomCount > 0) {
            await pool.query(`
              UPDATE bookable_units SET 
                bedrooms = $1, num_bedrooms = $1,
                bathrooms = $2, num_bathrooms = $2
              WHERE id = $3
            `, [bedroomCount || null, bathroomCount || null, room.id]);
            
            if (bedroomCount > 0) bedroomUpdates++;
            if (bathroomCount > 0) bathroomUpdates++;
            
            if (samples.length < 10) {
              samples.push({ id: room.id, name: room.name, bedrooms: bedroomCount, bathrooms: bathroomCount });
            }
          }
        }
        
        return res.json({
          success: true,
          message: 'Recalculated bedroom/bathroom counts from feature_codes',
          rooms_checked: rooms.rows.length,
          bedrooms_updated: bedroomUpdates,
          bathrooms_updated: bathroomUpdates,
          samples
        });
      }
      
      // Copy bedrooms -> num_bedrooms and bathrooms -> num_bathrooms for ALL rooms
      const bedroomFix = await pool.query(`
        UPDATE bookable_units 
        SET num_bedrooms = COALESCE(bedrooms, num_bedrooms, 0)
        WHERE bedrooms IS NOT NULL AND bedrooms > 0
        RETURNING id, name, bedrooms, num_bedrooms
      `);
      results.push(`Updated num_bedrooms on ${bedroomFix.rowCount} rooms from bedrooms column`);
      
      const bathroomFix = await pool.query(`
        UPDATE bookable_units 
        SET num_bathrooms = COALESCE(bathrooms, num_bathrooms, 0)
        WHERE bathrooms IS NOT NULL AND bathrooms > 0
        RETURNING id, name, bathrooms, num_bathrooms
      `);
      results.push(`Updated num_bathrooms on ${bathroomFix.rowCount} rooms from bathrooms column`);
      
      // Also update from property_bedrooms/bathrooms tables if they exist
      const bedroomTableFix = await pool.query(`
        UPDATE bookable_units bu
        SET num_bedrooms = sub.cnt
        FROM (
          SELECT room_id, COUNT(*) as cnt 
          FROM property_bedrooms 
          GROUP BY room_id
        ) sub
        WHERE bu.id = sub.room_id AND (bu.num_bedrooms IS NULL OR bu.num_bedrooms = 0)
        RETURNING bu.id, bu.name, bu.num_bedrooms
      `);
      results.push(`Updated num_bedrooms on ${bedroomTableFix.rowCount} rooms from property_bedrooms table`);
      
      const bathroomTableFix = await pool.query(`
        UPDATE bookable_units bu
        SET num_bathrooms = sub.cnt
        FROM (
          SELECT room_id, COUNT(*) as cnt 
          FROM property_bathrooms 
          GROUP BY room_id
        ) sub
        WHERE bu.id = sub.room_id AND (bu.num_bathrooms IS NULL OR bu.num_bathrooms = 0)
        RETURNING bu.id, bu.name, bu.num_bathrooms
      `);
      results.push(`Updated num_bathrooms on ${bathroomTableFix.rowCount} rooms from property_bathrooms table`);
      
      return res.json({
        success: true,
        results,
        bedrooms_from_column: bedroomFix.rows.slice(0, 10),
        bathrooms_from_column: bathroomFix.rows.slice(0, 10)
      });
    }
    
    // Delete test rooms from account 108 properties
    const rooms = await pool.query(
      'DELETE FROM bookable_units WHERE property_id IN (SELECT id FROM properties WHERE account_id = 108) RETURNING id'
    );
    results.push(`Deleted ${rooms.rowCount} rooms from account 108`);
    
    // Delete test properties from account 108
    const props = await pool.query(
      'DELETE FROM properties WHERE account_id = 108 RETURNING id'
    );
    results.push(`Deleted ${props.rowCount} properties from account 108`);
    
    // Delete test sub-account 108
    const acct = await pool.query(
      'DELETE FROM accounts WHERE id = 108 RETURNING id'
    );
    results.push(`Deleted ${acct.rowCount} sub-accounts`);
    
    // Remove Beds24 connections from Elevate (account 92)
    const cc = await pool.query(
      'DELETE FROM channel_connections WHERE gas_account_id = 92 RETURNING id'
    );
    results.push(`Deleted ${cc.rowCount} channel_connections`);
    
    const gsc = await pool.query(
      'DELETE FROM gas_sync_connections WHERE account_id = 92 RETURNING id'
    );
    results.push(`Deleted ${gsc.rowCount} gas_sync_connections`);
    
    // Optionally delete properties directly on account 92
    if (deleteAccount92Props) {
      const rooms92 = await pool.query(
        'DELETE FROM bookable_units WHERE property_id IN (SELECT id FROM properties WHERE account_id = 92) RETURNING id'
      );
      results.push(`Deleted ${rooms92.rowCount} rooms from account 92`);
      
      const props92 = await pool.query(
        'DELETE FROM properties WHERE account_id = 92 RETURNING id'
      );
      results.push(`Deleted ${props92.rowCount} properties from account 92`);
    }
    
    // Optionally update Elevate role to agency_admin
    if (updateRole) {
      await pool.query(
        "UPDATE accounts SET role = 'agency_admin', updated_at = NOW() WHERE id = 92"
      );
      results.push('Updated account 92 role to agency_admin');
    }
    
    // Check remaining properties on account 92
    const remaining = await pool.query(
      'SELECT id, name, beds24_property_id FROM properties WHERE account_id = 92'
    );
    
    // Check current role
    const accountInfo = await pool.query(
      'SELECT id, name, role FROM accounts WHERE id = 92'
    );
    
    res.json({
      success: true,
      cleanup_results: results,
      account_92: accountInfo.rows[0],
      remaining_properties_on_92: remaining.rows,
      tips: [
        remaining.rows.length > 0 ? 'Add ?delete92=true to delete account 92 properties' : null,
        accountInfo.rows[0]?.role !== 'agency_admin' ? 'Add ?role=agency_admin to update role' : null
      ].filter(Boolean)
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Helper to generate API key for new sub-accounts
function generateApiKey() {
  const crypto = require('crypto');
  return 'gas_' + crypto.randomBytes(32).toString('hex');
}

// =========================================================
// ELEVATE PARTNER API - CLIENT MANAGEMENT
// =========================================================

// List all Elevate sub-accounts (clients)
app.get('/api/elevate/:apiKey/clients', async (req, res) => {
  console.log('=== ELEVATE: LIST CLIENTS ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const result = await pool.query(`
      SELECT 
        a.id as account_id,
        a.public_id,
        a.name,
        a.email,
        a.contact_name,
        a.phone,
        a.business_name,
        a.currency,
        a.timezone,
        a.settings->>'account_type' as account_type,
        a.settings->>'external_id' as external_id,
        a.api_key,
        a.status,
        a.created_at,
        COUNT(DISTINCT p.id) as property_count
      FROM accounts a
      LEFT JOIN properties p ON p.account_id = a.id AND p.status = 'active'
      WHERE (a.parent_id = $1 OR a.id = $1)
      GROUP BY a.id
      ORDER BY a.created_at DESC
    `, [ELEVATE_MASTER_ACCOUNT_ID]);
    
    res.json({ 
      success: true, 
      clients: result.rows,
      total: result.rows.length
    });
    
  } catch (error) {
    console.error('Elevate list clients error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get single client details
app.get('/api/elevate/:apiKey/clients/:clientId', async (req, res) => {
  console.log('=== ELEVATE: GET CLIENT ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { clientId } = req.params;
    
    // Find by GAS account_id or partner_external_id (external_id)
    const result = await pool.query(`
      SELECT 
        a.id as account_id,
        a.public_id,
        a.name,
        a.email,
        a.contact_name,
        a.phone,
        a.business_name,
        a.currency,
        a.timezone,
        a.role as account_type,
        a.partner_external_id as external_id,
        a.api_key,
        a.status,
        a.created_at
      FROM accounts a
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (a.id::text = $2 OR a.partner_external_id = $2 OR a.public_id::text = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, clientId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Client not found' });
    }
    
    // Get client's properties
    const properties = await pool.query(`
      SELECT id, name, display_name, short_description, address, city, country, 
             currency, status, cm_property_id as external_id
      FROM properties 
      WHERE account_id = $1 AND status = 'active'
    `, [result.rows[0].account_id]);
    
    // Get rooms for each property
    const propertiesWithRooms = await Promise.all(properties.rows.map(async (prop) => {
      const rooms = await pool.query(`
        SELECT id, name, display_name, short_description, room_type, status,
               max_guests, max_adults, max_children, quantity,
               base_price, currency, cm_room_id as external_id,
               num_bedrooms, num_bathrooms
        FROM bookable_units 
        WHERE property_id = $1 AND (status IS NULL OR status = 'active')
        ORDER BY name
      `, [prop.id]);
      
      return {
        ...prop,
        rooms: rooms.rows
      };
    }));
    
    res.json({ 
      success: true, 
      client: result.rows[0],
      properties: propertiesWithRooms
    });
    
  } catch (error) {
    console.error('Elevate get client error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE PARTNER API - PROPERTY WITH CLIENT HANDLING
// =========================================================

// Create property (with client create or assign to existing)
app.post('/api/elevate/:apiKey/property', async (req, res) => {
  console.log('=== ELEVATE: CREATE PROPERTY ===');
  console.log('Body:', JSON.stringify(req.body, null, 2));
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { client, property, rooms } = req.body;
    
    if (!client || !property) {
      return res.status(400).json({ 
        success: false, 
        error: 'Both "client" and "property" objects are required' 
      });
    }
    
    let clientAccountId;
    let clientApiKey;
    let clientUserId;
    let clientCreated = false;
    
    // =========================================================
    // HANDLE CLIENT - CREATE NEW OR USE EXISTING
    // =========================================================
    
    if (client.action === 'create') {
      // Validate required fields for new client
      if (!client.name || !client.email) {
        return res.status(400).json({ 
          success: false, 
          error: 'client.name and client.email are required for new clients' 
        });
      }
      
      // Check if external_id already exists
      if (client.external_id) {
        const existing = await pool.query(
          "SELECT id FROM accounts WHERE parent_id = $1 AND settings->>'external_id' = $2",
          [ELEVATE_MASTER_ACCOUNT_ID, client.external_id]
        );
        if (existing.rows.length > 0) {
          return res.status(400).json({ 
            success: false, 
            error: `Client with external_id "${client.external_id}" already exists. Use action: "existing" to add properties to it.`,
            existing_account_id: existing.rows[0].id
          });
        }
      }
      
      // Check if email already exists under Elevate accounts
      const emailCheck = await pool.query(
        'SELECT id FROM accounts WHERE parent_id = $1 AND email = $2',
        [ELEVATE_MASTER_ACCOUNT_ID, client.email]
      );
      if (emailCheck.rows.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: `Client with email "${client.email}" already exists.`,
          existing_account_id: emailCheck.rows[0].id
        });
      }
      
      // Create new sub-account
      clientApiKey = generateApiKey();
      const accountType = client.account_type || 'individual';
      
      // First, check if user with this email already exists
      let userId;
      const existingUser = await pool.query(
        'SELECT id FROM users WHERE email = $1',
        [client.email]
      );
      
      if (existingUser.rows.length > 0) {
        // Use existing user
        userId = existingUser.rows[0].id;
        console.log(`[Elevate] Using existing user ${userId} for client`);
      } else {
        // Create new user record so they can log in to GAS
        const tempPassword = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        const passwordHash = Buffer.from(tempPassword).toString('base64');
        
        // Split client name into first/last
        const nameParts = (client.name || 'Elevate Client').split(' ');
        const firstName = nameParts[0] || 'Elevate';
        const lastName = nameParts.slice(1).join(' ') || 'Client';
        
        const newUser = await pool.query(`
          INSERT INTO users (
            email, password_hash, first_name, last_name, 
            user_type, account_status, company_name, created_at
          )
          VALUES ($1, $2, $3, $4, $5, 'active', $6, NOW())
          RETURNING id
        `, [
          client.email,
          passwordHash,
          firstName,
          lastName,
          accountType === 'group' ? 'property_owner' : 'property_owner',
          client.business_name || client.name || ''
        ]);
        
        userId = newUser.rows[0].id;
        console.log(`[Elevate] Created new user ${userId} for client`);
      }
      
      // Now create the account (store user_id in settings since column doesn't exist)
      const newAccount = await pool.query(`
        INSERT INTO accounts (
          parent_id, name, email, contact_name, phone, business_name,
          currency, timezone, api_key, api_key_created_at, status, settings, created_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), 'active', $10, NOW()
        )
        RETURNING id, public_id, api_key
      `, [
        ELEVATE_MASTER_ACCOUNT_ID,
        client.name,
        client.email,
        client.contact_name || null,
        client.phone || null,
        client.business_name || client.name,
        client.currency || 'CHF',
        client.timezone || 'Europe/Zurich',
        clientApiKey,
        JSON.stringify({
          account_type: accountType,
          external_id: client.external_id || null,
          created_by: 'elevate_api',
          user_id: userId
        })
      ]);
      
      clientAccountId = newAccount.rows[0].id;
      clientApiKey = newAccount.rows[0].api_key;
      clientUserId = userId;
      clientCreated = true;
      
      // Link user back to account
      await pool.query('UPDATE users SET account_id = $1 WHERE id = $2', [clientAccountId, userId]);
      
      console.log(`[Elevate] Created new ${accountType} client account ${clientAccountId} with user_id ${userId}`);
      
    } else if (client.action === 'existing') {
      // Find existing client by account_id or external_id
      const identifier = client.account_id || client.external_id;
      if (!identifier) {
        return res.status(400).json({ 
          success: false, 
          error: 'client.account_id or client.external_id required for existing clients' 
        });
      }
      
      const existingClient = await pool.query(`
        SELECT id, api_key, email, settings FROM accounts 
        WHERE parent_id = $1 
        AND (id::text = $2 OR settings->>'external_id' = $2)
      `, [ELEVATE_MASTER_ACCOUNT_ID, String(identifier)]);
      
      if (existingClient.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: `Client "${identifier}" not found` 
        });
      }
      
      clientAccountId = existingClient.rows[0].id;
      clientApiKey = existingClient.rows[0].api_key;
      
      // Get user_id from settings JSON - safely parse if string
      let settings = existingClient.rows[0].settings || {};
      if (typeof settings === 'string') {
        try { settings = JSON.parse(settings); } catch(e) { settings = {}; }
      }
      clientUserId = settings.user_id;
      
      // If existing account doesn't have user_id, try to find or create one
      if (!clientUserId) {
        const email = existingClient.rows[0].email;
        
        if (email) {
          const existingUser = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
          if (existingUser.rows.length > 0) {
            clientUserId = existingUser.rows[0].id;
          } else {
            // Create user for this existing account with correct schema
            const tempPassword = Math.random().toString(36).substring(2, 15);
            const passwordHash = Buffer.from(tempPassword).toString('base64');
            
            const nameParts = (client.name || 'Elevate Client').split(' ');
            const firstName = nameParts[0] || 'Elevate';
            const lastName = nameParts.slice(1).join(' ') || 'Client';
            
            const newUser = await pool.query(`
              INSERT INTO users (
                email, password_hash, first_name, last_name,
                user_type, account_status, company_name, created_at
              )
              VALUES ($1, $2, $3, $4, 'property_owner', 'active', $5, NOW())
              RETURNING id
            `, [email, passwordHash, firstName, lastName, client.business_name || '']);
            clientUserId = newUser.rows[0].id;
          }
          
          // Update account settings with user_id
          const updatedSettings = { ...settings, user_id: clientUserId };
          try {
            await pool.query('UPDATE accounts SET settings = $1 WHERE id = $2', [JSON.stringify(updatedSettings), clientAccountId]);
            console.log(`[Elevate] Linked user ${clientUserId} to existing account ${clientAccountId}`);
          } catch (settingsError) {
            console.error(`[Elevate] Existing account settings UPDATE failed for account ${clientAccountId}:`, settingsError.message);
            console.error('[Elevate] Settings value was:', JSON.stringify(updatedSettings));
            return res.status(500).json({ 
              success: false, 
              error: settingsError.message,
              step: 'existing_settings_update'
            });
          }
        }
      }
      
      console.log(`[Elevate] Using existing client account ${clientAccountId} with user_id ${clientUserId}`);
      
    } else if (client.action === 'tenant') {
      // Use tenant_id from partner_tenant_mapping (created via Partner API)
      if (!client.tenant_id) {
        return res.status(400).json({ 
          success: false, 
          error: 'client.tenant_id is required when using action: "tenant"' 
        });
      }
      
      const tenantMapping = await pool.query(`
        SELECT ptm.gas_account_id, a.api_key, a.email, a.settings
        FROM partner_tenant_mapping ptm
        JOIN accounts a ON a.id = ptm.gas_account_id
        WHERE ptm.partner_account_id = $1 AND ptm.external_tenant_id = $2
      `, [ELEVATE_MASTER_ACCOUNT_ID, client.tenant_id]);
      
      if (tenantMapping.rows.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: `Tenant "${client.tenant_id}" not found. Create it first via POST /api/partner/tenants` 
        });
      }
      
      clientAccountId = tenantMapping.rows[0].gas_account_id;
      clientApiKey = tenantMapping.rows[0].api_key;
      
      // Get user_id from settings JSON - safely parse if string
      let settings = tenantMapping.rows[0].settings || {};
      if (typeof settings === 'string') {
        try { settings = JSON.parse(settings); } catch(e) { settings = {}; }
      }
      clientUserId = settings.user_id;
      
      // If tenant account doesn't have user_id, try to find or create one
      if (!clientUserId) {
        const email = tenantMapping.rows[0].email;
        
        if (email) {
          const existingUser = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
          if (existingUser.rows.length > 0) {
            clientUserId = existingUser.rows[0].id;
          } else {
            // Create user for this tenant account
            const tempPassword = Math.random().toString(36).substring(2, 15);
            const passwordHash = Buffer.from(tempPassword).toString('base64');
            
            const newUser = await pool.query(`
              INSERT INTO users (
                email, password_hash, first_name, last_name,
                user_type, account_status, created_at
              )
              VALUES ($1, $2, 'Tenant', 'User', 'property_owner', 'active', NOW())
              RETURNING id
            `, [email, passwordHash]);
            clientUserId = newUser.rows[0].id;
          }
          
          // Update account settings with user_id
          const updatedSettings = { ...settings, user_id: clientUserId };
          try {
            await pool.query('UPDATE accounts SET settings = $1 WHERE id = $2', [JSON.stringify(updatedSettings), clientAccountId]);
            console.log(`[Elevate] Linked user ${clientUserId} to tenant account ${clientAccountId}`);
          } catch (settingsError) {
            console.error(`[Elevate] Tenant settings UPDATE failed for account ${clientAccountId}:`, settingsError.message);
            console.error('[Elevate] Settings value was:', JSON.stringify(updatedSettings));
            return res.status(500).json({ 
              success: false, 
              error: settingsError.message,
              step: 'tenant_settings_update'
            });
          }
        }
      }
      
      console.log(`[Elevate] Using tenant account ${clientAccountId} (tenant_id: ${client.tenant_id}) with user_id ${clientUserId}`);
      
    } else {
      return res.status(400).json({ 
        success: false, 
        error: 'client.action must be "create", "existing", or "tenant"' 
      });
    }
    
    // =========================================================
    // CREATE PROPERTY
    // =========================================================
    
    if (!property.name) {
      return res.status(400).json({ success: false, error: 'property.name is required' });
    }
    
    // Check if property with this external_id already exists for this client
    if (property.external_id) {
      const existingProp = await pool.query(
        "SELECT id FROM properties WHERE account_id = $1 AND cm_property_id = $2",
        [clientAccountId, property.external_id]
      );
      if (existingProp.rows.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: `Property with external_id "${property.external_id}" already exists for this client`,
          existing_property_id: existingProp.rows[0].id
        });
      }
    }
    
    // Ensure we have a valid user_id
    if (!clientUserId) {
      return res.status(500).json({
        success: false,
        error: 'Could not determine user_id for this client. Please contact support.'
      });
    }
    
    // Prepare description values - handle both TEXT and JSONB column types
    // The live DB may have these as JSONB for multilingual support
    const rawShortDesc = property.short_description || property.description || null;
    const rawFullDesc = property.long_description || property.full_description || property.description || null;
    const rawDisplayName = property.display_name || property.name;
    
    // Helper: wrap a string as JSONB {"en": "..."} if needed
    function toJsonbSafe(val) {
      if (val === null || val === undefined) return null;
      if (typeof val === 'object') return JSON.stringify(val);
      // Already valid JSON?
      try { JSON.parse(val); return val; } catch(e) {}
      // Wrap plain string as multilingual object
      return JSON.stringify({ en: val });
    }
    
    // First, check the actual column types in the live database
    let colTypes = {};
    try {
      const typeCheck = await pool.query(`
        SELECT column_name, data_type 
        FROM information_schema.columns 
        WHERE table_name = 'properties' 
          AND column_name IN ('short_description', 'full_description', 'display_name', 'description')
      `);
      for (const row of typeCheck.rows) {
        colTypes[row.column_name] = row.data_type;
      }
      console.log('[Elevate] Properties column types:', JSON.stringify(colTypes));
    } catch (schemaErr) {
      console.log('[Elevate] Could not check column types:', schemaErr.message);
    }
    
    // Format values based on actual column types
    const shortDesc = (colTypes.short_description === 'jsonb' || colTypes.short_description === 'json') 
      ? toJsonbSafe(rawShortDesc) : rawShortDesc;
    const fullDesc = (colTypes.full_description === 'jsonb' || colTypes.full_description === 'json') 
      ? toJsonbSafe(rawFullDesc) : rawFullDesc;
    const displayName = (colTypes.display_name === 'jsonb' || colTypes.display_name === 'json') 
      ? toJsonbSafe(rawDisplayName) : rawDisplayName;
    
    console.log('[Elevate] Property INSERT params:', JSON.stringify({
      user_id: clientUserId,
      account_id: clientAccountId, 
      name: property.name,
      display_name: displayName,
      short_desc_type: typeof shortDesc,
      full_desc_type: typeof fullDesc,
      display_name_type: typeof displayName,
      colTypes
    }));
    
    let newProperty;
    try {
      newProperty = await pool.query(`
        INSERT INTO properties (
          user_id, account_id, name, display_name, short_description, full_description,
          address, city, state, country, postal_code,
          latitude, longitude, phone, email, currency, property_type,
          cm_source, cm_property_id, status, created_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
          'elevate', $18, 'active', NOW()
        )
        RETURNING id
      `, [
        clientUserId,
        clientAccountId,
        property.name,
        displayName,
        shortDesc,
        fullDesc,
        property.address || null,
        property.city || null,
        property.state || null,
        property.country || 'CH',
        property.zip || property.postal_code || property.zip_code || null,
        property.latitude || null,
        property.longitude || null,
        property.phone || null,
        property.email || null,
        property.currency || 'CHF',
        property.property_type || 'vacation_rental',
        property.external_id || null
      ]);
    } catch (propError) {
      console.error('[Elevate] Property INSERT failed:', propError.message);
      console.error('[Elevate] Failed with colTypes:', JSON.stringify(colTypes));
      console.error('[Elevate] Failed param values:', JSON.stringify({
        shortDesc, fullDesc, displayName,
        short_type: typeof shortDesc,
        full_type: typeof fullDesc,
        display_type: typeof displayName
      }));
      return res.status(500).json({ 
        success: false, 
        error: propError.message,
        step: 'property_insert',
        colTypes,
        debug: {
          short_desc_value: shortDesc ? shortDesc.substring(0, 50) : null,
          full_desc_value: fullDesc ? fullDesc.substring(0, 50) : null,
          display_name_value: displayName ? String(displayName).substring(0, 50) : null
        }
      });
    }
    
    const propertyId = newProperty.rows[0].id;
    console.log(`[Elevate] Created property ${propertyId} for client ${clientAccountId} (user_id: ${clientUserId})`);
    
    // =========================================================
    // CREATE ROOMS (if provided)
    // =========================================================
    
    const createdRooms = [];
    
    if (rooms && Array.isArray(rooms) && rooms.length > 0) {
      for (const room of rooms) {
        if (!room.name) continue;
        
        // bookable_units has JSONB columns for display_name, short_description, full_description
        // Wrap plain strings as {"en": "..."} for JSONB compatibility
        const roomDisplayName = toJsonbSafe(room.display_name || room.name);
        const roomShortDesc = toJsonbSafe(room.short_description || room.description || null);
        const roomFullDesc = toJsonbSafe(room.long_description || room.full_description || null);
        
        let newRoom;
        try {
          newRoom = await pool.query(`
            INSERT INTO bookable_units (
              property_id, name, display_name, room_type, max_guests, num_bedrooms, num_bathrooms, base_price,
              short_description, full_description,
              currency, cm_room_id, cm_source, status, created_at
            ) VALUES (
              $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, 'elevate', 'active', NOW()
            )
            RETURNING id
          `, [
            propertyId,
            room.name,
            roomDisplayName,
            room.room_type || 'room',
            room.max_guests || room.max_guest || room.max_occupancy || 2,
            room.bedrooms || room.num_bedrooms || null,
            room.bathrooms || room.num_bathrooms || null,
            room.base_rate || room.base_price || null,
            roomShortDesc,
            roomFullDesc,
            room.currency || property.currency || 'CHF',
            room.external_id || null
          ]);
        } catch (roomError) {
          console.error(`[Elevate] Room INSERT failed for "${room.name}":`, roomError.message);
          console.error('[Elevate] Room params:', JSON.stringify({ roomDisplayName, roomShortDesc, roomFullDesc }));
          // Return partial success - property was created but room failed
          return res.status(500).json({ 
            success: false, 
            error: roomError.message,
            step: 'room_insert',
            room_name: room.name,
            property_id: propertyId
          });
        }
        
        createdRooms.push({
          external_id: room.external_id || null,
          gas_room_id: newRoom.rows[0].id,
          unit_id: newRoom.rows[0].id,  // Same as gas_room_id, for clarity
          name: room.name
        });
        
        console.log(`[Elevate] Created room ${newRoom.rows[0].id}: ${room.name}`);
      }
    }
    
    // =========================================================
    // RESPONSE
    // =========================================================
    
    res.json({
      success: true,
      client_created: clientCreated,
      account_id: clientAccountId,
      account_api_key: clientApiKey,
      property_id: propertyId,
      rooms: createdRooms
    });
    
  } catch (error) {
    console.error('Elevate create property error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Update property
app.put('/api/elevate/:apiKey/property/:propertyId', async (req, res) => {
  console.log('=== ELEVATE: UPDATE PROPERTY ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId } = req.params;
    
    // Support both flat format and nested { property: {...} } format
    // This maintains backward compatibility while supporting Elevate's preferred format
    let updates = req.body;
    if (req.body.property && typeof req.body.property === 'object') {
      updates = req.body.property;
      console.log('Using nested property object format');
    }
    
    // Find property (by GAS ID or external_id) that belongs to an Elevate sub-account
    const propCheck = await pool.query(`
      SELECT p.id, p.account_id 
      FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const gasPropertyId = propCheck.rows[0].id;
    
    // Build update query dynamically
    const updateFields = [];
    const values = [];
    let paramIndex = 1;
    
    const allowedFields = ['name', 'display_name', 'short_description', 'full_description',
                          'address', 'address_line2', 'city', 'region', 
                          'postcode', 'country', 'latitude', 'longitude', 
                          'phone', 'email', 'currency', 'timezone', 'property_type'];
    
    // Handle long_description as alias for full_description
    if (updates.long_description !== undefined && updates.full_description === undefined) {
      updates.full_description = updates.long_description;
    }
    
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        updateFields.push(`${field} = $${paramIndex}`);
        values.push(updates[field]);
        paramIndex++;
      }
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({ success: false, error: 'No valid fields to update' });
    }
    
    updateFields.push(`updated_at = NOW()`);
    values.push(gasPropertyId);
    
    await pool.query(
      `UPDATE properties SET ${updateFields.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    
    res.json({ success: true, property_id: gasPropertyId });
    
  } catch (error) {
    console.error('Elevate update property error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete/deactivate property
app.delete('/api/elevate/:apiKey/property/:propertyId', async (req, res) => {
  console.log('=== ELEVATE: DELETE PROPERTY ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId } = req.params;
    
    // Find property that belongs to an Elevate sub-account
    const propCheck = await pool.query(`
      SELECT p.id 
      FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    // Soft delete - set status to inactive
    await pool.query(
      "UPDATE properties SET status = 'inactive', updated_at = NOW() WHERE id = $1",
      [propCheck.rows[0].id]
    );
    
    res.json({ success: true, property_id: propCheck.rows[0].id, status: 'inactive' });
    
  } catch (error) {
    console.error('Elevate delete property error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE PARTNER API - ROOM MANAGEMENT
// =========================================================

// Add room to property
app.post('/api/elevate/:apiKey/property/:propertyId/room', async (req, res) => {
  console.log('=== ELEVATE: ADD ROOM ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId } = req.params;
    const room = req.body;
    
    // Find property
    const propCheck = await pool.query(`
      SELECT p.id, p.currency
      FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const gasPropertyId = propCheck.rows[0].id;
    
    if (!room.name) {
      return res.status(400).json({ success: false, error: 'room.name is required' });
    }
    
    const newRoom = await pool.query(`
      INSERT INTO bookable_units (
        property_id, name, display_name, short_description, full_description,
        room_type, max_guests, max_adults, max_children, quantity,
        base_price, currency, cm_room_id, cm_source, status, created_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'elevate', $14, NOW()
      )
      RETURNING id
    `, [
      gasPropertyId,
      room.name,
      room.display_name || room.name,
      room.short_description || null,
      room.long_description || room.full_description || null,
      room.room_type || 'room',
      room.max_guests || room.max_occupancy || 2,
      room.max_adults || room.max_guests || room.max_occupancy || 2,
      room.max_children || 0,
      room.quantity || room.qty || 1,
      room.base_rate || room.base_price || null,
      room.currency || propCheck.rows[0].currency || 'CHF',
      room.external_id || null,
      room.status || 'active'
    ]);
    
    res.json({
      success: true,
      property_id: gasPropertyId,
      room_id: newRoom.rows[0].id,
      unit_id: newRoom.rows[0].id,  // Same as room_id, for clarity with room-types endpoint
      external_id: room.external_id || null
    });
    
  } catch (error) {
    console.error('Elevate add room error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get rooms for a property
app.get('/api/elevate/:apiKey/property/:propertyId/rooms', async (req, res) => {
  console.log('=== ELEVATE: GET PROPERTY ROOMS ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId } = req.params;
    
    // Find property
    const propCheck = await pool.query(`
      SELECT p.id
      FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const gasPropertyId = propCheck.rows[0].id;
    
    // Get rooms
    const rooms = await pool.query(`
      SELECT id, name, display_name, short_description, full_description,
             room_type, status, max_guests, max_adults, max_children, 
             quantity, base_price, currency, cm_room_id as external_id,
             num_bedrooms, num_bathrooms, created_at
      FROM bookable_units 
      WHERE property_id = $1 AND (status IS NULL OR status != 'deleted')
      ORDER BY name
    `, [gasPropertyId]);
    
    res.json({
      success: true,
      property_id: gasPropertyId,
      room_count: rooms.rows.length,
      rooms: rooms.rows
    });
    
  } catch (error) {
    console.error('Elevate get property rooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Update room
app.put('/api/elevate/:apiKey/room/:roomId', async (req, res) => {
  console.log('=== ELEVATE: UPDATE ROOM ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    
    // Support both flat format and nested { room: {...} } format
    let updates = req.body;
    if (req.body.room && typeof req.body.room === 'object') {
      updates = req.body.room;
      console.log('Using nested room object format');
    }
    
    // Find room that belongs to an Elevate property
    const roomCheck = await pool.query(`
      SELECT bu.id 
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    const updateFields = [];
    const values = [];
    let paramIndex = 1;
    
    // JSONB columns need special handling - convert string to JSON object
    const jsonbColumns = ['display_name', 'short_description', 'full_description'];
    
    // Numeric columns - convert strings to numbers
    const numericColumns = ['max_guests', 'max_adults', 'max_children', 'quantity', 'num_bedrooms', 'num_bathrooms', 'base_price'];
    
    // Map API field names to database column names
    const fieldMap = {
      'name': 'name',
      'display_name': 'display_name',
      'short_description': 'short_description',
      'long_description': 'full_description',
      'full_description': 'full_description',
      'description': 'full_description',
      'room_type': 'room_type',
      'status': 'status',
      'max_guests': 'max_guests',
      'max_occupancy': 'max_guests',
      'max_adults': 'max_adults',
      'max_children': 'max_children',
      'quantity': 'quantity',
      'qty': 'quantity',
      'num_bedrooms': 'num_bedrooms',
      'bedrooms': 'num_bedrooms',
      'num_bathrooms': 'num_bathrooms',
      'bathrooms': 'num_bathrooms',
      'base_rate': 'base_price',
      'base_price': 'base_price',
      'currency': 'currency'
    };
    
    for (const [apiField, dbField] of Object.entries(fieldMap)) {
      if (updates[apiField] !== undefined && updates[apiField] !== null) {
        let value = updates[apiField];
        
        // Handle JSONB columns - convert string to JSON object with 'en' key
        if (jsonbColumns.includes(dbField)) {
          let jsonValue;
          if (typeof value === 'string') {
            jsonValue = JSON.stringify({ en: value });
          } else if (typeof value === 'object') {
            jsonValue = JSON.stringify(value);
          } else {
            continue;
          }
          updateFields.push(`${dbField} = $${paramIndex}::jsonb`);
          values.push(jsonValue);
        } 
        // Handle numeric columns - convert string to number
        else if (numericColumns.includes(dbField)) {
          const numValue = parseFloat(value);
          if (isNaN(numValue)) {
            continue; // Skip invalid numeric values
          }
          updateFields.push(`${dbField} = $${paramIndex}`);
          values.push(numValue);
        }
        else {
          updateFields.push(`${dbField} = $${paramIndex}`);
          values.push(value);
        }
        paramIndex++;
      }
    }
    
    if (updateFields.length === 0) {
      return res.status(400).json({ success: false, error: 'No valid fields to update' });
    }
    
    updateFields.push(`updated_at = NOW()`);
    values.push(gasRoomId);
    
    await pool.query(
      `UPDATE bookable_units SET ${updateFields.join(', ')} WHERE id = $${paramIndex}`,
      values
    );
    
    res.json({ success: true, room_id: gasRoomId });
    
  } catch (error) {
    console.error('Elevate update room error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE: ROOM AMENITIES
// =========================================================

// Get amenities for a room
app.get('/api/elevate/:apiKey/room/:roomId/amenities', async (req, res) => {
  console.log('=== ELEVATE: GET ROOM AMENITIES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    
    // Find room and get amenities from bookable_units
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.amenities
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const amenitiesData = roomCheck.rows[0].amenities;
    
    // Parse amenities - could be JSON object with amenities array, or just array
    let amenities = [];
    if (amenitiesData) {
      if (Array.isArray(amenitiesData)) {
        amenities = amenitiesData;
      } else if (amenitiesData.amenities && Array.isArray(amenitiesData.amenities)) {
        amenities = amenitiesData.amenities;
      } else if (amenitiesData.raw_amenities && Array.isArray(amenitiesData.raw_amenities)) {
        amenities = amenitiesData.raw_amenities.map(a => a.name || a);
      }
    }
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      amenities: amenities
    });
    
  } catch (error) {
    console.error('Elevate get amenities error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Set amenities for a room (replaces existing) - WITH INTELLIGENT MATCHING
app.put('/api/elevate/:apiKey/room/:roomId/amenities', async (req, res) => {
  console.log('=== ELEVATE: SET ROOM AMENITIES (with matching) ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    const { amenities } = req.body;
    
    if (!Array.isArray(amenities)) {
      return res.status(400).json({ success: false, error: 'amenities must be an array' });
    }
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id 
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    // Clear existing room_amenity_selections for this room
    await pool.query('DELETE FROM room_amenity_selections WHERE room_id = $1', [gasRoomId]);
    
    // Process and match each amenity
    const matched = [];
    const unmatched = [];
    const processedAmenities = [];
    
    for (const a of amenities) {
      const rawName = typeof a === 'string' ? a : a.name;
      if (!rawName) continue;
      
      const matchResult = await matchAmenity(rawName, 'elevate');
      
      if (matchResult.matched) {
        matched.push({
          raw: rawName,
          matched_to: matchResult.amenity.amenity_code,
          name: matchResult.amenity.amenity_name,
          icon: matchResult.amenity.icon,
          category: matchResult.amenity.category,
          match_type: matchResult.match_type
        });
        
        // Get amenity name as string
        let amenityName = matchResult.amenity.amenity_name;
        if (typeof amenityName === 'object') {
          amenityName = amenityName.en || Object.values(amenityName)[0] || matchResult.amenity.amenity_code;
        }
        
        processedAmenities.push({
          code: matchResult.amenity.amenity_code,
          name: amenityName,
          icon: matchResult.amenity.icon,
          category: matchResult.amenity.category
        });
        
        // Insert into room_amenity_selections for proper linking
        await pool.query(`
          INSERT INTO room_amenity_selections (room_id, amenity_id)
          VALUES ($1, $2)
          ON CONFLICT (room_id, amenity_id) DO NOTHING
        `, [gasRoomId, matchResult.amenity.id]);
        
      } else {
        unmatched.push(rawName);
        processedAmenities.push({
          code: rawName.toLowerCase().replace(/[^a-z0-9]/g, '_'),
          name: rawName,
          icon: '‚úì',
          category: 'Other',
          unmatched: true
        });
      }
    }
    
    // Save to bookable_units.amenities JSON field (for quick access)
    const amenitiesJson = {
      amenities: processedAmenities,
      raw_amenities: amenities.map(a => typeof a === 'string' ? { name: a } : a),
      matched_count: matched.length,
      unmatched_count: unmatched.length,
      updated_at: new Date().toISOString(),
      source: 'elevate'
    };
    
    await pool.query(
      'UPDATE bookable_units SET amenities = $1, updated_at = NOW() WHERE id = $2',
      [JSON.stringify(amenitiesJson), gasRoomId]
    );
    
    console.log(`Elevate amenities: ${matched.length} matched, ${unmatched.length} unmatched for room ${gasRoomId}`);
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      total_count: processedAmenities.length,
      matched_count: matched.length,
      unmatched_count: unmatched.length,
      matched: matched,
      unmatched: unmatched
    });
    
  } catch (error) {
    console.error('Elevate set amenities error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Add amenities to a room (without removing existing)
app.post('/api/elevate/:apiKey/room/:roomId/amenities', async (req, res) => {
  console.log('=== ELEVATE: ADD ROOM AMENITIES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    const { amenities } = req.body;
    
    if (!Array.isArray(amenities)) {
      return res.status(400).json({ success: false, error: 'amenities must be an array' });
    }
    
    // Find room and get existing amenities
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.amenities
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const existingAmenities = roomCheck.rows[0].amenities || {};
    
    // Get existing amenities list
    let existingList = [];
    if (existingAmenities.amenities && Array.isArray(existingAmenities.amenities)) {
      existingList = existingAmenities.amenities;
    }
    
    // Process new amenities
    const newAmenities = amenities.map(a => typeof a === 'string' ? a : a.name).filter(Boolean);
    
    // Merge with existing (no duplicates)
    const mergedAmenities = [...new Set([...existingList, ...newAmenities])];
    
    // Save to bookable_units.amenities JSON field
    const amenitiesJson = {
      amenities: mergedAmenities,
      raw_amenities: mergedAmenities.map(a => ({ name: a })),
      updated_at: new Date().toISOString(),
      source: 'elevate'
    };
    
    await pool.query(
      'UPDATE bookable_units SET amenities = $1, updated_at = NOW() WHERE id = $2',
      [JSON.stringify(amenitiesJson), gasRoomId]
    );
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      added: newAmenities.length,
      total: mergedAmenities.length,
      amenities: mergedAmenities
    });
    
  } catch (error) {
    console.error('Elevate add amenities error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE: BEDROOM/BATHROOM CONFIGURATION
// =========================================================

// Set bedroom configuration for a room (replaces existing)
app.put('/api/elevate/:apiKey/room/:roomId/bedrooms', async (req, res) => {
  console.log('=== ELEVATE: SET ROOM BEDROOMS ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    let { bedrooms } = req.body;
    
    // Support nested format: { bedrooms: [...] }
    if (!bedrooms && req.body.room?.bedrooms) {
      bedrooms = req.body.room.bedrooms;
    }
    
    if (!Array.isArray(bedrooms)) {
      return res.status(400).json({ success: false, error: 'bedrooms must be an array' });
    }
    
    // Find room and get property_id
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.property_id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const propertyId = roomCheck.rows[0].property_id;
    
    // Remove existing bedrooms for this room
    await pool.query('DELETE FROM property_bedrooms WHERE room_id = $1', [gasRoomId]);
    
    // Add new bedrooms
    const addedBedrooms = [];
    let displayOrder = 1;
    
    for (const bedroom of bedrooms) {
      const bedroomName = bedroom.name || `Bedroom ${displayOrder}`;
      
      // Build bed_config JSONB from beds array
      const beds = bedroom.beds || [{ type: bedroom.bed_type || 'bed_double', count: bedroom.bed_count || 1 }];
      
      // Normalize bed types to match UI expectations (no 'bed_' prefix, 'qty' instead of 'count')
      const normalizedBeds = beds.map(bed => {
        let bedType = bed.type || bed.bed_type || 'double';
        const bedTypeLower = bedType.toLowerCase().replace(/\s+/g, '-').replace(/^bed[_-]?/, '');
        
        // Map to standard UI bed types
        let uiType = 'double';
        if (bedTypeLower.includes('super') && bedTypeLower.includes('king')) uiType = 'super-king';
        else if (bedTypeLower.includes('king')) uiType = 'king';
        else if (bedTypeLower.includes('queen')) uiType = 'queen';
        else if (bedTypeLower.includes('double')) uiType = 'double';
        else if (bedTypeLower.includes('single') || bedTypeLower.includes('twin')) uiType = 'single';
        else if (bedTypeLower.includes('sofa') && bedTypeLower.includes('single')) uiType = 'sofa-bed-single';
        else if (bedTypeLower.includes('sofa')) uiType = 'sofa-bed';
        else if (bedTypeLower.includes('bunk')) uiType = 'bunk';
        else if (bedTypeLower.includes('cot') || bedTypeLower.includes('crib')) uiType = 'cot';
        else if (bedTypeLower.includes('futon')) uiType = 'futon';
        else if (bedTypeLower.includes('murphy')) uiType = 'murphy';
        else if (bedTypeLower.includes('daybed')) uiType = 'daybed';
        else if (bedTypeLower.includes('trundle')) uiType = 'trundle';
        else if (bedTypeLower.includes('toddler')) uiType = 'toddler';
        else if (bedTypeLower.includes('air')) uiType = 'air-mattress';
        else if (bedTypeLower.includes('floor')) uiType = 'floor-mattress';
        else uiType = bedTypeLower;
        
        return {
          type: uiType,
          qty: bed.count || bed.qty || bed.bed_count || 1
        };
      });
      
      // Save as flat array (UI expects this format, not {beds: [...]})
      const bedConfig = normalizedBeds;
      
      const result = await pool.query(`
        INSERT INTO property_bedrooms (property_id, room_id, name, bed_config, has_ensuite, display_order, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
        RETURNING id
      `, [propertyId, gasRoomId, bedroomName, JSON.stringify(bedConfig), bedroom.has_ensuite || false, displayOrder]);
      
      addedBedrooms.push({
        id: result.rows[0].id,
        name: bedroomName,
        bed_config: bedConfig,
        has_ensuite: bedroom.has_ensuite || false,
        display_order: displayOrder
      });
      
      displayOrder++;
    }
    
    // Also update num_bedrooms on the room
    await pool.query(
      'UPDATE bookable_units SET num_bedrooms = $1, updated_at = NOW() WHERE id = $2',
      [bedrooms.length, gasRoomId]
    );
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      bedrooms_count: addedBedrooms.length,
      bedrooms: addedBedrooms
    });
    
  } catch (error) {
    console.error('Elevate set bedrooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get bedroom configuration for a room
app.get('/api/elevate/:apiKey/room/:roomId/bedrooms', async (req, res) => {
  console.log('=== ELEVATE: GET ROOM BEDROOMS ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.num_bedrooms
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    // Get bedrooms
    const bedroomsResult = await pool.query(`
      SELECT id, name, bed_config, has_ensuite, display_order
      FROM property_bedrooms
      WHERE room_id = $1
      ORDER BY display_order
    `, [gasRoomId]);
    
    res.json({
      success: true,
      room_id: gasRoomId,
      num_bedrooms: roomCheck.rows[0].num_bedrooms,
      bedrooms: bedroomsResult.rows
    });
    
  } catch (error) {
    console.error('Elevate get bedrooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Set bathroom configuration for a room (replaces existing)
app.put('/api/elevate/:apiKey/room/:roomId/bathrooms', async (req, res) => {
  console.log('=== ELEVATE: SET ROOM BATHROOMS ===');
  console.log('Content-Type:', req.headers['content-type']);
  console.log('Raw body type:', typeof req.body);
  console.log('Request body:', JSON.stringify(req.body, null, 2));
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    let { bathrooms } = req.body;
    
    // Support nested format
    if (!bathrooms && req.body.room?.bathrooms) {
      bathrooms = req.body.room.bathrooms;
    }
    
    if (!bathrooms) {
      return res.status(400).json({ success: false, error: 'bathrooms field is required' });
    }
    
    if (!Array.isArray(bathrooms)) {
      return res.status(400).json({ success: false, error: 'bathrooms must be an array' });
    }
    
    // Find room and get property_id
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.property_id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const propertyId = roomCheck.rows[0].property_id;
    
    // Remove existing bathrooms for this room
    await pool.query('DELETE FROM property_bathrooms WHERE room_id = $1', [gasRoomId]);
    
    // Add new bathrooms
    const addedBathrooms = [];
    let displayOrder = 1;
    
    for (const bathroom of bathrooms) {
      let bathType = bathroom.type || bathroom.bathroom_type || 'bathroom_full';
      const quantity = bathroom.quantity || 1;
      const name = bathroom.name || null;
      const features = bathroom.features ? JSON.stringify(bathroom.features) : null;
      const linkedBedroom = bathroom.linked_bedroom || null;
      
      // Normalize bathroom type
      const bathTypeLower = bathType.toLowerCase().replace(/\s+/g, '_');
      if (bathTypeLower.includes('ensuite') || bathTypeLower.includes('private')) bathType = 'bathroom_private_ensuite';
      else if (bathTypeLower.includes('shared')) bathType = 'bathroom_shared';
      else if (bathTypeLower.includes('half') || bathTypeLower.includes('powder')) bathType = 'bathroom_half';
      else if (bathTypeLower.includes('jack')) bathType = 'bathroom_jack_and_jill';
      else if (bathTypeLower.includes('outdoor')) bathType = 'bathroom_outdoor_shower';
      else if (bathTypeLower.includes('full')) bathType = 'bathroom_full';
      else if (!bathType.startsWith('bathroom_')) bathType = 'bathroom_' + bathTypeLower;
      
      // Check if this is an ensuite linked to a bedroom
      let linkedBedroomId = null;
      if (linkedBedroom) {
        const bedroomLookup = await pool.query(
          'SELECT id FROM property_bedrooms WHERE room_id = $1 AND name = $2',
          [gasRoomId, linkedBedroom]
        );
        if (bedroomLookup.rows.length > 0) {
          linkedBedroomId = bedroomLookup.rows[0].id;
        }
      }
      
      const result = await pool.query(`
        INSERT INTO property_bathrooms (property_id, room_id, name, bathroom_type, features, quantity, display_order, linked_bedroom_id, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
        RETURNING id
      `, [propertyId, gasRoomId, name, bathType, features, quantity, bathroom.display_order || displayOrder, linkedBedroomId]);
      
      addedBathrooms.push({
        id: result.rows[0].id,
        name: name,
        bathroom_type: bathType,
        features: bathroom.features || [],
        quantity: quantity,
        display_order: bathroom.display_order || displayOrder,
        linked_bedroom_id: linkedBedroomId
      });
      
      displayOrder++;
    }
    
    // Also update num_bathrooms on the room
    const totalBathrooms = bathrooms.reduce((sum, b) => sum + (b.quantity || 1), 0);
    await pool.query(
      'UPDATE bookable_units SET num_bathrooms = $1, updated_at = NOW() WHERE id = $2',
      [totalBathrooms, gasRoomId]
    );
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      bathrooms_count: addedBathrooms.length,
      total_bathrooms: totalBathrooms,
      bathrooms: addedBathrooms
    });
    
  } catch (error) {
    console.error('Elevate set bathrooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get bathroom configuration for a room
app.get('/api/elevate/:apiKey/room/:roomId/bathrooms', async (req, res) => {
  console.log('=== ELEVATE: GET ROOM BATHROOMS ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.num_bathrooms
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    // Get bathrooms
    const bathroomsResult = await pool.query(`
      SELECT id, bathroom_type, quantity, display_order
      FROM property_bathrooms
      WHERE room_id = $1
      ORDER BY display_order
    `, [gasRoomId]);
    
    res.json({
      success: true,
      room_id: gasRoomId,
      num_bathrooms: roomCheck.rows[0].num_bathrooms,
      bathrooms: bathroomsResult.rows
    });
    
  } catch (error) {
    console.error('Elevate get bathrooms error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE: PRICING & AVAILABILITY
// =========================================================

// Set combined pricing and availability for a room
app.put('/api/elevate/:apiKey/room/:roomId/calendar', async (req, res) => {
  console.log('=== ELEVATE: SET ROOM CALENDAR ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    let { dates } = req.body;
    
    if (!Array.isArray(dates)) {
      return res.status(400).json({ success: false, error: 'dates must be an array' });
    }
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.currency
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const defaultCurrency = roomCheck.rows[0].currency || 'USD';
    
    // Ensure room_calendar table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_calendar (
        id SERIAL PRIMARY KEY,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
        date DATE NOT NULL,
        price DECIMAL(10,2),
        currency VARCHAR(3) DEFAULT 'USD',
        available BOOLEAN DEFAULT true,
        min_stay INTEGER DEFAULT 1,
        max_stay INTEGER,
        closed_to_arrival BOOLEAN DEFAULT false,
        closed_to_departure BOOLEAN DEFAULT false,
        status VARCHAR(20) DEFAULT 'available',
        notes TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(room_id, date)
      )
    `);
    
    let updatedCount = 0;
    let createdCount = 0;
    
    for (const day of dates) {
      if (!day.date) continue;
      
      const price = day.price !== undefined ? day.price : null;
      const available = day.available !== undefined ? day.available : true;
      const minStay = day.min_stay || day.minStay || 1;
      
      const result = await pool.query(`
        INSERT INTO room_availability (room_id, date, cm_price, is_available, is_blocked, min_stay, source, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, 'elevate', NOW())
        ON CONFLICT (room_id, date) DO UPDATE SET
          cm_price = COALESCE(EXCLUDED.cm_price, room_availability.cm_price),
          is_available = EXCLUDED.is_available,
          is_blocked = EXCLUDED.is_blocked,
          min_stay = EXCLUDED.min_stay,
          source = 'elevate',
          updated_at = NOW()
        RETURNING (xmax = 0) AS inserted
      `, [gasRoomId, day.date, price, available, !available, minStay]);
      
      if (result.rows[0]?.inserted) {
        createdCount++;
      } else {
        updatedCount++;
      }
    }
    
    res.json({
      success: true,
      room_id: gasRoomId,
      dates_processed: dates.length,
      created: createdCount,
      updated: updatedCount
    });
    
  } catch (error) {
    console.error('Elevate set calendar error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get calendar/pricing for a room
app.get('/api/elevate/:apiKey/room/:roomId/calendar', async (req, res) => {
  console.log('=== ELEVATE: GET ROOM CALENDAR ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    const { start_date, end_date } = req.query;
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    let query = 'SELECT date, price, currency, available, min_stay, max_stay, status FROM room_calendar WHERE room_id = $1';
    const params = [gasRoomId];
    
    if (start_date) {
      query += ' AND date >= $2';
      params.push(start_date);
    }
    if (end_date) {
      query += ` AND date <= $${params.length + 1}`;
      params.push(end_date);
    }
    
    query += ' ORDER BY date';
    
    const result = await pool.query(query, params);
    
    res.json({
      success: true,
      room_id: gasRoomId,
      dates: result.rows
    });
    
  } catch (error) {
    console.error('Elevate get calendar error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Set pricing only
app.put('/api/elevate/:apiKey/room/:roomId/pricing', async (req, res) => {
  console.log('=== ELEVATE: SET ROOM PRICING ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    let { dates } = req.body;
    
    if (!Array.isArray(dates)) {
      return res.status(400).json({ success: false, error: 'dates must be an array' });
    }
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.currency
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const defaultCurrency = roomCheck.rows[0].currency || 'USD';
    
    let processedCount = 0;
    
    for (const day of dates) {
      if (!day.date || day.price === undefined) continue;
      
      await pool.query(`
        INSERT INTO room_availability (room_id, date, cm_price, source, updated_at)
        VALUES ($1, $2, $3, 'elevate', NOW())
        ON CONFLICT (room_id, date) DO UPDATE SET
          cm_price = EXCLUDED.cm_price,
          source = 'elevate',
          updated_at = NOW()
      `, [gasRoomId, day.date, day.price]);
      
      processedCount++;
    }
    
    res.json({
      success: true,
      room_id: gasRoomId,
      dates_processed: processedCount
    });
    
  } catch (error) {
    console.error('Elevate set pricing error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Set availability only
app.put('/api/elevate/:apiKey/room/:roomId/availability', async (req, res) => {
  console.log('=== ELEVATE: SET ROOM AVAILABILITY ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    let { dates } = req.body;
    
    if (!Array.isArray(dates)) {
      return res.status(400).json({ success: false, error: 'dates must be an array' });
    }
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    let processedCount = 0;
    
    for (const day of dates) {
      if (!day.date) continue;
      
      const available = day.available !== undefined ? day.available : true;
      
      await pool.query(`
        INSERT INTO room_availability (room_id, date, is_available, is_blocked, source, updated_at)
        VALUES ($1, $2, $3, $4, 'elevate', NOW())
        ON CONFLICT (room_id, date) DO UPDATE SET
          is_available = EXCLUDED.is_available,
          is_blocked = EXCLUDED.is_blocked,
          source = 'elevate',
          updated_at = NOW()
      `, [gasRoomId, day.date, available, !available]);
      
      processedCount++;
    }
    
    res.json({
      success: true,
      room_id: gasRoomId,
      dates_processed: processedCount
    });
    
  } catch (error) {
    console.error('Elevate set availability error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE: PROPERTY/ROOM IMAGES
// =========================================================

// Get images for a property
app.get('/api/elevate/:apiKey/property/:propertyId/images', async (req, res) => {
  console.log('=== ELEVATE: GET PROPERTY IMAGES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId } = req.params;
    
    // Find property
    const propCheck = await pool.query(`
      SELECT p.id FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const gasPropertyId = propCheck.rows[0].id;
    
    // Get images
    try {
      const images = await pool.query(`
        SELECT id, COALESCE(image_url, url) as url, caption, COALESCE(display_order, sort_order, 0) as sort_order, is_primary, room_id, external_id
        FROM property_images
        WHERE property_id = $1 AND room_id IS NULL AND (is_active IS NULL OR is_active = true)
        ORDER BY COALESCE(display_order, sort_order, 0), id
      `, [gasPropertyId]);
      
      res.json({ 
        success: true, 
        property_id: gasPropertyId,
        images: images.rows 
      });
    } catch (tableError) {
      res.json({ 
        success: true, 
        property_id: gasPropertyId,
        images: [],
        note: 'Images table not configured'
      });
    }
    
  } catch (error) {
    console.error('Elevate get property images error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Add images to a property
app.post('/api/elevate/:apiKey/property/:propertyId/images', async (req, res) => {
  console.log('=== ELEVATE: ADD PROPERTY IMAGES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId } = req.params;
    const { images } = req.body; // Array of { url, caption, sort_order, is_primary, external_id }
    
    if (!Array.isArray(images)) {
      return res.status(400).json({ success: false, error: 'images must be an array' });
    }
    
    // Find property
    const propCheck = await pool.query(`
      SELECT p.id FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const gasPropertyId = propCheck.rows[0].id;
    
    // Ensure property_images table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS property_images (
        id SERIAL PRIMARY KEY,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
        url TEXT NOT NULL,
        caption VARCHAR(500),
        sort_order INTEGER DEFAULT 0,
        is_primary BOOLEAN DEFAULT false,
        external_id VARCHAR(255),
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const addedImages = [];
    
    for (const img of images) {
      if (!img.url) continue;
      
      // Check if image with this external_id already exists
      if (img.external_id) {
        const existing = await pool.query(
          'SELECT id FROM property_images WHERE property_id = $1 AND external_id = $2',
          [gasPropertyId, img.external_id]
        );
        if (existing.rows.length > 0) {
          // Update existing
          await pool.query(`
            UPDATE property_images SET image_url = $1, url = $1, caption = $2, sort_order = $3, display_order = $3, is_primary = $4
            WHERE id = $5
          `, [img.url, img.caption || null, img.sort_order || 0, img.is_primary || false, existing.rows[0].id]);
          addedImages.push({ id: existing.rows[0].id, url: img.url, updated: true });
          continue;
        }
      }
      
      // Generate image_key from URL or external_id
      const imageKey = img.external_id || `elevate_${gasPropertyId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const result = await pool.query(`
        INSERT INTO property_images (property_id, image_key, image_url, url, caption, sort_order, display_order, is_primary, external_id, is_active)
        VALUES ($1, $2, $3, $3, $4, $5, $5, $6, $7, true)
        RETURNING id
      `, [gasPropertyId, imageKey, img.url, img.caption || null, img.sort_order || 0, img.is_primary || false, img.external_id || null]);
      
      addedImages.push({ id: result.rows[0].id, url: img.url });
    }
    
    res.json({ 
      success: true, 
      property_id: gasPropertyId,
      images_added: addedImages.length,
      images: addedImages
    });
    
  } catch (error) {
    console.error('Elevate add property images error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE: ROOM IMAGES
// =========================================================

// Get room images
app.get('/api/elevate/:apiKey/room/:roomId/images', async (req, res) => {
  console.log('=== ELEVATE: GET ROOM IMAGES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    
    // Find room by ID or external_id
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.name
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    // Get room images
    const images = await pool.query(`
      SELECT id, image_key, image_url, caption, display_order as sort_order, is_active
      FROM room_images
      WHERE room_id = $1
      ORDER BY display_order ASC
    `, [gasRoomId]);
    
    res.json({
      success: true,
      room_id: gasRoomId,
      room_name: roomCheck.rows[0].name,
      images: images.rows
    });
    
  } catch (error) {
    console.error('Elevate get room images error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Add/update room images
app.post('/api/elevate/:apiKey/room/:roomId/images', async (req, res) => {
  console.log('=== ELEVATE: ADD ROOM IMAGES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    const { images } = req.body; // Array of { url, caption, sort_order, external_id }
    
    if (!Array.isArray(images)) {
      return res.status(400).json({ success: false, error: 'images must be an array' });
    }
    
    // Find room by ID or external_id
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.name
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    // Ensure room_images table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_images (
        id SERIAL PRIMARY KEY,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
        image_key VARCHAR(100),
        image_url TEXT NOT NULL,
        thumbnail_url TEXT,
        caption VARCHAR(500),
        display_order INTEGER DEFAULT 0,
        upload_source VARCHAR(50) DEFAULT 'elevate',
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const addedImages = [];
    
    for (const img of images) {
      if (!img.url) continue;
      
      // Generate unique image key
      const imageKey = img.external_id || `elevate_room_${gasRoomId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Check if image with this key already exists
      const existing = await pool.query(
        'SELECT id FROM room_images WHERE room_id = $1 AND image_key = $2',
        [gasRoomId, imageKey]
      );
      
      if (existing.rows.length > 0) {
        // Update existing
        await pool.query(`
          UPDATE room_images SET image_url = $1, caption = $2, display_order = $3, is_active = true
          WHERE id = $4
        `, [img.url, img.caption || null, img.sort_order || 0, existing.rows[0].id]);
        addedImages.push({ id: existing.rows[0].id, url: img.url, updated: true });
      } else {
        // Insert new
        const result = await pool.query(`
          INSERT INTO room_images (room_id, image_key, image_url, caption, display_order, upload_source, is_active, created_at)
          VALUES ($1, $2, $3, $4, $5, 'elevate', true, NOW())
          RETURNING id
        `, [gasRoomId, imageKey, img.url, img.caption || null, img.sort_order || 0]);
        
        addedImages.push({ id: result.rows[0].id, url: img.url });
      }
    }
    
    console.log(`[Elevate] Added ${addedImages.length} images to room ${gasRoomId}`);
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      room_name: roomCheck.rows[0].name,
      images_added: addedImages.length,
      images: addedImages
    });
    
  } catch (error) {
    console.error('Elevate add room images error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete room image
app.delete('/api/elevate/:apiKey/room/:roomId/images/:imageId', async (req, res) => {
  console.log('=== ELEVATE: DELETE ROOM IMAGE ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId, imageId } = req.params;
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    
    // Delete image (by id or image_key)
    const result = await pool.query(`
      DELETE FROM room_images 
      WHERE room_id = $1 AND (id::text = $2 OR image_key = $2)
      RETURNING id
    `, [gasRoomId, imageId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Image not found' });
    }
    
    res.json({ success: true, deleted: true, image_id: result.rows[0].id });
    
  } catch (error) {
    console.error('Elevate delete room image error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete property image
app.delete('/api/elevate/:apiKey/property/:propertyId/images/:imageId', async (req, res) => {
  console.log('=== ELEVATE: DELETE PROPERTY IMAGE ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { propertyId, imageId } = req.params;
    
    // Find property
    const propCheck = await pool.query(`
      SELECT p.id FROM properties p
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (p.id::text = $2 OR p.cm_property_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, propertyId]);
    
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const gasPropertyId = propCheck.rows[0].id;
    
    // Delete image
    const result = await pool.query(
      'DELETE FROM property_images WHERE property_id = $1 AND (id::text = $2 OR external_id = $2) RETURNING id',
      [gasPropertyId, imageId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Image not found' });
    }
    
    res.json({ success: true, deleted_image_id: result.rows[0].id });
    
  } catch (error) {
    console.error('Elevate delete property image error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get images for a room
app.get('/api/elevate/:apiKey/room/:roomId/images', async (req, res) => {
  console.log('=== ELEVATE: GET ROOM IMAGES ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.property_id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const propertyId = roomCheck.rows[0].property_id;
    
    // Get images
    try {
      const images = await pool.query(`
        SELECT id, COALESCE(image_url, url) as url, caption, COALESCE(display_order, sort_order, 0) as sort_order, is_primary, external_id
        FROM property_images
        WHERE property_id = $1 AND room_id = $2 AND (is_active IS NULL OR is_active = true)
        ORDER BY COALESCE(display_order, sort_order, 0), id
      `, [propertyId, gasRoomId]);
      
      res.json({ 
        success: true, 
        room_id: gasRoomId,
        images: images.rows 
      });
    } catch (tableError) {
      res.json({ 
        success: true, 
        room_id: gasRoomId,
        images: [],
        note: 'Images table not configured'
      });
    }
    
  } catch (error) {
    console.error('Elevate get room images error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Add images to a room
app.post('/api/elevate/:apiKey/room/:roomId/images', async (req, res) => {
  console.log('=== ELEVATE: ADD ROOM IMAGES ===');
  console.log('Room ID param:', req.params.roomId);
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId } = req.params;
    const { images } = req.body;
    
    if (!Array.isArray(images)) {
      return res.status(400).json({ success: false, error: 'images must be an array' });
    }
    
    // Find room by GAS ID or external_id (cm_room_id)
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.property_id, bu.name, bu.cm_room_id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    console.log('Room lookup result:', roomCheck.rows);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'Room not found',
        hint: 'Use the GAS room ID (from property creation response) or your external_id',
        searched_for: roomId
      });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const propertyId = roomCheck.rows[0].property_id;
    
    // Ensure property_images table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS property_images (
        id SERIAL PRIMARY KEY,
        property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
        room_id INTEGER REFERENCES bookable_units(id) ON DELETE CASCADE,
        url TEXT NOT NULL,
        caption VARCHAR(500),
        sort_order INTEGER DEFAULT 0,
        is_primary BOOLEAN DEFAULT false,
        external_id VARCHAR(255),
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);
    
    const addedImages = [];
    
    for (const img of images) {
      if (!img.url) continue;
      
      // Check if image with this external_id already exists
      if (img.external_id) {
        const existing = await pool.query(
          'SELECT id FROM property_images WHERE property_id = $1 AND room_id = $2 AND external_id = $3',
          [propertyId, gasRoomId, img.external_id]
        );
        if (existing.rows.length > 0) {
          await pool.query(`
            UPDATE property_images SET image_url = $1, url = $1, caption = $2, sort_order = $3, display_order = $3, is_primary = $4
            WHERE id = $5
          `, [img.url, img.caption || null, img.sort_order || 0, img.is_primary || false, existing.rows[0].id]);
          addedImages.push({ id: existing.rows[0].id, url: img.url, updated: true });
          continue;
        }
      }
      
      // Generate image_key from external_id or create unique one
      const imageKey = img.external_id || `elevate_room_${gasRoomId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const result = await pool.query(`
        INSERT INTO property_images (property_id, room_id, image_key, image_url, url, caption, sort_order, display_order, is_primary, external_id, is_active)
        VALUES ($1, $2, $3, $4, $4, $5, $6, $6, $7, $8, true)
        RETURNING id
      `, [propertyId, gasRoomId, imageKey, img.url, img.caption || null, img.sort_order || 0, img.is_primary || false, img.external_id || null]);
      
      addedImages.push({ id: result.rows[0].id, url: img.url });
    }
    
    res.json({ 
      success: true, 
      room_id: gasRoomId,
      images_added: addedImages.length,
      images: addedImages
    });
    
  } catch (error) {
    console.error('Elevate add room images error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete room image
app.delete('/api/elevate/:apiKey/room/:roomId/images/:imageId', async (req, res) => {
  console.log('=== ELEVATE: DELETE ROOM IMAGE ===');
  
  try {
    const auth = await validateElevatePartnerKey(req.params.apiKey);
    if (!auth.valid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { roomId, imageId } = req.params;
    
    // Find room
    const roomCheck = await pool.query(`
      SELECT bu.id, bu.property_id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      JOIN accounts a ON a.id = p.account_id
      WHERE (a.parent_id = $1 OR a.id = $1) 
      AND (bu.id::text = $2 OR bu.cm_room_id = $2)
    `, [ELEVATE_MASTER_ACCOUNT_ID, roomId]);
    
    if (roomCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const gasRoomId = roomCheck.rows[0].id;
    const propertyId = roomCheck.rows[0].property_id;
    
    // Delete image
    const result = await pool.query(
      'DELETE FROM property_images WHERE property_id = $1 AND room_id = $2 AND (id::text = $3 OR external_id = $3) RETURNING id',
      [propertyId, gasRoomId, imageId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Image not found' });
    }
    
    res.json({ success: true, deleted_image_id: result.rows[0].id });
    
  } catch (error) {
    console.error('Elevate delete room image error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// =========================================================
// ELEVATE LEGACY WEBHOOKS (for backwards compatibility)
// =========================================================

// Validate Elevate API key (legacy - per account)
async function validateElevateApiKey(accountId, apiKey) {
  // For Elevate, API keys are generated with format: gas_[hash]
  // First try database lookup
  const result = await pool.query(`
    SELECT id FROM gas_sync_connections 
    WHERE account_id = $1 
    AND adapter_code = 'elevate' 
    AND credentials->>'apiKey' = $2
  `, [accountId, apiKey]);
  
  if (result.rows.length > 0) {
    return true;
  }
  
  // Fallback: check if API key matches expected format and account exists
  if (apiKey && apiKey.startsWith('gas_') && apiKey.length > 20) {
    // Verify account exists
    const accountCheck = await pool.query('SELECT id FROM accounts WHERE id = $1', [accountId]);
    if (accountCheck.rows.length > 0) {
      console.log(`[Elevate] API key validated by format for account ${accountId}`);
      return true;
    }
  }
  
  console.log(`[Elevate] API key validation failed for account ${accountId}`);
  return false;
}

// Elevate Pricing Update Webhook
// POST /webhooks/elevate/:accountId/:apiKey/pricing/update
app.post('/webhooks/elevate/:accountId/:apiKey/pricing/update', async (req, res) => {
  console.log('=== ELEVATE PRICING WEBHOOK ===');
  console.log('Account:', req.params.accountId);
  console.log('Body:', JSON.stringify(req.body));
  
  try {
    const { accountId, apiKey } = req.params;
    const { external_id, rates } = req.body;
    
    // Validate API key
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      console.log('Elevate webhook: Invalid API key');
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    if (!external_id || !rates || !Array.isArray(rates)) {
      return res.status(400).json({ success: false, error: 'external_id and rates array required' });
    }
    
    // Find the room by GAS room ID (external_id from Elevate's perspective)
    const roomResult = await pool.query(
      'SELECT id FROM bookable_units WHERE id = $1',
      [external_id]
    );
    
    if (roomResult.rows.length === 0) {
      console.log('Elevate webhook: Room not found:', external_id);
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const roomId = roomResult.rows[0].id;
    let updated = 0;
    
    // Update pricing for each date
    for (const rate of rates) {
      const { date, price } = rate;
      if (!date || price === undefined) continue;
      
      await pool.query(`
        INSERT INTO room_availability (room_id, date, cm_price, direct_price, source, updated_at)
        VALUES ($1, $2, $3, $3, 'elevate', NOW())
        ON CONFLICT (room_id, date) DO UPDATE SET
          cm_price = EXCLUDED.cm_price,
          direct_price = EXCLUDED.direct_price,
          source = 'elevate',
          updated_at = NOW()
      `, [roomId, date, price]);
      updated++;
    }
    
    console.log(`Elevate pricing webhook: Updated ${updated} rates for room ${roomId}`);
    res.json({ success: true, updated });
    
  } catch (error) {
    console.error('Elevate pricing webhook error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Elevate Availability Update Webhook
// POST /webhooks/elevate/:accountId/:apiKey/availability/update
app.post('/webhooks/elevate/:accountId/:apiKey/availability/update', async (req, res) => {
  console.log('=== ELEVATE AVAILABILITY WEBHOOK ===');
  console.log('Account:', req.params.accountId);
  console.log('Body:', JSON.stringify(req.body));
  
  try {
    const { accountId, apiKey } = req.params;
    const { external_id, rates } = req.body;
    
    // Validate API key
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      console.log('Elevate webhook: Invalid API key');
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    if (!external_id || !rates || !Array.isArray(rates)) {
      return res.status(400).json({ success: false, error: 'external_id and rates array required' });
    }
    
    // Find the room by GAS room ID
    const roomResult = await pool.query(
      'SELECT id FROM bookable_units WHERE id = $1',
      [external_id]
    );
    
    if (roomResult.rows.length === 0) {
      console.log('Elevate webhook: Room not found:', external_id);
      return res.status(404).json({ success: false, error: 'Room not found' });
    }
    
    const roomId = roomResult.rows[0].id;
    let updated = 0;
    
    // Update availability for each date
    for (const rate of rates) {
      const { date, available } = rate;
      if (!date || available === undefined) continue;
      
      // available = number of rooms available (0 = blocked, >0 = available)
      const isAvailable = available > 0;
      const isBlocked = available === 0;
      
      await pool.query(`
        INSERT INTO room_availability (room_id, date, is_available, is_blocked, source, updated_at)
        VALUES ($1, $2, $3, $4, 'elevate', NOW())
        ON CONFLICT (room_id, date) DO UPDATE SET
          is_available = EXCLUDED.is_available,
          is_blocked = EXCLUDED.is_blocked,
          source = 'elevate',
          updated_at = NOW()
      `, [roomId, date, isAvailable, isBlocked]);
      updated++;
    }
    
    console.log(`Elevate availability webhook: Updated ${updated} dates for room ${roomId}`);
    res.json({ success: true, updated });
    
  } catch (error) {
    console.error('Elevate availability webhook error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Elevate Property CRUD Webhooks
// POST /webhooks/elevate/:accountId/:apiKey/property/create
app.post('/webhooks/elevate/:accountId/:apiKey/property/create', async (req, res) => {
  console.log('=== ELEVATE PROPERTY CREATE WEBHOOK ===');
  console.log('Body:', JSON.stringify(req.body));
  
  try {
    const { accountId, apiKey } = req.params;
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { name, address, city, country, currency } = req.body;
    
    const result = await pool.query(`
      INSERT INTO properties (account_id, user_id, name, address, city, country, currency, cm_source, status, created_at)
      VALUES ($1, 1, $2, $3, $4, $5, $6, 'elevate', 'active', NOW())
      RETURNING id
    `, [accountId, name, address || '', city || '', country || '', currency || 'CHF']);
    
    console.log('Elevate: Created property', result.rows[0].id);
    res.json({ success: true, property_id: result.rows[0].id });
    
  } catch (error) {
    console.error('Elevate property create error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /webhooks/elevate/:accountId/:apiKey/property/update
app.post('/webhooks/elevate/:accountId/:apiKey/property/update', async (req, res) => {
  console.log('=== ELEVATE PROPERTY UPDATE WEBHOOK ===');
  
  try {
    const { accountId, apiKey } = req.params;
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { external_id, name, address, city, country } = req.body;
    
    await pool.query(`
      UPDATE properties SET name = COALESCE($2, name), address = COALESCE($3, address),
        city = COALESCE($4, city), country = COALESCE($5, country), updated_at = NOW()
      WHERE id = $1 AND account_id = $6
    `, [external_id, name, address, city, country, accountId]);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Elevate property update error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /webhooks/elevate/:accountId/:apiKey/property/delete
app.post('/webhooks/elevate/:accountId/:apiKey/property/delete', async (req, res) => {
  console.log('=== ELEVATE PROPERTY DELETE WEBHOOK ===');
  
  try {
    const { accountId, apiKey } = req.params;
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { external_id } = req.body;
    
    await pool.query(`
      UPDATE properties SET status = 'deleted', updated_at = NOW()
      WHERE id = $1 AND account_id = $2
    `, [external_id, accountId]);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Elevate property delete error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Room CRUD Webhooks
// POST /webhooks/elevate/:accountId/:apiKey/room/create
app.post('/webhooks/elevate/:accountId/:apiKey/room/create', async (req, res) => {
  console.log('=== ELEVATE ROOM CREATE WEBHOOK ===');
  
  try {
    const { accountId, apiKey } = req.params;
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { property_id, name, max_guests, base_price } = req.body;
    
    // Verify property belongs to account
    const propCheck = await pool.query(
      'SELECT id FROM properties WHERE id = $1 AND account_id = $2',
      [property_id, accountId]
    );
    if (propCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const result = await pool.query(`
      INSERT INTO bookable_units (property_id, name, max_guests, base_price, status, created_at)
      VALUES ($1, $2, $3, $4, 'available', NOW())
      RETURNING id
    `, [property_id, name, max_guests || 2, base_price]);
    
    console.log('Elevate: Created room', result.rows[0].id);
    res.json({ success: true, room_id: result.rows[0].id });
    
  } catch (error) {
    console.error('Elevate room create error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /webhooks/elevate/:accountId/:apiKey/room/update
app.post('/webhooks/elevate/:accountId/:apiKey/room/update', async (req, res) => {
  console.log('=== ELEVATE ROOM UPDATE WEBHOOK ===');
  
  try {
    const { accountId, apiKey } = req.params;
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { external_id, name, max_guests, base_price } = req.body;
    
    await pool.query(`
      UPDATE bookable_units SET 
        name = COALESCE($2, name), 
        max_guests = COALESCE($3, max_guests),
        base_price = COALESCE($4, base_price),
        updated_at = NOW()
      WHERE id = $1
    `, [external_id, name, max_guests, base_price]);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Elevate room update error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /webhooks/elevate/:accountId/:apiKey/room/delete
app.post('/webhooks/elevate/:accountId/:apiKey/room/delete', async (req, res) => {
  console.log('=== ELEVATE ROOM DELETE WEBHOOK ===');
  
  try {
    const { accountId, apiKey } = req.params;
    const isValid = await validateElevateApiKey(accountId, apiKey);
    if (!isValid) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const { external_id } = req.body;
    
    await pool.query(`
      UPDATE bookable_units SET status = 'deleted', updated_at = NOW()
      WHERE id = $1
    `, [external_id]);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Elevate room delete error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Elevate webhook verification (GET)
app.get('/webhooks/elevate/:accountId/:apiKey/:type/:action', async (req, res) => {
  res.json({ 
    status: 'active',
    message: 'Elevate webhook endpoint ready',
    endpoint: `${req.params.type}/${req.params.action}`
  });
});

// =========================================================
// SYNC PAYMENT TO BEDS24
// =========================================================
app.post('/api/admin/sync-payment-to-beds24', async (req, res) => {
  try {
    const { booking_id, payment_type, amount, description } = req.body;
    
    if (!booking_id || !amount) {
      return res.json({ success: false, error: 'booking_id and amount required' });
    }
    
    // Get booking with Beds24 ID
    const bookingResult = await pool.query(`
      SELECT b.*, bu.beds24_room_id
      FROM bookings b
      LEFT JOIN bookable_units bu ON b.bookable_unit_id = bu.id
      WHERE b.id = $1
    `, [booking_id]);
    
    const booking = bookingResult.rows[0];
    
    if (!booking) {
      return res.json({ success: false, error: 'Booking not found' });
    }
    
    if (!booking.beds24_booking_id) {
      return res.json({ success: false, error: 'No Beds24 booking ID - booking may not be synced to Beds24' });
    }
    
    // Get Beds24 access token
    const accessToken = await getBeds24AccessToken(pool);
    
    // Update the booking in Beds24 with the payment
    const paymentData = [{
      id: booking.beds24_booking_id,
      payments: [{
        description: description || (payment_type === 'balance' ? 'Balance payment via Stripe' : 'Payment via Stripe'),
        amount: parseFloat(amount),
        status: 'received',
        date: new Date().toISOString().split('T')[0]
      }]
    }];
    
    console.log('Syncing payment to Beds24:', JSON.stringify(paymentData));
    
    const beds24Response = await axios.post('https://beds24.com/api/v2/bookings', paymentData, {
      headers: {
        'token': accessToken,
        'Content-Type': 'application/json'
      }
    });
    
    console.log('Beds24 payment sync response:', JSON.stringify(beds24Response.data));
    
    res.json({
      success: true,
      beds24_response: beds24Response.data
    });
    
  } catch (error) {
    console.error('Sync payment to Beds24 error:', error.response?.data || error.message);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// MANUAL SYNC TRIGGER - Pull changes from Beds24
// =========================================================
app.post('/api/admin/sync-beds24-bookings', async (req, res) => {
  try {
    // Get access token
    const accessToken = await getBeds24AccessToken(pool);
    
    // Fetch recent bookings from Beds24 (last 30 days arrivals)
    const today = new Date();
    const fromDate = new Date(today);
    fromDate.setDate(fromDate.getDate() - 7); // Include bookings from last week
    const toDate = new Date(today);
    toDate.setDate(toDate.getDate() + 365); // Up to 365 days out
    
    console.log(`Fetching Beds24 bookings from ${fromDate.toISOString().split('T')[0]} to ${toDate.toISOString().split('T')[0]}`);
    
    const response = await axios.get('https://beds24.com/api/v2/bookings', {
      headers: { 'token': accessToken },
      params: {
        arrivalFrom: fromDate.toISOString().split('T')[0],
        arrivalTo: toDate.toISOString().split('T')[0]
      }
    });
    
    console.log('Beds24 bookings API response structure:', JSON.stringify(response.data).substring(0, 500));
    
    // Beds24 v2 API returns array directly or in .data
    const bookings = Array.isArray(response.data) ? response.data : (response.data.data || response.data.bookings || []);
    console.log(`Found ${bookings.length} bookings from Beds24`);
    
    if (bookings.length > 0) {
      console.log('Sample booking structure:', JSON.stringify(bookings[0]).substring(0, 300));
    }
    
    // Update availability based on bookings
    const client = await pool.connect();
    let updatedDates = 0;
    let processedBookings = 0;
    let skippedBookings = [];
    let unblockedDates = 0;
    let gasBookingsCancelled = 0;
    
    try {
      await client.query('BEGIN');
      
      for (const booking of bookings) {
        // Get room ID - Beds24 v2 uses roomId
        const beds24RoomId = booking.roomId || booking.room_id || booking.unitId;
        
        if (!beds24RoomId) {
          skippedBookings.push({ id: booking.id, reason: 'no room ID' });
          continue;
        }
        
        // Find our room
        const roomResult = await client.query(`
          SELECT id, name FROM bookable_units WHERE beds24_room_id = $1
        `, [beds24RoomId]);
        
        if (roomResult.rows.length === 0) {
          skippedBookings.push({ id: booking.id, beds24RoomId, reason: 'room not mapped' });
          continue;
        }
        
        const ourRoom = roomResult.rows[0];
        
        // Get dates - Beds24 v2 uses arrival/departure
        const arrival = booking.arrival || booking.firstNight || booking.arrivalDate;
        const departure = booking.departure || booking.lastNight || booking.departureDate;
        
        if (!arrival || !departure) {
          skippedBookings.push({ id: booking.id, reason: 'missing dates' });
          continue;
        }
        
        const isCancelled = booking.status === 'cancelled' || booking.status === 'Cancelled';
        console.log(`Processing booking ${booking.id}: room ${beds24RoomId} (${ourRoom.name}), ${arrival} to ${departure}, cancelled: ${isCancelled}`);
        
        // Check if we have a matching GAS booking (created from our system)
        if (isCancelled) {
          const gasBookingResult = await client.query(`
            UPDATE bookings 
            SET status = 'cancelled', updated_at = NOW()
            WHERE beds24_booking_id = $1 AND status != 'cancelled'
            RETURNING id
          `, [booking.id.toString()]);
          
          if (gasBookingResult.rowCount > 0) {
            console.log(`Cancelled GAS booking ${gasBookingResult.rows[0].id} (Beds24 booking ${booking.id} was cancelled)`);
            gasBookingsCancelled++;
          }
        }
        
        const startDate = new Date(arrival);
        const endDate = new Date(departure);
        
        for (let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)) {
          const dateStr = d.toISOString().split('T')[0];
          
          if (isCancelled) {
            // Unblock cancelled booking dates
            const result = await client.query(`
              UPDATE room_availability 
              SET is_available = true, is_blocked = false, source = 'beds24_cancelled', updated_at = NOW()
              WHERE room_id = $1 AND date = $2 AND source IN ('beds24_sync', 'beds24_webhook', 'beds24_inventory', 'booking')
            `, [ourRoom.id, dateStr]);
            if (result.rowCount > 0) unblockedDates++;
          } else {
            // Block confirmed booking dates
            await client.query(`
              INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
              VALUES ($1, $2, false, false, 'beds24_sync')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET is_available = false, source = 'beds24_sync', updated_at = NOW()
            `, [ourRoom.id, dateStr]);
            updatedDates++;
          }
        }
        processedBookings++;
      }
      
      await client.query('COMMIT');
    } finally {
      client.release();
    }
    
    console.log(`Bookings sync complete: ${processedBookings} processed, ${updatedDates} blocked, ${unblockedDates} unblocked, ${gasBookingsCancelled} GAS bookings cancelled`);
    if (skippedBookings.length > 0) {
      console.log('Skipped bookings:', JSON.stringify(skippedBookings.slice(0, 10)));
    }
    
    res.json({
      success: true,
      bookingsFound: bookings.length,
      bookingsProcessed: processedBookings,
      datesUpdated: updatedDates,
      datesUnblocked: unblockedDates,
      gasBookingsCancelled,
      skipped: skippedBookings.length
    });
    
  } catch (error) {
    console.error('Sync bookings error:', error.response?.data || error.message || error);
    res.json({ success: false, error: error.response?.data?.message || error.message || 'Unknown error' });
  }
});

// =========================================================
// FULL INVENTORY SYNC - Run once daily to catch blackouts
// =========================================================
app.post('/api/admin/sync-beds24-inventory', async (req, res) => {
  try {
    const accessToken = await getBeds24AccessToken(pool);
    const today = new Date();
    
    // Get all rooms with beds24_room_id
    const roomsResult = await pool.query(`
      SELECT bu.id, bu.beds24_room_id, bu.name 
      FROM bookable_units bu 
      WHERE bu.beds24_room_id IS NOT NULL
    `);
    
    const rooms = roomsResult.rows;
    console.log(`Full inventory sync: checking ${rooms.length} rooms using availability endpoint`);
    
    let inventoryBlocksFound = 0;
    let inventoryDatesBlocked = 0;
    let datesUnblocked = 0;
    
    // Calculate date range - next 365 days
    const startDate = today.toISOString().split('T')[0];
    const endDate = new Date(today.getTime() + 365*24*60*60*1000).toISOString().split('T')[0];
    
    // For each room, get availability
    for (const room of rooms) {
      try {
        const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
          headers: { 'token': accessToken },
          params: { 
            roomId: room.beds24_room_id,
            startDate,
            endDate
          }
        });
        
        const data = availResponse.data?.data?.[0];
        if (data && data.availability) {
          // Loop through each date
          for (const [dateStr, isAvailable] of Object.entries(data.availability)) {
            if (isAvailable === false) {
              // This date is blocked in Beds24
              inventoryBlocksFound++;
              
              await pool.query(`
                INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
                VALUES ($1, $2, false, true, 'beds24_inventory')
                ON CONFLICT (room_id, date) 
                DO UPDATE SET is_available = false, is_blocked = true, 
                  source = CASE WHEN room_availability.source IN ('beds24_sync', 'booking') THEN room_availability.source ELSE 'beds24_inventory' END,
                  updated_at = NOW()
              `, [room.id, dateStr]);
              
              inventoryDatesBlocked++;
            } else {
              // This date is AVAILABLE in Beds24 - unblock if it was blocked by beds24
              const result = await pool.query(`
                UPDATE room_availability 
                SET is_available = true, is_blocked = false, source = 'beds24_unblocked', updated_at = NOW()
                WHERE room_id = $1 AND date = $2 AND source IN ('beds24_inventory', 'beds24_sync', 'beds24_webhook')
                RETURNING id
              `, [room.id, dateStr]);
              
              if (result.rowCount > 0) {
                datesUnblocked++;
              }
            }
          }
          console.log(`Room ${room.name}: synced availability`);
        }
        
      } catch (roomError) {
        console.log(`Error syncing room ${room.beds24_room_id}: ${roomError.message}`);
      }
    }
    
    console.log(`Full inventory sync complete: ${inventoryBlocksFound} blocked, ${datesUnblocked} unblocked across ${rooms.length} rooms`);
    
    res.json({
      success: true,
      roomsChecked: rooms.length,
      inventoryBlocksFound,
      inventoryDatesBlocked,
      datesUnblocked
    });
    
  } catch (error) {
    console.error('Inventory sync error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Full Pricing & Availability Sync - syncs ALL data for 365 days
app.post('/api/admin/sync-beds24-full-pricing', async (req, res) => {
  try {
    const { propertyId } = req.body;
    
    // Property ID is required
    if (!propertyId) {
      return res.json({ success: false, error: 'Property ID is required. Select a property first.' });
    }
    
    // Get the connection for this property via the room types
    // Match tiered sync: connections use sync_enabled, not just status='active'
    console.log(`[Full Pricing Sync] Looking for connection for property ${propertyId}`);
    
    const connQuery = await pool.query(`
      SELECT DISTINCT c.id, c.credentials, c.access_token, c.refresh_token, c.token_expires_at, c.account_id
      FROM gas_sync_connections c
      JOIN gas_sync_properties sp ON sp.connection_id = c.id
      JOIN gas_sync_room_types rt ON rt.sync_property_id = sp.id
      JOIN bookable_units bu ON bu.id = rt.gas_room_id
      WHERE bu.property_id = $1 
        AND c.adapter_code = 'beds24' 
        AND c.sync_enabled = true
      LIMIT 1
    `, [propertyId]);
    
    console.log(`[Full Pricing Sync] Connection query returned ${connQuery.rows.length} rows`);
    
    if (connQuery.rows.length === 0) {
      return res.json({ success: false, error: 'No Beds24 connection found for this property' });
    }
    
    const conn = connQuery.rows[0];
    console.log(`[Full Pricing Sync] Using connection ${conn.id} for property ${propertyId}`);
    
    // Get or refresh access token for THIS connection (match tiered sync method)
    let accessToken = conn.access_token;
    
    // Always refresh token like tiered sync does
    if (conn.refresh_token) {
      try {
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': conn.refresh_token }
        });
        accessToken = tokenResponse.data.token;
        await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [accessToken, conn.id]);
        console.log(`[Full Pricing Sync] Refreshed token for connection ${conn.id}`);
      } catch (refreshErr) {
        console.error(`[Full Pricing Sync] Token refresh failed: ${refreshErr.message}`);
        return res.json({ success: false, error: 'Failed to refresh Beds24 token: ' + refreshErr.message });
      }
    }
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No valid access token for this connection' });
    }
    
    // Get V1 credentials from this connection
    const credentials = typeof conn.credentials === 'string' 
      ? JSON.parse(conn.credentials || '{}') 
      : (conn.credentials || {});
    const v1ApiKey = credentials.v1ApiKey || credentials.apiKey;
    
    // Get rooms for this property
    const roomsResult = await pool.query(`
      SELECT bu.id, bu.beds24_room_id, bu.name, sp.prop_key
      FROM bookable_units bu
      JOIN gas_sync_room_types rt ON rt.gas_room_id = bu.id
      JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
      WHERE bu.property_id = $1 AND bu.beds24_room_id IS NOT NULL
    `, [propertyId]);
    
    const rooms = roomsResult.rows;
    
    if (rooms.length === 0) {
      return res.json({ success: false, error: 'No Beds24 rooms found for this property' });
    }
    
    console.log(`[Full Pricing Sync] Starting for ${rooms.length} rooms (property ${propertyId})`);
    
    const today = new Date();
    const startDate = today.toISOString().split('T')[0];
    const endDate = new Date(today.getTime() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    let totalDaysUpdated = 0;
    let roomsSynced = 0;
    let errors = [];
    
    for (const room of rooms) {
      try {
        console.log(`  Syncing ${room.name} (${room.beds24_room_id})...`);
        
        // Get calendar data from V2 (includes prices)
        const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
          headers: { 'token': accessToken },
          params: {
            roomId: parseInt(room.beds24_room_id),
            startDate,
            endDate,
            includeNumAvail: true,
            includePrices: true,
            includeMinStay: true
          }
        });
        
        const calendarData = calResponse.data.data?.[0]?.calendar || [];
        let daysUpdated = 0;
        let hasAnyPrices = calendarData.some(entry => entry.price1 || entry.price);
        
        console.log(`    V2 calendar entries: ${calendarData.length}, hasAnyPrices: ${hasAnyPrices}`);
        
        if (hasAnyPrices) {
          // V2 has prices - use them
          for (const entry of calendarData) {
            const fromDate = new Date(entry.from);
            const toDate = new Date(entry.to);
            
            for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
              const dateStr = d.toISOString().split('T')[0];
              const numAvail = entry.numAvail || 0;
              const price = entry.price1 || null;
              const minStay = entry.minStay || 1;
              
              await pool.query(`
                INSERT INTO room_availability (room_id, date, cm_price, direct_price, standard_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                VALUES ($1, $2, $3, $3, $3, $4, $5, $6, $6, 'beds24-full', NOW())
                ON CONFLICT (room_id, date) 
                DO UPDATE SET 
                  cm_price = COALESCE($3, room_availability.cm_price),
                  direct_price = COALESCE($3, room_availability.direct_price),
                  standard_price = COALESCE($3, room_availability.standard_price),
                  is_available = $4,
                  is_blocked = $5,
                  min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                  cm_min_stay = $6,
                  source = 'beds24-full',
                  updated_at = NOW()
              `, [room.id, dateStr, price, numAvail > 0, numAvail === 0, minStay]);
              
              daysUpdated++;
            }
          }
        } else if (v1ApiKey && room.prop_key) {
          // V2 has no prices - use V1 getRates (batch endpoint)
          console.log(`    V2 no prices, using V1 getRates fallback...`);
          
          try {
            const v1Response = await axios.post('https://api.beds24.com/json/getRates', {
              authentication: {
                apiKey: v1ApiKey,
                propKey: room.prop_key
              },
              roomId: String(room.beds24_room_id),
              from: startDate,
              to: endDate
            });
            
            const ratesData = v1Response.data;
            
            if (Array.isArray(ratesData)) {
              for (const rate of ratesData) {
                const dateStr = rate.date;
                const price = parseFloat(rate.price1 || rate.price || 0);
                const minStay = parseInt(rate.minStay) || 1;
                const isAvailable = rate.numAvail > 0 || rate.available !== false;
                
                if (dateStr && price > 0) {
                  await pool.query(`
                    INSERT INTO room_availability (room_id, date, cm_price, direct_price, standard_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                    VALUES ($1, $2, $3, $3, $3, $4, $5, $6, $6, 'beds24-v1-full', NOW())
                    ON CONFLICT (room_id, date) 
                    DO UPDATE SET 
                      cm_price = COALESCE($3, room_availability.cm_price),
                      direct_price = COALESCE($3, room_availability.direct_price),
                      standard_price = COALESCE($3, room_availability.standard_price),
                      is_available = $4,
                      is_blocked = $5,
                      min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                      cm_min_stay = $6,
                      source = 'beds24-v1-full',
                      updated_at = NOW()
                  `, [room.id, dateStr, price, isAvailable, !isAvailable, minStay]);
                  
                  daysUpdated++;
                }
              }
            }
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
          } catch (v1Error) {
            console.log(`    V1 getRates failed: ${v1Error.message}`);
          }
        } else {
          console.log(`    No V1 fallback available (v1ApiKey: ${!!v1ApiKey}, prop_key: ${room.prop_key})`);
        }
        
        totalDaysUpdated += daysUpdated;
        roomsSynced++;
        console.log(`    ‚úì ${room.name}: ${daysUpdated} days synced`);
        
        // Delay between rooms
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (roomError) {
        console.error(`    ‚úó ${room.name}: ${roomError.message}`);
        errors.push({ room: room.name, error: roomError.message });
      }
    }
    
    console.log(`[Full Pricing Sync] Complete: ${roomsSynced} rooms, ${totalDaysUpdated} days`);
    
    res.json({
      success: true,
      roomsSynced,
      totalDaysUpdated,
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('Full pricing sync error:', error.message);
    res.json({ success: false, error: error.message });
  }
});

// Debug endpoint - check specific date availability from Beds24
app.get('/api/admin/debug/beds24-availability/:date', async (req, res) => {
  try {
    const { date } = req.params; // Format: 2026-01-03
    const accessToken = await getBeds24AccessToken(pool);
    
    // Get all rooms
    const roomsResult = await pool.query(`
      SELECT bu.id, bu.beds24_room_id, bu.name 
      FROM bookable_units bu 
      WHERE bu.beds24_room_id IS NOT NULL
    `);
    
    const rooms = roomsResult.rows;
    const beds24RoomIds = rooms.map(r => r.beds24_room_id);
    
    // Calculate departure (next day)
    const arrivalDate = new Date(date);
    const departDate = new Date(arrivalDate);
    departDate.setDate(departDate.getDate() + 1);
    const departure = departDate.toISOString().split('T')[0];
    
    // Call offers endpoint
    const offerResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
      headers: { 'token': accessToken },
      params: {
        roomId: beds24RoomIds,
        arrival: date,
        departure: departure,
        numAdults: 1
      },
      paramsSerializer: params => {
        const parts = [];
        for (const key in params) {
          if (Array.isArray(params[key])) {
            params[key].forEach(val => parts.push(`${key}=${val}`));
          } else {
            parts.push(`${key}=${params[key]}`);
          }
        }
        return parts.join('&');
      }
    });
    
    const rawResponse = offerResponse.data;
    const offers = Array.isArray(rawResponse) ? rawResponse : (rawResponse.data || []);
    const availableRoomIds = offers.map(o => o.roomId);
    
    // Find which rooms are missing (blocked)
    const blockedRooms = rooms.filter(r => !availableRoomIds.includes(r.beds24_room_id));
    const availableRooms = rooms.filter(r => availableRoomIds.includes(r.beds24_room_id));
    
    res.json({
      date,
      departure,
      allRoomIds: beds24RoomIds,
      availableRoomIds,
      blockedRooms: blockedRooms.map(r => ({ id: r.id, beds24_id: r.beds24_room_id, name: r.name })),
      availableRooms: availableRooms.map(r => ({ id: r.id, beds24_id: r.beds24_room_id, name: r.name })),
      rawOffersCount: offers.length,
      sampleOffer: offers[0] || null
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug endpoint - check Beds24 inventory/calendar directly
app.get('/api/admin/debug/beds24-inventory/:roomId', async (req, res) => {
  try {
    const { roomId } = req.params;
    const { from, to } = req.query;
    const accessToken = await getBeds24AccessToken(pool);
    
    const startDate = from || new Date().toISOString().split('T')[0];
    const endDate = to || new Date(Date.now() + 30*24*60*60*1000).toISOString().split('T')[0];
    
    // Try multiple Beds24 endpoints to find inventory data
    const results = {};
    
    // 1. Try /inventory/rooms endpoint
    try {
      const invResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms', {
        headers: { 'token': accessToken },
        params: { roomId }
      });
      results.inventoryRooms = invResponse.data;
    } catch (e) {
      results.inventoryRooms = { error: e.message };
    }
    
    // 2. Try /inventory/rooms/availability endpoint
    try {
      const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
        headers: { 'token': accessToken },
        params: { 
          roomId,
          startDate,
          endDate
        }
      });
      results.availability = availResponse.data;
    } catch (e) {
      results.availability = { error: e.message };
    }
    
    // 3. Try /inventory/rooms/calendar endpoint
    try {
      const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
        headers: { 'token': accessToken },
        params: { 
          roomId,
          startDate,
          endDate
        }
      });
      results.calendar = calResponse.data;
    } catch (e) {
      results.calendar = { error: e.message };
    }
    
    // 4. Try /properties/rooms endpoint
    try {
      const propsResponse = await axios.get('https://beds24.com/api/v2/properties/rooms', {
        headers: { 'token': accessToken },
        params: { roomId }
      });
      results.propertiesRooms = propsResponse.data;
    } catch (e) {
      results.propertiesRooms = { error: e.message };
    }
    
    // 5. Try /inventory endpoint with dates
    try {
      const invDateResponse = await axios.get('https://beds24.com/api/v2/inventory', {
        headers: { 'token': accessToken },
        params: { 
          roomId,
          startDate,
          endDate
        }
      });
      results.inventory = invDateResponse.data;
    } catch (e) {
      results.inventory = { error: e.message };
    }
    
    res.json({
      roomId,
      startDate,
      endDate,
      results
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// AI CONTENT GENERATION
// =====================================================

app.post('/api/ai/generate-content', async (req, res) => {
  const { type, property_id, room_id, prompt } = req.body;
  
  try {
    let propertyContext = '';
    let roomContext = '';
    
    if (property_id) {
      const propResult = await pool.query(`
        SELECT p.*, 
               (SELECT string_agg(name, ', ') FROM bookable_units WHERE property_id = p.id) as room_names
        FROM properties p WHERE id = $1
      `, [property_id]);
      
      if (propResult.rows[0]) {
        const p = propResult.rows[0];
        propertyContext = `Property: ${p.name}. Type: ${p.property_type || 'accommodation'}. Location: ${p.city || ''}, ${p.country || ''}.`;
      }
    }
    
    if (room_id) {
      const roomResult = await pool.query(`
        SELECT bu.*, p.name as property_name, p.city, p.country
        FROM bookable_units bu
        LEFT JOIN properties p ON bu.property_id = p.id
        WHERE bu.id = $1
      `, [room_id]);
      
      if (roomResult.rows[0]) {
        const r = roomResult.rows[0];
        roomContext = `Room: ${r.name} at ${r.property_name}. Max guests: ${r.max_guests || 2}.`;
      }
    }
    
    let systemPrompt = 'You are an expert hospitality copywriter. Write engaging, warm, professional descriptions. No clich√©s.';
    let userPrompt = '';
    
    switch(type) {
      case 'property_description':
        userPrompt = `Write a property description (2-3 paragraphs). ${propertyContext} ${prompt ? `Notes: ${prompt}` : ''}`;
        break;
      case 'property_short':
        userPrompt = `Write a short property description (1-2 sentences, max 30 words). ${propertyContext} ${prompt ? `Notes: ${prompt}` : ''}`;
        break;
      case 'property_location':
        userPrompt = `Write a location description (1-2 paragraphs). ${propertyContext} ${prompt ? `Notes: ${prompt}` : ''}`;
        break;
      case 'room_short':
      case 'room_short_description':
        const { room_name: shortRoomName, room_type: shortRoomType, max_guests: shortMaxGuests } = req.body;
        userPrompt = `Write a short room description (1-2 sentences, max 150 characters) for a booking website.

Room: "${shortRoomName}"
Type: ${shortRoomType || 'room'}
Sleeps: ${shortMaxGuests || 2} guests
${propertyContext}

Rules:
- Brief, punchy tagline for search results
- Highlight key features
- No clich√©s
- Max 150 characters

Just return the description, nothing else.`;
        break;
      case 'room_full':
      case 'room_full_description':
        const { room_name: fullRoomName, short_description: shortDescContext, room_type: fullRoomType, max_guests: fullMaxGuests } = req.body;
        userPrompt = `Write a detailed room description (2-3 paragraphs) for a booking website.

Room: "${fullRoomName}"
Type: ${fullRoomType || 'room'}
Sleeps: ${fullMaxGuests || 2} guests
${shortDescContext ? `Tagline: ${shortDescContext}` : ''}
${propertyContext}

Rules:
- Engaging, warm, professional
- Describe ambiance, features, view
- Mention comfort and convenience
- No clich√©s like "luxurious", "stunning", "oasis"
- 2-3 paragraphs

Just return the description, nothing else.`;
        break;
      case 'room_display_name':
        // Get property context for the room
        const { room_id: rId, original_name: roomOrigName, room_type: rType, max_guests: rGuests } = req.body;
        let propContext = '';
        
        if (rId) {
          const roomPropResult = await pool.query(`
            SELECT p.name as property_name, p.property_type, p.city, p.description, p.address
            FROM bookable_units bu
            LEFT JOIN properties p ON bu.property_id = p.id
            WHERE bu.id = $1
          `, [rId]);
          
          if (roomPropResult.rows[0]) {
            const rp = roomPropResult.rows[0];
            propContext = `Property: ${rp.property_name}. Type: ${rp.property_type || 'accommodation'}. Location: ${rp.city || ''}.`;
            if (rp.description) propContext += ` Description: ${rp.description.substring(0, 200)}`;
          }
        }
        
        userPrompt = `Create a marketing-friendly room name for a booking website.

Original room name: "${roomOrigName}"
Room type: ${rType || 'room'}
Sleeps: ${rGuests || 2} guests
${propContext}

Rules:
- Create an appealing, descriptive name that captures the room's character
- Include the room type or bed type if relevant (e.g., "Suite", "King", "Double")
- Can reference the property style if it adds value
- Max 5-6 words
- Don't use clich√©s like "Luxurious", "Stunning", "Paradise", "Oasis"
- Keep it natural and memorable
- Examples of good names: "The Garden View Suite", "Riverside King Room", "Cozy Attic Retreat", "Historic Corner Suite"

Just return the new name, nothing else.`;
        break;
      case 'display_name':
        const { original_name, property_type: propType, city: propCity } = req.body;
        userPrompt = `Create a marketing-friendly property name from this original name: "${original_name}". Property type: ${propType || 'accommodation'}. Location: ${propCity || 'unknown'}.

Rules:
- Remove codes like BC138, ME3, Coastal1 etc
- Keep the core descriptive words
- Make it appealing but not overly flowery
- Max 6 words
- Don't use words like "Luxurious", "Stunning", "Paradise"
- Keep it natural and professional

Just return the new name, nothing else.`;
        break;
      default:
        return res.json({ success: false, error: 'Unknown content type' });
    }
    
    const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
      model: 'claude-sonnet-4-20250514',
      max_tokens: 500,
      messages: [{ role: 'user', content: userPrompt }],
      system: systemPrompt
    }, {
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      }
    });
    
    res.json({ success: true, content: claudeResponse.data.content[0].text.trim() });
    
  } catch (error) {
    console.error('AI generation error:', error.response?.data || error.message);
    res.json({ success: false, error: 'AI generation failed' });
  }
});

// =====================================================
// API KEY MANAGEMENT (Admin)
// =====================================================

// Generate a secure random API key
function generateApiKey() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let key = 'gas_';
    for (let i = 0; i < 32; i++) {
        key += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return key;
}

// Get all API keys for a client
app.get('/api/admin/api-keys', async (req, res) => {
    try {
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT id, key_name, api_key, permissions, rate_limit_per_minute, rate_limit_per_day,
                   last_used_at, total_requests, is_active, expires_at, allowed_origins, created_at
            FROM client_api_keys 
            WHERE client_id = $1
            ORDER BY created_at DESC
        `, [clientId]);
        
        res.json({ success: true, api_keys: result.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Create new API key
app.post('/api/admin/api-keys', async (req, res) => {
    try {
        const {
            client_id = 1,
            key_name,
            permissions = ['read:rooms', 'read:availability', 'read:pricing', 'read:offers', 'read:content'],
            rate_limit_per_minute = 60,
            rate_limit_per_day = 10000,
            allowed_origins = [],
            expires_at = null
        } = req.body;
        
        const api_key = generateApiKey();
        
        const result = await pool.query(`
            INSERT INTO client_api_keys (
                client_id, key_name, api_key, permissions, 
                rate_limit_per_minute, rate_limit_per_day, allowed_origins, expires_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING *
        `, [client_id, key_name, api_key, JSON.stringify(permissions), rate_limit_per_minute, rate_limit_per_day, allowed_origins, expires_at]);
        
        res.json({ success: true, api_key: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Update API key
app.put('/api/admin/api-keys/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { key_name, permissions, rate_limit_per_minute, rate_limit_per_day, is_active, allowed_origins, expires_at } = req.body;
        
        const result = await pool.query(`
            UPDATE client_api_keys SET
                key_name = COALESCE($2, key_name),
                permissions = COALESCE($3, permissions),
                rate_limit_per_minute = COALESCE($4, rate_limit_per_minute),
                rate_limit_per_day = COALESCE($5, rate_limit_per_day),
                is_active = COALESCE($6, is_active),
                allowed_origins = COALESCE($7, allowed_origins),
                expires_at = $8,
                updated_at = NOW()
            WHERE id = $1
            RETURNING *
        `, [id, key_name, permissions ? JSON.stringify(permissions) : null, rate_limit_per_minute, rate_limit_per_day, is_active, allowed_origins, expires_at]);
        
        res.json({ success: true, api_key: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Delete API key
app.delete('/api/admin/api-keys/:id', async (req, res) => {
    try {
        const { id } = req.params;
        await pool.query('DELETE FROM client_api_keys WHERE id = $1', [id]);
        res.json({ success: true });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Regenerate API key
app.post('/api/admin/api-keys/:id/regenerate', async (req, res) => {
    try {
        const { id } = req.params;
        const new_key = generateApiKey();
        
        const result = await pool.query(`
            UPDATE client_api_keys SET api_key = $2, updated_at = NOW()
            WHERE id = $1
            RETURNING *
        `, [id, new_key]);
        
        res.json({ success: true, api_key: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =====================================================
// API KEY AUTHENTICATION MIDDLEWARE
// =====================================================

async function authenticateApiKey(req, res, next) {
    const apiKey = req.headers['x-api-key'] || req.query.api_key;
    
    if (!apiKey) {
        return res.status(401).json({ success: false, error: 'API key required. Include X-API-Key header or api_key query parameter.' });
    }
    
    try {
        const result = await pool.query(`
            SELECT ak.*, c.id as client_id 
            FROM client_api_keys ak
            JOIN clients c ON ak.client_id = c.id
            WHERE ak.api_key = $1 AND ak.is_active = true
        `, [apiKey]);
        
        if (result.rows.length === 0) {
            return res.status(401).json({ success: false, error: 'Invalid or inactive API key' });
        }
        
        const keyData = result.rows[0];
        
        // Check expiration
        if (keyData.expires_at && new Date(keyData.expires_at) < new Date()) {
            return res.status(401).json({ success: false, error: 'API key has expired' });
        }
        
        // Check origin if allowed_origins is set
        const origin = req.headers.origin;
        if (keyData.allowed_origins && keyData.allowed_origins.length > 0) {
            if (!origin || !keyData.allowed_origins.includes(origin)) {
                return res.status(403).json({ success: false, error: 'Origin not allowed for this API key' });
            }
        }
        
        // Update usage stats
        await pool.query(`
            UPDATE client_api_keys SET 
                last_used_at = NOW(), 
                total_requests = total_requests + 1 
            WHERE id = $1
        `, [keyData.id]);
        
        // Attach key data to request
        req.apiKey = keyData;
        req.clientId = keyData.client_id;
        
        next();
    } catch (error) {
        console.error('API auth error:', error);
        res.status(500).json({ success: false, error: 'Authentication error' });
    }
}

// Helper to check permissions
function hasPermission(req, permission) {
    if (!req.apiKey || !req.apiKey.permissions) return false;
    const perms = typeof req.apiKey.permissions === 'string' 
        ? JSON.parse(req.apiKey.permissions) 
        : req.apiKey.permissions;
    return perms.includes(permission) || perms.includes('*');
}

// =====================================================
// SECURE API ENDPOINTS (Require API Key)
// =====================================================

// Get all rooms with full details and pricing
app.get('/api/v1/rooms', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:rooms')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:rooms required' });
    }
    
    try {
        const rooms = await pool.query(`
            SELECT r.*, p.name as property_name, p.currency, p.timezone,
                   array_agg(DISTINCT ri.image_url) FILTER (WHERE ri.image_url IS NOT NULL) as images,
                   array_agg(DISTINCT a.name) FILTER (WHERE a.name IS NOT NULL) as amenities
            FROM rooms r
            JOIN properties p ON r.property_id = p.id
            LEFT JOIN room_images ri ON r.id = ri.room_id
            LEFT JOIN room_amenities ra ON r.id = ra.room_id
            LEFT JOIN amenities a ON ra.amenity_id = a.id
            WHERE p.client_id = $1
            GROUP BY r.id, p.name, p.currency, p.timezone
            ORDER BY p.name, r.name
        `, [req.clientId]);
        
        res.json({ success: true, rooms: rooms.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get room by ID with full details
app.get('/api/v1/rooms/:roomId', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:rooms')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:rooms required' });
    }
    
    try {
        const { roomId } = req.params;
        
        const room = await pool.query(`
            SELECT r.*, p.name as property_name, p.currency, p.timezone
            FROM rooms r
            JOIN properties p ON r.property_id = p.id
            WHERE r.id = $1 AND p.client_id = $2
        `, [roomId, req.clientId]);
        
        if (room.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Room not found' });
        }
        
        // Get images
        const images = await pool.query(`
            SELECT image_url, caption, display_order FROM room_images WHERE room_id = $1 ORDER BY display_order
        `, [roomId]);
        
        // Get amenities
        const amenities = await pool.query(`
            SELECT a.* FROM amenities a
            JOIN room_amenities ra ON a.id = ra.amenity_id
            WHERE ra.room_id = $1
        `, [roomId]);
        
        res.json({ 
            success: true, 
            room: {
                ...room.rows[0],
                images: images.rows,
                amenities: amenities.rows
            }
        });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get availability for date range
app.get('/api/v1/availability', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:availability')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:availability required' });
    }
    
    try {
        const { room_id, start_date, end_date } = req.query;
        
        if (!start_date || !end_date) {
            return res.status(400).json({ success: false, error: 'start_date and end_date required' });
        }
        
        let query = `
            SELECT ra.*, r.name as room_name, r.base_price
            FROM room_availability ra
            JOIN rooms r ON ra.room_id = r.id
            JOIN properties p ON r.property_id = p.id
            WHERE p.client_id = $1 AND ra.date >= $2 AND ra.date <= $3
        `;
        const params = [req.clientId, start_date, end_date];
        
        if (room_id) {
            query += ` AND ra.room_id = $4`;
            params.push(room_id);
        }
        
        query += ` ORDER BY ra.room_id, ra.date`;
        
        const result = await pool.query(query, params);
        
        // Group by room
        const availabilityByRoom = {};
        result.rows.forEach(row => {
            if (!availabilityByRoom[row.room_id]) {
                availabilityByRoom[row.room_id] = {
                    room_id: row.room_id,
                    room_name: row.room_name,
                    base_price: row.base_price,
                    dates: []
                };
            }
            availabilityByRoom[row.room_id].dates.push({
                date: row.date,
                available: row.available,
                price: row.price || row.base_price,
                min_stay: row.min_stay,
                check_in_allowed: row.check_in_allowed,
                check_out_allowed: row.check_out_allowed
            });
        });
        
        res.json({ success: true, availability: Object.values(availabilityByRoom) });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Check specific availability
app.post('/api/v1/availability/check', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:availability')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:availability required' });
    }
    
    try {
        const { room_id, check_in, check_out, guests } = req.body;
        
        if (!room_id || !check_in || !check_out) {
            return res.status(400).json({ success: false, error: 'room_id, check_in, and check_out required' });
        }
        
        // Verify room belongs to client
        const roomCheck = await pool.query(`
            SELECT r.*, p.currency FROM rooms r
            JOIN properties p ON r.property_id = p.id
            WHERE r.id = $1 AND p.client_id = $2
        `, [room_id, req.clientId]);
        
        if (roomCheck.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Room not found' });
        }
        
        const room = roomCheck.rows[0];
        
        // Check guest capacity
        if (guests && guests > room.max_occupancy) {
            return res.json({ 
                success: true, 
                available: false, 
                reason: `Maximum occupancy is ${room.max_occupancy} guests` 
            });
        }
        
        // Check for existing bookings
        const bookings = await pool.query(`
            SELECT id FROM bookings 
            WHERE room_id = $1 
            AND status NOT IN ('cancelled', 'rejected')
            AND (
                (check_in_date <= $2 AND check_out_date > $2)
                OR (check_in_date < $3 AND check_out_date >= $3)
                OR (check_in_date >= $2 AND check_out_date <= $3)
            )
        `, [room_id, check_in, check_out]);
        
        if (bookings.rows.length > 0) {
            return res.json({ 
                success: true, 
                available: false, 
                reason: 'Room is already booked for these dates' 
            });
        }
        
        // Check availability table for blocked dates
        const blocked = await pool.query(`
            SELECT date FROM room_availability 
            WHERE room_id = $1 AND date >= $2 AND date < $3 AND available = false
        `, [room_id, check_in, check_out]);
        
        if (blocked.rows.length > 0) {
            return res.json({ 
                success: true, 
                available: false, 
                reason: 'Some dates are not available',
                blocked_dates: blocked.rows.map(r => r.date)
            });
        }
        
        // Calculate price
        const nights = Math.ceil((new Date(check_out) - new Date(check_in)) / (1000 * 60 * 60 * 24));
        
        const pricing = await pool.query(`
            SELECT date, price FROM room_availability 
            WHERE room_id = $1 AND date >= $2 AND date < $3
        `, [room_id, check_in, check_out]);
        
        let totalPrice = 0;
        const priceByDate = {};
        pricing.rows.forEach(p => { priceByDate[p.date] = p.price; });
        
        for (let d = new Date(check_in); d < new Date(check_out); d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            totalPrice += priceByDate[dateStr] || room.base_price || 0;
        }
        
        res.json({ 
            success: true, 
            available: true,
            room: {
                id: room.id,
                name: room.name,
                base_price: room.base_price,
                max_occupancy: room.max_occupancy
            },
            pricing: {
                nights: nights,
                total: totalPrice,
                average_per_night: totalPrice / nights,
                currency: room.currency
            }
        });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get pricing (seasonal rates, special dates)
app.get('/api/v1/pricing', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:pricing')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:pricing required' });
    }
    
    try {
        const { room_id, start_date, end_date } = req.query;
        
        // Get base room prices
        let roomQuery = `
            SELECT r.id, r.name, r.base_price, r.weekend_price, p.currency
            FROM rooms r
            JOIN properties p ON r.property_id = p.id
            WHERE p.client_id = $1
        `;
        const params = [req.clientId];
        
        if (room_id) {
            roomQuery += ` AND r.id = $2`;
            params.push(room_id);
        }
        
        const rooms = await pool.query(roomQuery, params);
        
        // Get seasonal pricing if date range specified
        let seasonalPricing = [];
        if (start_date && end_date) {
            const pricingResult = await pool.query(`
                SELECT ra.room_id, ra.date, ra.price, ra.min_stay
                FROM room_availability ra
                JOIN rooms r ON ra.room_id = r.id
                JOIN properties p ON r.property_id = p.id
                WHERE p.client_id = $1 AND ra.date >= $2 AND ra.date <= $3
                ${room_id ? 'AND ra.room_id = $4' : ''}
                ORDER BY ra.room_id, ra.date
            `, room_id ? [req.clientId, start_date, end_date, room_id] : [req.clientId, start_date, end_date]);
            
            seasonalPricing = pricingResult.rows;
        }
        
        res.json({ 
            success: true, 
            rooms: rooms.rows,
            seasonal_pricing: seasonalPricing
        });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get active offers
app.get('/api/v1/offers', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:offers')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:offers required' });
    }
    
    try {
        const { active_only = true } = req.query;
        
        let query = `
            SELECT o.*, p.name as property_name
            FROM offers o
            JOIN properties p ON o.property_id = p.id
            WHERE p.client_id = $1
        `;
        
        if (active_only === 'true' || active_only === true) {
            query += ` AND o.is_active = true 
                       AND (o.valid_from IS NULL OR o.valid_from <= CURRENT_DATE)
                       AND (o.valid_until IS NULL OR o.valid_until >= CURRENT_DATE)`;
        }
        
        query += ` ORDER BY o.created_at DESC`;
        
        const result = await pool.query(query, [req.clientId]);
        
        res.json({ success: true, offers: result.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Validate and apply offer/voucher
app.post('/api/v1/offers/validate', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:offers')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:offers required' });
    }
    
    try {
        const { code, room_id, check_in, check_out, subtotal } = req.body;
        
        if (!code) {
            return res.status(400).json({ success: false, error: 'Offer code required' });
        }
        
        // Check vouchers first
        const voucher = await pool.query(`
            SELECT v.* FROM vouchers v
            JOIN properties p ON v.property_id = p.id
            WHERE p.client_id = $1 AND v.code = $2 AND v.is_active = true
        `, [req.clientId, code.toUpperCase()]);
        
        if (voucher.rows.length > 0) {
            const v = voucher.rows[0];
            
            // Check validity
            if (v.valid_from && new Date(v.valid_from) > new Date()) {
                return res.json({ success: true, valid: false, reason: 'Voucher not yet valid' });
            }
            if (v.valid_until && new Date(v.valid_until) < new Date()) {
                return res.json({ success: true, valid: false, reason: 'Voucher has expired' });
            }
            if (v.usage_limit && v.times_used >= v.usage_limit) {
                return res.json({ success: true, valid: false, reason: 'Voucher usage limit reached' });
            }
            if (v.min_nights && check_in && check_out) {
                const nights = Math.ceil((new Date(check_out) - new Date(check_in)) / (1000 * 60 * 60 * 24));
                if (nights < v.min_nights) {
                    return res.json({ success: true, valid: false, reason: `Minimum ${v.min_nights} nights required` });
                }
            }
            
            // Calculate discount
            let discount = 0;
            if (v.discount_type === 'percentage' && subtotal) {
                discount = subtotal * (v.discount_value / 100);
                if (v.max_discount && discount > v.max_discount) {
                    discount = v.max_discount;
                }
            } else if (v.discount_type === 'fixed') {
                discount = v.discount_value;
            }
            
            return res.json({
                success: true,
                valid: true,
                type: 'voucher',
                voucher: {
                    id: v.id,
                    code: v.code,
                    discount_type: v.discount_type,
                    discount_value: v.discount_value,
                    calculated_discount: discount
                }
            });
        }
        
        // Check offers table (try both code and offer_code columns)
        let offer;
        try {
            offer = await pool.query(`
                SELECT o.* FROM offers o
                JOIN properties p ON o.property_id = p.id
                WHERE p.client_id = $1 AND (o.code = $2 OR o.offer_code = $2) AND o.is_active = true
            `, [req.clientId, code.toUpperCase()]);
        } catch (e) {
            // If column doesn't exist, try without it
            offer = { rows: [] };
        }
        
        if (offer.rows.length > 0) {
            const o = offer.rows[0];
            
            let discount = 0;
            if (o.discount_type === 'percentage' && subtotal) {
                discount = subtotal * (o.discount_percentage / 100);
            } else if (o.discount_type === 'fixed') {
                discount = o.discount_amount;
            }
            
            return res.json({
                success: true,
                valid: true,
                type: 'offer',
                offer: {
                    id: o.id,
                    name: o.name,
                    discount_type: o.discount_type,
                    calculated_discount: discount
                }
            });
        }
        
        // Check turbine_campaigns by offer_code
        const campaign = await pool.query(`
            SELECT c.* FROM turbine_campaigns c
            JOIN properties p ON p.id = c.property_id
            WHERE p.account_id = $1 AND c.offer_code = $2 AND c.status != 'cancelled'
        `, [req.clientId, code.toUpperCase()]);
        
        if (campaign.rows.length > 0) {
            const c = campaign.rows[0];
            
            let discount = 0;
            if (c.discount_type === 'percent' || c.discount_type === 'percentage') {
                discount = subtotal ? subtotal * (parseFloat(c.discount_value) / 100) : 0;
            } else if (c.discount_type === 'fixed') {
                discount = parseFloat(c.discount_value);
            }
            
            return res.json({
                success: true,
                valid: true,
                type: 'campaign',
                campaign: {
                    id: c.id,
                    name: c.name,
                    discount_type: c.discount_type,
                    discount_value: c.discount_value,
                    calculated_discount: discount
                }
            });
        }
        
        res.json({ success: true, valid: false, reason: 'Invalid code' });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get upsells
app.get('/api/v1/upsells', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:offers')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:offers required' });
    }
    
    try {
        const { room_id } = req.query;
        
        let query = `
            SELECT u.* FROM upsells u
            JOIN properties p ON u.property_id = p.id
            WHERE p.client_id = $1 AND u.is_active = true
        `;
        const params = [req.clientId];
        
        // If room_id provided, filter applicable upsells
        if (room_id) {
            query += ` AND (u.applicable_rooms IS NULL OR u.applicable_rooms @> ARRAY[$2]::integer[])`;
            params.push(room_id);
        }
        
        query += ` ORDER BY u.display_order, u.name`;
        
        const result = await pool.query(query, params);
        
        res.json({ success: true, upsells: result.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get taxes and fees
app.get('/api/v1/taxes', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:pricing')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:pricing required' });
    }
    
    try {
        const taxes = await pool.query(`
            SELECT t.* FROM taxes t
            JOIN properties p ON t.property_id = p.id
            WHERE p.client_id = $1 AND t.is_active = true
            ORDER BY t.name
        `, [req.clientId]);
        
        const fees = await pool.query(`
            SELECT f.* FROM fees f
            JOIN properties p ON f.property_id = p.id
            WHERE p.client_id = $1 AND f.is_active = true
            ORDER BY f.name
        `, [req.clientId]);
        
        res.json({ 
            success: true, 
            taxes: taxes.rows,
            fees: fees.rows
        });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get full content (pages, contact, branding) - authenticated version with all fields
app.get('/api/v1/content', authenticateApiKey, async (req, res) => {
    if (!hasPermission(req, 'read:content')) {
        return res.status(403).json({ success: false, error: 'Permission denied: read:content required' });
    }
    
    try {
        const [pages, contact, branding, blog, attractions] = await Promise.all([
            pool.query(`SELECT * FROM client_pages WHERE client_id = $1`, [req.clientId]),
            pool.query(`SELECT * FROM client_contact_info WHERE client_id = $1`, [req.clientId]),
            pool.query(`SELECT * FROM client_branding WHERE client_id = $1`, [req.clientId]),
            pool.query(`SELECT * FROM blog_posts WHERE client_id = $1 AND is_published = true ORDER BY published_at DESC`, [req.clientId]),
            pool.query(`SELECT * FROM attractions WHERE client_id = $1 AND is_published = true ORDER BY display_order`, [req.clientId])
        ]);
        
        res.json({
            success: true,
            content: {
                pages: pages.rows,
                contact: contact.rows[0] || {},
                branding: branding.rows[0] || {},
                blog: blog.rows,
                attractions: attractions.rows
            }
        });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =====================================================
// PUBLIC API ENDPOINTS (for WordPress plugin & widgets)
// =====================================================

// Get property info (public)
app.get('/api/public/property/:propertyId', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    const property = await pool.query(`
      SELECT id, name, property_type, description, short_description, city, country, currency, timezone
      FROM properties WHERE id = $1
    `, [propertyId]);
    
    if (!property.rows[0]) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const units = await pool.query(`
      SELECT id, name, unit_type, max_guests, description, short_description, base_price
      FROM bookable_units WHERE property_id = $1 AND status = 'active'
      ORDER BY name
    `, [propertyId]);
    
    const images = await pool.query(`
      SELECT id, url, alt_text, is_primary
      FROM property_images WHERE property_id = $1
      ORDER BY sort_order, is_primary DESC
    `, [propertyId]);
    
    res.json({
      success: true,
      property: property.rows[0],
      units: units.rows,
      images: images.rows
    });
  } catch (error) {
    console.error('Public property error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get unit/room info (public)
app.get('/api/public/unit/:unitId', async (req, res) => {
  try {
    const { unitId } = req.params;
    
    const unit = await pool.query(`
      SELECT bu.*, 
             p.name as property_name, 
             p.currency, 
             p.timezone
      FROM bookable_units bu
      LEFT JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [unitId]);
    
    if (!unit.rows[0]) {
      return res.json({ success: false, error: 'Unit not found' });
    }
    
    // Try room_images first, fallback to bookable_unit_images
    let images = await pool.query(`
      SELECT id, image_url as url, alt_text
      FROM room_images WHERE room_id = $1
      ORDER BY is_primary DESC, display_order ASC, id ASC
    `, [unitId]);
    
    // If no images in room_images, try bookable_unit_images
    if (images.rows.length === 0) {
      try {
        images = await pool.query(`
          SELECT id, url, alt_text
          FROM bookable_unit_images WHERE bookable_unit_id = $1
          ORDER BY is_primary DESC, display_order ASC, id ASC
        `, [unitId]);
      } catch (e) {
        // Table doesn't exist, that's fine
        images = { rows: [] };
      }
    }
    
    // Get amenities from room_amenity_selections joined with master_amenities
    let amenities = { rows: [] };
    try {
      amenities = await pool.query(`
        SELECT ma.amenity_name as name, ma.category, ma.icon
        FROM room_amenity_selections ras
        JOIN master_amenities ma ON ras.amenity_id = ma.id
        WHERE ras.room_id = $1
        ORDER BY ma.category, ras.display_order
      `, [unitId]);
    } catch (e) {
      // Fallback to old table structure
      try {
        amenities = await pool.query(`
          SELECT amenity_name as name, category, icon
          FROM bookable_unit_amenities WHERE bookable_unit_id = $1
          ORDER BY category, display_order
        `, [unitId]);
      } catch (e2) {
        // Neither table exists
      }
    }
    
    res.json({
      success: true,
      unit: unit.rows[0],
      images: images.rows,
      amenities: amenities.rows
    });
  } catch (error) {
    console.error('Public unit error:', error);
    res.json({ success: false, error: error.message });
  }
});

// PUBLIC API - Get reviews for a room
app.get('/api/public/rooms/:roomId/reviews', async (req, res) => {
  try {
    const { roomId } = req.params;
    const limit = parseInt(req.query.limit) || 10;
    const offset = parseInt(req.query.offset) || 0;
    
    // Get reviews for this room that are public and approved
    const reviews = await pool.query(`
      SELECT 
        id,
        guest_name,
        guest_country,
        rating,
        title,
        comment,
        host_reply,
        review_date,
        stay_date_start,
        stay_date_end,
        channel_name,
        sub_ratings
      FROM reviews
      WHERE room_id = $1 
        AND is_public = true 
        AND is_approved = true
      ORDER BY review_date DESC
      LIMIT $2 OFFSET $3
    `, [roomId, limit, offset]);
    
    // Get total count and average rating
    const stats = await pool.query(`
      SELECT 
        COUNT(*) as total_reviews,
        ROUND(AVG(rating)::numeric, 1) as average_rating
      FROM reviews
      WHERE room_id = $1 
        AND is_public = true 
        AND is_approved = true
    `, [roomId]);
    
    res.json({
      success: true,
      reviews: reviews.rows,
      stats: {
        totalReviews: parseInt(stats.rows[0]?.total_reviews || 0),
        averageRating: parseFloat(stats.rows[0]?.average_rating || 0)
      },
      pagination: {
        limit,
        offset,
        hasMore: reviews.rows.length === limit
      }
    });
  } catch (error) {
    console.error('Public reviews error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get occupancy settings for a room (PUBLIC API - for booking widget)
app.get('/api/public/rooms/:roomId/occupancy-settings', async (req, res) => {
  try {
    const { roomId } = req.params;
    
    const result = await pool.query(`
      SELECT 
        bu.id,
        bu.name,
        bu.max_guests,
        bu.max_adults,
        bu.pricing_mode,
        bu.base_occupancy,
        bu.extra_adult_type,
        bu.extra_adult_charge,
        bu.single_discount_type,
        bu.single_discount_value,
        bu.child_charge_type,
        bu.child_charge,
        bu.children_allowed,
        p.child_max_age,
        p.currency
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [roomId]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Room not found' });
    }
    
    const room = result.rows[0];
    const currencySymbol = getCurrencySymbol(room.currency);
    
    res.json({ 
      success: true, 
      data: {
        ...room,
        currency_symbol: currencySymbol,
        // Calculate max adults and children for dropdowns
        max_adults: room.max_adults || room.max_guests || 4,
        max_children: room.children_allowed !== false ? Math.max(0, (room.max_guests || 4) - 1) : 0
      }
    });
  } catch (error) {
    console.error('Public occupancy settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get property terms and policies (PUBLIC API - for WordPress plugin)
app.get('/api/public/property/:propertyId/terms', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    // Get terms from property_terms table
    const termsResult = await pool.query(
      'SELECT * FROM property_terms WHERE property_id = $1',
      [propertyId]
    );
    
    // Get property-level info (house rules, cancellation policy from properties table)
    const propertyResult = await pool.query(
      `SELECT 
        house_rules, 
        cancellation_policy, 
        check_in_instructions, 
        check_out_instructions,
        check_in_time,
        check_out_time
      FROM properties WHERE id = $1`,
      [propertyId]
    );
    
    const terms = termsResult.rows[0] || {};
    const property = propertyResult.rows[0] || {};
    
    // Build formatted response for WordPress
    const response = {
      check_in: {
        from: terms.checkin_from || property.check_in_time || '15:00',
        until: terms.checkin_until || '22:00',
        self_checkin: terms.self_checkin || false,
        is_24hr: terms.checkin_24hr || false,
        instructions: property.check_in_instructions || null
      },
      check_out: {
        by: terms.checkout_by || property.check_out_time || '11:00',
        late_fee: terms.late_checkout_fee || null,
        instructions: property.check_out_instructions || null
      },
      smoking: {
        policy: terms.smoking_policy || 'no',
        fine: terms.smoking_fine || null
      },
      pets: {
        policy: terms.pet_policy || 'no',
        deposit: terms.pet_deposit || null,
        fee_per_night: terms.pet_fee_per_night || null,
        dogs_allowed: terms.dogs_allowed || false,
        cats_allowed: terms.cats_allowed || false,
        small_pets_only: terms.small_pets_only || false,
        max_pets: terms.max_pets || 0
      },
      children: {
        policy: terms.children_policy || 'all',
        cots_available: terms.cots_available || false,
        highchairs_available: terms.highchairs_available || false,
        cot_fee: terms.cot_fee_per_night || null
      },
      events: {
        policy: terms.events_policy || 'no'
      },
      accessibility: {
        wheelchair: terms.wheelchair_accessible || false,
        step_free: terms.step_free_access || false,
        accessible_bathroom: terms.accessible_bathroom || false,
        grab_rails: terms.grab_rails || false,
        roll_in_shower: terms.roll_in_shower || false,
        elevator: terms.elevator_access || false,
        ground_floor: terms.ground_floor_available || false
      },
      house_rules: {
        quiet_hours_from: terms.quiet_hours_from || null,
        quiet_hours_until: terms.quiet_hours_until || null,
        no_outside_guests: terms.no_outside_guests || false,
        id_required: terms.id_required || false,
        additional_rules: terms.additional_rules || property.house_rules || null
      },
      cancellation_policy: property.cancellation_policy || null
    };
    
    res.json({ success: true, data: response });
  } catch (error) {
    console.error('Public property terms error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get availability calendar (public)
app.get('/api/public/availability/:unitId', async (req, res) => {
  try {
    const { unitId } = req.params;
    const { from, to } = req.query;
    
    // Default to next 90 days if not specified
    const startDate = from || new Date().toISOString().split('T')[0];
    const endDate = to || new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    const availability = await pool.query(`
      SELECT 
        date,
        COALESCE(direct_price, cm_price) as price,
        is_available,
        is_blocked,
        min_stay
      FROM room_availability
      WHERE room_id = $1 AND date >= $2 AND date < $3
      ORDER BY date
    `, [unitId, startDate, endDate]);
    
    // Get unit info for base price fallback
    const unit = await pool.query(`
      SELECT bu.base_price, COALESCE(bu.currency, p.currency) as currency FROM bookable_units bu
      LEFT JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [unitId]);
    
    const basePrice = unit.rows[0]?.base_price || 0;
    const currency = unit.rows[0]?.currency || 'GBP';
    
    // Build calendar with all dates
    const calendar = [];
    let current = new Date(startDate);
    const end = new Date(endDate);
    const availMap = {};
    
    availability.rows.forEach(a => {
      const dateStr = a.date.toISOString().split('T')[0];
      availMap[dateStr] = a;
    });
    
    // Check overall availability and calculate total
    let isAvailable = true;
    let totalPrice = 0;
    let nightCount = 0;
    
    while (current < end) {
      const dateStr = current.toISOString().split('T')[0];
      const dayData = availMap[dateStr];
      
      const dayPrice = dayData?.price || basePrice;
      // Day is unavailable if: explicitly unavailable, blocked, OR no price set
      const hasPrice = dayPrice && parseFloat(dayPrice) > 0;
      const dayAvailable = dayData ? (dayData.is_available && !dayData.is_blocked && hasPrice) : (basePrice > 0);
      
      calendar.push({
        date: dateStr,
        price: parseFloat(dayPrice) || 0,
        available: dayAvailable,
        min_stay: dayData?.min_stay || 1
      });
      
      // If any day is unavailable, whole range is unavailable
      if (!dayAvailable) {
        isAvailable = false;
      }
      
      totalPrice += parseFloat(dayPrice);
      nightCount++;
      
      current.setDate(current.getDate() + 1);
    }
    
    res.json({
      success: true,
      unit_id: unitId,
      currency: currency,
      is_available: isAvailable,
      total_price: totalPrice,
      nights: nightCount,
      calendar: calendar
    });
  } catch (error) {
    console.error('Public availability error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Calculate price for dates (public) - supports offers, vouchers, upsells
app.post('/api/public/calculate-price', async (req, res) => {
  try {
    const { unit_id, check_in, check_out, guests, adults, children, voucher_code, upsells } = req.body;
    
    if (!unit_id || !check_in || !check_out) {
      return res.json({ success: false, error: 'unit_id, check_in, and check_out required' });
    }
    
    // Get availability for date range - include min_stay
    const availability = await pool.query(`
      SELECT date, 
             COALESCE(standard_price, direct_price, cm_price) as price, 
             is_available, 
             is_blocked,
             COALESCE(min_stay_override, min_stay, cm_min_stay, 1) as min_stay
      FROM room_availability
      WHERE room_id = $1 AND date >= $2 AND date < $3
      ORDER BY date
    `, [unit_id, check_in, check_out]);
    
    // Get unit with occupancy settings
    const unit = await pool.query(`
      SELECT bu.base_price, bu.max_guests, bu.name, 
             bu.pricing_mode, bu.base_occupancy, 
             bu.extra_adult_type, bu.extra_adult_charge,
             bu.single_discount_type, bu.single_discount_value,
             bu.child_charge_type, bu.child_charge,
             bu.children_allowed,
             p.currency, p.child_max_age
      FROM bookable_units bu
      LEFT JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [unit_id]);
    
    if (!unit.rows[0]) {
      return res.json({ success: false, error: 'Unit not found' });
    }
    
    const roomData = unit.rows[0];
    const basePrice = roomData.base_price || 0;
    const currency = roomData.currency || 'GBP';
    
    // Parse guests - support both old (guests) and new (adults + children) format
    const numAdults = parseInt(adults) || parseInt(guests) || 2;
    const numChildren = parseInt(children) || 0;
    const totalGuests = numAdults + numChildren;
    
    // Calculate nights
    const checkInDate = new Date(check_in);
    const checkOutDate = new Date(check_out);
    const nights = Math.ceil((checkOutDate - checkInDate) / (1000 * 60 * 60 * 24));
    
    if (nights < 1) {
      return res.json({ success: false, error: 'Invalid date range' });
    }
    
    // Check minimum stay requirement - use the max min_stay from any day in the range
    let maxMinStay = 1;
    let minStayDate = null;
    for (const dayData of availability.rows) {
      const dayMinStay = parseInt(dayData.min_stay) || 1;
      if (dayMinStay > maxMinStay) {
        maxMinStay = dayMinStay;
        minStayDate = dayData.date;
      }
    }
    
    if (nights < maxMinStay) {
      return res.json({ 
        success: false, 
        error: `Minimum stay of ${maxMinStay} nights required`,
        min_stay_required: maxMinStay,
        nights_selected: nights,
        min_stay_date: minStayDate
      });
    }
    
    // Build nightly breakdown with occupancy adjustments
    const nightlyBreakdown = [];
    let accommodationTotal = 0;
    let occupancyAdjustmentTotal = 0;
    let allAvailable = true;
    
    // Occupancy settings
    const pricingMode = roomData.pricing_mode || 'per_room';
    const baseOccupancy = parseInt(roomData.base_occupancy) || 2;
    const extraAdultType = roomData.extra_adult_type || 'fixed';
    const extraAdultCharge = parseFloat(roomData.extra_adult_charge) || 0;
    const singleDiscountType = roomData.single_discount_type || 'fixed';
    const singleDiscountValue = parseFloat(roomData.single_discount_value) || 0;
    const childChargeType = roomData.child_charge_type || 'free';
    const childCharge = parseFloat(roomData.child_charge) || 0;
    
    let current = new Date(check_in);
    for (let i = 0; i < nights; i++) {
      const dateStr = current.toISOString().split('T')[0];
      const dayData = availability.rows.find(a => a.date.toISOString().split('T')[0] === dateStr);
      
      let nightPrice = parseFloat(dayData?.price || basePrice);
      let nightOccupancyAdjustment = 0;
      
      // Apply occupancy pricing if enabled
      if (pricingMode === 'per_occupancy') {
        // Single occupancy discount - only applies if base_occupancy is more than 1
        // (i.e., room is normally for 2+ people but only 1 is staying)
        if (numAdults === 1 && baseOccupancy > 1 && singleDiscountValue > 0) {
          if (singleDiscountType === 'percent') {
            nightOccupancyAdjustment = -(nightPrice * singleDiscountValue / 100);
          } else {
            nightOccupancyAdjustment = -singleDiscountValue;
          }
        }
        // Extra adult charge - applies when MORE adults than base occupancy
        else if (numAdults > baseOccupancy && extraAdultCharge > 0) {
          const extraAdults = numAdults - baseOccupancy;
          if (extraAdultType === 'percent') {
            nightOccupancyAdjustment = nightPrice * (extraAdultCharge / 100) * extraAdults;
          } else {
            nightOccupancyAdjustment = extraAdultCharge * extraAdults;
          }
        }
        
        // Child charges
        if (numChildren > 0 && childChargeType !== 'free' && childCharge > 0) {
          if (childChargeType === 'percent') {
            nightOccupancyAdjustment += nightPrice * (childCharge / 100) * numChildren;
          } else {
            nightOccupancyAdjustment += childCharge * numChildren;
          }
        }
      }
      
      const adjustedNightPrice = nightPrice + nightOccupancyAdjustment;
      accommodationTotal += adjustedNightPrice;
      occupancyAdjustmentTotal += nightOccupancyAdjustment;
      
      if (dayData && (!dayData.is_available || dayData.is_blocked)) {
        allAvailable = false;
      }
      
      nightlyBreakdown.push({
        date: dateStr,
        base_price: nightPrice,
        occupancy_adjustment: nightOccupancyAdjustment,
        price: adjustedNightPrice
      });
      
      current.setDate(current.getDate() + 1);
    }
    
    // Build occupancy label for display
    let occupancyLabel = '';
    if (occupancyAdjustmentTotal !== 0) {
      if (occupancyAdjustmentTotal < 0) {
        occupancyLabel = 'Single occupancy discount';
      } else if (numAdults > baseOccupancy) {
        occupancyLabel = `Extra guest charge (${numAdults - baseOccupancy} extra adult${numAdults - baseOccupancy > 1 ? 's' : ''})`;
      }
      if (numChildren > 0 && childChargeType !== 'free') {
        if (occupancyLabel) occupancyLabel += ' + ';
        occupancyLabel += `${numChildren} child${numChildren > 1 ? 'ren' : ''}`;
      }
    }
    
    // Check for applicable offers - filter by property_id and pricing_tier
    let discount = 0;
    let offerApplied = null;
    let useFixedPricePerNight = null;
    let isNonStandardTier = false;
    
    // Get the pricing_tier from the request (passed from the site's configured tier)
    const requestedPricingTier = req.body.pricing_tier || 'standard';
    isNonStandardTier = requestedPricingTier !== 'standard';
    
    // Get the account_id for the unit to scope offers correctly
    const unitAccountResult = await pool.query(`
      SELECT p.account_id, p.client_id 
      FROM bookable_units bu 
      JOIN properties p ON bu.property_id = p.id 
      WHERE bu.id = $1
    `, [unit_id]);
    const unitAccountId = unitAccountResult.rows[0]?.account_id || unitAccountResult.rows[0]?.client_id;
    
    const offers = await pool.query(`
      SELECT * FROM offers
      WHERE active = true
        AND account_id = $6
        AND (property_id IS NULL OR property_id = (SELECT property_id FROM bookable_units WHERE id = $1))
        AND (room_id IS NULL OR room_id = $1)
        AND (min_nights IS NULL OR min_nights <= $2)
        AND (valid_from IS NULL OR valid_from <= $3)
        AND (valid_until IS NULL OR valid_until >= $4)
        AND (pricing_tier IS NULL OR pricing_tier = $5)
      ORDER BY priority DESC, discount_value DESC
      LIMIT 1
    `, [unit_id, nights, check_in, check_out, requestedPricingTier, unitAccountId]);
    
    if (offers.rows[0]) {
      const offer = offers.rows[0];
      
      // For non-standard tiers (corporate/agent), the adjusted price IS the price
      if (isNonStandardTier) {
        if (offer.price_per_night) {
          // Fixed price per night (negotiated rate)
          useFixedPricePerNight = parseFloat(offer.price_per_night);
          accommodationTotal = useFixedPricePerNight * nights;
          occupancyAdjustmentTotal = 0;
          discount = 0;
          offerApplied = { 
            name: offer.name, 
            discount_type: 'fixed_price', 
            price_per_night: useFixedPricePerNight,
            pricing_tier: offer.pricing_tier,
            hide_discount_badge: true
          };
        } else if (offer.discount_type === 'percentage') {
          // Percentage adjustment (can be + or -)
          // For corporate: negative discount_value = markup, positive = discount
          const adjustmentPercent = parseFloat(offer.discount_value) || 0;
          const adjustment = accommodationTotal * (adjustmentPercent / 100);
          // Apply adjustment directly to accommodation total (not as separate discount)
          accommodationTotal = accommodationTotal - adjustment;
          discount = 0; // No visible discount - this IS the corporate price
          offerApplied = { 
            name: offer.name, 
            discount_type: 'tier_adjustment',
            adjustment_percent: adjustmentPercent,
            pricing_tier: offer.pricing_tier,
            hide_discount_badge: true
          };
        } else {
          // Fixed amount adjustment
          accommodationTotal = accommodationTotal - parseFloat(offer.discount_value || 0);
          discount = 0;
          offerApplied = { 
            name: offer.name, 
            discount_type: 'tier_adjustment',
            pricing_tier: offer.pricing_tier,
            hide_discount_badge: true
          };
        }
      } else {
        // Standard tier - use percentage/fixed discount with visible badge
        if (offer.discount_type === 'percentage') {
          discount = accommodationTotal * (offer.discount_value / 100);
        } else {
          discount = parseFloat(offer.discount_value);
        }
        offerApplied = { name: offer.name, discount_type: offer.discount_type, discount_value: offer.discount_value };
      }
    }
    
    // Check voucher
    let voucherDiscount = 0;
    let voucherApplied = null;
    
    if (voucher_code) {
      const voucher = await pool.query(`
        SELECT * FROM vouchers
        WHERE code = $1 AND active = true
          AND (valid_from IS NULL OR valid_from <= $4)
          AND (valid_until IS NULL OR valid_until >= $5)
          AND (max_uses IS NULL OR uses_count < max_uses)
      `, [voucher_code.toUpperCase(), unit_id, nights, check_in, check_out]);
      
      if (voucher.rows[0]) {
        const v = voucher.rows[0];
        if (v.discount_type === 'percentage') {
          voucherDiscount = accommodationTotal * (v.discount_value / 100);
        } else {
          voucherDiscount = parseFloat(v.discount_value);
        }
        voucherApplied = { code: v.code, name: v.name, discount_type: v.discount_type, discount_value: v.discount_value };
      } else {
        return res.json({ success: false, error: 'Invalid or expired voucher code' });
      }
    }
    
    // Calculate upsells total
    let upsellsTotal = 0;
    const upsellsBreakdown = [];
    
    if (upsells && upsells.length > 0) {
      for (const item of upsells) {
        const upsellResult = await pool.query(`
          SELECT * FROM upsells WHERE id = $1 AND active = true
        `, [item.id]);
        
        if (upsellResult.rows[0]) {
          const u = upsellResult.rows[0];
          let itemTotal = parseFloat(u.price);
          
          // Calculate based on charge type
          if (u.charge_type === 'per_night') {
            itemTotal = itemTotal * nights;
          } else if (u.charge_type === 'per_guest') {
            itemTotal = itemTotal * (guests || 1);
          } else if (u.charge_type === 'per_guest_per_night') {
            itemTotal = itemTotal * nights * (guests || 1);
          }
          
          // Apply quantity
          itemTotal = itemTotal * (item.quantity || 1);
          
          upsellsTotal += itemTotal;
          upsellsBreakdown.push({
            id: u.id,
            name: u.name,
            unit_price: parseFloat(u.price),
            charge_type: u.charge_type,
            quantity: item.quantity || 1,
            total: itemTotal
          });
        }
      }
    }
    
    // Get applicable taxes
    let taxTotal = 0;
    const taxBreakdown = [];
    
    // Get taxes for this specific property
    let taxes = { rows: [] };
    try {
      taxes = await pool.query(`
        SELECT t.* FROM taxes t
        WHERE t.active = true
          AND t.property_id = (SELECT property_id FROM bookable_units WHERE id = $1)
          AND (t.room_id IS NULL OR t.room_id = $1)
      `, [unit_id]);
    } catch (taxQueryError) {
      console.log('Tax query fallback - trying simpler query');
      try {
        taxes = await pool.query(`SELECT * FROM taxes WHERE active = true`);
      } catch (e) {
        console.log('No taxes table or query failed');
      }
    }
    
    const subtotalAfterDiscounts = accommodationTotal - discount - voucherDiscount + upsellsTotal;
    
    taxes.rows.forEach(tax => {
      let taxAmount = 0;
      // Support both old (tax_type/rate) and new (amount_type/amount) column names
      const taxType = tax.tax_type || tax.amount_type || tax.charge_per || 'fixed';
      const taxRate = parseFloat(tax.rate || tax.amount) || 0;
      
      if (taxType === 'percentage') {
        taxAmount = subtotalAfterDiscounts * (taxRate / 100);
      } else if (taxType === 'per_night') {
        taxAmount = taxRate * nights;
      } else if (taxType === 'per_person_per_night') {
        taxAmount = taxRate * nights * (guests || 1);
      } else {
        // Fixed amount
        taxAmount = taxRate;
      }
      
      // Apply max_nights limit if set
      if (tax.max_nights && nights > tax.max_nights) {
        if (taxType === 'per_night') {
          taxAmount = taxRate * tax.max_nights;
        } else if (taxType === 'per_person_per_night') {
          taxAmount = taxRate * tax.max_nights * (guests || 1);
        }
      }
      
      taxTotal += taxAmount;
      taxBreakdown.push({ name: tax.name, amount: taxAmount });
    });
    
    // Get tourist tax from property settings (wrapped in try-catch in case columns don't exist)
    try {
      const propertyTax = await pool.query(`
        SELECT 
          p.tourist_tax_enabled,
          p.tourist_tax_type,
          p.tourist_tax_amount,
          p.tourist_tax_name,
          p.tourist_tax_max_nights,
          p.tourist_tax_exempt_children
        FROM properties p
        JOIN bookable_units bu ON bu.property_id = p.id
        WHERE bu.id = $1
      `, [unit_id]);
      
      if (propertyTax.rows[0] && propertyTax.rows[0].tourist_tax_enabled) {
        const pt = propertyTax.rows[0];
        const taxableNights = pt.tourist_tax_max_nights ? Math.min(nights, pt.tourist_tax_max_nights) : nights;
        let touristTaxAmount = 0;
        
        switch (pt.tourist_tax_type) {
          case 'per_guest_per_night':
            touristTaxAmount = parseFloat(pt.tourist_tax_amount) * taxableNights * (guests || 1);
            break;
          case 'per_night':
            touristTaxAmount = parseFloat(pt.tourist_tax_amount) * taxableNights;
            break;
          case 'per_booking':
            touristTaxAmount = parseFloat(pt.tourist_tax_amount);
            break;
          case 'percentage':
            touristTaxAmount = accommodationTotal * (parseFloat(pt.tourist_tax_amount) / 100);
            break;
          default:
            touristTaxAmount = parseFloat(pt.tourist_tax_amount) * taxableNights * (guests || 1);
        }
        
        if (touristTaxAmount > 0) {
          taxTotal += touristTaxAmount;
          taxBreakdown.push({ 
            name: pt.tourist_tax_name || 'Tourist Tax', 
            amount: touristTaxAmount,
            type: 'tourist_tax'
          });
        }
      }
    } catch (touristTaxError) {
      // Tourist tax columns may not exist yet - skip silently
      console.log('Tourist tax columns not available:', touristTaxError.message);
    }
    
    const grandTotal = subtotalAfterDiscounts + taxTotal;
    
    // Debug info for availability
    const availabilityDebug = {
      dates_checked: nights,
      availability_rows_found: availability.rows.length,
      unavailable_dates: nightlyBreakdown.filter((n, i) => {
        const dayData = availability.rows.find(a => a.date.toISOString().split('T')[0] === n.date);
        return dayData && (!dayData.is_available || dayData.is_blocked);
      }).map(n => n.date)
    };
    
    res.json({
      success: true,
      available: allAvailable,
      availability_debug: availabilityDebug,
      currency: currency,
      nights: nights,
      min_stay: maxMinStay,
      room_name: roomData.name,
      adults: numAdults,
      children: numChildren,
      total_guests: totalGuests,
      pricing_mode: pricingMode,
      occupancy_adjustment: occupancyAdjustmentTotal,
      occupancy_label: occupancyLabel,
      accommodation_total: accommodationTotal,
      offer_discount: discount,
      offer_applied: offerApplied,
      voucher_discount: voucherDiscount,
      voucher_applied: voucherApplied,
      upsells_total: upsellsTotal,
      upsells_breakdown: upsellsBreakdown,
      subtotal: subtotalAfterDiscounts,
      taxes: taxBreakdown,
      tax_total: taxTotal,
      grand_total: grandTotal,
      nightly_breakdown: nightlyBreakdown
    });
  } catch (error) {
    console.error('Calculate price error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get min stay for a room's date range (public - for calendar display)
app.get('/api/public/rooms/:roomId/min-stay', async (req, res) => {
  try {
    const { roomId } = req.params;
    const { start_date, end_date } = req.query;
    
    const startDate = start_date || new Date().toISOString().split('T')[0];
    const endDate = end_date || new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    const result = await pool.query(`
      SELECT date, 
             COALESCE(min_stay_override, min_stay, cm_min_stay, 1) as min_stay,
             cm_min_stay
      FROM room_availability
      WHERE room_id = $1 AND date >= $2 AND date <= $3
      ORDER BY date
    `, [roomId, startDate, endDate]);
    
    // Also get default min stay from room settings
    const roomResult = await pool.query(`
      SELECT min_stay FROM bookable_units WHERE id = $1
    `, [roomId]);
    
    const defaultMinStay = roomResult.rows[0]?.min_stay || 1;
    
    res.json({ 
      success: true, 
      default_min_stay: defaultMinStay,
      dates: result.rows.map(r => ({
        date: r.date,
        min_stay: parseInt(r.min_stay) || defaultMinStay
      }))
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create booking (public)
app.post('/api/public/book', async (req, res) => {
  try {
    const { 
      unit_id, check_in, check_out, guests,
      guest_first_name, guest_last_name, guest_email, guest_phone,
      guest_address, guest_city, guest_country, guest_postcode,
      voucher_code, notes, total_price,
      stripe_payment_intent_id, deposit_amount, balance_amount, payment_method
    } = req.body;
    
    // Validate required fields
    if (!unit_id || !check_in || !check_out || !guest_first_name || !guest_last_name || !guest_email) {
      return res.json({ success: false, error: 'Missing required fields' });
    }
    
    // Get unit and property info
    const unit = await pool.query(`
      SELECT bu.*, p.id as property_id, p.name as property_name
      FROM bookable_units bu
      LEFT JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [unit_id]);
    
    if (!unit.rows[0]) {
      return res.json({ success: false, error: 'Unit not found' });
    }
    
    // ========== REAL-TIME AVAILABILITY CHECK ==========
    // Check Beds24 for latest availability before confirming booking
    const beds24RoomId = unit.rows[0].beds24_room_id;
    if (beds24RoomId) {
      try {
        // Use property-specific token lookup for GasSync connections
        const accessToken = await getBeds24AccessTokenForProperty(pool, unit.rows[0].property_id, unit_id);
        if (accessToken) {
          console.log(`Real-time availability check for room ${beds24RoomId}: ${check_in} to ${check_out}`);
          
          const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
            headers: { 'token': accessToken },
            params: {
              roomId: beds24RoomId,
              startDate: check_in,
              endDate: check_out
            }
          });
          
          const data = availResponse.data?.data?.[0];
          if (data && data.availability) {
            // Check each date in the range
            for (const [dateStr, isAvailable] of Object.entries(data.availability)) {
              if (isAvailable === false) {
                console.log(`Real-time check FAILED: ${dateStr} is not available`);
                return res.json({ 
                  success: false, 
                  error: 'Sorry, these dates are no longer available. Please select different dates.',
                  unavailable_date: dateStr
                });
              }
            }
            console.log('Real-time availability check PASSED');
          }
        }
      } catch (availError) {
        // Log but don't block - fall back to local availability
        console.error('Real-time availability check error:', availError.message);
      }
    }
    // ========== END AVAILABILITY CHECK ==========
    
    // Determine payment status
    let paymentStatus = 'pending';
    let bookingStatus = 'pending';
    
    if (stripe_payment_intent_id && deposit_amount) {
      paymentStatus = 'deposit_paid';
      bookingStatus = 'confirmed';
    } else if (payment_method === 'property') {
      paymentStatus = 'pending';
      bookingStatus = 'confirmed';
    }
    
    // Calculate balance due date (14 days before arrival by default)
    const arrivalDate = new Date(check_in);
    const balanceDueDate = new Date(arrivalDate);
    balanceDueDate.setDate(balanceDueDate.getDate() - 14);
    
    // Create booking
    const booking = await pool.query(`
      INSERT INTO bookings (
        property_id, property_owner_id, bookable_unit_id, 
        arrival_date, departure_date, 
        num_adults, num_children, 
        guest_first_name, guest_last_name, guest_email, guest_phone,
        accommodation_price, subtotal, grand_total, 
        deposit_amount, balance_amount, balance_due_date,
        stripe_payment_intent_id, payment_status,
        status, booking_source, currency, notes
      ) 
      VALUES ($1, 1, $2, $3, $4, $5, 0, $6, $7, $8, $9, $10, $10, $10, $11, $12, $13, $14, $15, $16, 'direct', 'USD', $17)
      RETURNING *
    `, [
      unit.rows[0].property_id,
      unit_id,
      check_in,
      check_out,
      guests || 1,
      guest_first_name,
      guest_last_name,
      guest_email,
      guest_phone || null,
      total_price || 0,
      deposit_amount || null,
      balance_amount || null,
      balanceDueDate,
      stripe_payment_intent_id || null,
      paymentStatus,
      bookingStatus,
      notes || null
    ]);
    
    const newBooking = booking.rows[0];
    
    // If card payment was made, record the transaction
    if (stripe_payment_intent_id && deposit_amount) {
      try {
        await pool.query(`
          INSERT INTO payment_transactions (booking_id, type, amount, currency, status, stripe_payment_intent_id, created_at)
          VALUES ($1, 'deposit', $2, 'USD', 'completed', $3, NOW())
        `, [newBooking.id, deposit_amount, stripe_payment_intent_id]);
      } catch (txError) {
        console.log('Could not record payment transaction (table may not exist yet):', txError.message);
      }
    }
    
    // If voucher was used, increment usage
    if (voucher_code) {
      await pool.query(`
        UPDATE vouchers SET times_used = times_used + 1 WHERE code = $1
      `, [voucher_code.toUpperCase()]);
    }
    
    // Block availability for these dates
    console.log(`Blocking dates for unit ${unit_id} from ${check_in} to ${check_out}`);
    
    // Parse dates properly (avoid timezone issues)
    const startParts = check_in.split('-');
    const endParts = check_out.split('-');
    let current = new Date(startParts[0], startParts[1] - 1, startParts[2]);
    const checkOutDate = new Date(endParts[0], endParts[1] - 1, endParts[2]);
    
    while (current < checkOutDate) {
      const dateStr = current.toISOString().split('T')[0];
      console.log(`Blocking date: ${dateStr} for unit ${unit_id}`);
      try {
        await pool.query(`
          INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
          VALUES ($1, $2, false, true, 'booking')
          ON CONFLICT (room_id, date) DO UPDATE SET is_available = false, is_blocked = true, source = 'booking'
        `, [unit_id, dateStr]);
      } catch (blockErr) {
        console.error(`Error blocking date ${dateStr}:`, blockErr.message);
      }
      current.setDate(current.getDate() + 1);
    }
    console.log('Finished blocking dates');
    
    // ========== CHANNEL MANAGER SYNC ==========
    let beds24BookingId = null;
    let smoobuBookingId = null;
    let hostawayReservationId = null;
    
    // Get CM IDs for this unit
    const cmResult = await pool.query(`
      SELECT bu.beds24_room_id, bu.smoobu_id, bu.hostaway_listing_id,
             p.account_id
      FROM bookable_units bu
      LEFT JOIN properties p ON bu.property_id = p.id
      WHERE bu.id = $1
    `, [unit_id]);
    
    const cmData = cmResult.rows[0];
    
    // BEDS24 SYNC
    if (cmData?.beds24_room_id) {
      try {
        // Use property-specific token lookup for GasSync connections
        const accessToken = await getBeds24AccessTokenForProperty(pool, newBooking.property_id, unit_id);
        
        // Build payment array if deposit was taken
        const payments = [];
        console.log(`Beds24 sync - deposit_amount: ${deposit_amount}, stripe_payment_intent_id: ${stripe_payment_intent_id}`);
        
        if (stripe_payment_intent_id && deposit_amount) {
          payments.push({
            description: 'Deposit via Stripe',
            amount: parseFloat(deposit_amount),
            status: 'received',
            date: new Date().toISOString().split('T')[0]
          });
          console.log('Added deposit payment to Beds24 payload:', JSON.stringify(payments));
        }
        
        const beds24Booking = [{
          roomId: cmData.beds24_room_id,
          status: 'confirmed',
          arrival: check_in,
          departure: check_out,
          numAdult: guests || 1,
          numChild: 0,
          firstName: guest_first_name,
          lastName: guest_last_name,
          email: guest_email,
          mobile: guest_phone || '',
          phone: guest_phone || '',
          address: guest_address || '',
          city: guest_city || '',
          postcode: guest_postcode || '',
          country: guest_country || '',
          referer: `GAS #${newBooking.id}`,
          notes: `GAS Booking ID: ${newBooking.id}`,
          price: parseFloat(total_price) || 0,
          deposit: deposit_amount ? parseFloat(deposit_amount) : 0,
          invoiceItems: [{
            description: 'Accommodation',
            status: '',
            qty: 1,
            amount: parseFloat(total_price) || 0,
            vatRate: 0
          }],
          payments: payments.length > 0 ? payments : undefined
        }];
        
        console.log('Pushing booking to Beds24:', JSON.stringify(beds24Booking));
        
        const beds24Response = await axios.post('https://beds24.com/api/v2/bookings', beds24Booking, {
          headers: {
            'token': accessToken,
            'Content-Type': 'application/json'
          }
        });
        
        console.log('Beds24 response:', JSON.stringify(beds24Response.data));
        
        if (beds24Response.data && beds24Response.data[0]?.success) {
          beds24BookingId = beds24Response.data[0]?.new?.id;
          if (beds24BookingId) {
            await pool.query(`UPDATE bookings SET beds24_booking_id = $1 WHERE id = $2`, [beds24BookingId, newBooking.id]);
          }
        }
      } catch (beds24Error) {
        console.error('Error syncing to Beds24:', beds24Error.response?.data || beds24Error.message);
      }
    }
    
    // SMOOBU SYNC
    if (cmData?.smoobu_id) {
      try {
        // Get Smoobu API key for this account
        const smoobuKeyResult = await pool.query(`
          SELECT setting_value FROM client_settings 
          WHERE client_id = $1 AND setting_key = 'smoobu_api_key'
        `, [cmData.account_id]);
        
        const smoobuApiKey = smoobuKeyResult.rows[0]?.setting_value;
        
        if (smoobuApiKey) {
          const smoobuResponse = await axios.post('https://login.smoobu.com/api/reservations', {
            arrivalDate: check_in,
            departureDate: check_out,
            apartmentId: parseInt(cmData.smoobu_id),
            channelId: 13, // Direct booking
            firstName: guest_first_name,
            lastName: guest_last_name,
            email: guest_email,
            phone: guest_phone || '',
            adults: guests || 1,
            children: 0,
            price: total_price || 0,
            notice: `GAS Booking ID: ${newBooking.id}`
          }, {
            headers: {
              'Api-Key': smoobuApiKey,
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Smoobu response:', JSON.stringify(smoobuResponse.data));
          
          if (smoobuResponse.data?.id) {
            smoobuBookingId = smoobuResponse.data.id;
            await pool.query(`UPDATE bookings SET smoobu_booking_id = $1 WHERE id = $2`, [smoobuBookingId, newBooking.id]);
          }
        }
      } catch (smoobuError) {
        console.error('Error syncing to Smoobu:', smoobuError.response?.data || smoobuError.message);
      }
    }
    
    // HOSTAWAY SYNC
    if (cmData?.hostaway_listing_id) {
      try {
        const stored = await getStoredHostawayToken(pool);
        
        if (stored?.accessToken) {
          const hostawayResponse = await axios.post('https://api.hostaway.com/v1/reservations', {
            listingMapId: cmData.hostaway_listing_id,
            channelId: 2000,
            source: 'manual',
            arrivalDate: check_in,
            departureDate: check_out,
            guestFirstName: guest_first_name,
            guestLastName: guest_last_name,
            guestEmail: guest_email,
            guestPhone: guest_phone || '',
            numberOfGuests: guests || 1,
            adults: guests || 1,
            children: 0,
            totalPrice: total_price || 0,
            isPaid: deposit_amount ? 1 : 0,
            status: 'new',
            comment: `GAS Booking ID: ${newBooking.id}`
          }, {
            headers: {
              'Authorization': `Bearer ${stored.accessToken}`,
              'Content-Type': 'application/json'
            }
          });
          
          console.log('Hostaway response:', JSON.stringify(hostawayResponse.data));
          
          if (hostawayResponse.data?.result?.id) {
            hostawayReservationId = hostawayResponse.data.result.id;
            await pool.query(`UPDATE bookings SET hostaway_reservation_id = $1 WHERE id = $2`, [hostawayReservationId, newBooking.id]);
          }
        }
      } catch (hostawayError) {
        console.error('Error syncing to Hostaway:', hostawayError.response?.data || hostawayError.message);
      }
    }
    // ========== END CM SYNC ==========
    
    // ========== SEND CONFIRMATION EMAIL ==========
    try {
      // Get property details for the email
      const propertyResult = await pool.query(`
        SELECT p.*, a.email as account_email 
        FROM properties p 
        LEFT JOIN accounts a ON p.account_id = a.id 
        WHERE p.id = $1
      `, [unit.rows[0].property_id]);
      
      const property = propertyResult.rows[0];
      const room = unit.rows[0];
      
      // Build booking object with all details
      const bookingForEmail = {
        id: newBooking.id,
        arrival_date: check_in,
        departure_date: check_out,
        num_adults: guests || 1,
        grand_total: total_price,
        deposit_amount: deposit_amount,
        balance_amount: balance_amount,
        currency: room.currency || '$'
      };
      
      const emailHtml = generateBookingConfirmationEmail(bookingForEmail, property, room);
      
      // Send to guest
      await sendEmail({
        to: guest_email,
        subject: `Booking Confirmed - ${property?.name || 'Your Reservation'} (Ref: ${newBooking.id})`,
        html: emailHtml
      });
      
      // Also send to property owner if different email
      if (property?.account_email && property.account_email !== guest_email) {
        await sendEmail({
          to: property.account_email,
          subject: `New Booking - ${guest_first_name} ${guest_last_name} (Ref: ${newBooking.id})`,
          html: emailHtml
        });
      }
    } catch (emailError) {
      console.error('Email sending error:', emailError.message);
      // Don't fail the booking if email fails
    }
    // ========== END EMAIL ==========
    
    res.json({
      success: true,
      booking_id: newBooking.id,
      booking: newBooking,
      cm_sync: {
        beds24: beds24BookingId ? { success: true, id: beds24BookingId } : null,
        smoobu: smoobuBookingId ? { success: true, id: smoobuBookingId } : null,
        hostaway: hostawayReservationId ? { success: true, id: hostawayReservationId } : null
      }
    });
  } catch (error) {
    console.error('Create booking error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Validate voucher (public)
app.post('/api/public/validate-voucher', async (req, res) => {
  try {
    const { code, unit_id, check_in, check_out } = req.body;
    
    if (!code) {
      return res.json({ success: false, error: 'Voucher code required' });
    }
    
    const nights = check_in && check_out ? 
      Math.ceil((new Date(check_out) - new Date(check_in)) / (1000 * 60 * 60 * 24)) : 1;
    
    // Simple voucher lookup - just by code and active status
    // More complex property/unit filtering requires schema updates
    let voucher;
    try {
      voucher = await pool.query(`
        SELECT * FROM vouchers
        WHERE UPPER(code) = UPPER($1) AND active = true
          AND (valid_from IS NULL OR valid_from <= CURRENT_DATE)
          AND (valid_until IS NULL OR valid_until >= CURRENT_DATE)
          AND (max_uses IS NULL OR times_used < max_uses)
      `, [code]);
    } catch (queryError) {
      console.log('Voucher query error:', queryError.message);
      // Ultimate fallback - just check code
      voucher = await pool.query(`
        SELECT * FROM vouchers WHERE UPPER(code) = UPPER($1) AND active = true
      `, [code]);
    }
    
    if (voucher.rows[0]) {
      const v = voucher.rows[0];
      // Check min_nights if column exists
      if (v.min_nights && nights < v.min_nights) {
        return res.json({ success: true, valid: false, error: `Minimum ${v.min_nights} nights required` });
      }
      
      res.json({
        success: true,
        valid: true,
        voucher: {
          code: v.code,
          name: v.name,
          discount_type: v.discount_type,
          discount_value: v.discount_value
        }
      });
    } else {
      res.json({ success: true, valid: false, error: 'Invalid or expired voucher code' });
    }
  } catch (error) {
    console.error('Validate voucher error:', error);
    res.json({ success: false, error: 'Unable to validate voucher' });
  }
});

// Get available upsells (public)
app.get('/api/public/upsells/:unitId', async (req, res) => {
  try {
    const { unitId } = req.params;
    
    const upsells = await pool.query(`
      SELECT id, name, description, category, price, charge_type as price_type
      FROM upsells
      WHERE active = true
        AND (property_id IS NULL OR property_id = (SELECT property_id FROM bookable_units WHERE id = $1))
        AND (room_id IS NULL OR room_id = $1)
      ORDER BY category, name
    `, [unitId]);
    
    res.json({ success: true, upsells: upsells.rows });
  } catch (error) {
    console.error('Get upsells error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// PUBLIC API - OFFERS, UPSELLS & PREMIUM FEATURES
// =========================================================
// UI TRANSLATIONS API
// =========================================================

// Translations data - comprehensive UI strings for all supported languages
const GAS_TRANSLATIONS = {
  "en": {
    "lang": "en",
    "name": "English",
    "flag": "üá¨üáß",
    "strings": {
      "common": {
        "loading": "Loading...",
        "error": "Error",
        "success": "Success",
        "save": "Save",
        "cancel": "Cancel",
        "close": "Close",
        "back": "Back",
        "next": "Next",
        "submit": "Submit",
        "confirm": "Confirm",
        "search": "Search",
        "filter": "Filter",
        "sort": "Sort",
        "all": "All",
        "from": "From",
        "to": "To",
        "per": "per",
        "total": "Total",
        "available": "Available",
        "unavailable": "Unavailable",
        "under": "under",
        "more_info": "More Information",
        "apply": "Apply",
        "and": "and",
        "processing": "Processing...",
        "coming_soon": "Coming soon"
      },
      "booking": {
        "book_now": "Book Now",
        "view_book": "View & Book",
        "check_availability": "Check Availability",
        "check_in": "Check-in",
        "check_out": "Check-out",
        "select_dates": "Select date",
        "where_going": "Where are you going?",
        "location": "Location",
        "nights": "nights",
        "night": "night",
        "guests": "Guests",
        "guest": "Guest",
        "adults": "Adults",
        "adult": "Adult",
        "children": "Children",
        "child": "Child",
        "price_per_night": "per night",
        "price_from": "From",
        "total": "Total",
        "total_price": "Total Price",
        "cleaning_fee": "Cleaning Fee",
        "service_fee": "Service Fee",
        "taxes": "Taxes",
        "discount": "Discount",
        "offer_discount": "Offer discount",
        "promo_code": "Promo Code",
        "apply": "Apply",
        "min_stay": "Minimum stay",
        "max_guests": "Maximum guests",
        "not_available": "Not available for selected dates",
        "continue_booking": "Continue Booking",
        "complete_booking": "Complete your booking",
        "confirm_booking": "Confirm Booking",
        "booking_confirmed": "Booking Confirmed!",
        "booking_reference": "Booking Reference",
        "select_dates_to_check": "Select dates to check availability",
        "add_to_cart": "Add to Cart",
        "go_to_cart": "Go to Cart",
        "rooms_in_cart": "room(s) in cart",
        "add_another_room": "Add another room",
        "clear_cart": "Clear cart",
        "special_offer": "Special Offer",
        "special_rates_available": "We have special rates available for your dates!",
        "see_rates_below": "See rate options below ‚Üì",
        "guest_adjustment": "Guest adjustment",
        "first_name": "First Name",
        "last_name": "Last Name",
        "email": "Email",
        "phone": "Phone",
        "special_requests": "Special Requests",
        "minimum": "Minimum",
        "required": "required",
        "you_selected": "You selected",
        "choose_longer": "Please choose a longer stay.",
        "guest": "guest"
      },
      "guest_details": {
        "guest_details": "Guest Details",
        "first_name": "First Name",
        "last_name": "Last Name",
        "email": "Email",
        "phone": "Phone",
        "country": "Country",
        "special_requests": "Special Requests",
        "arrival_time": "Estimated Arrival Time",
        "terms_agree": "I agree to the",
        "terms_conditions": "Terms and Conditions",
        "privacy_policy": "Privacy Policy"
      },
      "payment": {
        "payment": "Payment",
        "pay_now": "Pay Now",
        "pay_deposit": "Pay Deposit",
        "pay_at_property": "Pay at Property",
        "pay_at_property_desc": "Pay when you arrive - no payment needed now",
        "pay_by_card": "Pay by Card",
        "card_number": "Card Number",
        "card_details": "Card Details",
        "expiry_date": "Expiry Date",
        "cvv": "CVV",
        "cardholder_name": "Cardholder Name",
        "payment_secure": "Your payment is secured by Stripe",
        "payment_processing": "Processing payment...",
        "deposit_amount": "Deposit Amount",
        "balance_due": "Balance due at check-in",
        "deposit_info": "A deposit will be charged now. The remaining balance is due at check-in."
      },
      "property": {
        "property": "Property",
        "properties": "Properties",
        "description": "Description",
        "availability": "Availability",
        "amenities": "Amenities",
        "features": "Features",
        "location": "Location",
        "reviews": "Reviews",
        "terms": "Terms",
        "house_rules": "House Rules",
        "guests_label": "Guests",
        "bedrooms": "bedrooms",
        "bedroom": "bedroom",
        "bathrooms": "bathrooms",
        "bathroom": "bathroom",
        "beds": "beds",
        "bed": "bed",
        "general_terms": "General Terms",
        "house_rules": "House Rules",
        "cancellation_policy": "Cancellation Policy",
        "no_terms": "No general terms provided.",
        "no_rules": "No house rules provided.",
        "no_cancellation": "No cancellation policy provided."
      },
      "properties_portfolio": {
        "page_title": "Our Properties",
        "page_subtitle": "Explore our collection of vacation rentals",
        "view_apartments": "View Apartments",
        "view_rooms": "View Rooms",
        "view_property": "View Property",
        "rooms_available": "rooms available",
        "room_available": "room available",
        "from_price": "From",
        "per_night": "per night",
        "no_properties": "No properties available at this time.",
        "loading": "Loading properties...",
        "all_locations": "All Locations",
        "filter_by_location": "Filter by location",
        "bedrooms_range": "bedrooms",
        "max_guests": "max guests",
        "properties_count": "properties",
        "property_count": "property"
      },
      "terms": {
        "check_in": "Check-in",
        "check_out": "Check-out",
        "by": "By",
        "self_checkin": "Self check-in available",
        "checkin_24hr": "24-hour check-in",
        "late_checkout_fee": "Late check-out fee",
        "children": "Children",
        "children_all_ages": "Children of all ages welcome",
        "no_children": "No children allowed",
        "children_policy": "Children policy",
        "cots_available": "Cots available",
        "highchairs_available": "Highchairs available",
        "events": "Events",
        "no_events": "No events or parties",
        "events_on_request": "Events on request",
        "events_allowed": "Events allowed",
        "smoking": "Smoking",
        "no_smoking": "No smoking",
        "smoking_designated": "Smoking in designated areas only",
        "smoking_allowed": "Smoking allowed",
        "fine": "Fine",
        "pets": "Pets",
        "no_pets": "No pets allowed",
        "pets_on_request": "Pets on request",
        "pets_allowed": "Pets allowed",
        "dogs_welcome": "Dogs welcome",
        "cats_welcome": "Cats welcome",
        "deposit": "Deposit",
        "fee": "Fee",
        "night": "night",
        "quiet_hours": "Quiet hours",
        "id_required": "ID required",
        "valid_id_required": "Valid ID required at check-in",
        "guests": "Guests",
        "no_unregistered": "No unregistered visitors allowed",
        "accessibility": "Accessibility",
        "wheelchair": "Wheelchair accessible",
        "step_free": "Step-free access",
        "accessible_bathroom": "Accessible bathroom",
        "elevator": "Elevator access",
        "ground_floor": "Ground floor available"
      },
      "filters": {
        "sort_by": "Sort By",
        "default": "Default",
        "price_low": "Price: Low to High",
        "price_high": "Price: High to Low",
        "location": "Location",
        "all_locations": "All Locations",
        "amenities": "Amenities",
        "select_amenities": "Select Amenities",
        "clear_filters": "Clear Filters"
      },
      "calendar": {
        "today": "Today",
        "mon": "Mon", "tue": "Tue", "wed": "Wed", "thu": "Thu", "fri": "Fri", "sat": "Sat", "sun": "Sun",
        "january": "January", "february": "February", "march": "March", "april": "April",
        "may": "May", "june": "June", "july": "July", "august": "August",
        "september": "September", "october": "October", "november": "November", "december": "December"
      },
      "checkout": {
        "your_booking": "Your Booking",
        "your_rooms": "Your Rooms",
        "guest_details": "Guest Details",
        "your_details": "Your Details",
        "extras": "Extras",
        "payment": "Payment",
        "first_name": "First Name",
        "last_name": "Last Name",
        "email_address": "Email Address",
        "confirm_email": "Confirm Email",
        "phone_number": "Phone Number",
        "country": "Country",
        "address": "Address",
        "city": "City",
        "postcode": "Postcode",
        "optional": "optional",
        "price_details": "Price Details",
        "total": "Total",
        "nights": "nights",
        "standard_rate": "Standard Rate",
        "special_offer": "Special Offer",
        "offer_discount": "Offer Discount",
        "your_extras": "Your Extras",
        "promo_code": "Promo Code",
        "enter_promo": "Enter promo code",
        "taxes_fees": "Taxes & Fees",
        "includes_taxes": "Includes all taxes and fees",
        "cancellation_policy": "Cancellation Policy",
        "free_cancellation": "Free cancellation",
        "until_48h": "until 48 hours before check-in.",
        "non_refundable": "Non-refundable.",
        "cannot_cancel": "This rate cannot be cancelled or modified.",
        "please_enter_details": "Please enter your details. We'll send the booking confirmation to your email.",
        "enhance_stay": "Enhance Your Stay",
        "add_extras_text": "Add extras to make your stay even more special.",
        "no_extras": "No extras available for this booking.",
        "continue_payment": "Continue to Payment",
        "continue_extras": "Continue to Extras",
        "back_to_room": "Back to Room",
        "secure_booking": "Secure Booking",
        "instant_confirmation": "Instant Confirmation",
        "support_24_7": "24/7 Support",
        "special_requests_placeholder": "E.g., late check-in, dietary requirements, special occasion...",
        "special_requests_hint": "Special requests are subject to availability and cannot be guaranteed.",
        "marketing_opt_in": "Send me special offers and updates (you can unsubscribe anytime)"
      }
    }
  },
  "fr": {
    "lang": "fr",
    "name": "Fran√ßais",
    "flag": "üá´üá∑",
    "strings": {
      "common": {
        "loading": "Chargement...",
        "error": "Erreur",
        "success": "Succ√®s",
        "save": "Enregistrer",
        "cancel": "Annuler",
        "close": "Fermer",
        "back": "Retour",
        "next": "Suivant",
        "submit": "Envoyer",
        "confirm": "Confirmer",
        "search": "Rechercher",
        "filter": "Filtrer",
        "sort": "Trier",
        "all": "Tous",
        "from": "De",
        "to": "√Ä",
        "per": "par",
        "total": "Total",
        "available": "Disponible",
        "unavailable": "Indisponible",
        "under": "moins de",
        "more_info": "Plus d'informations",
        "apply": "Appliquer",
        "and": "et",
        "processing": "Traitement en cours...",
        "coming_soon": "Bient√¥t disponible"
      },
      "booking": {
        "book_now": "R√©server",
        "view_book": "Voir & R√©server",
        "check_availability": "V√©rifier la disponibilit√©",
        "check_in": "Arriv√©e",
        "check_out": "D√©part",
        "select_dates": "S√©lectionner une date",
        "select_dates_to_check": "S√©lectionnez les dates pour v√©rifier la disponibilit√©",
        "where_going": "O√π allez-vous ?",
        "location": "Destination",
        "nights": "nuits",
        "night": "nuit",
        "guests": "Voyageurs",
        "guest": "Voyageur",
        "adults": "Adultes",
        "adult": "Adulte",
        "children": "Enfants",
        "child": "Enfant",
        "price_per_night": "par nuit",
        "price_from": "√Ä partir de",
        "total": "Total",
        "total_price": "Prix total",
        "cleaning_fee": "Frais de m√©nage",
        "service_fee": "Frais de service",
        "taxes": "Taxes",
        "discount": "R√©duction",
        "offer_discount": "R√©duction offre",
        "promo_code": "Code promo",
        "apply": "Appliquer",
        "min_stay": "S√©jour minimum",
        "max_guests": "Capacit√© maximale",
        "not_available": "Non disponible pour les dates s√©lectionn√©es",
        "continue_booking": "Continuer la r√©servation",
        "complete_booking": "Finaliser votre r√©servation",
        "confirm_booking": "Confirmer la r√©servation",
        "booking_confirmed": "R√©servation confirm√©e !",
        "booking_reference": "R√©f√©rence de r√©servation",
        "add_to_cart": "Ajouter au panier",
        "go_to_cart": "Voir le panier",
        "rooms_in_cart": "chambre(s) dans le panier",
        "add_another_room": "Ajouter une autre chambre",
        "clear_cart": "Vider le panier",
        "special_offer": "Offre sp√©ciale",
        "special_rates_available": "Nous avons des tarifs sp√©ciaux pour vos dates !",
        "see_rates_below": "Voir les options tarifaires ci-dessous ‚Üì",
        "guest_adjustment": "Ajustement voyageurs",
        "first_name": "Pr√©nom",
        "last_name": "Nom",
        "email": "E-mail",
        "phone": "T√©l√©phone",
        "special_requests": "Demandes sp√©ciales",
        "minimum": "Minimum",
        "required": "requis",
        "you_selected": "Vous avez s√©lectionn√©",
        "choose_longer": "Veuillez choisir un s√©jour plus long.",
        "guest": "voyageur"
      },
      "guest_details": {
        "guest_details": "Informations voyageur",
        "first_name": "Pr√©nom",
        "last_name": "Nom",
        "email": "E-mail",
        "phone": "T√©l√©phone",
        "country": "Pays",
        "special_requests": "Demandes sp√©ciales",
        "arrival_time": "Heure d'arriv√©e estim√©e",
        "terms_agree": "J'accepte les",
        "terms_conditions": "Conditions g√©n√©rales",
        "privacy_policy": "Politique de confidentialit√©"
      },
      "payment": {
        "payment": "Paiement",
        "pay_now": "Payer maintenant",
        "pay_deposit": "Payer l'acompte",
        "pay_at_property": "Payer sur place",
        "pay_at_property_desc": "Payez √† votre arriv√©e - aucun paiement requis maintenant",
        "pay_by_card": "Payer par carte",
        "not_available_property": "Non disponible pour cette propri√©t√©",
        "card_number": "Num√©ro de carte",
        "card_details": "D√©tails de la carte",
        "expiry_date": "Date d'expiration",
        "cvv": "CVV",
        "cardholder_name": "Nom du titulaire",
        "payment_secure": "Votre paiement est s√©curis√© par Stripe",
        "payment_processing": "Traitement du paiement...",
        "deposit_amount": "Montant de l'acompte",
        "balance_due": "Solde d√ª √† l'arriv√©e",
        "deposit_info": "Un acompte sera pr√©lev√© maintenant. Le solde est d√ª √† l'arriv√©e."
      },
      "property": {
        "property": "Propri√©t√©",
        "properties": "Propri√©t√©s",
        "description": "Description",
        "availability": "Disponibilit√©",
        "amenities": "√âquipements",
        "features": "Caract√©ristiques",
        "location": "Emplacement",
        "reviews": "Avis",
        "terms": "Conditions",
        "house_rules": "R√®glement int√©rieur",
        "guests_label": "Voyageurs",
        "bedrooms": "chambres",
        "bedroom": "chambre",
        "bathrooms": "salles de bain",
        "bathroom": "salle de bain",
        "beds": "lits",
        "bed": "lit",
        "general_terms": "Conditions g√©n√©rales",
        "cancellation_policy": "Politique d'annulation",
        "no_terms": "Aucune condition g√©n√©rale fournie.",
        "no_rules": "Aucun r√®glement int√©rieur fourni.",
        "no_cancellation": "Aucune politique d'annulation fournie."
      },
      "properties_portfolio": {
        "page_title": "Nos Propri√©t√©s",
        "page_subtitle": "D√©couvrez notre collection de locations de vacances",
        "view_apartments": "Voir les Appartements",
        "view_rooms": "Voir les Chambres",
        "view_property": "Voir la Propri√©t√©",
        "rooms_available": "chambres disponibles",
        "room_available": "chambre disponible",
        "from_price": "√Ä partir de",
        "per_night": "par nuit",
        "no_properties": "Aucune propri√©t√© disponible pour le moment.",
        "loading": "Chargement des propri√©t√©s...",
        "all_locations": "Tous les Emplacements",
        "filter_by_location": "Filtrer par emplacement",
        "bedrooms_range": "chambres",
        "max_guests": "voyageurs max",
        "properties_count": "propri√©t√©s",
        "property_count": "propri√©t√©"
      },
      "terms": {
        "check_in": "Arriv√©e",
        "check_out": "D√©part",
        "by": "Avant",
        "self_checkin": "Auto check-in disponible",
        "checkin_24hr": "Check-in 24h/24",
        "late_checkout_fee": "Frais de d√©part tardif",
        "children": "Enfants",
        "children_all_ages": "Enfants de tous √¢ges bienvenus",
        "no_children": "Enfants non accept√©s",
        "children_policy": "Politique enfants",
        "cots_available": "Lits b√©b√© disponibles",
        "highchairs_available": "Chaises hautes disponibles",
        "events": "√âv√©nements",
        "no_events": "Pas d'√©v√©nements ni de f√™tes",
        "events_on_request": "√âv√©nements sur demande",
        "events_allowed": "√âv√©nements autoris√©s",
        "smoking": "Tabac",
        "no_smoking": "Non-fumeur",
        "smoking_designated": "Fumeur dans les zones d√©sign√©es uniquement",
        "smoking_allowed": "Fumeur autoris√©",
        "fine": "Amende",
        "pets": "Animaux",
        "no_pets": "Animaux non accept√©s",
        "pets_on_request": "Animaux sur demande",
        "pets_allowed": "Animaux accept√©s",
        "dogs_welcome": "Chiens bienvenus",
        "cats_welcome": "Chats bienvenus",
        "deposit": "Caution",
        "fee": "Frais",
        "night": "nuit",
        "quiet_hours": "Heures de silence",
        "id_required": "Pi√®ce d'identit√© requise",
        "valid_id_required": "Pi√®ce d'identit√© valide requise √† l'arriv√©e",
        "guests": "Invit√©s",
        "no_unregistered": "Pas de visiteurs non enregistr√©s",
        "accessibility": "Accessibilit√©",
        "wheelchair": "Accessible en fauteuil roulant",
        "step_free": "Acc√®s sans marches",
        "accessible_bathroom": "Salle de bain accessible",
        "elevator": "Ascenseur",
        "ground_floor": "Rez-de-chauss√©e disponible"
      },
      "filters": {
        "sort_by": "Trier par",
        "default": "Par d√©faut",
        "price_low": "Prix croissant",
        "price_high": "Prix d√©croissant",
        "location": "Emplacement",
        "all_locations": "Tous les emplacements",
        "amenities": "√âquipements",
        "select_amenities": "S√©lectionner √©quipements",
        "clear_filters": "Effacer les filtres"
      },
      "calendar": {
        "today": "Aujourd'hui",
        "mon": "Lun", "tue": "Mar", "wed": "Mer", "thu": "Jeu", "fri": "Ven", "sat": "Sam", "sun": "Dim",
        "january": "Janvier", "february": "F√©vrier", "march": "Mars", "april": "Avril",
        "may": "Mai", "june": "Juin", "july": "Juillet", "august": "Ao√ªt",
        "september": "Septembre", "october": "Octobre", "november": "Novembre", "december": "D√©cembre"
      },
      "checkout": {
        "your_booking": "Votre r√©servation",
        "your_rooms": "Vos chambres",
        "guest_details": "Informations voyageur",
        "your_details": "Vos informations",
        "extras": "Suppl√©ments",
        "payment": "Paiement",
        "first_name": "Pr√©nom",
        "last_name": "Nom",
        "email_address": "Adresse e-mail",
        "confirm_email": "Confirmer l'e-mail",
        "phone_number": "Num√©ro de t√©l√©phone",
        "country": "Pays",
        "address": "Adresse",
        "city": "Ville",
        "postcode": "Code postal",
        "optional": "facultatif",
        "price_details": "D√©tails du prix",
        "total": "Total",
        "nights": "nuits",
        "standard_rate": "Tarif standard",
        "special_offer": "Offre sp√©ciale",
        "offer_discount": "R√©duction offre",
        "your_extras": "Vos suppl√©ments",
        "promo_code": "Code promo",
        "enter_promo": "Entrez le code promo",
        "taxes_fees": "Taxes et frais",
        "includes_taxes": "Toutes taxes et frais inclus",
        "cancellation_policy": "Politique d'annulation",
        "free_cancellation": "Annulation gratuite",
        "until_48h": "jusqu'√† 48 heures avant l'arriv√©e.",
        "non_refundable": "Non remboursable.",
        "cannot_cancel": "Ce tarif ne peut √™tre annul√© ou modifi√©.",
        "please_enter_details": "Veuillez entrer vos informations. Nous vous enverrons la confirmation de r√©servation par e-mail.",
        "enhance_stay": "Am√©liorez votre s√©jour",
        "add_extras_text": "Ajoutez des suppl√©ments pour rendre votre s√©jour encore plus sp√©cial.",
        "no_extras": "Aucun suppl√©ment disponible pour cette r√©servation.",
        "continue_payment": "Continuer vers le paiement",
        "continue_extras": "Continuer vers les suppl√©ments",
        "back_to_room": "Retour √† la chambre",
        "secure_booking": "R√©servation s√©curis√©e",
        "instant_confirmation": "Confirmation instantan√©e",
        "support_24_7": "Assistance 24h/24",
        "special_requests_placeholder": "Ex: arriv√©e tardive, r√©gime alimentaire, occasion sp√©ciale...",
        "special_requests_hint": "Les demandes sp√©ciales sont soumises √† disponibilit√© et ne peuvent √™tre garanties.",
        "marketing_opt_in": "M'envoyer des offres sp√©ciales et actualit√©s (d√©sabonnement possible √† tout moment)"
      }
    }
  },
  "es": {
    "lang": "es",
    "name": "Espa√±ol",
    "flag": "üá™üá∏",
    "strings": {
      "common": {
        "loading": "Cargando...",
        "error": "Error",
        "success": "√âxito",
        "save": "Guardar",
        "cancel": "Cancelar",
        "close": "Cerrar",
        "back": "Atr√°s",
        "next": "Siguiente",
        "submit": "Enviar",
        "confirm": "Confirmar",
        "search": "Buscar",
        "filter": "Filtrar",
        "sort": "Ordenar",
        "all": "Todos",
        "from": "Desde",
        "to": "Hasta",
        "per": "por",
        "total": "Total",
        "available": "Disponible",
        "unavailable": "No disponible",
        "under": "menores de",
        "more_info": "M√°s informaci√≥n",
        "apply": "Aplicar",
        "and": "y",
        "processing": "Procesando...",
        "coming_soon": "Pr√≥ximamente"
      },
      "booking": {
        "book_now": "Reservar",
        "view_book": "Ver y Reservar",
        "check_availability": "Comprobar disponibilidad",
        "check_in": "Llegada",
        "check_out": "Salida",
        "select_dates": "Seleccionar fechas",
        "select_dates_to_check": "Selecciona fechas para comprobar disponibilidad",
        "nights": "noches",
        "night": "noche",
        "guests": "Hu√©spedes",
        "guest": "hu√©sped",
        "adults": "Adultos",
        "adult": "Adulto",
        "children": "Ni√±os",
        "child": "Ni√±o",
        "price_per_night": "por noche",
        "price_from": "Desde",
        "total": "Total",
        "total_price": "Precio total",
        "cleaning_fee": "Tarifa de limpieza",
        "service_fee": "Tarifa de servicio",
        "taxes": "Impuestos",
        "discount": "Descuento",
        "offer_discount": "Descuento oferta",
        "promo_code": "C√≥digo promocional",
        "apply": "Aplicar",
        "min_stay": "Estancia m√≠nima",
        "max_guests": "Capacidad m√°xima",
        "not_available": "No disponible para las fechas seleccionadas",
        "continue_booking": "Continuar reserva",
        "complete_booking": "Completar tu reserva",
        "confirm_booking": "Confirmar reserva",
        "booking_confirmed": "¬°Reserva confirmada!",
        "booking_reference": "Referencia de reserva",
        "add_to_cart": "A√±adir al carrito",
        "go_to_cart": "Ir al carrito",
        "rooms_in_cart": "habitaci√≥n(es) en el carrito",
        "add_another_room": "A√±adir otra habitaci√≥n",
        "clear_cart": "Vaciar carrito",
        "special_offer": "Oferta especial",
        "special_rates_available": "¬°Tenemos tarifas especiales para tus fechas!",
        "see_rates_below": "Ver opciones de tarifas abajo ‚Üì",
        "guest_adjustment": "Ajuste de hu√©spedes",
        "first_name": "Nombre",
        "last_name": "Apellidos",
        "email": "Correo electr√≥nico",
        "phone": "Tel√©fono",
        "special_requests": "Peticiones especiales",
        "minimum": "M√≠nimo",
        "required": "requerido",
        "you_selected": "Has seleccionado",
        "choose_longer": "Por favor elige una estancia m√°s larga.",
        "guest": "hu√©sped"
      },
      "guest_details": {
        "guest_details": "Datos del hu√©sped",
        "first_name": "Nombre",
        "last_name": "Apellidos",
        "email": "Correo electr√≥nico",
        "phone": "Tel√©fono",
        "country": "Pa√≠s",
        "special_requests": "Peticiones especiales",
        "arrival_time": "Hora estimada de llegada",
        "terms_agree": "Acepto los",
        "terms_conditions": "T√©rminos y condiciones",
        "privacy_policy": "Pol√≠tica de privacidad"
      },
      "payment": {
        "payment": "Pago",
        "pay_now": "Pagar ahora",
        "pay_deposit": "Pagar dep√≥sito",
        "pay_at_property": "Pagar en el alojamiento",
        "pay_at_property_desc": "Paga cuando llegues - no se necesita pago ahora",
        "pay_by_card": "Pagar con tarjeta",
        "not_available_property": "No disponible para esta propiedad",
        "card_number": "N√∫mero de tarjeta",
        "card_details": "Datos de la tarjeta",
        "expiry_date": "Fecha de caducidad",
        "cvv": "CVV",
        "cardholder_name": "Nombre del titular",
        "payment_secure": "Tu pago est√° protegido por Stripe",
        "payment_processing": "Procesando pago...",
        "deposit_amount": "Importe del dep√≥sito",
        "balance_due": "Saldo pendiente a la llegada",
        "deposit_info": "Se cobrar√° un dep√≥sito ahora. El saldo restante se paga a la llegada."
      },
      "property": {
        "property": "Propiedad",
        "properties": "Propiedades",
        "description": "Descripci√≥n",
        "availability": "Disponibilidad",
        "amenities": "Servicios",
        "features": "Caracter√≠sticas",
        "location": "Ubicaci√≥n",
        "reviews": "Opiniones",
        "terms": "Condiciones",
        "house_rules": "Normas de la casa",
        "guests_label": "Hu√©spedes",
        "bedrooms": "dormitorios",
        "bedroom": "dormitorio",
        "bathrooms": "ba√±os",
        "bathroom": "ba√±o",
        "beds": "camas",
        "bed": "cama",
        "general_terms": "Condiciones generales",
        "cancellation_policy": "Pol√≠tica de cancelaci√≥n",
        "no_terms": "No hay condiciones generales disponibles.",
        "no_rules": "No hay normas de la casa disponibles.",
        "no_cancellation": "No hay pol√≠tica de cancelaci√≥n disponible."
      },
      "properties_portfolio": {
        "page_title": "Nuestras Propiedades",
        "page_subtitle": "Explore nuestra colecci√≥n de alquileres vacacionales",
        "view_apartments": "Ver Apartamentos",
        "view_rooms": "Ver Habitaciones",
        "view_property": "Ver Propiedad",
        "rooms_available": "habitaciones disponibles",
        "room_available": "habitaci√≥n disponible",
        "from_price": "Desde",
        "per_night": "por noche",
        "no_properties": "No hay propiedades disponibles en este momento.",
        "loading": "Cargando propiedades...",
        "all_locations": "Todas las Ubicaciones",
        "filter_by_location": "Filtrar por ubicaci√≥n",
        "bedrooms_range": "dormitorios",
        "max_guests": "hu√©spedes m√°x",
        "properties_count": "propiedades",
        "property_count": "propiedad"
      },
      "terms": {
        "check_in": "Llegada",
        "check_out": "Salida",
        "by": "Antes de las",
        "self_checkin": "Auto check-in disponible",
        "checkin_24hr": "Check-in 24 horas",
        "late_checkout_fee": "Cargo por salida tard√≠a",
        "children": "Ni√±os",
        "children_all_ages": "Ni√±os de todas las edades bienvenidos",
        "no_children": "No se admiten ni√±os",
        "children_policy": "Pol√≠tica de ni√±os",
        "cots_available": "Cunas disponibles",
        "highchairs_available": "Tronas disponibles",
        "events": "Eventos",
        "no_events": "No se permiten eventos ni fiestas",
        "events_on_request": "Eventos bajo petici√≥n",
        "events_allowed": "Eventos permitidos",
        "smoking": "Fumar",
        "no_smoking": "Prohibido fumar",
        "smoking_designated": "Fumar solo en √°reas designadas",
        "smoking_allowed": "Se permite fumar",
        "fine": "Multa",
        "pets": "Mascotas",
        "no_pets": "No se admiten mascotas",
        "pets_on_request": "Mascotas bajo petici√≥n",
        "pets_allowed": "Se admiten mascotas",
        "dogs_welcome": "Perros bienvenidos",
        "cats_welcome": "Gatos bienvenidos",
        "deposit": "Dep√≥sito",
        "fee": "Cargo",
        "night": "noche",
        "quiet_hours": "Horas de silencio",
        "id_required": "Identificaci√≥n requerida",
        "valid_id_required": "Identificaci√≥n v√°lida requerida al llegar",
        "guests": "Invitados",
        "no_unregistered": "No se permiten visitantes no registrados",
        "accessibility": "Accesibilidad",
        "wheelchair": "Accesible en silla de ruedas",
        "step_free": "Acceso sin escalones",
        "accessible_bathroom": "Ba√±o accesible",
        "elevator": "Ascensor",
        "ground_floor": "Planta baja disponible"
      },
      "filters": {
        "sort_by": "Ordenar por",
        "default": "Por defecto",
        "price_low": "Precio: menor a mayor",
        "price_high": "Precio: mayor a menor",
        "location": "Ubicaci√≥n",
        "all_locations": "Todas las ubicaciones",
        "amenities": "Servicios",
        "select_amenities": "Seleccionar servicios",
        "clear_filters": "Borrar filtros"
      },
      "calendar": {
        "today": "Hoy",
        "mon": "Lun", "tue": "Mar", "wed": "Mi√©", "thu": "Jue", "fri": "Vie", "sat": "S√°b", "sun": "Dom",
        "january": "Enero", "february": "Febrero", "march": "Marzo", "april": "Abril",
        "may": "Mayo", "june": "Junio", "july": "Julio", "august": "Agosto",
        "september": "Septiembre", "october": "Octubre", "november": "Noviembre", "december": "Diciembre"
      },
      "checkout": {
        "your_booking": "Tu reserva",
        "your_rooms": "Tus habitaciones",
        "guest_details": "Datos del hu√©sped",
        "your_details": "Tus datos",
        "extras": "Extras",
        "payment": "Pago",
        "first_name": "Nombre",
        "last_name": "Apellidos",
        "email_address": "Correo electr√≥nico",
        "confirm_email": "Confirmar correo",
        "phone_number": "Tel√©fono",
        "country": "Pa√≠s",
        "address": "Direcci√≥n",
        "city": "Ciudad",
        "postcode": "C√≥digo postal",
        "optional": "opcional",
        "price_details": "Detalles del precio",
        "total": "Total",
        "nights": "noches",
        "standard_rate": "Tarifa est√°ndar",
        "special_offer": "Oferta especial",
        "offer_discount": "Descuento oferta",
        "your_extras": "Tus extras",
        "promo_code": "C√≥digo promocional",
        "enter_promo": "Introduce el c√≥digo promocional",
        "taxes_fees": "Impuestos y tasas",
        "includes_taxes": "Incluye todos los impuestos y tasas",
        "cancellation_policy": "Pol√≠tica de cancelaci√≥n",
        "free_cancellation": "Cancelaci√≥n gratuita",
        "until_48h": "hasta 48 horas antes de la llegada.",
        "non_refundable": "No reembolsable.",
        "cannot_cancel": "Esta tarifa no puede cancelarse ni modificarse.",
        "please_enter_details": "Introduce tus datos. Te enviaremos la confirmaci√≥n de la reserva por correo electr√≥nico.",
        "enhance_stay": "Mejora tu estancia",
        "add_extras_text": "A√±ade extras para hacer tu estancia a√∫n m√°s especial.",
        "no_extras": "No hay extras disponibles para esta reserva.",
        "continue_payment": "Continuar al pago",
        "continue_extras": "Continuar a extras",
        "back_to_room": "Volver a la habitaci√≥n",
        "secure_booking": "Reserva segura",
        "instant_confirmation": "Confirmaci√≥n instant√°nea",
        "support_24_7": "Soporte 24/7",
        "special_requests_placeholder": "Ej: llegada tard√≠a, requisitos diet√©ticos, ocasi√≥n especial...",
        "special_requests_hint": "Las peticiones especiales est√°n sujetas a disponibilidad y no pueden garantizarse.",
        "marketing_opt_in": "Enviadme ofertas especiales y novedades (puedes cancelar en cualquier momento)"
      }
    }
  },
  "nl": {
    "lang": "nl",
    "name": "Nederlands",
    "flag": "üá≥üá±",
    "strings": {
      "common": {
        "loading": "Laden...",
        "error": "Fout",
        "success": "Gelukt",
        "save": "Opslaan",
        "cancel": "Annuleren",
        "close": "Sluiten",
        "back": "Terug",
        "next": "Volgende",
        "submit": "Verzenden",
        "confirm": "Bevestigen",
        "search": "Zoeken",
        "filter": "Filteren",
        "sort": "Sorteren",
        "all": "Alle",
        "from": "Van",
        "to": "Tot",
        "per": "per",
        "total": "Totaal",
        "available": "Beschikbaar",
        "unavailable": "Niet beschikbaar",
        "under": "onder",
        "more_info": "Meer informatie",
        "apply": "Toepassen",
        "and": "en",
        "processing": "Bezig...",
        "coming_soon": "Binnenkort beschikbaar"
      },
      "booking": {
        "book_now": "Boek nu",
        "view_book": "Bekijk & Boek",
        "check_availability": "Beschikbaarheid controleren",
        "check_in": "Inchecken",
        "check_out": "Uitchecken",
        "select_dates": "Selecteer datum",
        "select_dates_to_check": "Selecteer data om beschikbaarheid te controleren",
        "where_going": "Waar gaat u naartoe?",
        "location": "Locatie",
        "nights": "nachten",
        "night": "nacht",
        "guests": "Gasten",
        "guest": "Gast",
        "adults": "Volwassenen",
        "adult": "Volwassene",
        "children": "Kinderen",
        "child": "Kind",
        "price_per_night": "per nacht",
        "price_from": "Vanaf",
        "total": "Totaal",
        "total_price": "Totaalprijs",
        "cleaning_fee": "Schoonmaakkosten",
        "service_fee": "Servicekosten",
        "taxes": "Belastingen",
        "discount": "Korting",
        "offer_discount": "Aanbiedingskorting",
        "promo_code": "Promotiecode",
        "apply": "Toepassen",
        "min_stay": "Minimale verblijfsduur",
        "max_guests": "Maximaal aantal gasten",
        "not_available": "Niet beschikbaar voor geselecteerde data",
        "continue_booking": "Doorgaan met boeken",
        "complete_booking": "Voltooi uw boeking",
        "confirm_booking": "Boeking bevestigen",
        "booking_confirmed": "Boeking bevestigd!",
        "booking_reference": "Boekingsreferentie",
        "add_to_cart": "In winkelwagen",
        "go_to_cart": "Naar winkelwagen",
        "rooms_in_cart": "kamer(s) in winkelwagen",
        "add_another_room": "Nog een kamer toevoegen",
        "clear_cart": "Winkelwagen leegmaken",
        "special_offer": "Speciale aanbieding",
        "special_rates_available": "We hebben speciale tarieven beschikbaar voor uw data!",
        "see_rates_below": "Zie tariefopties hieronder ‚Üì",
        "guest_adjustment": "Gastenaanpassing",
        "first_name": "Voornaam",
        "last_name": "Achternaam",
        "email": "E-mail",
        "phone": "Telefoon",
        "special_requests": "Speciale verzoeken",
        "minimum": "Minimaal",
        "required": "vereist",
        "you_selected": "U heeft geselecteerd",
        "choose_longer": "Kies alstublieft een langer verblijf.",
        "guest": "gast"
      },
      "guest_details": {
        "guest_details": "Gastgegevens",
        "first_name": "Voornaam",
        "last_name": "Achternaam",
        "email": "E-mail",
        "phone": "Telefoon",
        "country": "Land",
        "special_requests": "Speciale verzoeken",
        "arrival_time": "Geschatte aankomsttijd",
        "terms_agree": "Ik ga akkoord met de",
        "terms_conditions": "Algemene voorwaarden",
        "privacy_policy": "Privacybeleid"
      },
      "payment": {
        "payment": "Betaling",
        "pay_now": "Nu betalen",
        "pay_deposit": "Aanbetaling doen",
        "pay_at_property": "Betalen bij accommodatie",
        "pay_at_property_desc": "Betaal bij aankomst - nu geen betaling nodig",
        "pay_by_card": "Betalen met kaart",
        "not_available_property": "Niet beschikbaar voor deze accommodatie",
        "card_number": "Kaartnummer",
        "card_details": "Kaartgegevens",
        "expiry_date": "Vervaldatum",
        "cvv": "CVV",
        "cardholder_name": "Naam kaarthouder",
        "payment_secure": "Uw betaling is beveiligd door Stripe",
        "payment_processing": "Betaling wordt verwerkt...",
        "deposit_amount": "Aanbetaling",
        "balance_due": "Restbedrag bij inchecken",
        "deposit_info": "Nu wordt een aanbetaling afgeschreven. Het resterende bedrag is bij inchecken verschuldigd."
      },
      "property": {
        "property": "Accommodatie",
        "properties": "Accommodaties",
        "description": "Beschrijving",
        "availability": "Beschikbaarheid",
        "amenities": "Voorzieningen",
        "features": "Kenmerken",
        "location": "Locatie",
        "reviews": "Beoordelingen",
        "terms": "Voorwaarden",
        "house_rules": "Huisregels",
        "guests_label": "Gasten",
        "bedrooms": "slaapkamers",
        "bedroom": "slaapkamer",
        "bathrooms": "badkamers",
        "bathroom": "badkamer",
        "beds": "bedden",
        "bed": "bed",
        "general_terms": "Algemene voorwaarden",
        "cancellation_policy": "Annuleringsbeleid",
        "no_terms": "Geen algemene voorwaarden beschikbaar.",
        "no_rules": "Geen huisregels beschikbaar.",
        "no_cancellation": "Geen annuleringsbeleid beschikbaar."
      },
      "properties_portfolio": {
        "page_title": "Onze Accommodaties",
        "page_subtitle": "Ontdek onze collectie vakantiewoningen",
        "view_apartments": "Bekijk Appartementen",
        "view_rooms": "Bekijk Kamers",
        "view_property": "Bekijk Accommodatie",
        "rooms_available": "kamers beschikbaar",
        "room_available": "kamer beschikbaar",
        "from_price": "Vanaf",
        "per_night": "per nacht",
        "no_properties": "Er zijn momenteel geen accommodaties beschikbaar.",
        "loading": "Accommodaties laden...",
        "all_locations": "Alle Locaties",
        "filter_by_location": "Filteren op locatie",
        "bedrooms_range": "slaapkamers",
        "max_guests": "max gasten",
        "properties_count": "accommodaties",
        "property_count": "accommodatie"
      },
      "terms": {
        "check_in": "Inchecken",
        "check_out": "Uitchecken",
        "by": "V√≥√≥r",
        "self_checkin": "Zelf inchecken mogelijk",
        "checkin_24hr": "24-uurs inchecken",
        "late_checkout_fee": "Toeslag laat uitchecken",
        "children": "Kinderen",
        "children_all_ages": "Kinderen van alle leeftijden welkom",
        "no_children": "Geen kinderen toegestaan",
        "children_policy": "Kinderbeleid",
        "cots_available": "Kinderbedjes beschikbaar",
        "highchairs_available": "Kinderstoelen beschikbaar",
        "events": "Evenementen",
        "no_events": "Geen evenementen of feesten",
        "events_on_request": "Evenementen op aanvraag",
        "events_allowed": "Evenementen toegestaan",
        "smoking": "Roken",
        "no_smoking": "Niet roken",
        "smoking_designated": "Roken alleen op aangewezen plaatsen",
        "smoking_allowed": "Roken toegestaan",
        "fine": "Boete",
        "pets": "Huisdieren",
        "no_pets": "Geen huisdieren toegestaan",
        "pets_on_request": "Huisdieren op aanvraag",
        "pets_allowed": "Huisdieren toegestaan",
        "dogs_welcome": "Honden welkom",
        "cats_welcome": "Katten welkom",
        "deposit": "Borg",
        "fee": "Toeslag",
        "night": "nacht",
        "quiet_hours": "Stiltetijd",
        "id_required": "ID vereist",
        "valid_id_required": "Geldig ID vereist bij inchecken",
        "guests": "Gasten",
        "no_unregistered": "Geen ongeregistreerde bezoekers toegestaan",
        "accessibility": "Toegankelijkheid",
        "wheelchair": "Rolstoeltoegankelijk",
        "step_free": "Drempelloos",
        "accessible_bathroom": "Aangepaste badkamer",
        "elevator": "Lift aanwezig",
        "ground_floor": "Begane grond beschikbaar"
      },
      "filters": {
        "sort_by": "Sorteren op",
        "default": "Standaard",
        "price_low": "Prijs: laag naar hoog",
        "price_high": "Prijs: hoog naar laag",
        "location": "Locatie",
        "all_locations": "Alle locaties",
        "amenities": "Voorzieningen",
        "select_amenities": "Selecteer voorzieningen",
        "clear_filters": "Filters wissen"
      },
      "calendar": {
        "today": "Vandaag",
        "mon": "Ma", "tue": "Di", "wed": "Wo", "thu": "Do", "fri": "Vr", "sat": "Za", "sun": "Zo",
        "january": "Januari", "february": "Februari", "march": "Maart", "april": "April",
        "may": "Mei", "june": "Juni", "july": "Juli", "august": "Augustus",
        "september": "September", "october": "Oktober", "november": "November", "december": "December"
      },
      "checkout": {
        "your_booking": "Uw boeking",
        "your_rooms": "Uw kamers",
        "guest_details": "Gastgegevens",
        "your_details": "Uw gegevens",
        "extras": "Extra's",
        "payment": "Betaling",
        "first_name": "Voornaam",
        "last_name": "Achternaam",
        "email_address": "E-mailadres",
        "confirm_email": "E-mail bevestigen",
        "phone_number": "Telefoonnummer",
        "country": "Land",
        "address": "Adres",
        "city": "Stad",
        "postcode": "Postcode",
        "optional": "optioneel",
        "price_details": "Prijsdetails",
        "total": "Totaal",
        "nights": "nachten",
        "standard_rate": "Standaardtarief",
        "special_offer": "Speciale aanbieding",
        "offer_discount": "Aanbiedingskorting",
        "your_extras": "Uw extra's",
        "promo_code": "Promotiecode",
        "enter_promo": "Voer promotiecode in",
        "taxes_fees": "Belastingen & kosten",
        "includes_taxes": "Inclusief alle belastingen en kosten",
        "cancellation_policy": "Annuleringsbeleid",
        "free_cancellation": "Gratis annuleren",
        "until_48h": "tot 48 uur voor inchecken.",
        "non_refundable": "Niet-restitueerbaar.",
        "cannot_cancel": "Dit tarief kan niet worden geannuleerd of gewijzigd.",
        "please_enter_details": "Vul uw gegevens in. We sturen de boekingsbevestiging naar uw e-mailadres.",
        "enhance_stay": "Verbeter uw verblijf",
        "add_extras_text": "Voeg extra's toe om uw verblijf nog specialer te maken.",
        "no_extras": "Geen extra's beschikbaar voor deze boeking.",
        "continue_payment": "Doorgaan naar betaling",
        "continue_extras": "Doorgaan naar extra's",
        "back_to_room": "Terug naar kamer",
        "secure_booking": "Veilig boeken",
        "instant_confirmation": "Directe bevestiging",
        "support_24_7": "24/7 ondersteuning",
        "special_requests_placeholder": "Bijv. late aankomst, dieetwensen, speciale gelegenheid...",
        "special_requests_hint": "Speciale verzoeken zijn afhankelijk van beschikbaarheid en kunnen niet worden gegarandeerd.",
        "marketing_opt_in": "Stuur mij speciale aanbiedingen en updates (u kunt zich op elk moment afmelden)"
      }
    }
  },
  "de": {
    "lang": "de",
    "name": "Deutsch",
    "flag": "üá©üá™",
    "strings": {
      "common": {
        "loading": "Laden...",
        "error": "Fehler",
        "success": "Erfolg",
        "save": "Speichern",
        "cancel": "Abbrechen",
        "close": "Schlie√üen",
        "back": "Zur√ºck",
        "next": "Weiter",
        "submit": "Absenden",
        "confirm": "Best√§tigen",
        "search": "Suchen",
        "filter": "Filtern",
        "sort": "Sortieren",
        "all": "Alle",
        "from": "Von",
        "to": "Bis",
        "per": "pro",
        "total": "Gesamt",
        "available": "Verf√ºgbar",
        "unavailable": "Nicht verf√ºgbar",
        "under": "unter",
        "more_info": "Mehr Informationen",
        "apply": "Anwenden",
        "and": "und",
        "processing": "Wird verarbeitet...",
        "coming_soon": "Demn√§chst verf√ºgbar"
      },
      "booking": {
        "book_now": "Jetzt buchen",
        "view_book": "Ansehen & Buchen",
        "check_availability": "Verf√ºgbarkeit pr√ºfen",
        "check_in": "Anreise",
        "check_out": "Abreise",
        "select_dates": "Daten ausw√§hlen",
        "select_dates_to_check": "W√§hlen Sie Daten um die Verf√ºgbarkeit zu pr√ºfen",
        "nights": "N√§chte",
        "night": "Nacht",
        "guests": "G√§ste",
        "guest": "Gast",
        "adults": "Erwachsene",
        "adult": "Erwachsener",
        "children": "Kinder",
        "child": "Kind",
        "price_per_night": "pro Nacht",
        "price_from": "Ab",
        "total": "Gesamt",
        "total_price": "Gesamtpreis",
        "cleaning_fee": "Reinigungsgeb√ºhr",
        "service_fee": "Servicegeb√ºhr",
        "taxes": "Steuern",
        "discount": "Rabatt",
        "offer_discount": "Angebotsrabatt",
        "promo_code": "Aktionscode",
        "apply": "Anwenden",
        "min_stay": "Mindestaufenthalt",
        "max_guests": "Maximale G√§steanzahl",
        "not_available": "F√ºr ausgew√§hlte Daten nicht verf√ºgbar",
        "continue_booking": "Buchung fortsetzen",
        "complete_booking": "Buchung abschlie√üen",
        "confirm_booking": "Buchung best√§tigen",
        "booking_confirmed": "Buchung best√§tigt!",
        "booking_reference": "Buchungsreferenz",
        "add_to_cart": "In den Warenkorb",
        "go_to_cart": "Zum Warenkorb",
        "rooms_in_cart": "Zimmer im Warenkorb",
        "add_another_room": "Weiteres Zimmer hinzuf√ºgen",
        "clear_cart": "Warenkorb leeren",
        "special_offer": "Sonderangebot",
        "special_rates_available": "Wir haben Sonderpreise f√ºr Ihre Daten!",
        "see_rates_below": "Siehe Preisoptionen unten ‚Üì",
        "guest_adjustment": "G√§steanpassung",
        "first_name": "Vorname",
        "last_name": "Nachname",
        "email": "E-Mail",
        "phone": "Telefon",
        "special_requests": "Besondere W√ºnsche",
        "minimum": "Mindestens",
        "required": "erforderlich",
        "you_selected": "Sie haben gew√§hlt",
        "choose_longer": "Bitte w√§hlen Sie einen l√§ngeren Aufenthalt.",
        "guest": "Gast"
      },
      "guest_details": {
        "guest_details": "G√§stedaten",
        "first_name": "Vorname",
        "last_name": "Nachname",
        "email": "E-Mail",
        "phone": "Telefon",
        "country": "Land",
        "special_requests": "Besondere W√ºnsche",
        "arrival_time": "Gesch√§tzte Ankunftszeit",
        "terms_agree": "Ich akzeptiere die",
        "terms_conditions": "Allgemeinen Gesch√§ftsbedingungen",
        "privacy_policy": "Datenschutzrichtlinie"
      },
      "payment": {
        "payment": "Zahlung",
        "pay_now": "Jetzt bezahlen",
        "pay_deposit": "Anzahlung leisten",
        "pay_at_property": "Vor Ort bezahlen",
        "pay_at_property_desc": "Bezahlen Sie bei Ankunft - jetzt keine Zahlung erforderlich",
        "pay_by_card": "Mit Karte bezahlen",
        "not_available_property": "Nicht verf√ºgbar f√ºr diese Unterkunft",
        "card_number": "Kartennummer",
        "card_details": "Kartendetails",
        "expiry_date": "Ablaufdatum",
        "cvv": "CVV",
        "cardholder_name": "Name des Karteninhabers",
        "payment_secure": "Ihre Zahlung ist durch Stripe gesichert",
        "payment_processing": "Zahlung wird verarbeitet...",
        "deposit_amount": "Anzahlungsbetrag",
        "balance_due": "Restbetrag bei Anreise f√§llig",
        "deposit_info": "Jetzt wird eine Anzahlung berechnet. Der Restbetrag ist bei Anreise f√§llig."
      },
      "property": {
        "property": "Unterkunft",
        "properties": "Unterk√ºnfte",
        "description": "Beschreibung",
        "availability": "Verf√ºgbarkeit",
        "amenities": "Ausstattung",
        "features": "Merkmale",
        "location": "Lage",
        "reviews": "Bewertungen",
        "terms": "Bedingungen",
        "house_rules": "Hausordnung",
        "guests_label": "G√§ste",
        "bedrooms": "Schlafzimmer",
        "bedroom": "Schlafzimmer",
        "bathrooms": "Badezimmer",
        "bathroom": "Badezimmer",
        "beds": "Betten",
        "bed": "Bett",
        "general_terms": "Allgemeine Bedingungen",
        "cancellation_policy": "Stornierungsbedingungen",
        "no_terms": "Keine allgemeinen Bedingungen vorhanden.",
        "no_rules": "Keine Hausordnung vorhanden.",
        "no_cancellation": "Keine Stornierungsbedingungen vorhanden."
      },
      "properties_portfolio": {
        "page_title": "Unsere Unterk√ºnfte",
        "page_subtitle": "Entdecken Sie unsere Auswahl an Ferienunterk√ºnften",
        "view_apartments": "Apartments ansehen",
        "view_rooms": "Zimmer ansehen",
        "view_property": "Unterkunft ansehen",
        "rooms_available": "Zimmer verf√ºgbar",
        "room_available": "Zimmer verf√ºgbar",
        "from_price": "Ab",
        "per_night": "pro Nacht",
        "no_properties": "Derzeit sind keine Unterk√ºnfte verf√ºgbar.",
        "loading": "Unterk√ºnfte werden geladen...",
        "all_locations": "Alle Standorte",
        "filter_by_location": "Nach Standort filtern",
        "bedrooms_range": "Schlafzimmer",
        "max_guests": "max G√§ste",
        "properties_count": "Unterk√ºnfte",
        "property_count": "Unterkunft"
      },
      "terms": {
        "check_in": "Anreise",
        "check_out": "Abreise",
        "by": "Bis",
        "self_checkin": "Selbst-Check-in verf√ºgbar",
        "checkin_24hr": "24-Stunden-Check-in",
        "late_checkout_fee": "Geb√ºhr f√ºr sp√§tes Auschecken",
        "children": "Kinder",
        "children_all_ages": "Kinder jeden Alters willkommen",
        "no_children": "Keine Kinder erlaubt",
        "children_policy": "Kinderrichtlinie",
        "cots_available": "Kinderbetten verf√ºgbar",
        "highchairs_available": "Hochst√ºhle verf√ºgbar",
        "events": "Veranstaltungen",
        "no_events": "Keine Veranstaltungen oder Partys",
        "events_on_request": "Veranstaltungen auf Anfrage",
        "events_allowed": "Veranstaltungen erlaubt",
        "smoking": "Rauchen",
        "no_smoking": "Nichtraucher",
        "smoking_designated": "Rauchen nur in ausgewiesenen Bereichen",
        "smoking_allowed": "Rauchen erlaubt",
        "fine": "Strafe",
        "pets": "Haustiere",
        "no_pets": "Keine Haustiere erlaubt",
        "pets_on_request": "Haustiere auf Anfrage",
        "pets_allowed": "Haustiere erlaubt",
        "dogs_welcome": "Hunde willkommen",
        "cats_welcome": "Katzen willkommen",
        "deposit": "Kaution",
        "fee": "Geb√ºhr",
        "night": "Nacht",
        "quiet_hours": "Ruhezeiten",
        "id_required": "Ausweis erforderlich",
        "valid_id_required": "G√ºltiger Ausweis bei Anreise erforderlich",
        "guests": "Besucher",
        "no_unregistered": "Keine unangemeldeten Besucher erlaubt",
        "accessibility": "Barrierefreiheit",
        "wheelchair": "Rollstuhlgerecht",
        "step_free": "Stufenloser Zugang",
        "accessible_bathroom": "Barrierefreies Badezimmer",
        "elevator": "Aufzug vorhanden",
        "ground_floor": "Erdgeschoss verf√ºgbar"
      },
      "filters": {
        "sort_by": "Sortieren nach",
        "default": "Standard",
        "price_low": "Preis: aufsteigend",
        "price_high": "Preis: absteigend",
        "location": "Lage",
        "all_locations": "Alle Standorte",
        "amenities": "Ausstattung",
        "select_amenities": "Ausstattung ausw√§hlen",
        "clear_filters": "Filter l√∂schen"
      },
      "calendar": {
        "today": "Heute",
        "mon": "Mo", "tue": "Di", "wed": "Mi", "thu": "Do", "fri": "Fr", "sat": "Sa", "sun": "So",
        "january": "Januar", "february": "Februar", "march": "M√§rz", "april": "April",
        "may": "Mai", "june": "Juni", "july": "Juli", "august": "August",
        "september": "September", "october": "Oktober", "november": "November", "december": "Dezember"
      },
      "checkout": {
        "your_booking": "Ihre Buchung",
        "your_rooms": "Ihre Zimmer",
        "guest_details": "G√§stedaten",
        "your_details": "Ihre Daten",
        "extras": "Extras",
        "payment": "Zahlung",
        "first_name": "Vorname",
        "last_name": "Nachname",
        "email_address": "E-Mail-Adresse",
        "confirm_email": "E-Mail best√§tigen",
        "phone_number": "Telefonnummer",
        "country": "Land",
        "address": "Adresse",
        "city": "Stadt",
        "postcode": "Postleitzahl",
        "optional": "optional",
        "price_details": "Preisdetails",
        "total": "Gesamt",
        "nights": "N√§chte",
        "standard_rate": "Standardpreis",
        "special_offer": "Sonderangebot",
        "offer_discount": "Angebotsrabatt",
        "your_extras": "Ihre Extras",
        "promo_code": "Aktionscode",
        "enter_promo": "Aktionscode eingeben",
        "taxes_fees": "Steuern und Geb√ºhren",
        "includes_taxes": "Inklusive aller Steuern und Geb√ºhren",
        "cancellation_policy": "Stornierungsbedingungen",
        "free_cancellation": "Kostenlose Stornierung",
        "until_48h": "bis 48 Stunden vor Anreise.",
        "non_refundable": "Nicht erstattungsf√§hig.",
        "cannot_cancel": "Dieser Tarif kann nicht storniert oder ge√§ndert werden.",
        "please_enter_details": "Bitte geben Sie Ihre Daten ein. Wir senden Ihnen die Buchungsbest√§tigung per E-Mail.",
        "enhance_stay": "Verbessern Sie Ihren Aufenthalt",
        "add_extras_text": "F√ºgen Sie Extras hinzu, um Ihren Aufenthalt noch besonderer zu machen.",
        "no_extras": "Keine Extras f√ºr diese Buchung verf√ºgbar.",
        "continue_payment": "Weiter zur Zahlung",
        "continue_extras": "Weiter zu Extras",
        "back_to_room": "Zur√ºck zum Zimmer",
        "secure_booking": "Sichere Buchung",
        "instant_confirmation": "Sofortige Best√§tigung",
        "support_24_7": "24/7 Support",
        "special_requests_placeholder": "Z.B. sp√§te Anreise, Ern√§hrungsbed√ºrfnisse, besonderer Anlass...",
        "special_requests_hint": "Besondere W√ºnsche sind von der Verf√ºgbarkeit abh√§ngig und k√∂nnen nicht garantiert werden.",
        "marketing_opt_in": "Senden Sie mir Sonderangebote und Updates (Sie k√∂nnen sich jederzeit abmelden)"
      }
    }
  }
};

// Helper function to deep merge objects, filling missing keys from source
function fillMissingTranslations(target, source) {
  const result = JSON.parse(JSON.stringify(target)); // Deep clone
  
  for (const category in source) {
    if (!result[category]) {
      result[category] = {};
    }
    for (const key in source[category]) {
      if (result[category][key] === undefined) {
        // Mark missing translations with English value (prefixed for debugging if needed)
        result[category][key] = source[category][key];
      }
    }
  }
  return result;
}

// Get UI translations for a specific language
app.get('/api/public/translations/:lang', (req, res) => {
  const { lang } = req.params;
  const englishStrings = GAS_TRANSLATIONS['en']?.strings || {};
  
  if (GAS_TRANSLATIONS[lang]) {
    // Fill any missing keys from English
    const filledStrings = fillMissingTranslations(
      GAS_TRANSLATIONS[lang].strings || {},
      englishStrings
    );
    res.json({ 
      success: true, 
      translations: {
        ...GAS_TRANSLATIONS[lang],
        strings: filledStrings
      }
    });
  } else {
    // Return English as fallback
    res.json({ success: true, translations: GAS_TRANSLATIONS['en'] });
  }
});

// Get all available translations
app.get('/api/public/translations', (req, res) => {
  const available = Object.keys(GAS_TRANSLATIONS).map(lang => ({
    code: lang,
    name: GAS_TRANSLATIONS[lang].name,
    flag: GAS_TRANSLATIONS[lang].flag
  }));
  res.json({ success: true, available, translations: GAS_TRANSLATIONS });
});

// =========================================================
// PUBLIC CLIENT API ENDPOINTS
// =========================================================

// Get all rooms for a client (public - for WordPress plugin)
app.get('/api/public/client/:clientId/rooms', async (req, res) => {
  try {
    const { clientId } = req.params;
    const { property_id, room_ids, limit, offset, random } = req.query;
    
    // Pagination defaults
    const pageLimit = limit ? parseInt(limit) : null;  // null = no limit (all rooms)
    const pageOffset = offset ? parseInt(offset) : 0;
    
    // Get today's date for rate calendar lookup
    const today = new Date().toISOString().split('T')[0];
    
    // First get total count
    let countQuery = `
      SELECT COUNT(*) as total
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1
    `;
    const countParams = [clientId];
    let countParamIndex = 2;
    
    if (property_id) {
      countQuery += ` AND p.id = $${countParamIndex}`;
      countParams.push(property_id);
      countParamIndex++;
    }
    
    if (room_ids) {
      const ids = room_ids.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
      if (ids.length > 0) {
        countQuery += ` AND bu.id = ANY($${countParamIndex}::int[])`;
        countParams.push(ids);
      }
    }
    
    const countResult = await pool.query(countQuery, countParams);
    const totalCount = parseInt(countResult.rows[0]?.total || 0);
    
    let query = `
      SELECT 
        bu.id,
        bu.name,
        bu.display_name,
        bu.description,
        bu.base_price,
        bu.max_guests,
        bu.max_adults,
        bu.num_bedrooms,
        bu.num_bathrooms,
        bu.beds24_room_id,
        p.latitude,
        p.longitude,
        p.id as property_id,
        p.name as property_name,
        p.city,
        p.currency,
        (SELECT image_url FROM room_images WHERE room_id = bu.id AND is_active = true ORDER BY is_primary DESC, display_order ASC LIMIT 1) as image_url,
        (SELECT COALESCE(standard_price, cm_price) FROM room_availability WHERE room_id = bu.id AND date = $2 LIMIT 1) as todays_rate,
        (SELECT pc.payment_account_id FROM payment_configurations pc WHERE pc.property_id = p.id AND pc.provider = 'stripe' AND pc.is_enabled = true LIMIT 1) as payment_account_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1
    `;
    
    const params = [clientId, today];
    let paramIndex = 3;
    
    // Filter by property
    if (property_id) {
      query += ` AND p.id = $${paramIndex}`;
      params.push(property_id);
      paramIndex++;
    }
    
    // Filter by specific room IDs
    if (room_ids) {
      const ids = room_ids.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
      if (ids.length > 0) {
        query += ` AND bu.id = ANY($${paramIndex}::int[])`;
        params.push(ids);
        paramIndex++;
      }
    }
    
    // Order
    if (random === 'true') {
      query += ' ORDER BY RANDOM()';
    } else {
      query += ' ORDER BY bu.name';
    }
    
    // Pagination
    if (pageLimit) {
      query += ` LIMIT $${paramIndex}`;
      params.push(pageLimit);
      paramIndex++;
      
      if (pageOffset > 0) {
        query += ` OFFSET $${paramIndex}`;
        params.push(pageOffset);
        paramIndex++;
      }
    }
    
    const result = await pool.query(query, params);
    
    // Get room IDs for amenities lookup
    const roomIds = result.rows.map(r => r.id);
    
    // Fetch amenities for all rooms in one query
    let amenitiesByRoom = {};
    if (roomIds.length > 0) {
      const amenitiesResult = await pool.query(`
        SELECT 
          bua.bookable_unit_id as room_id,
          ma.amenity_code as code,
          ma.amenity_name->>'en' as name,
          ma.icon,
          ma.category
        FROM bookable_unit_amenities bua
        JOIN master_amenities ma ON bua.amenity_id = ma.id
        WHERE bua.bookable_unit_id = ANY($1::int[])
        ORDER BY bua.display_order
      `, [roomIds]);
      
      // Group amenities by room
      amenitiesResult.rows.forEach(a => {
        if (!amenitiesByRoom[a.room_id]) {
          amenitiesByRoom[a.room_id] = [];
        }
        amenitiesByRoom[a.room_id].push({
          code: a.code,
          name: a.name,
          icon: a.icon,
          category: a.category
        });
      });
    }
    
    // Use today's rate if available, otherwise fall back to base_price
    const rooms = result.rows.map(room => ({
      ...room,
      price: room.todays_rate || room.base_price || 0,
      amenities: amenitiesByRoom[room.id] || []
    }));
    
    // Get max guests across all rooms
    const maxGuestsResult = await pool.query(`
      SELECT MAX(COALESCE(bu.max_guests, bu.max_adults, 2)) as max_guests
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1
    `, [clientId]);
    
    res.json({
      success: true,
      rooms: rooms,
      meta: {
        total: totalCount,
        returned: rooms.length,
        offset: pageOffset,
        limit: pageLimit,
        has_more: pageLimit ? (pageOffset + rooms.length < totalCount) : false,
        max_guests_available: maxGuestsResult.rows[0]?.max_guests || 10
      }
    });
  } catch (error) {
    console.error('Get client rooms error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get all properties for a client (PUBLIC API - for GAS Properties WordPress Plugin)
app.get('/api/public/client/:clientId/properties', async (req, res) => {
  try {
    const { clientId } = req.params;
    const { limit, offset, sort } = req.query;
    
    // Get all active properties for this account with image and room stats
    let result;
    try {
      result = await pool.query(`
      SELECT 
        p.id,
        p.name,
        p.display_name,
        p.property_type,
        p.description,
        p.short_description,
        p.address,
        p.city,
        p.district,
        p.country,
        p.zip_code,
        p.latitude,
        p.longitude,
        p.currency,
        p.website_url,
        p.portfolio_display,
        
        -- Primary image: try property_images first, then fall back to first room image
        COALESCE(
          (SELECT COALESCE(pi.image_url, pi.url) 
           FROM property_images pi 
           WHERE pi.property_id = p.id AND (pi.room_id IS NULL)
           ORDER BY pi.is_primary DESC NULLS LAST, COALESCE(pi.display_order, pi.sort_order, 0) ASC, pi.id ASC 
           LIMIT 1
          ),
          (SELECT ri.image_url
           FROM room_images ri
           JOIN bookable_units bu ON ri.room_id = bu.id
           WHERE bu.property_id = p.id AND ri.is_active = true
           ORDER BY ri.is_primary DESC NULLS LAST, ri.display_order ASC, ri.id ASC
           LIMIT 1
          )
        ) as primary_image,
        
        -- Room count
        (SELECT COUNT(*) 
         FROM bookable_units bu 
         WHERE bu.property_id = p.id AND bu.status = 'active'
        ) as room_count,
        
        -- Min price from active rooms (today's rate or base_price)
        (SELECT MIN(COALESCE(
           (SELECT COALESCE(ra.standard_price, ra.cm_price) 
            FROM room_availability ra 
            WHERE ra.room_id = bu2.id AND ra.date = CURRENT_DATE 
            LIMIT 1),
           bu2.base_price
         ))
         FROM bookable_units bu2 
         WHERE bu2.property_id = p.id AND bu2.status = 'active' AND bu2.base_price > 0
        ) as min_price,
        
        -- Max price
        (SELECT MAX(COALESCE(
           (SELECT COALESCE(ra.standard_price, ra.cm_price) 
            FROM room_availability ra 
            WHERE ra.room_id = bu3.id AND ra.date = CURRENT_DATE 
            LIMIT 1),
           bu3.base_price
         ))
         FROM bookable_units bu3 
         WHERE bu3.property_id = p.id AND bu3.status = 'active' AND bu3.base_price > 0
        ) as max_price,
        
        -- Bedroom range
        (SELECT MIN(bu4.num_bedrooms) 
         FROM bookable_units bu4 
         WHERE bu4.property_id = p.id AND bu4.status = 'active' AND bu4.num_bedrooms > 0
        ) as min_bedrooms,
        (SELECT MAX(bu5.num_bedrooms) 
         FROM bookable_units bu5 
         WHERE bu5.property_id = p.id AND bu5.status = 'active' AND bu5.num_bedrooms > 0
        ) as max_bedrooms,
        
        -- Max guests
        (SELECT MAX(COALESCE(bu6.max_guests, bu6.max_adults, 2)) 
         FROM bookable_units bu6 
         WHERE bu6.property_id = p.id AND bu6.status = 'active'
        ) as max_guests
        
      FROM properties p
      WHERE p.account_id = $1
        AND p.status = 'active'
        AND (p.show_on_portfolio IS NULL OR p.show_on_portfolio = true)
      ORDER BY p.name ASC
    `, [clientId]);
    } catch (queryErr) {
      if (queryErr.message && queryErr.message.includes('does not exist')) {
        // Fallback: columns not yet migrated
        result = await pool.query(`
          SELECT 
            p.id, p.name, p.display_name, p.property_type, p.description, p.short_description,
            p.address, p.city, p.district, p.country, p.zip_code, p.latitude, p.longitude,
            p.currency, p.website_url,
            COALESCE(
              (SELECT COALESCE(pi.image_url, pi.url) FROM property_images pi 
               WHERE pi.property_id = p.id AND (pi.room_id IS NULL)
               ORDER BY pi.is_primary DESC NULLS LAST, COALESCE(pi.display_order, pi.sort_order, 0) ASC, pi.id ASC LIMIT 1),
              (SELECT ri.image_url FROM room_images ri JOIN bookable_units bu ON ri.room_id = bu.id
               WHERE bu.property_id = p.id AND ri.is_active = true
               ORDER BY ri.is_primary DESC NULLS LAST, ri.display_order ASC, ri.id ASC LIMIT 1)
            ) as primary_image,
            (SELECT COUNT(*) FROM bookable_units bu WHERE bu.property_id = p.id AND bu.status = 'active') as room_count,
            (SELECT MIN(bu2.base_price) FROM bookable_units bu2 WHERE bu2.property_id = p.id AND bu2.status = 'active' AND bu2.base_price > 0) as min_price,
            (SELECT MAX(bu3.base_price) FROM bookable_units bu3 WHERE bu3.property_id = p.id AND bu3.status = 'active' AND bu3.base_price > 0) as max_price,
            (SELECT MIN(bu4.num_bedrooms) FROM bookable_units bu4 WHERE bu4.property_id = p.id AND bu4.status = 'active' AND bu4.num_bedrooms > 0) as min_bedrooms,
            (SELECT MAX(bu5.num_bedrooms) FROM bookable_units bu5 WHERE bu5.property_id = p.id AND bu5.status = 'active' AND bu5.num_bedrooms > 0) as max_bedrooms,
            (SELECT MAX(COALESCE(bu6.max_guests, bu6.max_adults, 2)) FROM bookable_units bu6 WHERE bu6.property_id = p.id AND bu6.status = 'active') as max_guests
          FROM properties p
          WHERE p.account_id = $1 AND p.status = 'active'
          ORDER BY p.name ASC
        `, [clientId]);
      } else {
        throw queryErr;
      }
    }
    
    // Apply optional limit/offset in JS to keep SQL safe
    let properties = result.rows;
    if (offset) properties = properties.slice(parseInt(offset));
    if (limit) properties = properties.slice(0, parseInt(limit));
    
    // Build bedroom range strings and format response
    properties = properties.map(prop => {
      let bedroom_range = '';
      if (prop.min_bedrooms && prop.max_bedrooms) {
        if (prop.min_bedrooms === prop.max_bedrooms) {
          bedroom_range = String(prop.min_bedrooms);
        } else {
          bedroom_range = `${prop.min_bedrooms}-${prop.max_bedrooms}`;
        }
      }
      
      return {
        id: prop.id,
        name: prop.display_name || prop.name,
        internal_name: prop.name,
        property_type: prop.property_type,
        description: prop.description,
        short_description: prop.short_description,
        address: prop.address,
        city: prop.city,
        district: prop.district,
        country: prop.country,
        zip_code: prop.zip_code,
        latitude: prop.latitude,
        longitude: prop.longitude,
        currency: prop.currency,
        primary_image: prop.primary_image || null,
        portfolio_display: prop.portfolio_display || {},
        room_count: parseInt(prop.room_count) || 0,
        min_price: prop.min_price ? parseFloat(prop.min_price) : null,
        max_price: prop.max_price ? parseFloat(prop.max_price) : null,
        bedroom_range: bedroom_range,
        min_bedrooms: prop.min_bedrooms ? parseInt(prop.min_bedrooms) : null,
        max_bedrooms: prop.max_bedrooms ? parseInt(prop.max_bedrooms) : null,
        max_guests: prop.max_guests ? parseInt(prop.max_guests) : null
      };
    });
    
    // Get total count
    let countResult;
    try {
      countResult = await pool.query(
        'SELECT COUNT(*) as total FROM properties WHERE account_id = $1 AND status = \'active\' AND (show_on_portfolio IS NULL OR show_on_portfolio = true)',
        [clientId]
      );
    } catch (e) {
      countResult = await pool.query(
        'SELECT COUNT(*) as total FROM properties WHERE account_id = $1 AND status = \'active\'',
        [clientId]
      );
    }
    
    // Get unique locations for filter
    let locationsResult;
    try {
      locationsResult = await pool.query(
        `SELECT DISTINCT city, district FROM properties WHERE account_id = $1 AND status = 'active' AND (show_on_portfolio IS NULL OR show_on_portfolio = true) AND city IS NOT NULL ORDER BY city`,
        [clientId]
      );
    } catch (e) {
      locationsResult = await pool.query(
        `SELECT DISTINCT city, district FROM properties WHERE account_id = $1 AND status = 'active' AND city IS NOT NULL ORDER BY city`,
        [clientId]
      );
    }
    
    res.json({
      success: true,
      properties: properties,
      meta: {
        total: parseInt(countResult.rows[0]?.total || 0),
        returned: properties.length,
        locations: locationsResult.rows.map(l => ({
          city: l.city,
          district: l.district,
          display: l.district ? `${l.city}, ${l.district}` : l.city
        }))
      }
    });
    
  } catch (error) {
    console.error('Public client properties error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get active offers for a client (for website display)
app.get('/api/public/client/:clientId/offers', async (req, res) => {
  try {
    const { clientId } = req.params;
    const { unit_id, check_in, check_out, guests } = req.query;
    
    // Calculate nights if dates provided
    const nights = check_in && check_out ? 
      Math.ceil((new Date(check_out) - new Date(check_in)) / (1000 * 60 * 60 * 24)) : null;
    
    // Calculate advance days (days until check-in)
    const advanceDays = check_in ? 
      Math.ceil((new Date(check_in) - new Date()) / (1000 * 60 * 60 * 24)) : null;
    
    // Get day of week for check-in and check-out (0 = Sunday, 6 = Saturday)
    const checkinDayOfWeek = check_in ? new Date(check_in).getDay() : null;
    const checkoutDayOfWeek = check_out ? new Date(check_out).getDay() : null;
    
    let offers;
    try {
      // Try with new columns
      // Filter by account_id directly on offer OR via property's account_id
      // Do NOT use user_id as that's the admin who created it, not the account it belongs to
      offers = await pool.query(`
        SELECT 
          o.id,
          o.name,
          o.description,
          o.discount_type,
          o.discount_value,
          o.applies_to,
          o.min_nights,
          o.max_nights,
          o.allowed_checkin_days,
          o.allowed_checkout_days,
          o.valid_from,
          o.valid_until,
          o.property_id,
          o.room_id,
          p.name as property_name
        FROM offers o
        LEFT JOIN properties p ON o.property_id = p.id
        WHERE o.active = true
          AND (o.available_website = true OR o.available_website IS NULL)
          AND (o.account_id = $1 OR p.account_id = $1)
          AND (o.valid_from IS NULL OR o.valid_from <= CURRENT_DATE)
          AND (o.valid_until IS NULL OR o.valid_until >= CURRENT_DATE)
          AND ($2::integer IS NULL OR o.room_id IS NULL OR o.room_id = $2)
          AND ($3::integer IS NULL OR o.min_nights IS NULL OR o.min_nights <= $3)
          AND ($3::integer IS NULL OR o.max_nights IS NULL OR o.max_nights >= $3)
          AND ($4::integer IS NULL OR o.min_guests IS NULL OR o.min_guests <= $4)
          AND ($4::integer IS NULL OR o.max_guests IS NULL OR o.max_guests >= $4)
          AND ($5::integer IS NULL OR o.min_advance_days IS NULL OR o.min_advance_days <= $5)
          AND ($5::integer IS NULL OR o.max_advance_days IS NULL OR o.max_advance_days >= $5)
        ORDER BY o.priority DESC, o.discount_value DESC
      `, [clientId, unit_id || null, nights, guests || null, advanceDays]);
    } catch (colError) {
      // Fallback without new columns if they don't exist yet
      console.log('Falling back to offers query without checkin/checkout columns');
      offers = await pool.query(`
        SELECT 
          o.id,
          o.name,
          o.description,
          o.discount_type,
          o.discount_value,
          o.applies_to,
          o.min_nights,
          o.max_nights,
          o.valid_from,
          o.valid_until,
          o.property_id,
          o.room_id,
          p.name as property_name
        FROM offers o
        LEFT JOIN properties p ON o.property_id = p.id
        WHERE o.active = true
          AND (o.available_website = true OR o.available_website IS NULL)
          AND (o.account_id = $1 OR p.account_id = $1)
          AND (o.valid_from IS NULL OR o.valid_from <= CURRENT_DATE)
          AND (o.valid_until IS NULL OR o.valid_until >= CURRENT_DATE)
          AND ($2::integer IS NULL OR o.room_id IS NULL OR o.room_id = $2)
          AND ($3::integer IS NULL OR o.min_nights IS NULL OR o.min_nights <= $3)
          AND ($3::integer IS NULL OR o.max_nights IS NULL || o.max_nights >= $3)
          AND ($4::integer IS NULL OR o.min_guests IS NULL OR o.min_guests <= $4)
          AND ($4::integer IS NULL OR o.max_guests IS NULL OR o.max_guests >= $4)
          AND ($5::integer IS NULL OR o.min_advance_days IS NULL OR o.min_advance_days <= $5)
          AND ($5::integer IS NULL OR o.max_advance_days IS NULL OR o.max_advance_days >= $5)
        ORDER BY o.priority DESC, o.discount_value DESC
      `, [clientId, unit_id || null, nights, guests || null, advanceDays]);
    }
    
    // Filter by check-in/check-out day restrictions (done in JS for flexibility)
    let filteredOffers = offers.rows;
    if (checkinDayOfWeek !== null || checkoutDayOfWeek !== null) {
      filteredOffers = offers.rows.filter(offer => {
        // Check if check-in day is allowed
        if (checkinDayOfWeek !== null && offer.allowed_checkin_days) {
          const allowedCheckinDays = offer.allowed_checkin_days.split(',').map(d => parseInt(d.trim()));
          if (!allowedCheckinDays.includes(checkinDayOfWeek)) {
            return false;
          }
        }
        // Check if check-out day is allowed
        if (checkoutDayOfWeek !== null && offer.allowed_checkout_days) {
          const allowedCheckoutDays = offer.allowed_checkout_days.split(',').map(d => parseInt(d.trim()));
          if (!allowedCheckoutDays.includes(checkoutDayOfWeek)) {
            return false;
          }
        }
        return true;
      });
    }
    
    res.json({ 
      success: true, 
      offers: filteredOffers,
      meta: {
        total: filteredOffers.length,
        filters_applied: {
          unit_id: unit_id || null,
          nights: nights,
          guests: guests || null,
          advance_days: advanceDays,
          checkin_day: checkinDayOfWeek,
          checkout_day: checkoutDayOfWeek
        }
      }
    });
  } catch (error) {
    console.error('Get public offers error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get upsells for a client (all active upsells)
app.get('/api/public/client/:clientId/upsells', async (req, res) => {
  try {
    const { clientId } = req.params;
    const { unit_id, property_id } = req.query;
    
    // Get property_id from unit if not provided
    let propId = property_id;
    if (unit_id && !propId) {
      const unitResult = await pool.query('SELECT property_id FROM bookable_units WHERE id = $1', [unit_id]);
      if (unitResult.rows.length > 0) {
        propId = unitResult.rows[0].property_id;
      }
    }
    
    const upsells = await pool.query(`
      SELECT 
        u.id,
        u.name,
        u.description,
        u.price,
        u.charge_type,
        u.max_quantity,
        u.image_url,
        u.category,
        u.property_id,
        u.room_id,
        u.room_ids,
        p.name as property_name
      FROM upsells u
      LEFT JOIN properties p ON u.property_id = p.id
      WHERE u.active = true
        AND (p.account_id = $1 OR u.property_id IS NULL)
        AND ($2::integer IS NULL OR u.property_id = $2)
        AND (
          $3::integer IS NULL 
          OR u.room_id IS NULL 
          OR u.room_id = $3
          OR u.room_ids LIKE '%' || $3::text || '%'
        )
      ORDER BY u.category NULLS LAST, u.name
    `, [clientId, propId || null, unit_id || null]);
    
    // Group by category
    const grouped = {};
    upsells.rows.forEach(upsell => {
      const cat = upsell.category || 'Other';
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push(upsell);
    });
    
    res.json({ 
      success: true, 
      upsells: upsells.rows,
      upsells_by_category: grouped,
      meta: {
        total: upsells.rows.length,
        categories: Object.keys(grouped)
      }
    });
  } catch (error) {
    console.error('Get public upsells error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get public vouchers for a client (only public ones, not hidden codes)
app.get('/api/public/client/:clientId/vouchers', async (req, res) => {
  try {
    const { clientId } = req.params;
    
    // Get vouchers that are marked as public/showable
    const vouchers = await pool.query(`
      SELECT 
        v.id,
        v.code,
        v.name,
        v.description,
        v.discount_type,
        v.discount_value,
        v.min_nights,
        v.min_booking_value,
        v.valid_from,
        v.valid_until,
        v.max_uses,
        v.uses_count
      FROM vouchers v
      JOIN properties p ON v.property_id = p.id
      WHERE p.client_id = $1
        AND v.active = true
        AND v.is_public = true
        AND (v.valid_from IS NULL OR v.valid_from <= CURRENT_DATE)
        AND (v.valid_until IS NULL OR v.valid_until >= CURRENT_DATE)
        AND (v.max_uses IS NULL OR v.uses_count < v.max_uses)
      ORDER BY v.discount_value DESC
    `, [clientId]);
    
    // Format dates for display
    const formattedVouchers = vouchers.rows.map(v => ({
      ...v,
      valid_from: v.valid_from ? v.valid_from.toISOString().split('T')[0] : null,
      valid_until: v.valid_until ? v.valid_until.toISOString().split('T')[0] : null
    }));
    
    res.json({ 
      success: true, 
      vouchers: formattedVouchers,
      meta: {
        total: formattedVouchers.length
      }
    });
  } catch (error) {
    console.error('Get public vouchers error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get client features/modules (what's enabled based on plan)
app.get('/api/public/client/:clientId/features', async (req, res) => {
  try {
    const { clientId } = req.params;
    
    // Get client subscription info
    const client = await pool.query(`
      SELECT 
        c.id,
        c.name,
        c.plan,
        c.subscription_status,
        c.features_enabled,
        c.created_at
      FROM clients c
      WHERE c.id = $1
    `, [clientId]);
    
    if (!client.rows[0]) {
      return res.json({ success: false, error: 'Client not found' });
    }
    
    const clientData = client.rows[0];
    const plan = clientData.plan || 'free';
    const customFeatures = clientData.features_enabled || {};
    
    // Define features by plan
    const planFeatures = {
      free: {
        rooms: true,
        search_widget: true,
        availability_calendar: true,
        basic_booking: true,
        offers: false,
        upsells: false,
        vouchers: false,
        attractions: false,
        blog: false,
        analytics: false,
        white_label: false
      },
      pro: {
        rooms: true,
        search_widget: true,
        availability_calendar: true,
        basic_booking: true,
        offers: true,
        upsells: true,
        vouchers: true,
        attractions: true,
        blog: false,
        analytics: true,
        white_label: false
      },
      agency: {
        rooms: true,
        search_widget: true,
        availability_calendar: true,
        basic_booking: true,
        offers: true,
        upsells: true,
        vouchers: true,
        attractions: true,
        blog: true,
        analytics: true,
        white_label: true
      }
    };
    
    // Merge plan features with any custom overrides
    const features = {
      ...(planFeatures[plan] || planFeatures.free),
      ...customFeatures
    };
    
    res.json({ 
      success: true,
      client_id: clientId,
      plan: plan,
      subscription_status: clientData.subscription_status || 'active',
      features: features,
      meta: {
        available_plans: ['free', 'pro', 'agency'],
        upgrade_url: 'https://gas-booking.com/pricing'
      }
    });
  } catch (error) {
    console.error('Get client features error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get max guests across all rooms for a client (for dropdown limits)
app.get('/api/public/client/:clientId/max-guests', async (req, res) => {
  try {
    const { clientId } = req.params;
    
    const result = await pool.query(`
      SELECT MAX(COALESCE(bu.max_guests, bu.max_adults, 2)) as max_guests
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.client_id = $1
    `, [clientId]);
    
    const maxGuests = result.rows[0]?.max_guests || 10;
    
    res.json({
      success: true,
      max_guests: maxGuests
    });
  } catch (error) {
    console.error('Get max guests error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// CLIENT MANAGEMENT API
// =========================================================

// Get client info by public_id (for setup page - public endpoint)
app.get('/api/client/setup/:publicId', async (req, res) => {
  try {
    const { publicId } = req.params;
    
    // Validate UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(publicId)) {
      return res.json({ success: false, error: 'Invalid setup link' });
    }
    
    const result = await pool.query(`
      SELECT id, public_id, name, business_name, email, plan, status, created_at
      FROM clients 
      WHERE public_id = $1
    `, [publicId]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Account not found' });
    }
    
    res.json({ success: true, client: result.rows[0] });
  } catch (error) {
    console.error('Client setup error:', error);
    res.json({ success: false, error: 'Unable to load account' });
  }
});

// Get all clients (admin view) - excludes clients that are agencies
app.get('/api/admin/clients', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT 
        c.*,
        COUNT(DISTINCT p.id) as property_count,
        (SELECT COUNT(*) FROM rooms r2 JOIN properties p2 ON r2.property_id = p2.id WHERE p2.client_id = c.id) as room_count,
        0 as total_bookings
      FROM clients c
      LEFT JOIN properties p ON p.client_id = c.id
      WHERE NOT EXISTS (SELECT 1 FROM agencies a WHERE a.email = c.email)
      GROUP BY c.id
      ORDER BY c.created_at DESC
    `);
    
    res.json({ success: true, clients: result.rows });
  } catch (error) {
    console.error('Get clients error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get single client with details
app.get('/api/admin/clients/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const client = await pool.query(`SELECT * FROM clients WHERE id = $1`, [id]);
    
    if (client.rows.length === 0) {
      return res.json({ success: false, error: 'Client not found' });
    }
    
    // Get client's properties
    const properties = await pool.query(`
      SELECT p.*, COUNT(r.id) as room_count
      FROM properties p
      LEFT JOIN rooms r ON r.property_id = p.id
      WHERE p.client_id = $1
      GROUP BY p.id
      ORDER BY p.name
    `, [id]);
    
    // Get client's users
    const users = await pool.query(`
      SELECT id, email, first_name, last_name, role, status, last_login_at, created_at
      FROM client_users
      WHERE client_id = $1
      ORDER BY role, created_at
    `, [id]);
    
    res.json({ 
      success: true, 
      client: client.rows[0],
      properties: properties.rows,
      users: users.rows,
      connections: []
    });
  } catch (error) {
    console.error('Get client error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Create new client
app.post('/api/admin/clients', async (req, res) => {
  try {
    const {
      name, email, phone,
      address_line1, address_line2, city, region, postcode, country,
      currency, timezone, plan, notes
    } = req.body;
    
    // Generate API key
    const apiKey = 'gas_' + require('crypto').randomBytes(28).toString('hex');
    
    const result = await pool.query(`
      INSERT INTO clients (
        name, email, phone,
        address_line1, address_line2, city, region, postcode, country,
        currency, timezone, plan, notes,
        api_key, api_key_created_at, status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, CURRENT_TIMESTAMP, 'active')
      RETURNING *
    `, [
      name, email, phone,
      address_line1, address_line2, city, region, postcode, country || 'GB',
      currency || 'GBP', timezone || 'Europe/London', plan || 'free', notes,
      apiKey
    ]);
    
    res.json({ success: true, client: result.rows[0] });
  } catch (error) {
    console.error('Create client error:', error);
    if (error.code === '23505') {
      res.json({ success: false, error: 'A client with this email already exists' });
    } else {
      res.json({ success: false, error: error.message });
    }
  }
});

// Update client
app.put('/api/admin/clients/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name, email, phone,
      address_line1, address_line2, city, region, postcode, country,
      currency, timezone, plan, status, notes
    } = req.body;
    
    const result = await pool.query(`
      UPDATE clients SET
        name = COALESCE($1, name),
        email = COALESCE($2, email),
        phone = COALESCE($3, phone),
        address_line1 = COALESCE($4, address_line1),
        address_line2 = COALESCE($5, address_line2),
        city = COALESCE($6, city),
        region = COALESCE($7, region),
        postcode = COALESCE($8, postcode),
        country = COALESCE($9, country),
        currency = COALESCE($10, currency),
        timezone = COALESCE($11, timezone),
        plan = COALESCE($12, plan),
        status = COALESCE($13, status),
        notes = COALESCE($14, notes),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = $15
      RETURNING *
    `, [
      name, email, phone,
      address_line1, address_line2, city, region, postcode, country,
      currency, timezone, plan, status, notes,
      id
    ]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Client not found' });
    }
    
    res.json({ success: true, client: result.rows[0] });
  } catch (error) {
    console.error('Update client error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Delete client
app.delete('/api/admin/clients/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check for associated properties
    const properties = await pool.query(`SELECT COUNT(*) FROM properties WHERE client_id = $1`, [id]);
    
    if (parseInt(properties.rows[0].count) > 0) {
      return res.json({ 
        success: false, 
        error: `Cannot delete client with ${properties.rows[0].count} associated properties. Reassign or delete properties first.` 
      });
    }
    
    await pool.query(`DELETE FROM clients WHERE id = $1`, [id]);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Delete client error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Fix clients without public_id (UUID)
app.post('/api/admin/fix-client-uuids', async (req, res) => {
  try {
    // Add column if missing
    await pool.query(`ALTER TABLE clients ADD COLUMN IF NOT EXISTS public_id UUID DEFAULT gen_random_uuid() UNIQUE`);
    
    // Update any clients missing a public_id
    const result = await pool.query(`
      UPDATE clients 
      SET public_id = gen_random_uuid() 
      WHERE public_id IS NULL
      RETURNING id, name, public_id
    `);
    
    res.json({ 
      success: true, 
      message: `Fixed ${result.rows.length} clients`,
      clients: result.rows
    });
  } catch (error) {
    console.error('Fix UUIDs error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// AGENCY ENDPOINTS
// =====================================================

// Get all agencies
app.get('/api/admin/agencies', async (req, res) => {
  try {
    // Add agency_id column to properties if it doesn't exist
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS agency_id INTEGER REFERENCES agencies(id) ON DELETE SET NULL`);
    
    const result = await pool.query(`
      SELECT 
        a.*,
        COUNT(DISTINCT c.id) as client_count,
        (SELECT COUNT(*) FROM properties p WHERE p.agency_id = a.id) as property_count
      FROM agencies a
      LEFT JOIN clients c ON c.agency_id = a.id
      GROUP BY a.id
      ORDER BY a.created_at DESC
    `);
    
    res.json({ success: true, agencies: result.rows });
  } catch (error) {
    console.error('Get agencies error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get single agency with properties
app.get('/api/admin/agencies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const agency = await pool.query(`SELECT * FROM agencies WHERE id = $1`, [id]);
    
    if (agency.rows.length === 0) {
      return res.json({ success: false, error: 'Agency not found' });
    }
    
    // Get agency's properties (directly assigned via agency_id)
    const properties = await pool.query(`
      SELECT p.*, 
        (SELECT COUNT(*) FROM rooms r WHERE r.property_id = p.id) as room_count
      FROM properties p
      WHERE p.agency_id = $1
      ORDER BY p.name
    `, [id]);
    
    res.json({ 
      success: true, 
      agency: agency.rows[0],
      properties: properties.rows
    });
  } catch (error) {
    console.error('Get agency error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Create agency
app.post('/api/admin/agencies', async (req, res) => {
  try {
    const {
      name, email, phone, logo_url,
      primary_color, secondary_color,
      website_url, custom_domain,
      address_line1, address_line2, city, region, postcode, country,
      currency, timezone, plan, notes
    } = req.body;
    
    // Generate API key for agency
    const apiKey = 'gas_agency_' + require('crypto').randomBytes(24).toString('hex');
    
    const result = await pool.query(`
      INSERT INTO agencies (
        name, email, phone, logo_url,
        primary_color, secondary_color,
        website_url, custom_domain,
        address_line1, address_line2, city, region, postcode, country,
        currency, timezone, plan, notes,
        api_key, api_key_created_at, status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, CURRENT_TIMESTAMP, 'active')
      RETURNING *
    `, [
      name, email, phone, logo_url,
      primary_color || '#6366f1', secondary_color || '#8b5cf6',
      website_url, custom_domain,
      address_line1, address_line2, city, region, postcode, country || 'GB',
      currency || 'GBP', timezone || 'Europe/London', plan || 'agency', notes,
      apiKey
    ]);
    
    res.json({ success: true, agency: result.rows[0] });
  } catch (error) {
    console.error('Create agency error:', error);
    if (error.code === '23505') {
      res.json({ success: false, error: 'An agency with this email already exists' });
    } else {
      res.json({ success: false, error: error.message });
    }
  }
});

// Update agency
app.put('/api/admin/agencies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name, email, phone, logo_url,
      primary_color, secondary_color,
      website_url, custom_domain,
      address_line1, address_line2, city, region, postcode, country,
      currency, timezone, plan, status, notes
    } = req.body;
    
    const result = await pool.query(`
      UPDATE agencies SET
        name = COALESCE($1, name),
        email = COALESCE($2, email),
        phone = COALESCE($3, phone),
        logo_url = COALESCE($4, logo_url),
        primary_color = COALESCE($5, primary_color),
        secondary_color = COALESCE($6, secondary_color),
        website_url = COALESCE($7, website_url),
        custom_domain = COALESCE($8, custom_domain),
        address_line1 = COALESCE($9, address_line1),
        address_line2 = COALESCE($10, address_line2),
        city = COALESCE($11, city),
        region = COALESCE($12, region),
        postcode = COALESCE($13, postcode),
        country = COALESCE($14, country),
        currency = COALESCE($15, currency),
        timezone = COALESCE($16, timezone),
        plan = COALESCE($17, plan),
        status = COALESCE($18, status),
        notes = COALESCE($19, notes),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = $20
      RETURNING *
    `, [
      name, email, phone, logo_url,
      primary_color, secondary_color,
      website_url, custom_domain,
      address_line1, address_line2, city, region, postcode, country,
      currency, timezone, plan, status, notes,
      id
    ]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Agency not found' });
    }
    
    res.json({ success: true, agency: result.rows[0] });
  } catch (error) {
    console.error('Update agency error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Delete agency
app.delete('/api/admin/agencies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Check for associated clients
    const clients = await pool.query(`SELECT COUNT(*) FROM clients WHERE agency_id = $1`, [id]);
    
    if (parseInt(clients.rows[0].count) > 0) {
      return res.json({ 
        success: false, 
        error: `Cannot delete agency with ${clients.rows[0].count} associated clients. Reassign or delete clients first.` 
      });
    }
    
    await pool.query(`DELETE FROM agencies WHERE id = $1`, [id]);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Delete agency error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Assign client to agency
app.post('/api/admin/agencies/:id/assign-client', async (req, res) => {
  try {
    const { id } = req.params;
    const { client_id } = req.body;
    
    const result = await pool.query(`
      UPDATE clients SET agency_id = $1, updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
      RETURNING *
    `, [id, client_id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Client not found' });
    }
    
    res.json({ success: true, client: result.rows[0] });
  } catch (error) {
    console.error('Assign client error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Remove client from agency
app.post('/api/admin/agencies/:id/remove-client', async (req, res) => {
  try {
    const { client_id } = req.body;
    
    const result = await pool.query(`
      UPDATE clients SET agency_id = NULL, updated_at = CURRENT_TIMESTAMP
      WHERE id = $1
      RETURNING *
    `, [client_id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Client not found' });
    }
    
    res.json({ success: true, client: result.rows[0] });
  } catch (error) {
    console.error('Remove client error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get agency dashboard stats
app.get('/api/admin/agencies/:id/stats', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get counts
    const stats = await pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM clients WHERE agency_id = $1) as client_count,
        (SELECT COUNT(*) FROM properties p JOIN clients c ON p.client_id = c.id WHERE c.agency_id = $1) as property_count,
        (SELECT COUNT(*) FROM rooms r JOIN properties p ON r.property_id = p.id JOIN clients c ON p.client_id = c.id WHERE c.agency_id = $1) as room_count,
        (SELECT COUNT(*) FROM bookings b JOIN rooms r ON b.room_id = r.id JOIN properties p ON r.property_id = p.id JOIN clients c ON p.client_id = c.id WHERE c.agency_id = $1 AND b.status = 'confirmed') as active_bookings
    `, [id]);
    
    res.json({ success: true, stats: stats.rows[0] });
  } catch (error) {
    console.error('Get agency stats error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Convert a client to an agency (for clients with multiple properties)
app.post('/api/admin/clients/:id/convert-to-agency', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get the client
    const clientRes = await pool.query(`SELECT * FROM clients WHERE id = $1`, [id]);
    if (clientRes.rows.length === 0) {
      return res.json({ success: false, error: 'Client not found' });
    }
    const client = clientRes.rows[0];
    
    // Check if agency with this email already exists
    const existingAgency = await pool.query(`SELECT id FROM agencies WHERE email = $1`, [client.email]);
    if (existingAgency.rows.length > 0) {
      // Agency already exists - just link the client to it
      const agencyId = existingAgency.rows[0].id;
      await pool.query(`UPDATE clients SET agency_id = $1 WHERE id = $2`, [agencyId, id]);
      return res.json({ 
        success: true, 
        agency: existingAgency.rows[0],
        message: `Client linked to existing agency.`
      });
    }
    
    // Create the agency
    const apiKey = 'gas_agency_' + require('crypto').randomBytes(24).toString('hex');
    const agencyRes = await pool.query(`
      INSERT INTO agencies (
        name, email, phone, 
        address_line1, address_line2, city, region, postcode, country,
        currency, timezone, plan, api_key, api_key_created_at, status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 'agency', $12, CURRENT_TIMESTAMP, 'active')
      RETURNING *
    `, [
      client.business_name || client.name,
      client.email,
      client.phone,
      client.address_line1,
      client.address_line2,
      client.city,
      client.region,
      client.postcode,
      client.country,
      client.currency,
      client.timezone,
      apiKey
    ]);
    
    const newAgencyId = agencyRes.rows[0].id;
    
    // Link the client to the new agency (so properties show under agency)
    await pool.query(`UPDATE clients SET agency_id = $1 WHERE id = $2`, [newAgencyId, id]);
    
    res.json({ 
      success: true, 
      agency: agencyRes.rows[0],
      message: `Converted ${client.name} to agency. Properties are now linked.`
    });
  } catch (error) {
    console.error('Convert to agency error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Fix agency-client links (link clients to agencies by matching email)
app.post('/api/admin/fix-agency-links', async (req, res) => {
  try {
    // Find all clients whose email matches an agency email and link them
    const result = await pool.query(`
      UPDATE clients c
      SET agency_id = a.id
      FROM agencies a
      WHERE c.email = a.email AND c.agency_id IS NULL
      RETURNING c.id, c.name, c.email, a.id as agency_id, a.name as agency_name
    `);
    
    res.json({ 
      success: true, 
      message: `Linked ${result.rows.length} clients to their agencies`,
      linked: result.rows
    });
  } catch (error) {
    console.error('Fix agency links error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Assign property to agency
app.post('/api/admin/properties/:id/assign-agency', async (req, res) => {
  try {
    const { id } = req.params;
    const { agency_id } = req.body;
    
    // Add agency_id column to properties if it doesn't exist
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS agency_id INTEGER REFERENCES agencies(id) ON DELETE SET NULL`);
    
    const result = await pool.query(`
      UPDATE properties 
      SET agency_id = $1
      WHERE id = $2
      RETURNING *
    `, [agency_id || null, id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    res.json({ success: true, property: result.rows[0] });
  } catch (error) {
    console.error('Assign property to agency error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Regenerate API key
app.post('/api/admin/clients/:id/regenerate-api-key', async (req, res) => {
  try {
    const { id } = req.params;
    
    const newApiKey = 'gas_' + require('crypto').randomBytes(28).toString('hex');
    
    const result = await pool.query(`
      UPDATE clients 
      SET api_key = $1, api_key_created_at = CURRENT_TIMESTAMP
      WHERE id = $2
      RETURNING id, api_key, api_key_created_at
    `, [newApiKey, id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Client not found' });
    }
    
    res.json({ success: true, api_key: result.rows[0].api_key });
  } catch (error) {
    console.error('Regenerate API key error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Assign property to client
app.post('/api/admin/clients/:id/assign-property', async (req, res) => {
  try {
    const { id } = req.params;
    const { property_id } = req.body;
    
    const result = await pool.query(`
      UPDATE properties SET client_id = $1, updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
      RETURNING *
    `, [id, property_id]);
    
    // Also update channel manager connections
    await pool.query(`
      UPDATE channel_connections SET client_id = $1
      WHERE property_id = $2
    `, [id, property_id]);
    
    res.json({ success: true, property: result.rows[0] });
  } catch (error) {
    console.error('Assign property error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get unassigned properties (not belonging to any client)
app.get('/api/admin/properties/unassigned', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT p.*, COUNT(r.id) as room_count
      FROM properties p
      LEFT JOIN rooms r ON r.property_id = p.id
      WHERE p.client_id IS NULL
      GROUP BY p.id
      ORDER BY p.name
    `);
    
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    console.error('Get unassigned properties error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// CLIENT USER MANAGEMENT
// =========================================================

// Add user to client
app.post('/api/admin/clients/:id/users', async (req, res) => {
  try {
    const { id } = req.params;
    const { email, first_name, last_name, phone, role } = req.body;
    
    // Generate invite token
    const inviteToken = require('crypto').randomBytes(32).toString('hex');
    
    const result = await pool.query(`
      INSERT INTO client_users (client_id, email, first_name, last_name, phone, role, status, invite_token, invite_expires_at)
      VALUES ($1, $2, $3, $4, $5, $6, 'invited', $7, CURRENT_TIMESTAMP + INTERVAL '7 days')
      RETURNING *
    `, [id, email, first_name, last_name, phone, role || 'staff', inviteToken]);
    
    res.json({ 
      success: true, 
      user: result.rows[0],
      invite_link: `/accept-invite?token=${inviteToken}`
    });
  } catch (error) {
    console.error('Add user error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Update user
app.put('/api/admin/clients/:clientId/users/:userId', async (req, res) => {
  try {
    const { clientId, userId } = req.params;
    const { first_name, last_name, phone, role, status } = req.body;
    
    const result = await pool.query(`
      UPDATE client_users SET
        first_name = COALESCE($1, first_name),
        last_name = COALESCE($2, last_name),
        phone = COALESCE($3, phone),
        role = COALESCE($4, role),
        status = COALESCE($5, status),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = $6 AND client_id = $7
      RETURNING *
    `, [first_name, last_name, phone, role, status, userId, clientId]);
    
    res.json({ success: true, user: result.rows[0] });
  } catch (error) {
    console.error('Update user error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Remove user from client
app.delete('/api/admin/clients/:clientId/users/:userId', async (req, res) => {
  try {
    const { clientId, userId } = req.params;
    
    // Prevent deleting the owner
    const user = await pool.query(`SELECT role FROM client_users WHERE id = $1 AND client_id = $2`, [userId, clientId]);
    if (user.rows[0]?.role === 'owner') {
      return res.json({ success: false, error: 'Cannot delete the account owner' });
    }
    
    await pool.query(`DELETE FROM client_users WHERE id = $1 AND client_id = $2`, [userId, clientId]);
    
    res.json({ success: true });
  } catch (error) {
    console.error('Delete user error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// PUBLIC API - AUTHENTICATED BY API KEY
// =========================================================

// Middleware to validate API key and get client
const validateApiKey = async (req, res, next) => {
  const apiKey = req.headers['x-api-key'] || req.query.api_key;
  
  if (!apiKey) {
    return res.status(401).json({ success: false, error: 'API key required' });
  }
  
  try {
    const result = await pool.query(`
      SELECT id, name, plan, status FROM clients WHERE api_key = $1
    `, [apiKey]);
    
    if (result.rows.length === 0) {
      return res.status(401).json({ success: false, error: 'Invalid API key' });
    }
    
    const client = result.rows[0];
    
    if (client.status !== 'active') {
      return res.status(403).json({ success: false, error: 'Account is ' + client.status });
    }
    
    if (client.plan === 'free') {
      return res.status(403).json({ success: false, error: 'API access requires a paid plan. Please upgrade at your GAS dashboard.' });
    }
    
    // Attach client to request
    req.client = client;
    
    // Track API usage
    await pool.query(`
      UPDATE clients SET 
        api_requests_today = CASE 
          WHEN api_requests_reset_at < CURRENT_DATE THEN 1 
          ELSE api_requests_today + 1 
        END,
        api_requests_reset_at = CURRENT_DATE
      WHERE id = $1
    `, [client.id]);
    
    next();
  } catch (error) {
    console.error('API key validation error:', error);
    res.status(500).json({ success: false, error: 'Authentication error' });
  }
};

// Get client's properties (authenticated)
app.get('/api/v1/properties', validateApiKey, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT p.*, COUNT(r.id) as room_count
      FROM properties p
      LEFT JOIN rooms r ON r.property_id = p.id
      WHERE p.client_id = $1
      GROUP BY p.id
      ORDER BY p.name
    `, [req.client.id]);
    
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    console.error('Get client properties error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get all units for client (authenticated)
app.get('/api/v1/units', validateApiKey, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT r.*, p.name as property_name, p.id as property_id
      FROM rooms r
      JOIN properties p ON r.property_id = p.id
      WHERE p.client_id = $1
      ORDER BY p.name, r.name
    `, [req.client.id]);
    
    res.json({ success: true, units: result.rows });
  } catch (error) {
    console.error('Get client units error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get availability for a unit (authenticated - checks ownership)
app.get('/api/v1/availability/:unitId', validateApiKey, async (req, res) => {
  try {
    const { unitId } = req.params;
    const { from, to } = req.query;
    
    // Verify unit belongs to this client
    const unitCheck = await pool.query(`
      SELECT r.id FROM rooms r
      JOIN properties p ON r.property_id = p.id
      WHERE r.id = $1 AND p.client_id = $2
    `, [unitId, req.client.id]);
    
    if (unitCheck.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Unit not found or not authorized' });
    }
    
    // Get availability (reuse existing logic)
    const availability = await pool.query(`
      SELECT date, price, available, min_stay, max_stay
      FROM daily_rates
      WHERE room_id = $1 AND date >= $2 AND date <= $3
      ORDER BY date
    `, [unitId, from, to]);
    
    res.json({ success: true, unit_id: unitId, calendar: availability.rows });
  } catch (error) {
    console.error('Get availability error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// CENTRALIZED CONTENT MANAGEMENT API
// Client Pages, Contact Info, Branding, Blog, Attractions
// =====================================================

// =========================================================
// CLIENT PAGES (About, Contact, Terms, Privacy)
// =========================================================

// Get all pages for a client
app.get('/api/admin/pages', async (req, res) => {
    try {
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT * FROM client_pages 
            WHERE client_id = $1 
            ORDER BY display_order, page_type
        `, [clientId]);
        res.json({ success: true, pages: result.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get single page by type
app.get('/api/admin/pages/:pageType', async (req, res) => {
    try {
        const { pageType } = req.params;
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT * FROM client_pages 
            WHERE client_id = $1 AND page_type = $2
        `, [clientId, pageType]);
        res.json({ success: true, page: result.rows[0] || null });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Create or update page
app.post('/api/admin/pages', async (req, res) => {
    try {
        const { 
            client_id = 1, page_type, slug, title, subtitle, content,
            meta_title, meta_description, faq_schema, is_published = true 
        } = req.body;
        
        const result = await pool.query(`
            INSERT INTO client_pages (
                client_id, page_type, slug, title, subtitle, content,
                meta_title, meta_description, faq_schema, is_published, updated_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
            ON CONFLICT (client_id, page_type) DO UPDATE SET
                slug = EXCLUDED.slug,
                title = EXCLUDED.title,
                subtitle = EXCLUDED.subtitle,
                content = EXCLUDED.content,
                meta_title = EXCLUDED.meta_title,
                meta_description = EXCLUDED.meta_description,
                faq_schema = EXCLUDED.faq_schema,
                is_published = EXCLUDED.is_published,
                updated_at = NOW()
            RETURNING *
        `, [client_id, page_type, slug || page_type, title, subtitle, content, meta_title, meta_description, faq_schema, is_published]);
        
        res.json({ success: true, page: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Delete page
app.delete('/api/admin/pages/:pageType', async (req, res) => {
    try {
        const { pageType } = req.params;
        const clientId = req.query.client_id || 1;
        await pool.query(`
            DELETE FROM client_pages WHERE client_id = $1 AND page_type = $2
        `, [clientId, pageType]);
        res.json({ success: true });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// CLIENT CONTACT INFO
// =========================================================

// Get contact info
app.get('/api/admin/contact-info', async (req, res) => {
    try {
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT * FROM client_contact_info WHERE client_id = $1
        `, [clientId]);
        res.json({ success: true, contact: result.rows[0] || null });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Update contact info
app.post('/api/admin/contact-info', async (req, res) => {
    try {
        const {
            client_id = 1,
            business_name, tagline,
            email, phone, phone_secondary, whatsapp,
            address_line1, address_line2, city, state_province, postal_code, country,
            google_maps_embed, google_maps_url, latitude, longitude,
            business_hours,
            facebook_url, instagram_url, twitter_url, linkedin_url, youtube_url, tiktok_url
        } = req.body;
        
        const result = await pool.query(`
            INSERT INTO client_contact_info (
                client_id, business_name, tagline,
                email, phone, phone_secondary, whatsapp,
                address_line1, address_line2, city, state_province, postal_code, country,
                google_maps_embed, google_maps_url, latitude, longitude,
                business_hours,
                facebook_url, instagram_url, twitter_url, linkedin_url, youtube_url, tiktok_url,
                updated_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, NOW())
            ON CONFLICT (client_id) DO UPDATE SET
                business_name = EXCLUDED.business_name,
                tagline = EXCLUDED.tagline,
                email = EXCLUDED.email,
                phone = EXCLUDED.phone,
                phone_secondary = EXCLUDED.phone_secondary,
                whatsapp = EXCLUDED.whatsapp,
                address_line1 = EXCLUDED.address_line1,
                address_line2 = EXCLUDED.address_line2,
                city = EXCLUDED.city,
                state_province = EXCLUDED.state_province,
                postal_code = EXCLUDED.postal_code,
                country = EXCLUDED.country,
                google_maps_embed = EXCLUDED.google_maps_embed,
                google_maps_url = EXCLUDED.google_maps_url,
                latitude = EXCLUDED.latitude,
                longitude = EXCLUDED.longitude,
                business_hours = EXCLUDED.business_hours,
                facebook_url = EXCLUDED.facebook_url,
                instagram_url = EXCLUDED.instagram_url,
                twitter_url = EXCLUDED.twitter_url,
                linkedin_url = EXCLUDED.linkedin_url,
                youtube_url = EXCLUDED.youtube_url,
                tiktok_url = EXCLUDED.tiktok_url,
                updated_at = NOW()
            RETURNING *
        `, [
            client_id, business_name, tagline,
            email, phone, phone_secondary, whatsapp,
            address_line1, address_line2, city, state_province, postal_code, country,
            google_maps_embed, google_maps_url, latitude, longitude,
            JSON.stringify(business_hours || {}),
            facebook_url, instagram_url, twitter_url, linkedin_url, youtube_url, tiktok_url
        ]);
        
        res.json({ success: true, contact: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// CLIENT BRANDING
// =========================================================

// Get branding
app.get('/api/admin/branding', async (req, res) => {
    try {
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT * FROM client_branding WHERE client_id = $1
        `, [clientId]);
        res.json({ success: true, branding: result.rows[0] || null });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Update branding
app.post('/api/admin/branding', async (req, res) => {
    try {
        const {
            client_id = 1,
            // Logo & Identity
            logo_url, logo_dark_url, logo_alt_text, favicon_url, og_image_url,
            site_title, site_description,
            // Colors
            primary_color, secondary_color, accent_color,
            text_color, text_light_color, background_color, surface_color,
            // Header
            header_bg_color, header_text_color, header_sticky, header_transparent_home,
            // Footer
            footer_bg_color, footer_text_color, footer_link_color, footer_link_hover_color, copyright_text,
            // Buttons
            button_primary_bg, button_primary_text, button_primary_hover,
            button_secondary_bg, button_secondary_text, button_secondary_border, button_border_radius,
            // Typography
            font_heading, font_body, font_heading_weight, font_body_weight,
            // Custom
            custom_css
        } = req.body;
        
        const result = await pool.query(`
            INSERT INTO client_branding (
                client_id,
                logo_url, logo_dark_url, logo_alt_text, favicon_url, og_image_url,
                site_title, site_description,
                primary_color, secondary_color, accent_color,
                text_color, text_light_color, background_color, surface_color,
                header_bg_color, header_text_color, header_sticky, header_transparent_home,
                footer_bg_color, footer_text_color, footer_link_color, footer_link_hover_color, copyright_text,
                button_primary_bg, button_primary_text, button_primary_hover,
                button_secondary_bg, button_secondary_text, button_secondary_border, button_border_radius,
                font_heading, font_body, font_heading_weight, font_body_weight,
                custom_css, updated_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, NOW())
            ON CONFLICT (client_id) DO UPDATE SET
                logo_url = EXCLUDED.logo_url,
                logo_dark_url = EXCLUDED.logo_dark_url,
                logo_alt_text = EXCLUDED.logo_alt_text,
                favicon_url = EXCLUDED.favicon_url,
                og_image_url = EXCLUDED.og_image_url,
                site_title = EXCLUDED.site_title,
                site_description = EXCLUDED.site_description,
                primary_color = EXCLUDED.primary_color,
                secondary_color = EXCLUDED.secondary_color,
                accent_color = EXCLUDED.accent_color,
                text_color = EXCLUDED.text_color,
                text_light_color = EXCLUDED.text_light_color,
                background_color = EXCLUDED.background_color,
                surface_color = EXCLUDED.surface_color,
                header_bg_color = EXCLUDED.header_bg_color,
                header_text_color = EXCLUDED.header_text_color,
                header_sticky = EXCLUDED.header_sticky,
                header_transparent_home = EXCLUDED.header_transparent_home,
                footer_bg_color = EXCLUDED.footer_bg_color,
                footer_text_color = EXCLUDED.footer_text_color,
                footer_link_color = EXCLUDED.footer_link_color,
                footer_link_hover_color = EXCLUDED.footer_link_hover_color,
                copyright_text = EXCLUDED.copyright_text,
                button_primary_bg = EXCLUDED.button_primary_bg,
                button_primary_text = EXCLUDED.button_primary_text,
                button_primary_hover = EXCLUDED.button_primary_hover,
                button_secondary_bg = EXCLUDED.button_secondary_bg,
                button_secondary_text = EXCLUDED.button_secondary_text,
                button_secondary_border = EXCLUDED.button_secondary_border,
                button_border_radius = EXCLUDED.button_border_radius,
                font_heading = EXCLUDED.font_heading,
                font_body = EXCLUDED.font_body,
                font_heading_weight = EXCLUDED.font_heading_weight,
                font_body_weight = EXCLUDED.font_body_weight,
                custom_css = EXCLUDED.custom_css,
                updated_at = NOW()
            RETURNING *
        `, [
            client_id,
            logo_url, logo_dark_url, logo_alt_text, favicon_url, og_image_url,
            site_title, site_description,
            primary_color || '#2563eb', secondary_color || '#7c3aed', accent_color || '#f59e0b',
            text_color || '#1e293b', text_light_color || '#64748b', background_color || '#ffffff', surface_color || '#f8fafc',
            header_bg_color || '#ffffff', header_text_color || '#1e293b', header_sticky !== false, header_transparent_home || false,
            footer_bg_color || '#0f172a', footer_text_color || '#ffffff', footer_link_color || '#94a3b8', footer_link_hover_color || '#ffffff', copyright_text,
            button_primary_bg, button_primary_text || '#ffffff', button_primary_hover,
            button_secondary_bg, button_secondary_text, button_secondary_border, button_border_radius || '8px',
            font_heading || 'Inter', font_body || 'Inter', font_heading_weight || '700', font_body_weight || '400',
            custom_css
        ]);
        
        res.json({ success: true, branding: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// BLOG POSTS
// =========================================================

// AI Generate Blog Post from Keyword
app.post('/api/admin/blog/generate', async (req, res) => {
    try {
        const { keyword, property_id, language = 'en', event_date, event_location, event_description } = req.body;
        
        if (!keyword) {
            return res.json({ success: false, error: 'keyword is required' });
        }
        
        // Get property details for context
        let propertyContext = '';
        let propertyName = '';
        if (property_id) {
            const propResult = await pool.query(`
                SELECT p.*, a.name as account_name 
                FROM properties p 
                LEFT JOIN accounts a ON p.client_id = a.id 
                WHERE p.id = $1
            `, [property_id]);
            
            if (propResult.rows[0]) {
                const prop = propResult.rows[0];
                propertyName = prop.name;
                propertyContext = `
Property: ${prop.name}
Location: ${prop.address || ''}, ${prop.city || ''}, ${prop.state || ''}, ${prop.country || ''}
Type: ${prop.property_type || 'Holiday accommodation'}
Description: ${prop.description || ''}
`;
            }
        }
        
        // Build event context if this is about an event
        let eventContext = '';
        if (event_date) {
            const eventDateObj = new Date(event_date);
            const formattedDate = eventDateObj.toLocaleDateString('en-US', { 
                weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' 
            });
            eventContext = `
EVENT INFORMATION:
- Event Date: ${formattedDate}
- Event Location: ${event_location || 'See event details'}
- Event Details: ${event_description || 'Local event'}

IMPORTANT: This is a blog post about an upcoming event. Make sure to:
- Prominently mention the event date (${formattedDate}) early in the article
- Include practical information for visitors attending this event
- Suggest booking accommodation at the property for this event
- Create urgency around booking before the event date
`;
        }
        
        // Get nearby attractions for context
        let attractionsContext = '';
        if (property_id) {
            const attractionsResult = await pool.query(`
                SELECT name, description, category 
                FROM attractions 
                WHERE property_id = $1 AND is_published = true
                LIMIT 5
            `, [property_id]);
            
            if (attractionsResult.rows.length > 0) {
                attractionsContext = '\nNearby Attractions:\n' + 
                    attractionsResult.rows.map(a => `- ${a.name} (${a.category}): ${a.description || ''}`).join('\n');
            }
        }
        
        const languageNames = {
            'en': 'English',
            'es': 'Spanish',
            'de': 'German',
            'fr': 'French',
            'it': 'Italian',
            'nl': 'Dutch',
            'pt': 'Portuguese',
            'pl': 'Polish'
        };
        
        const languageName = languageNames[language] || 'English';
        
        console.log(`Generating blog post for keyword: "${keyword}" in ${languageName}${event_date ? ' (EVENT: ' + event_date + ')' : ''}`);
        
        const prompt = `You are a professional travel and hospitality content writer. Write an engaging, SEO-optimized blog post about the following topic.

Keyword to target: "${keyword}"
Language: ${languageName}
${propertyContext}
${eventContext}
${attractionsContext}

Requirements:
1. Write a compelling title that includes the keyword naturally
2. Write 600-800 words of high-quality, engaging content
3. Include the keyword naturally 3-5 times throughout the article
4. Structure with clear headings (H2, H3)
5. Include practical tips or information visitors would find useful
6. End with a subtle call-to-action encouraging booking
7. Write in ${languageName}
8. Include 3-5 FAQ questions and answers based on the content
${event_date ? '9. IMPORTANT: Mention the specific event date prominently in the content' : ''}

Return your response in this exact JSON format:
{
    "title": "The blog post title",
    "excerpt": "A 150-character summary for SEO",
    "content": "The full blog post content in HTML format with <h2>, <h3>, <p> tags",
    "meta_title": "SEO title (max 60 chars)",
    "meta_description": "SEO description (max 160 chars)",
    "suggested_tags": ["tag1", "tag2", "tag3"],
    "faq": [
        {"question": "Question 1?", "answer": "Answer 1"},
        {"question": "Question 2?", "answer": "Answer 2"},
        {"question": "Question 3?", "answer": "Answer 3"}
    ]
}`;

        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            messages: [{ role: 'user', content: prompt }]
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        const responseText = claudeResponse.data.content[0].text;
        
        // Parse the JSON response
        let blogData;
        try {
            // Extract JSON from response (handle markdown code blocks)
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                blogData = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('No JSON found in response');
            }
        } catch (parseError) {
            console.error('Failed to parse AI response:', parseError);
            return res.json({ success: false, error: 'Failed to parse AI response' });
        }
        
        res.json({
            success: true,
            blog: {
                title: blogData.title,
                excerpt: blogData.excerpt,
                content: blogData.content,
                meta_title: blogData.meta_title,
                meta_description: blogData.meta_description,
                suggested_tags: blogData.suggested_tags || [],
                keyword: keyword,
                property_id: property_id,
                property_name: propertyName,
                language: language,
                faq: blogData.faq || [],
                faq_schema: blogData.faq && blogData.faq.length > 0 ? {
                    "@context": "https://schema.org",
                    "@type": "FAQPage",
                    "mainEntity": blogData.faq.map(item => ({
                        "@type": "Question",
                        "name": item.question,
                        "acceptedAnswer": {
                            "@type": "Answer",
                            "text": item.answer
                        }
                    }))
                } : null
            }
        });
        
    } catch (error) {
        console.error('AI Blog generation error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get blog topic suggestions for a property
app.get('/api/admin/blog/suggestions', async (req, res) => {
    try {
        const { property_id } = req.query;
        
        // Get property info for variable replacement
        let propertyData = { city: '', region: '', country: '' };
        if (property_id) {
            const propResult = await pool.query(
                'SELECT name, city, state, country, property_type FROM properties WHERE id = $1',
                [property_id]
            );
            if (propResult.rows[0]) {
                propertyData = propResult.rows[0];
            }
        }
        
        // Get all active templates
        const templates = await pool.query(
            'SELECT * FROM blog_topic_templates WHERE is_active = true ORDER BY sort_order, category'
        );
        
        // Replace variables in templates
        const suggestions = templates.rows.map(t => {
            let topic = t.template;
            topic = topic.replace(/{city}/g, propertyData.city || 'your area');
            topic = topic.replace(/{region}/g, propertyData.state || 'the region');
            topic = topic.replace(/{country}/g, propertyData.country || '');
            topic = topic.replace(/{location}/g, propertyData.city || propertyData.state || 'your location');
            
            return {
                id: t.id,
                category: t.category,
                topic: topic,
                template: t.template,
                description: t.description
            };
        });
        
        // Group by category
        const grouped = {};
        suggestions.forEach(s => {
            if (!grouped[s.category]) grouped[s.category] = [];
            grouped[s.category].push(s);
        });
        
        // Get existing attractions for this property as additional suggestions
        let attractionSuggestions = [];
        if (property_id) {
            const attractions = await pool.query(
                'SELECT name, category FROM attractions WHERE property_id = $1 LIMIT 10',
                [property_id]
            );
            attractionSuggestions = attractions.rows.map(a => ({
                category: 'attractions',
                topic: `Guide to ${a.name}`,
                description: `Write about the ${a.category} attraction`
            }));
        }
        
        res.json({ 
            success: true, 
            suggestions: grouped,
            attractionSuggestions,
            propertyData
        });
    } catch (error) {
        console.error('Blog suggestions error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get blog schedules
app.get('/api/admin/blog/schedules', async (req, res) => {
    try {
        const { client_id, property_id } = req.query;
        
        let query = 'SELECT bs.*, p.name as property_name FROM blog_schedules bs LEFT JOIN properties p ON bs.property_id = p.id WHERE 1=1';
        const params = [];
        
        if (client_id && client_id !== 'null') {
            params.push(client_id);
            query += ` AND bs.client_id = $${params.length}`;
        }
        if (property_id) {
            params.push(property_id);
            query += ` AND bs.property_id = $${params.length}`;
        }
        
        query += ' ORDER BY bs.next_run_at ASC';
        
        const result = await pool.query(query, params);
        res.json({ success: true, schedules: result.rows });
    } catch (error) {
        console.error('Get blog schedules error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Create blog schedule
app.post('/api/admin/blog/schedules', async (req, res) => {
    try {
        const { client_id, property_id, topic, language, frequency, day_of_week, day_of_month, auto_publish } = req.body;
        
        // Calculate next run date
        let nextRun = new Date();
        if (frequency === 'weekly' && day_of_week !== undefined) {
            const daysUntil = (day_of_week - nextRun.getDay() + 7) % 7 || 7;
            nextRun.setDate(nextRun.getDate() + daysUntil);
        } else if (frequency === 'monthly' && day_of_month) {
            nextRun.setDate(day_of_month);
            if (nextRun <= new Date()) {
                nextRun.setMonth(nextRun.getMonth() + 1);
            }
        } else if (frequency === 'biweekly') {
            nextRun.setDate(nextRun.getDate() + 14);
        }
        nextRun.setHours(9, 0, 0, 0); // Run at 9 AM
        
        const result = await pool.query(`
            INSERT INTO blog_schedules (client_id, property_id, topic, language, frequency, day_of_week, day_of_month, next_run_at, auto_publish)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING *
        `, [client_id, property_id, topic, language || 'en', frequency || 'weekly', day_of_week, day_of_month, nextRun, auto_publish || false]);
        
        res.json({ success: true, schedule: result.rows[0] });
    } catch (error) {
        console.error('Create blog schedule error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Update blog schedule
app.put('/api/admin/blog/schedules/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { topic, language, frequency, day_of_week, day_of_month, is_active, auto_publish } = req.body;
        
        const result = await pool.query(`
            UPDATE blog_schedules SET
                topic = COALESCE($1, topic),
                language = COALESCE($2, language),
                frequency = COALESCE($3, frequency),
                day_of_week = COALESCE($4, day_of_week),
                day_of_month = COALESCE($5, day_of_month),
                is_active = COALESCE($6, is_active),
                auto_publish = COALESCE($7, auto_publish),
                updated_at = NOW()
            WHERE id = $8
            RETURNING *
        `, [topic, language, frequency, day_of_week, day_of_month, is_active, auto_publish, id]);
        
        res.json({ success: true, schedule: result.rows[0] });
    } catch (error) {
        console.error('Update blog schedule error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Delete blog schedule
app.delete('/api/admin/blog/schedules/:id', async (req, res) => {
    try {
        const { id } = req.params;
        await pool.query('DELETE FROM blog_schedules WHERE id = $1', [id]);
        res.json({ success: true });
    } catch (error) {
        console.error('Delete blog schedule error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get all blog posts
app.get('/api/admin/blog', async (req, res) => {
    try {
        let { client_id, property_id, category, is_published, is_featured, limit, offset } = req.query;
        
        // Handle null/undefined/empty client_id - for master users, show all or filter by property
        let clientId = client_id;
        if (!clientId || clientId === 'null' || clientId === 'undefined') {
            // If property_id is provided, get client_id from property
            if (property_id) {
                const propResult = await pool.query('SELECT client_id FROM properties WHERE id = $1', [property_id]);
                if (propResult.rows[0]) {
                    clientId = propResult.rows[0].client_id;
                }
            }
            // If still no clientId, return all posts (master view) or default to 1
            if (!clientId) {
                clientId = null; // Will show all posts
            }
        }
        
        let query = `
            SELECT bp.*, p.name as property_name 
            FROM blog_posts bp
            LEFT JOIN properties p ON bp.property_id = p.id
            WHERE 1=1
        `;
        const params = [];
        let paramIndex = 1;
        
        // Only filter by client_id if it's a valid number (non-master users)
        if (clientId && clientId !== 'null' && clientId !== 'undefined' && !isNaN(clientId)) {
            query += ` AND bp.client_id = $${paramIndex}`;
            params.push(parseInt(clientId));
            paramIndex++;
        }
        
        if (property_id) {
            query += ` AND bp.property_id = $${paramIndex}`;
            params.push(property_id);
            paramIndex++;
        }
        
        if (category) {
            query += ` AND bp.category = $${paramIndex}`;
            params.push(category);
            paramIndex++;
        }
        
        if (is_published !== undefined) {
            query += ` AND bp.is_published = $${paramIndex}`;
            params.push(is_published === 'true');
            paramIndex++;
        }
        
        if (is_featured === 'true') {
            query += ` AND bp.is_featured = true`;
        }
        
        query += ` ORDER BY bp.published_at DESC NULLS LAST, bp.created_at DESC`;
        
        if (limit) {
            query += ` LIMIT $${paramIndex}`;
            params.push(parseInt(limit));
            paramIndex++;
        }
        
        if (offset) {
            query += ` OFFSET $${paramIndex}`;
            params.push(parseInt(offset));
        }
        
        console.log('Blog GET query:', query, 'params:', params);
        
        const result = await pool.query(query, params);
        
        // Get total count
        let countQuery = `SELECT COUNT(*) FROM blog_posts WHERE 1=1`;
        const countParams = [];
        let countParamIndex = 1;
        if (clientId) {
            countQuery += ` AND client_id = $${countParamIndex}`;
            countParams.push(clientId);
            countParamIndex++;
        }
        if (property_id) {
            countQuery += ` AND property_id = $${countParamIndex}`;
            countParams.push(property_id);
        }
        const countResult = await pool.query(countQuery, countParams);
        
        res.json({ 
            success: true, 
            posts: result.rows,
            total: parseInt(countResult.rows[0].count)
        });
    } catch (error) {
        console.error('Blog GET error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get single blog post
app.get('/api/admin/blog/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const result = await pool.query(`SELECT * FROM blog_posts WHERE id = $1`, [id]);
        res.json({ success: true, post: result.rows[0] || null });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Create blog post
app.post('/api/admin/blog', async (req, res) => {
    try {
        let {
            property_id,
            title, slug, excerpt, content, featured_image_url,
            category, tags,
            meta_title, meta_description,
            author_name, author_image_url,
            read_time_minutes, is_featured, is_published, published_at,
            scheduled_at, ai_generated, source_keyword, language,
            faq_schema,
            // Multilingual fields
            title_ml, excerpt_ml, content_ml, meta_title_ml, meta_description_ml
        } = req.body;
        
        console.log('Blog POST received:', { property_id, title });
        
        // Property is required for blogs
        if (!property_id) {
            return res.json({ success: false, error: 'Property is required for blog posts' });
        }
        
        // Get client_id from property's account_id (same relationship used by booking system)
        const propResult = await pool.query('SELECT account_id, client_id, name FROM properties WHERE id = $1', [property_id]);
        console.log('Property lookup:', propResult.rows[0]);
        
        if (!propResult.rows[0]) {
            return res.json({ success: false, error: 'Property not found' });
        }
        
        // Use account_id (primary) or fall back to client_id 
        const client_id = propResult.rows[0].account_id || propResult.rows[0].client_id;
        
        if (!client_id) {
            console.error('Property has no account_id or client_id:', property_id, propResult.rows[0]);
            return res.json({ success: false, error: `Property "${propResult.rows[0].name}" is not linked to an account. Please link it in Settings > Accounts.` });
        }
        
        console.log('Final client_id:', client_id);
        
        // Generate slug if not provided
        const finalSlug = slug || title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
        
        const result = await pool.query(`
            INSERT INTO blog_posts (
                client_id, property_id, title, slug, excerpt, content, featured_image_url,
                category, tags, meta_title, meta_description,
                author_name, author_image_url, read_time_minutes,
                is_featured, is_published, published_at,
                scheduled_at, ai_generated, source_keyword, language,
                title_ml, excerpt_ml, content_ml, meta_title_ml, meta_description_ml,
                faq_schema
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27)
            RETURNING *
        `, [
            client_id, property_id || null, title, finalSlug, excerpt, content, featured_image_url,
            category, tags || [], meta_title, meta_description,
            author_name, author_image_url, read_time_minutes || 5,
            is_featured || false, is_published === true, is_published === true ? (published_at || new Date()) : null,
            scheduled_at || null, ai_generated || false, source_keyword || null, language || 'en',
            title_ml ? JSON.stringify(title_ml) : null,
            excerpt_ml ? JSON.stringify(excerpt_ml) : null,
            content_ml ? JSON.stringify(content_ml) : null,
            meta_title_ml ? JSON.stringify(meta_title_ml) : null,
            meta_description_ml ? JSON.stringify(meta_description_ml) : null,
            faq_schema ? JSON.stringify(faq_schema) : null
        ]);
        
        res.json({ success: true, post: result.rows[0] });
    } catch (error) {
        console.error('Blog POST error:', error);
        if (error.code === '23505') {
            res.json({ success: false, error: 'A post with this slug already exists' });
        } else {
            res.json({ success: false, error: error.message });
        }
    }
});

// Update blog post
app.put('/api/admin/blog/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const {
            property_id,
            title, slug, excerpt, content, featured_image_url,
            category, tags,
            meta_title, meta_description,
            author_name, author_image_url,
            read_time_minutes, is_featured, is_published, published_at,
            faq_schema,
            // Multilingual fields
            title_ml, excerpt_ml, content_ml, meta_title_ml, meta_description_ml
        } = req.body;
        
        const result = await pool.query(`
            UPDATE blog_posts SET
                property_id = COALESCE($1, property_id),
                title = COALESCE($2, title),
                slug = COALESCE($3, slug),
                excerpt = $4,
                content = $5,
                featured_image_url = $6,
                category = $7,
                tags = COALESCE($8, tags),
                meta_title = $9,
                meta_description = $10,
                author_name = $11,
                author_image_url = $12,
                read_time_minutes = COALESCE($13, read_time_minutes),
                is_featured = COALESCE($14, is_featured),
                is_published = COALESCE($15, is_published),
                published_at = COALESCE($16, published_at),
                title_ml = $17,
                excerpt_ml = $18,
                content_ml = $19,
                meta_title_ml = $20,
                meta_description_ml = $21,
                faq_schema = $22,
                updated_at = NOW()
            WHERE id = $23
            RETURNING *
        `, [
            property_id, title, slug, excerpt, content, featured_image_url,
            category, tags, meta_title, meta_description,
            author_name, author_image_url, read_time_minutes,
            is_featured, is_published, published_at,
            title_ml ? JSON.stringify(title_ml) : null,
            excerpt_ml ? JSON.stringify(excerpt_ml) : null,
            content_ml ? JSON.stringify(content_ml) : null,
            meta_title_ml ? JSON.stringify(meta_title_ml) : null,
            meta_description_ml ? JSON.stringify(meta_description_ml) : null,
            faq_schema ? JSON.stringify(faq_schema) : null,
            id
        ]);
        
        res.json({ success: true, post: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Delete blog post
app.delete('/api/admin/blog/:id', async (req, res) => {
    try {
        const { id } = req.params;
        await pool.query(`DELETE FROM blog_posts WHERE id = $1`, [id]);
        res.json({ success: true });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Publish blog post
app.put('/api/admin/blog/:id/publish', async (req, res) => {
    try {
        const { id } = req.params;
        const result = await pool.query(`
            UPDATE blog_posts 
            SET is_published = true, published_at = NOW(), updated_at = NOW()
            WHERE id = $1
            RETURNING *
        `, [id]);
        
        if (result.rows.length === 0) {
            return res.json({ success: false, error: 'Post not found' });
        }
        
        res.json({ success: true, post: result.rows[0] });
    } catch (error) {
        console.error('Publish blog error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get blog categories
app.get('/api/admin/blog-categories', async (req, res) => {
    try {
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT * FROM blog_categories 
            WHERE client_id = $1 
            ORDER BY display_order, name
        `, [clientId]);
        res.json({ success: true, categories: result.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Create/update blog category
app.post('/api/admin/blog-categories', async (req, res) => {
    try {
        const { client_id = 1, name, slug, description, display_order } = req.body;
        const finalSlug = slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        
        const result = await pool.query(`
            INSERT INTO blog_categories (client_id, name, slug, description, display_order)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (client_id, slug) DO UPDATE SET
                name = EXCLUDED.name,
                description = EXCLUDED.description,
                display_order = EXCLUDED.display_order
            RETURNING *
        `, [client_id, name, finalSlug, description, display_order || 0]);
        
        res.json({ success: true, category: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// GOOGLE SEARCH CONSOLE & ANALYTICS APIs
// =========================================================

// Get Search Console keywords for a site
app.get('/api/admin/seo/keywords', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url, start_date, end_date, limit = 50 } = req.query;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url required' });
        }
        
        // Default to last 28 days if not specified
        const endDate = end_date || new Date().toISOString().split('T')[0];
        const startDate = start_date || new Date(Date.now() - 28 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const response = await searchConsole.searchanalytics.query({
            siteUrl: site_url,
            requestBody: {
                startDate: startDate,
                endDate: endDate,
                dimensions: ['query'],
                rowLimit: parseInt(limit),
                dataState: 'final'
            }
        });
        
        const keywords = (response.data.rows || []).map(row => ({
            keyword: row.keys[0],
            clicks: row.clicks,
            impressions: row.impressions,
            ctr: (row.ctr * 100).toFixed(2),
            position: row.position.toFixed(1)
        }));
        
        res.json({ 
            success: true, 
            keywords,
            period: { start: startDate, end: endDate },
            total: keywords.length
        });
    } catch (error) {
        console.error('Search Console keywords error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get Search Console pages performance
app.get('/api/admin/seo/pages', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url, start_date, end_date, limit = 50 } = req.query;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url required' });
        }
        
        const endDate = end_date || new Date().toISOString().split('T')[0];
        const startDate = start_date || new Date(Date.now() - 28 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const response = await searchConsole.searchanalytics.query({
            siteUrl: site_url,
            requestBody: {
                startDate: startDate,
                endDate: endDate,
                dimensions: ['page'],
                rowLimit: parseInt(limit),
                dataState: 'final'
            }
        });
        
        const pages = (response.data.rows || []).map(row => ({
            page: row.keys[0],
            clicks: row.clicks,
            impressions: row.impressions,
            ctr: (row.ctr * 100).toFixed(2),
            position: row.position.toFixed(1)
        }));
        
        res.json({ 
            success: true, 
            pages,
            period: { start: startDate, end: endDate },
            total: pages.length
        });
    } catch (error) {
        console.error('Search Console pages error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get Search Console site summary (totals)
app.get('/api/admin/seo/summary', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url, start_date, end_date } = req.query;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url required' });
        }
        
        const endDate = end_date || new Date().toISOString().split('T')[0];
        const startDate = start_date || new Date(Date.now() - 28 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        // Get current period
        const currentResponse = await searchConsole.searchanalytics.query({
            siteUrl: site_url,
            requestBody: {
                startDate: startDate,
                endDate: endDate,
                dataState: 'final'
            }
        });
        
        // Get previous period for comparison
        const daysDiff = Math.round((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24));
        const prevEndDate = new Date(new Date(startDate).getTime() - 1 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        const prevStartDate = new Date(new Date(prevEndDate).getTime() - daysDiff * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const prevResponse = await searchConsole.searchanalytics.query({
            siteUrl: site_url,
            requestBody: {
                startDate: prevStartDate,
                endDate: prevEndDate,
                dataState: 'final'
            }
        });
        
        const current = currentResponse.data.rows?.[0] || { clicks: 0, impressions: 0, ctr: 0, position: 0 };
        const previous = prevResponse.data.rows?.[0] || { clicks: 0, impressions: 0, ctr: 0, position: 0 };
        
        res.json({ 
            success: true,
            current: {
                clicks: current.clicks || 0,
                impressions: current.impressions || 0,
                ctr: ((current.ctr || 0) * 100).toFixed(2),
                position: (current.position || 0).toFixed(1)
            },
            previous: {
                clicks: previous.clicks || 0,
                impressions: previous.impressions || 0,
                ctr: ((previous.ctr || 0) * 100).toFixed(2),
                position: (previous.position || 0).toFixed(1)
            },
            change: {
                clicks: current.clicks - (previous.clicks || 0),
                impressions: current.impressions - (previous.impressions || 0),
                ctr: (((current.ctr || 0) - (previous.ctr || 0)) * 100).toFixed(2),
                position: ((previous.position || 0) - (current.position || 0)).toFixed(1) // Inverted: lower is better
            },
            period: { 
                current: { start: startDate, end: endDate },
                previous: { start: prevStartDate, end: prevEndDate }
            }
        });
    } catch (error) {
        console.error('Search Console summary error:', error);
        res.json({ success: false, error: error.message });
    }
});

// List sites in Search Console
app.get('/api/admin/seo/sites', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { account_id } = req.query;
        
        const response = await searchConsole.sites.list();
        
        let sites = (response.data.siteEntry || []).map(site => ({
            url: site.siteUrl,
            permission: site.permissionLevel
        }));
        
        // Filter out domain properties and parent domains (only keep actual site URLs)
        sites = sites.filter(site => 
            !site.url.startsWith('sc-domain:') && 
            site.url !== 'https://sites.gas.travel/' &&
            site.url !== 'https://sites.gas.travel'
        );
        
        // Get all active deployed sites from database
        const activeSitesQuery = account_id && account_id !== 'null'
            ? await pool.query(
                'SELECT site_url FROM deployed_sites WHERE account_id = $1 AND status != $2',
                [account_id, 'deleted']
              )
            : await pool.query(
                'SELECT site_url FROM deployed_sites WHERE status != $1',
                ['deleted']
              );
        
        const activeUrls = activeSitesQuery.rows.map(r => r.site_url?.replace(/\/$/, ''));
        
        // Only show sites that exist in deployed_sites (not deleted)
        sites = sites.filter(site => {
            const siteUrlClean = site.url.replace(/\/$/, '').replace('https://', '').replace('http://', '');
            return activeUrls.some(url => {
                const urlClean = url?.replace('https://', '').replace('http://', '');
                return urlClean && (siteUrlClean.includes(urlClean) || urlClean.includes(siteUrlClean));
            });
        });
        
        res.json({ success: true, sites });
    } catch (error) {
        console.error('Search Console sites error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get SEO opportunities (keywords ranking 5-20 with high impressions)
app.get('/api/admin/seo/opportunities', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url } = req.query;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url required' });
        }
        
        const endDate = new Date().toISOString().split('T')[0];
        const startDate = new Date(Date.now() - 28 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const response = await searchConsole.searchanalytics.query({
            siteUrl: site_url,
            requestBody: {
                startDate: startDate,
                endDate: endDate,
                dimensions: ['query'],
                rowLimit: 500,
                dataState: 'final'
            }
        });
        
        // Filter for opportunities: position 5-20 with decent impressions
        const opportunities = (response.data.rows || [])
            .filter(row => row.position >= 5 && row.position <= 20 && row.impressions >= 10)
            .sort((a, b) => b.impressions - a.impressions)
            .slice(0, 20)
            .map(row => ({
                keyword: row.keys[0],
                clicks: row.clicks,
                impressions: row.impressions,
                ctr: (row.ctr * 100).toFixed(2),
                position: row.position.toFixed(1),
                potential: Math.round(row.impressions * 0.1) // Estimated clicks if moved to top 3
            }));
        
        res.json({ 
            success: true, 
            opportunities,
            suggestion: 'These keywords rank 5-20 with good impressions. Create content to boost rankings!'
        });
    } catch (error) {
        console.error('Search Console opportunities error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Auto-create GA4 property for a new site
const GA4_ACCOUNT_ID = '378182832';

app.post('/api/admin/seo/create-property', async (req, res) => {
    try {
        if (!analyticsAdmin) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { property_name, site_url, timezone = 'Europe/London', currency = 'GBP' } = req.body;
        
        if (!property_name || !site_url) {
            return res.json({ success: false, error: 'property_name and site_url are required' });
        }
        
        console.log(`Creating GA4 property: ${property_name} for ${site_url}`);
        
        // Step 1: Create the GA4 property
        const propertyResponse = await analyticsAdmin.properties.create({
            requestBody: {
                parent: `accounts/${GA4_ACCOUNT_ID}`,
                displayName: property_name,
                timeZone: timezone,
                currencyCode: currency,
                industryCategory: 'TRAVEL',
                propertyType: 'PROPERTY_TYPE_ORDINARY'
            }
        });
        
        const propertyId = propertyResponse.data.name; // Format: properties/123456789
        console.log(`Created GA4 property: ${propertyId}`);
        
        // Step 2: Create a web data stream
        const streamResponse = await analyticsAdmin.properties.dataStreams.create({
            parent: propertyId,
            requestBody: {
                type: 'WEB_DATA_STREAM',
                displayName: `${property_name} - Website`,
                webStreamData: {
                    defaultUri: site_url
                }
            }
        });
        
        const measurementId = streamResponse.data.webStreamData?.measurementId;
        console.log(`Created data stream with Measurement ID: ${measurementId}`);
        
        res.json({ 
            success: true, 
            property_id: propertyId,
            measurement_id: measurementId,
            message: `GA4 property created: ${measurementId}`
        });
        
    } catch (error) {
        console.error('Create GA4 property error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Add site to Search Console and get verification token
app.post('/api/admin/seo/add-site', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url } = req.body;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url is required' });
        }
        
        console.log(`Adding site to Search Console: ${site_url}`);
        
        // Add the site - service account becomes owner
        await searchConsole.sites.add({
            siteUrl: site_url
        });
        
        console.log(`Site added to Search Console: ${site_url}`);
        
        res.json({ 
            success: true, 
            site_url,
            message: 'Site added to Search Console successfully'
        });
        
    } catch (error) {
        console.error('Add Search Console site error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Remove site from Search Console
app.post('/api/admin/seo/remove-site', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url } = req.body;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url is required' });
        }
        
        console.log(`Removing site from Search Console: ${site_url}`);
        
        // Remove the site from Search Console
        await searchConsole.sites.delete({
            siteUrl: site_url
        });
        
        console.log(`Site removed from Search Console: ${site_url}`);
        
        res.json({ 
            success: true, 
            site_url,
            message: 'Site removed from Search Console'
        });
        
    } catch (error) {
        console.error('Remove Search Console site error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Verify a Search Console site
app.post('/api/admin/seo/verify-site', async (req, res) => {
    try {
        if (!searchConsole) {
            return res.json({ success: false, error: 'Google APIs not configured' });
        }
        
        const { site_url } = req.body;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url is required' });
        }
        
        console.log(`Verifying site in Search Console: ${site_url}`);
        
        // Attempt verification
        const verifyResponse = await searchConsole.webResource.insert({
            requestBody: {
                site: {
                    type: 'SITE',
                    identifier: site_url
                },
                verificationMethod: 'META'
            }
        });
        
        res.json({ 
            success: true, 
            site_url,
            verified: true,
            message: 'Site verified successfully'
        });
        
    } catch (error) {
        console.error('Verify Search Console site error:', error);
        res.json({ success: false, error: error.message });
    }
});

// PageSpeed Insights - Site Health Check
app.get('/api/admin/seo/pagespeed', async (req, res) => {
    try {
        const { url } = req.query;
        
        if (!url) {
            return res.json({ success: false, error: 'url is required' });
        }
        
        console.log(`Running PageSpeed analysis for: ${url}`);
        
        // Fetch both mobile and desktop scores
        const [mobileResponse, desktopResponse] = await Promise.all([
            fetch(`https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${encodeURIComponent(url)}&strategy=mobile&category=PERFORMANCE&category=ACCESSIBILITY&category=BEST_PRACTICES&category=SEO`),
            fetch(`https://www.googleapis.com/pagespeedonline/v5/runPagespeed?url=${encodeURIComponent(url)}&strategy=desktop&category=PERFORMANCE&category=ACCESSIBILITY&category=BEST_PRACTICES&category=SEO`)
        ]);
        
        const mobileData = await mobileResponse.json();
        const desktopData = await desktopResponse.json();
        
        const extractScores = (data) => {
            const categories = data.lighthouseResult?.categories || {};
            return {
                performance: Math.round((categories.performance?.score || 0) * 100),
                accessibility: Math.round((categories.accessibility?.score || 0) * 100),
                bestPractices: Math.round((categories['best-practices']?.score || 0) * 100),
                seo: Math.round((categories.seo?.score || 0) * 100)
            };
        };
        
        res.json({
            success: true,
            url,
            mobile: extractScores(mobileData),
            desktop: extractScores(desktopData)
        });
        
    } catch (error) {
        console.error('PageSpeed error:', error);
        res.json({ success: false, error: error.message });
    }
});

// GA4 Traffic Stats
app.get('/api/admin/seo/ga4-stats', async (req, res) => {
    try {
        if (!analyticsData) {
            return res.json({ success: false, error: 'Google Analytics API not configured' });
        }
        
        const { site_url } = req.query;
        
        if (!site_url) {
            return res.json({ success: false, error: 'site_url is required' });
        }
        
        // Look up the GA4 property ID from deployed_sites
        const siteResult = await pool.query(
            'SELECT ga4_property_id, ga4_measurement_id FROM deployed_sites WHERE site_url = $1',
            [site_url]
        );
        
        if (!siteResult.rows[0]?.ga4_property_id) {
            return res.json({ success: false, error: 'No GA4 property linked to this site' });
        }
        
        const propertyId = siteResult.rows[0].ga4_property_id;
        console.log(`Fetching GA4 stats for property: ${propertyId}`);
        
        // Fetch basic metrics
        const response = await analyticsData.properties.runReport({
            property: propertyId,
            requestBody: {
                dateRanges: [{ startDate: '28daysAgo', endDate: 'today' }],
                metrics: [
                    { name: 'activeUsers' },
                    { name: 'sessions' },
                    { name: 'screenPageViews' },
                    { name: 'averageSessionDuration' }
                ]
            }
        });
        
        const row = response.data.rows?.[0]?.metricValues || [];
        const avgDuration = parseFloat(row[3]?.value || 0);
        const minutes = Math.floor(avgDuration / 60);
        const seconds = Math.floor(avgDuration % 60);
        
        // Fetch top pages
        const pagesResponse = await analyticsData.properties.runReport({
            property: propertyId,
            requestBody: {
                dateRanges: [{ startDate: '28daysAgo', endDate: 'today' }],
                dimensions: [{ name: 'pagePath' }],
                metrics: [{ name: 'screenPageViews' }],
                limit: 10,
                orderBys: [{ metric: { metricName: 'screenPageViews' }, desc: true }]
            }
        });
        
        const topPages = (pagesResponse.data.rows || []).map(r => ({
            page: r.dimensionValues[0].value,
            views: parseInt(r.metricValues[0].value)
        }));
        
        // Fetch traffic sources
        const sourcesResponse = await analyticsData.properties.runReport({
            property: propertyId,
            requestBody: {
                dateRanges: [{ startDate: '28daysAgo', endDate: 'today' }],
                dimensions: [{ name: 'sessionSource' }],
                metrics: [{ name: 'sessions' }],
                limit: 10,
                orderBys: [{ metric: { metricName: 'sessions' }, desc: true }]
            }
        });
        
        const trafficSources = (sourcesResponse.data.rows || []).map(r => ({
            source: r.dimensionValues[0].value || '(direct)',
            sessions: parseInt(r.metricValues[0].value)
        }));
        
        res.json({
            success: true,
            stats: {
                users: parseInt(row[0]?.value || 0),
                sessions: parseInt(row[1]?.value || 0),
                pageViews: parseInt(row[2]?.value || 0),
                avgSessionDuration: `${minutes}:${seconds.toString().padStart(2, '0')}`,
                topPages,
                trafficSources
            }
        });
        
    } catch (error) {
        console.error('GA4 stats error:', error);
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// CONTENT IDEAS LIBRARY
// =========================================================

// Setup content_ideas table
app.get('/api/setup-content-ideas', async (req, res) => {
    try {
        await pool.query(`
            CREATE TABLE IF NOT EXISTS content_ideas (
                id SERIAL PRIMARY KEY,
                client_id INTEGER,
                property_id INTEGER REFERENCES properties(id) ON DELETE CASCADE,
                title VARCHAR(500) NOT NULL,
                description TEXT,
                content_type VARCHAR(50) DEFAULT 'blog',
                category VARCHAR(100),
                status VARCHAR(50) DEFAULT 'active',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        await pool.query(`CREATE INDEX IF NOT EXISTS idx_content_ideas_client ON content_ideas(client_id)`);
        await pool.query(`CREATE INDEX IF NOT EXISTS idx_content_ideas_property ON content_ideas(property_id)`);
        await pool.query(`CREATE INDEX IF NOT EXISTS idx_content_ideas_status ON content_ideas(status)`);
        
        // Also add faq_schema column to blog_posts if it doesn't exist
        await pool.query(`ALTER TABLE blog_posts ADD COLUMN IF NOT EXISTS faq_schema JSONB`);
        
        // Add faq_schema column to attractions if it doesn't exist
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS faq_schema JSONB`);

        // Add faq_schema column to client_pages if it doesn't exist
        await pool.query(`ALTER TABLE client_pages ADD COLUMN IF NOT EXISTS faq_schema JSONB`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS meta_title VARCHAR(100)`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS meta_description VARCHAR(300)`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS scheduled_at TIMESTAMP`);
        
        // Add multilingual columns to attractions
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS name_ml JSONB`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS short_description_ml JSONB`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS description_ml JSONB`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS meta_title_ml JSONB`);
        await pool.query(`ALTER TABLE attractions ADD COLUMN IF NOT EXISTS meta_description_ml JSONB`);
        
        res.json({ success: true, message: 'Content ideas table created + FAQ schema columns added to blog_posts and attractions' });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// One-shot migration: add faq_schema column to client_pages
app.get('/api/setup-faq-schema', async (req, res) => {
    try {
        await pool.query(`ALTER TABLE client_pages ADD COLUMN IF NOT EXISTS faq_schema JSONB`);
        res.json({ success: true, message: 'faq_schema column added to client_pages' });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get content ideas
app.get('/api/admin/content-ideas', async (req, res) => {
    try {
        let { client_id, property_id, content_type, status, account_id } = req.query;
        
        let query = `
            SELECT ci.*, p.name as property_name 
            FROM content_ideas ci
            LEFT JOIN properties p ON ci.property_id = p.id
            WHERE 1=1
        `;
        const params = [];
        let paramIndex = 1;
        
        if (client_id && client_id !== 'null' && client_id !== 'undefined') {
            query += ` AND ci.client_id = $${paramIndex}`;
            params.push(parseInt(client_id));
            paramIndex++;
        }
        
        if (account_id && account_id !== 'null' && account_id !== 'undefined') {
            query += ` AND ci.client_id = $${paramIndex}`;
            params.push(parseInt(account_id));
            paramIndex++;
        }
        
        if (property_id) {
            query += ` AND ci.property_id = $${paramIndex}`;
            params.push(parseInt(property_id));
            paramIndex++;
        }
        
        if (content_type) {
            query += ` AND ci.content_type = $${paramIndex}`;
            params.push(content_type);
            paramIndex++;
        }
        
        if (status) {
            // Handle comma-separated statuses
            const statuses = status.split(',').map(s => s.trim());
            if (statuses.length === 1) {
                query += ` AND ci.status = $${paramIndex}`;
                params.push(statuses[0]);
                paramIndex++;
            } else {
                query += ` AND ci.status = ANY($${paramIndex})`;
                params.push(statuses);
                paramIndex++;
            }
        }
        
        query += ` ORDER BY ci.created_at DESC`;
        
        const result = await pool.query(query, params);
        res.json({ success: true, ideas: result.rows });
    } catch (error) {
        console.error('Get content ideas error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Generate SEO Meta Title & Description with AI
app.post('/api/admin/generate-seo-meta', async (req, res) => {
    try {
        const { page_type, business_name, account_id } = req.body;
        
        if (!page_type) {
            return res.json({ success: false, error: 'Page type required' });
        }
        
        // Get business context if account_id provided
        let businessContext = business_name || 'a vacation rental property';
        let location = '';
        
        if (account_id) {
            const accountResult = await pool.query(
                'SELECT business_name, city, country FROM accounts WHERE id = $1',
                [account_id]
            );
            if (accountResult.rows[0]) {
                const acc = accountResult.rows[0];
                businessContext = acc.business_name || business_name || 'our property';
                if (acc.city) location = acc.city;
                if (acc.country) location += (location ? ', ' : '') + acc.country;
            }
        }
        
        const prompt = `Generate an SEO-optimized meta title and meta description for the ${page_type} page of "${businessContext}"${location ? ` located in ${location}` : ''}.

Requirements:
- Meta Title: Exactly 50-60 characters, include the business name, be compelling
- Meta Description: Exactly 150-160 characters, include a call-to-action, be engaging

This is for a vacation rental / holiday accommodation website.

Return ONLY valid JSON with this exact structure, no other text:
{"meta_title": "Your title here", "meta_description": "Your description here"}`;

        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 500,
            messages: [{ role: 'user', content: prompt }]
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        const responseText = claudeResponse.data.content[0].text;
        
        // Extract JSON from response
        let result;
        try {
            result = JSON.parse(responseText);
        } catch (e) {
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                result = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('Could not parse response');
            }
        }
        
        res.json({ 
            success: true, 
            meta_title: result.meta_title,
            meta_description: result.meta_description
        });
        
    } catch (error) {
        console.error('Error generating SEO meta:', error);
        res.json({ success: false, error: error.message });
    }
});

// Generate FAQ schemas with AI
app.post('/api/admin/generate-faqs', async (req, res) => {
    try {
        const { page_type, business_name, account_id } = req.body;
        
        if (!page_type) {
            return res.json({ success: false, error: 'Page type required' });
        }
        
        // Get business context if account_id provided
        let businessContext = business_name || 'a vacation rental property';
        
        if (account_id) {
            const accountResult = await pool.query(
                'SELECT business_name, city, country FROM accounts WHERE id = $1',
                [account_id]
            );
            if (accountResult.rows[0]) {
                const acc = accountResult.rows[0];
                businessContext = acc.business_name || business_name || 'our property';
                if (acc.city) businessContext += ` in ${acc.city}`;
                if (acc.country) businessContext += `, ${acc.country}`;
            }
        }
        
        const pageContexts = {
            'homepage': `the homepage of ${businessContext}, a vacation rental website`,
            'accommodation/rooms': `the rooms and accommodation page of ${businessContext}`,
            'about us': `the about us page of ${businessContext}`,
            'photo gallery': `the photo gallery page of ${businessContext}`,
            'blog': `the blog page of ${businessContext}`,
            'local attractions and things to do': `the local attractions and things to do page near ${businessContext}`,
            'restaurant and dining': `the restaurant and dining options at or near ${businessContext}`,
            'contact information': `the contact page of ${businessContext}`,
            'terms and conditions': `the terms and conditions page for booking at ${businessContext}`,
            'privacy policy': `the privacy policy page of ${businessContext}`
        };
        
        const context = pageContexts[page_type] || `the ${page_type} page of ${businessContext}`;
        
        const prompt = `Generate 5 frequently asked questions (FAQs) for ${context}.

These FAQs will be used as structured data (FAQ schema) for SEO purposes.

Requirements:
- Questions should be what real guests/visitors would ask
- Answers should be helpful, concise (2-3 sentences max), and professional
- Focus on practical information guests need
- Avoid generic filler content

Return ONLY a valid JSON array with this exact structure, no other text:
[
  {"question": "Question here?", "answer": "Answer here."},
  {"question": "Question here?", "answer": "Answer here."}
]`;

        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            messages: [{ role: 'user', content: prompt }]
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        const responseText = claudeResponse.data.content[0].text;
        
        // Extract JSON from response
        let faqs;
        try {
            // Try to parse directly
            faqs = JSON.parse(responseText);
        } catch (e) {
            // Try to extract JSON from response
            const jsonMatch = responseText.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                faqs = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('Could not parse FAQ response');
            }
        }
        
        if (!Array.isArray(faqs)) {
            throw new Error('Invalid FAQ format');
        }
        
        res.json({ success: true, faqs });
        
    } catch (error) {
        console.error('Error generating FAQs:', error);
        res.json({ success: false, error: error.message });
    }
});

// Generate website content with AI (intro, about sections)
app.post('/api/admin/ai/generate-website-content', async (req, res) => {
    try {
        const { type, business_name, location, title, account_id } = req.body;
        
        if (!type) {
            return res.json({ success: false, error: 'Content type required' });
        }
        
        // Get business context if account_id provided
        let businessContext = business_name || 'Our Property';
        let locationContext = location || '';
        
        if (account_id) {
            const accountResult = await pool.query(
                'SELECT name, city, country FROM accounts WHERE id = $1',
                [account_id]
            );
            if (accountResult.rows[0]) {
                const acc = accountResult.rows[0];
                if (!business_name && acc.name) businessContext = acc.name;
                if (!location) {
                    if (acc.city) locationContext = acc.city;
                    if (acc.country) locationContext += (locationContext ? ', ' : '') + acc.country;
                }
            }
        }
        
        let prompt = '';
        
        switch(type) {
            case 'intro_title':
                prompt = `Generate a welcoming, engaging title for the introduction section of a vacation rental website.

Business/Property Name: ${businessContext}
Location: ${locationContext || 'Not specified'}

Requirements:
- Short and impactful (3-6 words)
- Welcoming and inviting tone
- Can reference the location or experience
- Do NOT include quotes around the text
- Do NOT include any explanation, just the title text

Examples of good titles:
- Welcome to Paradise
- Your Perfect Getaway Awaits
- Experience Coastal Living
- Discover Tranquility

Generate ONE title only, nothing else:`;
                break;
                
            case 'intro_text':
                prompt = `Generate welcoming introduction text for a vacation rental website.

Business/Property Name: ${businessContext}
Location: ${locationContext || 'Not specified'}
Section Title: ${title || 'Welcome'}

Requirements:
- 2-3 sentences (40-60 words)
- Warm, inviting, and professional tone
- Highlight the experience guests can expect
- Mention location benefits if applicable
- Do NOT include quotes around the text
- Do NOT include any explanation or labels

Generate the intro paragraph only, nothing else:`;
                break;
                
            case 'about_title':
                prompt = `Generate an engaging title for the "About Us" section of a vacation rental website.

Business/Property Name: ${businessContext}
Location: ${locationContext || 'Not specified'}

Requirements:
- Short and compelling (3-6 words)
- Should convey experience, quality, or hospitality
- Do NOT use "About Us" literally
- Do NOT include quotes around the text
- Do NOT include any explanation

Examples of good titles:
- Experience Luxury & Comfort
- Our Story, Your Escape
- Where Memories Are Made
- The Art of Hospitality

Generate ONE title only, nothing else:`;
                break;
                
            case 'about_text':
                prompt = `Generate compelling "About Us" text for a vacation rental website.

Business/Property Name: ${businessContext}
Location: ${locationContext || 'Not specified'}
Section Title: ${title || 'About Us'}

Requirements:
- 3-4 sentences (60-100 words)
- Professional yet warm tone
- Highlight what makes the property/business special
- Mention commitment to guest experience
- Include something about the location if known
- Do NOT include quotes around the text
- Do NOT include any explanation or labels

Generate the about paragraph only, nothing else:`;
                break;
                
            case 'page_about_title':
                prompt = `Generate an engaging page title for a standalone "About Us" page on a vacation rental website.

Business/Property Name: ${businessContext}
Location: ${locationContext || 'Not specified'}

Requirements:
- 2-5 words
- More formal/professional than homepage section titles
- Can be creative but clear
- Do NOT just use "About Us" - make it unique
- Do NOT include quotes around the text

Examples:
- Our Story
- The Heart of Hospitality
- Meet Your Hosts
- A Legacy of Excellence
- Where Dreams Stay

Generate ONE title only, nothing else:`;
                break;
                
            case 'page_about_content':
                prompt = `Generate comprehensive content for a standalone "About Us" page on a vacation rental website.

Business/Property Name: ${businessContext}
Location: ${locationContext || 'Not specified'}
Page Title: ${title || 'About Us'}

Requirements:
- 3-4 paragraphs (200-300 words total)
- Professional yet warm and personal tone
- Include: the story/history, what makes you unique, your commitment to guests
- Mention the location and its appeal if known
- Make it feel authentic and personal
- Do NOT use headers or bullet points - just flowing paragraphs
- Do NOT include quotes around the text
- Separate paragraphs with blank lines

Generate the page content only, nothing else:`;
                break;
                
            default:
                return res.json({ success: false, error: 'Unknown content type' });
        }
        
        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1000,
            messages: [{ role: 'user', content: prompt }]
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        let content = claudeResponse.data.content[0].text.trim();
        
        // Clean up any quotes or extra formatting
        content = content.replace(/^["']|["']$/g, '').trim();
        
        console.log(`Generated ${type} content:`, content);
        
        res.json({ success: true, content, type });
        
    } catch (error) {
        console.error('Error generating website content:', error);
        res.json({ success: false, error: error.message });
    }
});

// Generate content ideas with AI
app.post('/api/admin/content-ideas/generate', async (req, res) => {
    try {
        const { property_id, content_type, category, count, client_id } = req.body;
        
        if (!property_id) {
            return res.json({ success: false, error: 'Property ID required' });
        }
        
        // Get property info for context (use account_id to join to accounts)
        const propResult = await pool.query(`
            SELECT p.*, a.city as account_city, a.country as account_country,
                   COALESCE(p.account_id, p.client_id) as effective_client_id
            FROM properties p 
            LEFT JOIN accounts a ON p.account_id = a.id
            WHERE p.id = $1
        `, [property_id]);
        
        if (propResult.rows.length === 0) {
            return res.json({ success: false, error: 'Property not found' });
        }
        
        const property = propResult.rows[0];
        const propertyClientId = property.effective_client_id || property.account_id || property.client_id || client_id;
        const location = `${property.city || property.account_city || 'the area'}, ${property.country || property.account_country || ''}`.trim().replace(/,\s*$/, '');
        
        // Current date for time-relevant content
        const now = new Date();
        const currentMonth = now.toLocaleString('en-US', { month: 'long' });
        const currentYear = now.getFullYear();
        const next3Months = [];
        for (let i = 0; i < 3; i++) {
            const d = new Date(now.getFullYear(), now.getMonth() + i, 1);
            next3Months.push(d.toLocaleString('en-US', { month: 'long', year: 'numeric' }));
        }
        
        // Build prompt based on content type
        let prompt = '';
        const numIdeas = count || 10;
        
        // System instruction prefix with current date context
        const systemPrefix = `You are a local travel expert and content strategist. Today's date is ${currentMonth} ${now.getDate()}, ${currentYear}.

IMPORTANT: Generate content about REAL, ACTUAL places and events. Do not make up fictional events or places.
Always respond with a valid JSON array only, no other text.

`;
        
        if (content_type === 'blog') {
            // Parse category - format is "category_subcategory" like "events_sports" or "attractions_museums"
            const [mainCategory, subCategory] = (category || '').split('_');
            
            let categoryContext = '';
            let topicFocus = '';
            
            if (mainCategory === 'attractions') {
                const subCategoryPrompts = {
                    'museums': 'museums, galleries, and cultural institutions',
                    'landmarks': 'famous landmarks, monuments, and iconic buildings',
                    'parks': 'parks, gardens, nature reserves, and outdoor spaces',
                    'beaches': 'beaches, coastline, and waterfront areas',
                    'restaurants': 'restaurants, local cuisine, and dining experiences',
                    'cafes': 'cafes, coffee shops, and bakeries',
                    'nightlife': 'bars, clubs, pubs, and evening entertainment',
                    'shopping': 'shopping districts, markets, and retail areas',
                    'nature': 'hiking trails, nature walks, and outdoor activities',
                    'daytrips': 'day trip destinations and nearby towns to explore'
                };
                topicFocus = subCategoryPrompts[subCategory] || 'local attractions and places to visit';
                categoryContext = `Write about REAL ${topicFocus} in and around ${location}.
Include actual place names, addresses where known, and what makes each place special.`;
            } else if (mainCategory === 'events') {
                const subCategoryPrompts = {
                    'festivals': 'festivals, cultural celebrations, and annual events',
                    'concerts': 'concerts, live music performances, and music venues',
                    'theater': 'theater performances, shows, and performing arts',
                    'sports': 'sporting events, matches, games, and sports venues',
                    'markets': 'markets, fairs, craft shows, and pop-up events',
                    'cultural': 'cultural events, exhibitions, and community gatherings',
                    'seasonal': 'seasonal activities and events for the current time of year',
                    'holidays': 'holiday events, celebrations, and special occasions',
                    'family': 'family-friendly events and activities for children'
                };
                topicFocus = subCategoryPrompts[subCategory] || 'local events and happenings';
                categoryContext = `Write about UPCOMING ${topicFocus} in ${location}.

CRITICAL: Focus on events happening in the NEXT 3 MONTHS (${next3Months.join(', ')}).
Include:
- Actual event names and venues
- Approximate dates or typical timing
- What visitors can expect
- Why it's worth attending

For sports events, think about:
- Local football/soccer teams and their home matches
- Rugby, cricket, or other popular local sports
- Major sporting venues in the area
- Annual sporting events or tournaments

DO NOT include past events or make up fictional events.`;
            } else {
                categoryContext = `Write about travel tips, local guides, and helpful information for visitors to ${location}.`;
            }
            
            prompt = systemPrefix + `Generate ${numIdeas} unique blog post ideas for a vacation rental property.

Property: ${property.name}
Location: ${location}
Current Date: ${currentMonth} ${currentYear}

TOPIC FOCUS: ${topicFocus}

${categoryContext}

For each idea, provide:
1. A compelling, SEO-friendly title (50-60 characters ideal)
2. A brief description of what the post should cover (1-2 sentences)

Format as JSON array:
[
  {"title": "Blog Title Here", "description": "Brief description of the content"},
  ...
]

Make titles specific to ${location}. Use REAL place names and events.`;

        } else if (content_type === 'attraction') {
            // Parse category for attractions
            const attractionType = category || 'general';
            
            const typePrompts = {
                'museums': 'museums, galleries, and cultural institutions',
                'landmarks': 'historical landmarks, monuments, and famous buildings',
                'parks': 'parks, gardens, and green spaces',
                'beaches': 'beaches and coastal areas',
                'restaurants': 'popular restaurants and dining spots',
                'cafes': 'cafes and coffee shops',
                'nightlife': 'bars, pubs, and nightlife venues',
                'shopping': 'shopping areas and markets',
                'nature': 'nature spots and outdoor areas',
                'family': 'family-friendly attractions and activities'
            };
            
            const focusType = typePrompts[attractionType] || 'local attractions';
            
            prompt = systemPrefix + `Generate ${numIdeas} REAL local ${focusType} to add to a vacation rental website.

Property: ${property.name}
Location: ${location}

Generate ideas for ACTUAL, REAL ${focusType} near ${location} that guests would want to visit.

For each attraction, provide:
1. The REAL name of the place (actual business/venue name)
2. A brief description of what it is and why guests should visit (1-2 sentences)

Format as JSON array:
[
  {"title": "Real Place Name", "description": "Brief description of the attraction"},
  ...
]

IMPORTANT: Only include REAL places that actually exist in ${location}. Be specific with actual names.
If you're not certain a place exists, don't include it.`;

        } else {
            // Fallback for any other type
            prompt = systemPrefix + `Generate ${numIdeas} unique blog post ideas for a vacation rental website.

Property: ${property.name}
Location: ${location}

Format as JSON array:
[
  {"title": "Content Topic", "description": "Brief description of the content"},
  ...
]`;
        }
        
        // Call Claude API (same as blog generator)
        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            messages: [{ role: 'user', content: prompt }]
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        const responseText = claudeResponse.data.content[0].text;
        
        // Parse AI response
        let ideas = [];
        try {
            // Extract JSON from response (handle markdown code blocks)
            const jsonMatch = responseText.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                ideas = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('No JSON array found in response');
            }
        } catch (parseError) {
            console.error('Parse error:', parseError);
            return res.json({ success: false, error: 'Failed to parse AI response' });
        }
        
        // Save ideas to database
        const savedIdeas = [];
        for (const idea of ideas) {
            const insertResult = await pool.query(`
                INSERT INTO content_ideas (client_id, property_id, title, description, content_type, category, status)
                VALUES ($1, $2, $3, $4, $5, $6, 'active')
                RETURNING *
            `, [propertyClientId, property_id, idea.title, idea.description, content_type, category]);
            savedIdeas.push(insertResult.rows[0]);
        }
        
        res.json({ success: true, ideas: savedIdeas, count: savedIdeas.length });
        
    } catch (error) {
        console.error('Generate content ideas error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Update idea status
app.put('/api/admin/content-ideas/:id/status', async (req, res) => {
    try {
        const { id } = req.params;
        const { status } = req.body;
        
        if (!['active', 'used', 'archived'].includes(status)) {
            return res.json({ success: false, error: 'Invalid status' });
        }
        
        const result = await pool.query(`
            UPDATE content_ideas 
            SET status = $1, updated_at = CURRENT_TIMESTAMP
            WHERE id = $2
            RETURNING *
        `, [status, id]);
        
        if (result.rows.length === 0) {
            return res.json({ success: false, error: 'Idea not found' });
        }
        
        res.json({ success: true, idea: result.rows[0] });
    } catch (error) {
        console.error('Update idea status error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Update content idea (category, title, description, etc)
app.put('/api/admin/content-ideas/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { category, title, description, subcategory, event_date, event_location } = req.body;
        
        // Build dynamic update query
        const updates = [];
        const params = [];
        let paramIndex = 1;
        
        if (category !== undefined) {
            updates.push(`category = $${paramIndex++}`);
            params.push(category);
        }
        if (title !== undefined) {
            updates.push(`title = $${paramIndex++}`);
            params.push(title);
        }
        if (description !== undefined) {
            updates.push(`description = $${paramIndex++}`);
            params.push(description);
        }
        if (subcategory !== undefined) {
            updates.push(`subcategory = $${paramIndex++}`);
            params.push(subcategory);
        }
        if (event_date !== undefined) {
            updates.push(`event_date = $${paramIndex++}`);
            params.push(event_date);
        }
        if (event_location !== undefined) {
            updates.push(`event_location = $${paramIndex++}`);
            params.push(event_location);
        }
        
        updates.push(`updated_at = NOW()`);
        
        if (updates.length === 1) {
            return res.json({ success: false, error: 'No fields to update' });
        }
        
        params.push(id);
        const result = await pool.query(`
            UPDATE content_ideas SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *
        `, params);
        
        if (result.rows.length === 0) {
            return res.json({ success: false, error: 'Idea not found' });
        }
        
        res.json({ success: true, idea: result.rows[0] });
    } catch (error) {
        console.error('Update idea error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Delete content idea
app.delete('/api/admin/content-ideas/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        const result = await pool.query(`
            DELETE FROM content_ideas WHERE id = $1 RETURNING *
        `, [id]);
        
        if (result.rows.length === 0) {
            return res.json({ success: false, error: 'Idea not found' });
        }
        
        res.json({ success: true, message: 'Idea deleted' });
    } catch (error) {
        console.error('Delete idea error:', error);
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// ATTRACTIONS
// =========================================================

// Get all attractions
app.get('/api/admin/attractions', async (req, res) => {
    try {
        let { client_id, category, property_id, is_published, is_featured, limit } = req.query;
        
        // Handle null/undefined/empty client_id
        let clientId = client_id;
        if (!clientId || clientId === 'null' || clientId === 'undefined') {
            if (property_id) {
                const propResult = await pool.query('SELECT client_id FROM properties WHERE id = $1', [property_id]);
                if (propResult.rows[0]) {
                    clientId = propResult.rows[0].client_id;
                }
            }
            if (!clientId) {
                clientId = null; // Will show all attractions
            }
        }
        
        let query = `
            SELECT a.*, p.name as property_name,
                (SELECT image_url FROM attraction_images WHERE attraction_id = a.id ORDER BY is_primary DESC, display_order LIMIT 1) as image_url
            FROM attractions a 
            LEFT JOIN properties p ON a.property_id = p.id
            WHERE 1=1
        `;
        const params = [];
        let paramIndex = 1;
        
        // Only add client_id filter if it's a valid number
        if (clientId && clientId !== 'null' && clientId !== 'undefined' && !isNaN(clientId)) {
            query += ` AND a.client_id = $${paramIndex}`;
            params.push(parseInt(clientId));
            paramIndex++;
        }
        
        if (category) {
            query += ` AND a.category = $${paramIndex}`;
            params.push(category);
            paramIndex++;
        }
        
        if (property_id) {
            query += ` AND a.property_id = $${paramIndex}`;
            params.push(property_id);
            paramIndex++;
        }
        
        if (is_published !== undefined) {
            query += ` AND a.is_published = $${paramIndex}`;
            params.push(is_published === 'true');
            paramIndex++;
        }
        
        if (is_featured === 'true') {
            query += ` AND a.is_featured = true`;
        }
        
        query += ` ORDER BY a.display_order, a.name`;
        
        if (limit) {
            query += ` LIMIT $${paramIndex}`;
            params.push(parseInt(limit));
        }
        
        const result = await pool.query(query, params);
        res.json({ success: true, attractions: result.rows });
    } catch (error) {
        console.error('Attractions GET error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get single attraction
app.get('/api/admin/attractions/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const result = await pool.query(`SELECT * FROM attractions WHERE id = $1`, [id]);
        
        // Get images
        const imagesResult = await pool.query(`
            SELECT * FROM attraction_images 
            WHERE attraction_id = $1 AND is_active = true
            ORDER BY is_primary DESC, display_order
        `, [id]);
        
        const attraction = result.rows[0];
        if (attraction) {
            attraction.images = imagesResult.rows;
        }
        
        res.json({ success: true, attraction });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// AI Generate Attraction Details
app.post('/api/admin/attractions/ai-generate', async (req, res) => {
    try {
        const { attraction_name, property_name, property_city } = req.body;
        
        if (!attraction_name) {
            return res.json({ success: false, error: 'Attraction name required' });
        }
        
        const prompt = `You are a local travel expert. Generate detailed information about this attraction for a vacation rental website.

Attraction: ${attraction_name}
${property_city ? `Location: Near ${property_city}` : ''}
${property_name ? `For guests staying at: ${property_name}` : ''}

Provide the following information in JSON format:
{
    "short_description": "1-2 sentence description for attraction cards (max 150 chars)",
    "description": "2-3 paragraph detailed description mentioning why visitors/guests would enjoy it, what to expect, and practical tips. Mention the property name naturally if provided.",
    "category": "One of: Museums & Galleries, Historic Sites, Parks & Gardens, Beaches, Entertainment, Shopping, Food & Drink, Sports & Activities, Nightlife, Family Fun",
    "distance": "Estimated distance/time from city center, e.g. '10 min walk' or '2 miles'",
    "address": "Full address if known, or best guess based on location",
    "website": "Official website URL if known, otherwise leave empty",
    "price_range": "One of: Free, ¬£, ¬£¬£, ¬£¬£¬£",
    "duration": "Typical visit duration, e.g. '1-2 hours'",
    "meta_title": "SEO title under 60 characters",
    "meta_description": "SEO description under 160 characters",
    "faq": [
        {"question": "Common question about this attraction?", "answer": "Helpful answer"},
        {"question": "Another question visitors often ask?", "answer": "Detailed answer"},
        {"question": "Third common question?", "answer": "Practical answer"}
    ]
}

Be accurate and helpful. If you're not certain about specific details like address or website, provide reasonable estimates or leave those fields empty.`;

        const claudeResponse = await axios.post('https://api.anthropic.com/v1/messages', {
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            messages: [{ role: 'user', content: prompt }]
        }, {
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': process.env.ANTHROPIC_API_KEY,
                'anthropic-version': '2023-06-01'
            }
        });
        
        const responseText = claudeResponse.data.content[0].text;
        
        // Parse JSON response
        let attractionData;
        try {
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                attractionData = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('No JSON found');
            }
        } catch (parseError) {
            console.error('Parse error:', parseError);
            return res.json({ success: false, error: 'Failed to parse AI response' });
        }
        
        // Build FAQ schema if FAQs provided
        let faqSchema = null;
        if (attractionData.faq && attractionData.faq.length > 0) {
            faqSchema = {
                "@context": "https://schema.org",
                "@type": "FAQPage",
                "mainEntity": attractionData.faq.map(item => ({
                    "@type": "Question",
                    "name": item.question,
                    "acceptedAnswer": {
                        "@type": "Answer",
                        "text": item.answer
                    }
                }))
            };
        }
        
        res.json({
            success: true,
            attraction: {
                short_description: attractionData.short_description,
                description: attractionData.description,
                category: attractionData.category,
                distance: attractionData.distance,
                address: attractionData.address,
                website: attractionData.website,
                price_range: attractionData.price_range,
                duration: attractionData.duration,
                meta_title: attractionData.meta_title,
                meta_description: attractionData.meta_description,
                faq_schema: faqSchema
            }
        });
        
    } catch (error) {
        console.error('AI attraction generate error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Create attraction
app.post('/api/admin/attractions', async (req, res) => {
    try {
        const {
            property_id,
            name, slug, description, short_description, featured_image_url,
            address, city, distance_text, distance_value, latitude, longitude, google_maps_url,
            category, phone, website_url, opening_hours, price_range, rating,
            meta_title, meta_description,
            is_featured, is_published, display_order,
            faq_schema,
            // Multilingual fields
            name_ml, short_description_ml, description_ml, meta_title_ml, meta_description_ml
        } = req.body;
        
        // Get client_id from property's account_id (same relationship used by booking system)
        let client_id = null;
        if (property_id) {
            const propResult = await pool.query('SELECT account_id FROM properties WHERE id = $1', [property_id]);
            if (propResult.rows[0] && propResult.rows[0].account_id) {
                client_id = propResult.rows[0].account_id;
            }
        }
        
        // Generate unique slug
        let baseSlug = slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
        let finalSlug = baseSlug;
        let counter = 1;
        
        // Check if slug exists and add number suffix if needed
        while (true) {
            const existing = await pool.query('SELECT id FROM attractions WHERE slug = $1', [finalSlug]);
            if (existing.rows.length === 0) break;
            counter++;
            finalSlug = `${baseSlug}-${counter}`;
            if (counter > 100) break; // Safety limit
        }
        
        const result = await pool.query(`
            INSERT INTO attractions (
                client_id, property_id, name, slug, description, short_description, featured_image_url,
                address, city, distance_text, distance_value, latitude, longitude, google_maps_url,
                category, phone, website_url, opening_hours, price_range, rating,
                meta_title, meta_description, is_featured, is_published, display_order,
                name_ml, short_description_ml, description_ml, meta_title_ml, meta_description_ml,
                faq_schema
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31)
            RETURNING *
        `, [
            client_id, property_id, name, finalSlug, description, short_description, featured_image_url,
            address, city, distance_text, distance_value, latitude, longitude, google_maps_url,
            category, phone, website_url, opening_hours, price_range, rating,
            meta_title, meta_description, is_featured || false, is_published !== false, display_order || 0,
            name_ml ? JSON.stringify(name_ml) : null,
            short_description_ml ? JSON.stringify(short_description_ml) : null,
            description_ml ? JSON.stringify(description_ml) : null,
            meta_title_ml ? JSON.stringify(meta_title_ml) : null,
            meta_description_ml ? JSON.stringify(meta_description_ml) : null,
            faq_schema ? JSON.stringify(faq_schema) : null
        ]);
        
        res.json({ success: true, attraction: result.rows[0] });
    } catch (error) {
        if (error.code === '23505') {
            res.json({ success: false, error: 'An attraction with this slug already exists' });
        } else {
            res.json({ success: false, error: error.message });
        }
    }
});

// Update attraction
app.put('/api/admin/attractions/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const {
            property_id, name, slug, description, short_description, featured_image_url,
            address, city, distance_text, distance_value, latitude, longitude, google_maps_url,
            category, phone, website_url, opening_hours, price_range, rating,
            meta_title, meta_description, is_featured, is_published, display_order,
            faq_schema,
            // Multilingual fields
            name_ml, short_description_ml, description_ml, meta_title_ml, meta_description_ml
        } = req.body;
        
        const result = await pool.query(`
            UPDATE attractions SET
                property_id = $1,
                name = COALESCE($2, name),
                slug = COALESCE($3, slug),
                description = $4,
                short_description = $5,
                featured_image_url = $6,
                address = $7,
                city = $8,
                distance_text = $9,
                distance_value = $10,
                latitude = $11,
                longitude = $12,
                google_maps_url = $13,
                category = $14,
                phone = $15,
                website_url = $16,
                opening_hours = $17,
                price_range = $18,
                rating = $19,
                meta_title = $20,
                meta_description = $21,
                is_featured = COALESCE($22, is_featured),
                is_published = COALESCE($23, is_published),
                display_order = COALESCE($24, display_order),
                name_ml = $25,
                short_description_ml = $26,
                description_ml = $27,
                meta_title_ml = $28,
                meta_description_ml = $29,
                faq_schema = $30,
                updated_at = NOW()
            WHERE id = $31
            RETURNING *
        `, [
            property_id, name, slug, description, short_description, featured_image_url,
            address, city, distance_text, distance_value, latitude, longitude, google_maps_url,
            category, phone, website_url, opening_hours, price_range, rating,
            meta_title, meta_description, is_featured, is_published, display_order,
            name_ml ? JSON.stringify(name_ml) : null,
            short_description_ml ? JSON.stringify(short_description_ml) : null,
            description_ml ? JSON.stringify(description_ml) : null,
            meta_title_ml ? JSON.stringify(meta_title_ml) : null,
            meta_description_ml ? JSON.stringify(meta_description_ml) : null,
            faq_schema ? JSON.stringify(faq_schema) : null,
            id
        ]);
        
        res.json({ success: true, attraction: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Delete attraction
app.delete('/api/admin/attractions/:id', async (req, res) => {
    try {
        const { id } = req.params;
        await pool.query(`DELETE FROM attractions WHERE id = $1`, [id]);
        res.json({ success: true });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Publish attraction
app.put('/api/admin/attractions/:id/publish', async (req, res) => {
    try {
        const { id } = req.params;
        const result = await pool.query(`
            UPDATE attractions 
            SET is_published = true, updated_at = NOW()
            WHERE id = $1
            RETURNING *
        `, [id]);
        
        if (result.rows.length === 0) {
            return res.json({ success: false, error: 'Attraction not found' });
        }
        
        res.json({ success: true, attraction: result.rows[0] });
    } catch (error) {
        console.error('Publish attraction error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get attraction categories
app.get('/api/admin/attraction-categories', async (req, res) => {
    try {
        const clientId = req.query.client_id || 1;
        const result = await pool.query(`
            SELECT * FROM attraction_categories 
            WHERE client_id = $1 
            ORDER BY display_order, name
        `, [clientId]);
        res.json({ success: true, categories: result.rows });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Create/update attraction category
app.post('/api/admin/attraction-categories', async (req, res) => {
    try {
        const { client_id = 1, name, slug, icon, description, display_order } = req.body;
        const finalSlug = slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
        
        const result = await pool.query(`
            INSERT INTO attraction_categories (client_id, name, slug, icon, description, display_order)
            VALUES ($1, $2, $3, $4, $5, $6)
            ON CONFLICT (client_id, slug) DO UPDATE SET
                name = EXCLUDED.name,
                icon = EXCLUDED.icon,
                description = EXCLUDED.description,
                display_order = EXCLUDED.display_order
            RETURNING *
        `, [client_id, name, finalSlug, icon, description, display_order || 0]);
        
        res.json({ success: true, category: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// PUBLIC API - Site Configuration (for WordPress/External)
// =========================================================

// Get complete site config for a client (one API call for everything)
app.get('/api/public/client/:clientId/site-config', async (req, res) => {
    try {
        const { clientId } = req.params;
        
        // Get all data in parallel
        // First get the deployed_site_id for this client (account_id = client_id in this context)
        const deployedSiteIdResult = await pool.query(
            `SELECT id, account_id FROM deployed_sites WHERE account_id = $1 LIMIT 1`,
            [clientId]
        );
        const deployedSiteId = deployedSiteIdResult.rows[0]?.id;
        
        console.log(`site-config: clientId=${clientId}, found deployedSiteId=${deployedSiteId}, rows=${deployedSiteIdResult.rows.length}`);
        
        const [pagesResult, contactResult, brandingResult, navigationResult, propertiesResult, roomsResult, websiteSettingsResult, deployedSiteResult, langSettingsResult] = await Promise.all([
            pool.query(`SELECT * FROM client_pages WHERE client_id = $1`, [clientId]),
            pool.query(`SELECT * FROM client_contact_info WHERE client_id = $1`, [clientId]),
            pool.query(`SELECT * FROM client_branding WHERE client_id = $1`, [clientId]),
            pool.query(`SELECT * FROM client_navigation WHERE client_id = $1 AND is_active = true ORDER BY menu_location, display_order`, [clientId]),
            pool.query(`SELECT * FROM properties WHERE client_id = $1`, [clientId]),
            pool.query(`
                SELECT r.*, p.name as property_name 
                FROM rooms r 
                JOIN properties p ON r.property_id = p.id 
                WHERE p.client_id = $1
            `, [clientId]),
            // Check deployed_site_id first, then fall back to account_id
            pool.query(`
                SELECT section, settings FROM website_settings 
                WHERE deployed_site_id = $1
                UNION ALL
                SELECT section, settings FROM website_settings 
                WHERE account_id = $2 AND deployed_site_id IS NULL
                AND section NOT IN (SELECT section FROM website_settings WHERE deployed_site_id = $1)
            `, [deployedSiteId, clientId]),
            pool.query(`SELECT pricing_tier FROM deployed_sites WHERE account_id = $1 LIMIT 1`, [clientId]),
            pool.query(`SELECT settings FROM accounts WHERE id = $1`, [clientId])
        ]);
        
        // Get pricing_tier from deployed_sites
        const pricingTier = deployedSiteResult.rows[0]?.pricing_tier || 'standard';
        
        // Check if blog posts exist
        const blogCountResult = await pool.query(`
            SELECT COUNT(*) FROM blog_posts WHERE client_id = $1 AND is_published = true
        `, [clientId]);
        
        // Check if attractions exist
        const attractionsCountResult = await pool.query(`
            SELECT COUNT(*) FROM attractions WHERE client_id = $1 AND is_published = true
        `, [clientId]);
        
        // Build data objects
        const pages = pagesResult.rows;
        const contact = contactResult.rows[0] || {};
        const branding = brandingResult.rows[0] || {};
        const customNav = navigationResult.rows;
        const properties = propertiesResult.rows;
        const rooms = roomsResult.rows;
        
        // Build website settings object
        const websiteSettings = {};
        websiteSettingsResult.rows.forEach(row => {
            websiteSettings[row.section] = row.settings;
        });
        
        // Build pages object with full content
        const pagesObject = {};
        pages.forEach(page => {
            // Check for SEO override from website_settings
            const pageSettings = websiteSettings['page-' + page.page_type] || {};
            
            pagesObject[page.page_type] = {
                id: page.id,
                page_type: page.page_type,
                slug: page.slug,
                title: page.title,
                subtitle: page.subtitle,
                content: page.content,
                // Use website_settings SEO if set, otherwise fall back to client_pages
                meta_title: pageSettings['meta-title'] || page.meta_title,
                meta_description: pageSettings['meta-description'] || page.meta_description,
                faq_schema: page.faq_schema,
                is_published: page.is_published,
                display_order: page.display_order,
                created_at: page.created_at,
                updated_at: page.updated_at
            };
        });
        
        // Add homepage SEO (from hero section)
        const heroSettings = websiteSettings.hero || {};
        pagesObject['home'] = {
            page_type: 'home',
            slug: '/',
            meta_title: heroSettings['meta-title'] || websiteSettings.seo?.['meta-title'] || '',
            meta_description: heroSettings['meta-description'] || websiteSettings.seo?.['meta-description'] || ''
        };
        
        // Add rooms page SEO
        const roomsSettings = websiteSettings['page-rooms'] || {};
        if (!pagesObject['rooms']) {
            pagesObject['rooms'] = {
                page_type: 'rooms',
                slug: '/book-now/',
                meta_title: roomsSettings['meta-title'] || '',
                meta_description: roomsSettings['meta-description'] || ''
            };
        }
        
        // Add/merge terms page from website_settings
        const termsSettings = websiteSettings['page-terms'] || {};
        if (Object.keys(termsSettings).length > 0 || !pagesObject['terms']) {
            // Parse FAQs if stored as JSON string
            let termsFaqs = [];
            try {
                if (termsSettings.faqs) {
                    termsFaqs = typeof termsSettings.faqs === 'string' ? JSON.parse(termsSettings.faqs) : termsSettings.faqs;
                }
            } catch (e) { console.error('Error parsing terms FAQs:', e); }
            
            pagesObject['terms'] = {
                ...(pagesObject['terms'] || {}),
                page_type: 'terms',
                slug: '/terms/',
                title: termsSettings.title || pagesObject['terms']?.title || 'Terms & Conditions',
                meta_title: termsSettings['meta-title'] || pagesObject['terms']?.meta_title || '',
                meta_description: termsSettings['meta-description'] || pagesObject['terms']?.meta_description || '',
                updated_date: termsSettings.updated || null,
                faq_enabled: termsSettings['faq-enabled'] !== false,
                faqs: termsFaqs,
                sections: {
                    booking: {
                        enabled: termsSettings['booking-enabled'] !== false,
                        title: termsSettings['booking-title'] || 'Booking & Reservations',
                        content: termsSettings.booking || ''
                    },
                    cancellation: {
                        enabled: termsSettings['cancellation-enabled'] !== false,
                        title: termsSettings['cancellation-title'] || 'Cancellation Policy',
                        content: termsSettings.cancellation || '',
                        cancel_period: termsSettings['cancel-period'] || '48',
                        cancel_fee: termsSettings['cancel-fee'] || 'first-night'
                    },
                    checkin: {
                        enabled: termsSettings['checkin-enabled'] !== false,
                        title: termsSettings['checkin-title'] || 'Check-in & Check-out',
                        checkin_time: termsSettings['checkin-time'] || '',
                        checkout_time: termsSettings['checkout-time'] || '',
                        details: termsSettings['checkin-details'] || ''
                    },
                    house_rules: {
                        enabled: termsSettings['house-rules-enabled'] !== false,
                        title: termsSettings['house-rules-title'] || 'House Rules',
                        content: termsSettings['house-rules'] || ''
                    },
                    payment: {
                        enabled: termsSettings['payment-enabled'] !== false,
                        title: termsSettings['payment-title'] || 'Payment Terms',
                        content: termsSettings.payment || ''
                    },
                    liability: {
                        enabled: termsSettings['liability-enabled'] !== false,
                        title: termsSettings['liability-title'] || 'Liability & Damages',
                        content: termsSettings.liability || ''
                    },
                    additional: {
                        enabled: termsSettings['additional-enabled'] !== false,
                        title: termsSettings['additional-title'] || 'Additional Terms',
                        content: termsSettings.additional || ''
                    }
                }
            };
        }
        
        // Add/merge privacy page from website_settings
        const privacySettings = websiteSettings['page-privacy'] || {};
        if (Object.keys(privacySettings).length > 0 || !pagesObject['privacy']) {
            // Parse FAQs if stored as JSON string
            let privacyFaqs = [];
            try {
                if (privacySettings.faqs) {
                    privacyFaqs = typeof privacySettings.faqs === 'string' ? JSON.parse(privacySettings.faqs) : privacySettings.faqs;
                }
            } catch (e) { console.error('Error parsing privacy FAQs:', e); }
            
            pagesObject['privacy'] = {
                ...(pagesObject['privacy'] || {}),
                page_type: 'privacy',
                slug: '/privacy/',
                title: privacySettings.title || pagesObject['privacy']?.title || 'Privacy Policy',
                meta_title: privacySettings['meta-title'] || pagesObject['privacy']?.meta_title || '',
                meta_description: privacySettings['meta-description'] || pagesObject['privacy']?.meta_description || '',
                updated_date: privacySettings.updated || null,
                effective_date: privacySettings.effective || null,
                faq_enabled: privacySettings['faq-enabled'] !== false,
                faqs: privacyFaqs,
                sections: {
                    intro: {
                        enabled: privacySettings['intro-enabled'] !== false,
                        title: privacySettings['intro-title'] || 'Introduction',
                        sub_heading: privacySettings['intro-sub'] || '',
                        content: privacySettings.intro || ''
                    },
                    collection: {
                        enabled: privacySettings['collection-enabled'] !== false,
                        title: privacySettings['collection-title'] || 'Information We Collect',
                        sub_heading_1: privacySettings['collection-sub1'] || 'What Data We Collect',
                        content: privacySettings.collection || '',
                        sub_heading_2: privacySettings['how-collect-sub'] || 'How We Collect Data',
                        how_collect: privacySettings['how-collect'] || ''
                    },
                    usage: {
                        enabled: privacySettings['usage-enabled'] !== false,
                        title: privacySettings['usage-title'] || 'How We Use Your Information',
                        sub_heading: privacySettings['usage-sub'] || '',
                        content: privacySettings.usage || ''
                    },
                    sharing: {
                        enabled: privacySettings['sharing-enabled'] !== false,
                        title: privacySettings['sharing-title'] || 'Information Sharing',
                        sub_heading: privacySettings['sharing-sub'] || '',
                        content: privacySettings.sharing || ''
                    },
                    cookies: {
                        enabled: privacySettings['cookies-enabled'] !== false,
                        title: privacySettings['cookies-title'] || 'Cookies',
                        sub_heading: privacySettings['cookies-sub'] || '',
                        content: privacySettings.cookies || ''
                    },
                    rights: {
                        enabled: privacySettings['rights-enabled'] !== false,
                        title: privacySettings['rights-title'] || 'Your Rights',
                        sub_heading: privacySettings['rights-sub'] || '',
                        content: privacySettings.rights || ''
                    },
                    retention: {
                        enabled: privacySettings['retention-enabled'] !== false,
                        title: privacySettings['retention-title'] || 'Data Retention',
                        sub_heading: privacySettings['retention-sub'] || '',
                        content: privacySettings.retention || ''
                    },
                    contact: {
                        enabled: privacySettings['contact-enabled'] !== false,
                        title: privacySettings['contact-title'] || 'Contact Us',
                        sub_heading: privacySettings['contact-sub'] || '',
                        content: privacySettings.contact || ''
                    }
                }
            };
        }
        
        // Auto-generate footer links from website_settings or from what exists
        const footerQuickLinks = [];
        const footerLegalLinks = [];
        const footerSettings = websiteSettings.footer || {};
        
        // Check website builder settings for footer links (new method)
        if (footerSettings['link-home'] !== false) {
            footerQuickLinks.push({ label: 'Home', url: '/' });
        }
        if (footerSettings['link-rooms'] !== false) {
            footerQuickLinks.push({ label: 'Rooms', url: '/book-now/' });
        }
        if (footerSettings['link-about'] !== false) {
            const aboutPage = pages.find(p => p.page_type === 'about');
            if (aboutPage && aboutPage.is_published) {
                footerQuickLinks.push({ label: aboutPage.title || 'About Us', url: '/about/' });
            } else {
                footerQuickLinks.push({ label: 'About Us', url: '/about/' });
            }
        }
        if (footerSettings['link-contact'] !== false) {
            const contactPage = pages.find(p => p.page_type === 'contact');
            if (contactPage && contactPage.is_published) {
                footerQuickLinks.push({ label: contactPage.title || 'Contact', url: '/contact/' });
            } else {
                footerQuickLinks.push({ label: 'Contact', url: '/contact/' });
            }
        }
        if (footerSettings['link-blog'] === true && parseInt(blogCountResult.rows[0].count) > 0) {
            footerQuickLinks.push({ label: 'Blog', url: '/blog/' });
        }
        if (footerSettings['link-faq'] === true) {
            footerQuickLinks.push({ label: 'FAQ', url: '/faq/' });
        }
        
        // Legal links
        if (footerSettings['link-terms'] !== false) {
            const termsPage = pages.find(p => p.page_type === 'terms');
            footerLegalLinks.push({ label: termsPage?.title || 'Terms & Conditions', url: '/terms/' });
        }
        if (footerSettings['link-privacy'] !== false) {
            const privacyPage = pages.find(p => p.page_type === 'privacy');
            footerLegalLinks.push({ label: privacyPage?.title || 'Privacy Policy', url: '/privacy/' });
        }
        if (footerSettings['link-cookies'] === true) {
            footerLegalLinks.push({ label: 'Cookie Policy', url: '/cookies/' });
        }
        if (footerSettings['link-cancellation'] === true) {
            footerLegalLinks.push({ label: 'Cancellation Policy', url: '/cancellation/' });
        }
        
        // Add attractions if they exist and blog isn't manually enabled (fallback)
        if (parseInt(attractionsCountResult.rows[0].count) > 0) {
            footerQuickLinks.push({ label: 'Things To Do', url: '/attractions/' });
        }
        
        res.json({
            success: true,
            config: {
                // Full contact information
                contact: {
                    id: contact.id,
                    business_name: contact.business_name,
                    tagline: contact.tagline,
                    email: websiteSettings.footer?.email || contact.email,
                    phone: websiteSettings.footer?.phone || contact.phone,
                    phone_secondary: contact.phone_secondary,
                    whatsapp: contact.whatsapp,
                    address_line1: contact.address_line1,
                    address_line2: contact.address_line2,
                    city: contact.city,
                    state_province: contact.state_province,
                    postal_code: contact.postal_code,
                    country: contact.country,
                    address: websiteSettings.footer?.address || null,
                    address_formatted: websiteSettings.footer?.address || [contact.address_line1, contact.address_line2, contact.city, contact.state_province, contact.postal_code, contact.country].filter(Boolean).join(', '),
                    latitude: contact.latitude,
                    longitude: contact.longitude,
                    google_maps_url: contact.google_maps_url,
                    google_place_id: contact.google_place_id,
                    timezone: contact.timezone,
                    currency: contact.currency,
                    social: {
                        facebook: websiteSettings.footer?.['social-facebook'] || contact.facebook_url,
                        instagram: websiteSettings.footer?.['social-instagram'] || contact.instagram_url,
                        twitter: websiteSettings.footer?.['social-twitter'] || contact.twitter_url,
                        linkedin: websiteSettings.footer?.['social-linkedin'] || contact.linkedin_url,
                        youtube: websiteSettings.footer?.['social-youtube'] || contact.youtube_url,
                        tiktok: websiteSettings.footer?.['social-tiktok'] || contact.tiktok_url,
                        pinterest: websiteSettings.footer?.['social-pinterest'] || contact.pinterest_url,
                        tripadvisor: websiteSettings.footer?.['social-tripadvisor'] || contact.tripadvisor_url
                    }
                },
                
                // Full branding settings
                branding: {
                    id: branding.id,
                    logo_url: branding.logo_url,
                    logo_dark_url: branding.logo_dark_url,
                    logo_alt_text: branding.logo_alt_text,
                    favicon_url: branding.favicon_url,
                    og_image_url: branding.og_image_url,
                    colors: {
                        primary: branding.primary_color || '#2563eb',
                        secondary: branding.secondary_color || '#7c3aed',
                        accent: branding.accent_color || '#f59e0b',
                        text: branding.text_color || '#1e293b',
                        text_light: branding.text_light_color || '#64748b',
                        background: branding.background_color || '#ffffff',
                        surface: branding.surface_color || '#f8fafc'
                    },
                    header: {
                        bg_color: websiteSettings.header?.['bg-color'] || branding.header_bg_color || '#ffffff',
                        text_color: websiteSettings.header?.['text-color'] || branding.header_text_color || '#1e293b',
                        sticky: websiteSettings.header?.sticky !== undefined ? websiteSettings.header.sticky : (branding.header_sticky !== false),
                        transparent_home: websiteSettings.header?.transparent !== undefined ? websiteSettings.header.transparent : (branding.header_transparent_home || false)
                    },
                    footer: {
                        bg_color: websiteSettings.footer?.bg || branding.footer_bg_color || '#0f172a',
                        text_color: websiteSettings.footer?.text || branding.footer_text_color || '#ffffff',
                        link_color: branding.footer_link_color || '#94a3b8',
                        link_hover_color: branding.footer_link_hover_color || '#ffffff',
                        copyright: websiteSettings.footer?.copyright || branding.copyright_text || `¬© ${new Date().getFullYear()} ${contact.business_name || 'All rights reserved'}`,
                        layout: websiteSettings.footer?.layout || 'default'
                    },
                    buttons: {
                        primary_bg: branding.button_primary_bg || branding.primary_color || '#2563eb',
                        primary_text: branding.button_primary_text || '#ffffff',
                        primary_hover: branding.button_primary_hover || '#1d4ed8',
                        secondary_bg: branding.button_secondary_bg || 'transparent',
                        secondary_text: branding.button_secondary_text || branding.primary_color || '#2563eb',
                        secondary_border: branding.button_secondary_border || branding.primary_color || '#2563eb',
                        border_radius: branding.button_border_radius || '8px'
                    },
                    fonts: {
                        heading: branding.font_heading || 'Inter',
                        body: branding.font_body || 'Inter',
                        heading_weight: branding.font_heading_weight || '700',
                        body_weight: branding.font_body_weight || '400'
                    },
                    custom_css: branding.custom_css
                },
                
                // All pages with full content
                pages: pagesObject,
                
                // Navigation
                navigation: {
                    header: customNav.filter(n => n.menu_location === 'header'),
                    footer_quick_links: footerQuickLinks,
                    footer_legal: footerLegalLinks,
                    footer_custom: customNav.filter(n => n.menu_location === 'footer'),
                    all: customNav
                },
                
                // Properties summary
                properties: properties.map(p => ({
                    id: p.id,
                    name: p.name,
                    slug: p.slug,
                    description: p.description,
                    short_description: p.short_description,
                    property_type: p.property_type,
                    star_rating: p.star_rating,
                    featured_image: p.featured_image,
                    room_count: rooms.filter(r => r.property_id === p.id).length
                })),
                
                // Feature flags
                features: {
                    has_blog: parseInt(blogCountResult.rows[0].count) > 0,
                    has_attractions: parseInt(attractionsCountResult.rows[0].count) > 0,
                    has_multiple_properties: properties.length > 1,
                    blog_count: parseInt(blogCountResult.rows[0].count),
                    attractions_count: parseInt(attractionsCountResult.rows[0].count),
                    property_count: properties.length,
                    room_count: rooms.length,
                    pricing_tier: pricingTier,
                    is_corporate: pricingTier.startsWith('corporate'),
                    is_agent: pricingTier.startsWith('agent'),
                    hide_discount_badges: pricingTier !== 'standard'
                },
                
                // SEO settings (from website_settings.seo, branding, or contact)
                seo: {
                    // Basic meta
                    enabled: websiteSettings.seo?.enabled !== false,
                    meta_title: websiteSettings.seo?.['meta-title'] || branding.site_title || contact.business_name,
                    meta_description: websiteSettings.seo?.['meta-description'] || branding.site_description || contact.tagline,
                    og_image: websiteSettings.seo?.['og-image'] || branding.og_image_url,
                    
                    // Schema toggles
                    include_schema: websiteSettings.seo?.['include-schema'] !== false,
                    include_faqs: websiteSettings.seo?.['include-faqs'] !== false,
                    
                    // Analytics IDs
                    google_analytics_id: websiteSettings.seo?.['google-analytics-id'] || '',
                    google_tag_manager_id: websiteSettings.seo?.['google-tag-manager-id'] || '',
                    facebook_pixel_id: websiteSettings.seo?.['facebook-pixel-id'] || '',
                    google_site_verification: websiteSettings.seo?.['google-site-verification'] || '',
                    
                    // Legacy fields for backwards compatibility
                    site_title: branding.site_title || contact.business_name,
                    site_description: branding.site_description || contact.tagline,
                    twitter_handle: contact.twitter_url ? '@' + contact.twitter_url.split('/').pop() : null
                },
                
                // Website Builder settings (hero, intro, footer, styles, etc.)
                website: websiteSettings,
                
                // Language settings
                languages: (() => {
                    const acctSettings = langSettingsResult.rows[0]?.settings || {};
                    return {
                        primary: acctSettings.primary_language || 'en',
                        supported: acctSettings.supported_languages || ['en']
                    };
                })()
            }
        });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get single page content (public)
app.get('/api/public/client/:clientId/page/:pageType', async (req, res) => {
    try {
        const { clientId, pageType } = req.params;
        const result = await pool.query(`
            SELECT * FROM client_pages 
            WHERE client_id = $1 AND page_type = $2 AND is_published = true
        `, [clientId, pageType]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Page not found' });
        }
        
        res.json({ success: true, page: result.rows[0] });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get blog posts (public)
app.get('/api/public/client/:clientId/blog', async (req, res) => {
    try {
        const { clientId } = req.params;
        const { category, property_id, limit = 10, offset = 0, lang = 'en' } = req.query;
        
        console.log('Public blog API called:', { clientId, property_id, category, limit, lang });
        
        // Join to properties and filter by account_id - same pattern as rooms API
        let query = `
            SELECT bp.id, bp.title, bp.slug, bp.excerpt, bp.featured_image_url, bp.category, 
                   bp.author_name, bp.read_time_minutes, bp.published_at, bp.client_id, bp.property_id,
                   bp.title_ml, bp.excerpt_ml, bp.meta_title_ml, bp.meta_description_ml,
                   p.name as property_name
            FROM blog_posts bp
            JOIN properties p ON bp.property_id = p.id
            WHERE bp.is_published = true
              AND p.account_id = $1
        `;
        const params = [clientId];
        let paramIndex = 2;
        
        // Optional additional property filter
        if (property_id) {
            query += ` AND bp.property_id = $${paramIndex}`;
            params.push(property_id);
            paramIndex++;
        }
        
        if (category) {
            // Case-insensitive matching and handle slug-style categories
            const categoryPattern = category.replace(/-/g, '[- &]*');
            query += ` AND LOWER(bp.category) ~* $${paramIndex}`;
            params.push(categoryPattern.toLowerCase());
            paramIndex++;
        }
        
        query += ` ORDER BY bp.published_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
        params.push(parseInt(limit), parseInt(offset));
        
        console.log('Public blog query:', query, params);
        
        const result = await pool.query(query, params);
        
        // Apply language-specific content
        const posts = result.rows.map(post => {
            return {
                ...post,
                title: post.title_ml?.[lang] || post.title_ml?.en || post.title,
                excerpt: post.excerpt_ml?.[lang] || post.excerpt_ml?.en || post.excerpt,
                meta_title: post.meta_title_ml?.[lang] || post.meta_title_ml?.en || post.meta_title,
                meta_description: post.meta_description_ml?.[lang] || post.meta_description_ml?.en || post.meta_description
            };
        });
        
        console.log('Public blog results:', posts.length, 'posts found');
        
        res.json({ success: true, posts });
    } catch (error) {
        console.error('Public blog API error:', error);
        res.json({ success: false, error: error.message });
    }
});

// Get single blog post (public)
app.get('/api/public/client/:clientId/blog/:slug', async (req, res) => {
    try {
        const { clientId, slug } = req.params;
        const { lang = 'en' } = req.query;
        
        const result = await pool.query(`
            SELECT bp.*, p.name as property_name
            FROM blog_posts bp
            JOIN properties p ON bp.property_id = p.id
            WHERE p.account_id = $1 AND bp.slug = $2 AND bp.is_published = true
        `, [clientId, slug]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Post not found' });
        }
        
        const post = result.rows[0];
        
        // Apply language-specific content
        const localizedPost = {
            ...post,
            title: post.title_ml?.[lang] || post.title_ml?.en || post.title,
            excerpt: post.excerpt_ml?.[lang] || post.excerpt_ml?.en || post.excerpt,
            content: post.content_ml?.[lang] || post.content_ml?.en || post.content,
            meta_title: post.meta_title_ml?.[lang] || post.meta_title_ml?.en || post.meta_title,
            meta_description: post.meta_description_ml?.[lang] || post.meta_description_ml?.en || post.meta_description
        };
        
        res.json({ success: true, post: localizedPost });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get attractions (public)
app.get('/api/public/client/:clientId/attractions', async (req, res) => {
    try {
        const { clientId } = req.params;
        const { category, limit, lang = 'en' } = req.query;
        
        // Join to properties and filter by account_id - same pattern as rooms API
        let query = `
            SELECT a.id, a.name, a.slug, a.short_description, a.featured_image_url, a.category,
                   a.address, a.city, a.distance_text, a.rating, a.price_range,
                   a.name_ml, a.short_description_ml, a.meta_title_ml, a.meta_description_ml,
                   p.name as property_name
            FROM attractions a
            JOIN properties p ON a.property_id = p.id
            WHERE p.account_id = $1 AND a.is_published = true
        `;
        const params = [clientId];
        let paramIndex = 2;
        
        if (category) {
            // Case-insensitive matching and handle slug-style categories
            // e.g., "nightlife" matches "Nightlife", "nightlife-bars" matches "Nightlife & Bars"
            const categoryPattern = category.replace(/-/g, '[- &]*');
            query += ` AND LOWER(category) ~* $${paramIndex}`;
            params.push(categoryPattern.toLowerCase());
            paramIndex++;
        }
        
        query += ` ORDER BY display_order, name`;
        
        if (limit) {
            query += ` LIMIT $${paramIndex}`;
            params.push(parseInt(limit));
        }
        
        const result = await pool.query(query, params);
        
        // Apply language-specific content
        const attractions = result.rows.map(a => ({
            ...a,
            name: a.name_ml?.[lang] || a.name_ml?.en || a.name,
            short_description: a.short_description_ml?.[lang] || a.short_description_ml?.en || a.short_description,
            meta_title: a.meta_title_ml?.[lang] || a.meta_title_ml?.en || a.meta_title,
            meta_description: a.meta_description_ml?.[lang] || a.meta_description_ml?.en || a.meta_description
        }));
        
        res.json({ success: true, attractions });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// Get single attraction (public)
app.get('/api/public/client/:clientId/attractions/:slug', async (req, res) => {
    try {
        const { clientId, slug } = req.params;
        const { lang = 'en' } = req.query;
        
        const result = await pool.query(`
            SELECT a.*, p.name as property_name
            FROM attractions a
            JOIN properties p ON a.property_id = p.id
            WHERE p.account_id = $1 AND a.slug = $2 AND a.is_published = true
        `, [clientId, slug]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ success: false, error: 'Attraction not found' });
        }
        
        // Get images
        const imagesResult = await pool.query(`
            SELECT image_url, alt_text, caption FROM attraction_images 
            WHERE attraction_id = $1 AND is_active = true
            ORDER BY is_primary DESC, display_order
        `, [result.rows[0].id]);
        
        const a = result.rows[0];
        
        // Apply language-specific content
        const attraction = {
            ...a,
            name: a.name_ml?.[lang] || a.name_ml?.en || a.name,
            short_description: a.short_description_ml?.[lang] || a.short_description_ml?.en || a.short_description,
            description: a.description_ml?.[lang] || a.description_ml?.en || a.description,
            meta_title: a.meta_title_ml?.[lang] || a.meta_title_ml?.en || a.meta_title,
            meta_description: a.meta_description_ml?.[lang] || a.meta_description_ml?.en || a.meta_description,
            images: imagesResult.rows
        };
        
        res.json({ success: true, attraction });
    } catch (error) {
        res.json({ success: false, error: error.message });
    }
});

// =========================================================
// SITEMAP & ROBOTS.TXT - SEO ENDPOINTS
// =========================================================

// Generate sitemap.xml for a client
app.get('/api/public/client/:clientId/sitemap.xml', async (req, res) => {
    try {
        const { clientId } = req.params;
        const { baseUrl } = req.query; // Pass ?baseUrl=https://theadelphihotel.co.uk
        
        if (!baseUrl) {
            return res.status(400).send('<!-- baseUrl query parameter required -->');
        }
        
        const siteUrl = baseUrl.replace(/\/$/, ''); // Remove trailing slash
        
        // Get all data in parallel
        const [pagesResult, roomsResult, blogResult, attractionsResult, propertiesResult] = await Promise.all([
            pool.query(`SELECT page_type, slug, updated_at FROM client_pages WHERE client_id = $1 AND is_published = true`, [clientId]),
            pool.query(`
                SELECT r.slug, r.updated_at, p.slug as property_slug 
                FROM rooms r 
                JOIN properties p ON r.property_id = p.id 
                WHERE p.client_id = $1 AND r.is_active = true
            `, [clientId]),
            pool.query(`SELECT slug, updated_at FROM blog_posts WHERE client_id = $1 AND is_published = true ORDER BY published_at DESC`, [clientId]),
            pool.query(`SELECT slug, updated_at FROM attractions WHERE client_id = $1 AND is_published = true`, [clientId]),
            pool.query(`SELECT slug, updated_at FROM properties WHERE client_id = $1`, [clientId])
        ]);
        
        const urls = [];
        const now = new Date().toISOString().split('T')[0];
        
        // Homepage - highest priority
        urls.push({
            loc: siteUrl + '/',
            lastmod: now,
            changefreq: 'daily',
            priority: '1.0'
        });
        
        // Book Now / Rooms page
        urls.push({
            loc: siteUrl + '/book-now/',
            lastmod: now,
            changefreq: 'daily',
            priority: '0.9'
        });
        
        // Individual rooms
        roomsResult.rows.forEach(room => {
            urls.push({
                loc: siteUrl + '/room/' + room.slug + '/',
                lastmod: room.updated_at ? new Date(room.updated_at).toISOString().split('T')[0] : now,
                changefreq: 'weekly',
                priority: '0.8'
            });
        });
        
        // Static pages (about, contact, etc.)
        const pageMap = {
            'about': '/about/',
            'contact': '/contact/',
            'gallery': '/gallery/',
            'dining': '/dining/',
            'terms': '/terms/',
            'privacy': '/privacy/',
            'faq': '/faq/'
        };
        
        pagesResult.rows.forEach(page => {
            if (pageMap[page.page_type]) {
                urls.push({
                    loc: siteUrl + pageMap[page.page_type],
                    lastmod: page.updated_at ? new Date(page.updated_at).toISOString().split('T')[0] : now,
                    changefreq: 'monthly',
                    priority: '0.6'
                });
            }
        });
        
        // Blog posts
        if (blogResult.rows.length > 0) {
            urls.push({
                loc: siteUrl + '/blog/',
                lastmod: now,
                changefreq: 'weekly',
                priority: '0.7'
            });
            
            blogResult.rows.forEach(post => {
                urls.push({
                    loc: siteUrl + '/blog/' + post.slug + '/',
                    lastmod: post.updated_at ? new Date(post.updated_at).toISOString().split('T')[0] : now,
                    changefreq: 'monthly',
                    priority: '0.6'
                });
            });
        }
        
        // Attractions
        if (attractionsResult.rows.length > 0) {
            urls.push({
                loc: siteUrl + '/attractions/',
                lastmod: now,
                changefreq: 'weekly',
                priority: '0.7'
            });
            
            attractionsResult.rows.forEach(attraction => {
                urls.push({
                    loc: siteUrl + '/attractions/' + attraction.slug + '/',
                    lastmod: attraction.updated_at ? new Date(attraction.updated_at).toISOString().split('T')[0] : now,
                    changefreq: 'monthly',
                    priority: '0.5'
                });
            });
        }
        
        // Build XML
        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
        xml += '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n';
        
        urls.forEach(url => {
            xml += '  <url>\n';
            xml += '    <loc>' + url.loc + '</loc>\n';
            xml += '    <lastmod>' + url.lastmod + '</lastmod>\n';
            xml += '    <changefreq>' + url.changefreq + '</changefreq>\n';
            xml += '    <priority>' + url.priority + '</priority>\n';
            xml += '  </url>\n';
        });
        
        xml += '</urlset>';
        
        res.set('Content-Type', 'application/xml');
        res.send(xml);
        
    } catch (error) {
        console.error('Sitemap error:', error);
        res.status(500).send('<!-- Error generating sitemap: ' + error.message + ' -->');
    }
});

// Generate robots.txt for a client
app.get('/api/public/client/:clientId/robots.txt', async (req, res) => {
    try {
        const { clientId } = req.params;
        const { baseUrl } = req.query;
        
        if (!baseUrl) {
            return res.status(400).send('# baseUrl query parameter required');
        }
        
        const siteUrl = baseUrl.replace(/\/$/, '');
        
        let robots = '';
        robots += '# Robots.txt for ' + siteUrl + '\n';
        robots += '# Generated by GAS\n\n';
        robots += 'User-agent: *\n';
        robots += 'Allow: /\n\n';
        robots += '# Disallow admin and API paths\n';
        robots += 'Disallow: /wp-admin/\n';
        robots += 'Disallow: /wp-includes/\n';
        robots += 'Disallow: /checkout/\n';
        robots += 'Disallow: /cart/\n';
        robots += 'Disallow: /my-account/\n';
        robots += 'Disallow: /*?*\n\n';
        robots += '# Sitemap\n';
        robots += 'Sitemap: ' + siteUrl + '/sitemap.xml\n';
        
        res.set('Content-Type', 'text/plain');
        res.send(robots);
        
    } catch (error) {
        console.error('Robots.txt error:', error);
        res.status(500).send('# Error generating robots.txt');
    }
});

// =========================================================
// WEBSITE BUILDER API
// =========================================================

// Create website_settings table if not exists
pool.query(`
  CREATE TABLE IF NOT EXISTS website_settings (
    id SERIAL PRIMARY KEY,
    account_id INTEGER NOT NULL,
    section VARCHAR(50) NOT NULL,
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(account_id, section)
  )
`).catch(err => console.log('Website settings table may already exist'));

// Migrate old client_id to account_id if needed
pool.query(`ALTER TABLE website_settings ADD COLUMN IF NOT EXISTS account_id INTEGER`).catch(() => {});
pool.query(`UPDATE website_settings SET account_id = client_id WHERE account_id IS NULL AND client_id IS NOT NULL`).catch(() => {});

// Get website builder section settings
app.get('/api/admin/website-builder/:section', async (req, res) => {
  try {
    const { section } = req.params;
    const accountId = req.query.account_id || req.query.client_id;
    
    if (!accountId) {
      return res.json({ success: false, error: 'account_id required' });
    }
    
    // Get account-based settings, most recent first
    const result = await pool.query(`
      SELECT settings FROM website_settings
      WHERE account_id = $1 AND section = $2
      ORDER BY updated_at DESC NULLS LAST
      LIMIT 1
    `, [accountId, section]);
    
    if (result.rows.length > 0) {
      res.json({ success: true, settings: result.rows[0].settings });
    } else {
      res.json({ success: true, settings: null });
    }
  } catch (error) {
    console.error('Get website settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Upload image for website builder (hero, about, etc.)
app.post('/api/admin/website-builder/upload-image', (req, res, next) => {
  upload.single('image')(req, res, (err) => {
    if (err) {
      console.error('Website image upload multer error:', err.message);
      return res.status(400).json({ success: false, error: err.message });
    }
    next();
  });
}, async (req, res) => {
  try {
    const { account_id, client_id, deployed_site_id, section } = req.body;
    
    if (!req.file) {
      return res.json({ success: false, error: 'No image uploaded' });
    }
    
    // IMPORTANT: Use client_id for website images (maps to deployed site)
    // Fall back to deployed_site_id, then account_id for backwards compatibility
    const entityId = client_id || deployed_site_id || account_id;
    
    if (!entityId) {
      return res.json({ success: false, error: 'client_id, deployed_site_id, or account_id required' });
    }
    
    console.log(`Website image upload: section=${section}, client_id=${client_id}, deployed_site_id=${deployed_site_id}, account_id=${account_id}, using entityId=${entityId}`);
    
    // Check R2 is configured
    if (!r2Client) {
      return res.status(500).json({ success: false, error: 'R2 storage not configured. Check R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY, R2_ENDPOINT env vars.' });
    }
    
    // Process and upload to R2
    const results = await processAndUploadImage(
      req.file.buffer,
      `website/${section || 'general'}`,
      entityId,
      req.file.originalname
    );
    
    res.json({ 
      success: true, 
      url: results.large, // Use large size for hero images
      urls: results
    });
  } catch (error) {
    console.error('Website image upload error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Video upload for website builder (hero backgrounds, etc.)
const videoUpload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 100 * 1024 * 1024 }, // 100MB max
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('video/')) {
      cb(null, true);
    } else {
      cb(new Error('Only video files allowed'), false);
    }
  }
});

app.post('/api/admin/website-builder/upload-video', (req, res, next) => {
  videoUpload.single('video')(req, res, (err) => {
    if (err) {
      console.error('Website video upload multer error:', err.message);
      return res.status(400).json({ success: false, error: err.message });
    }
    next();
  });
}, async (req, res) => {
  try {
    const { account_id, client_id, deployed_site_id, section } = req.body;
    
    if (!req.file) {
      return res.json({ success: false, error: 'No video uploaded' });
    }
    
    // IMPORTANT: Use client_id for website videos (maps to deployed site)
    // Fall back to deployed_site_id, then account_id for backwards compatibility
    const entityId = client_id || deployed_site_id || account_id;
    
    if (!entityId) {
      return res.json({ success: false, error: 'client_id, deployed_site_id, or account_id required' });
    }
    
    console.log(`Website video upload: section=${section}, client_id=${client_id}, using entityId=${entityId}`);
    
    // Generate unique filename
    const ext = req.file.originalname.split('.').pop().toLowerCase();
    const filename = `video-${Date.now()}-${uuidv4().slice(0, 8)}.${ext}`;
    const key = `website/${section || 'hero'}/client-${entityId}/${filename}`;
    
    // Upload directly to R2 (no processing needed for video)
    await r2Client.send(new PutObjectCommand({
      Bucket: R2_BUCKET,
      Key: key,
      Body: req.file.buffer,
      ContentType: req.file.mimetype
    }));
    
    // Construct public URL
    const publicUrl = `${process.env.R2_PUBLIC_URL || 'https://images.gas.travel'}/${key}`;
    
    console.log(`Video uploaded: ${publicUrl}`);
    
    res.json({ 
      success: true, 
      url: publicUrl
    });
  } catch (error) {
    console.error('Website video upload error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Save website builder section settings
app.post('/api/admin/website-builder/:section', async (req, res) => {
  try {
    const { section } = req.params;
    const { account_id, client_id, settings } = req.body;
    const accountId = account_id || client_id;
    
    if (!accountId) {
      return res.json({ success: false, error: 'account_id required' });
    }
    
    // Try update first
    const updateResult = await pool.query(
      'UPDATE website_settings SET settings = $1, updated_at = CURRENT_TIMESTAMP WHERE account_id = $2 AND section = $3',
      [JSON.stringify(settings), accountId, section]
    );
    
    if (updateResult.rowCount === 0) {
      // No existing row, insert new one
      await pool.query(
        'INSERT INTO website_settings (account_id, section, settings, updated_at) VALUES ($1, $2, $3, CURRENT_TIMESTAMP)',
        [accountId, section, JSON.stringify(settings)]
      );
      console.log(`Inserted website_settings for account ${accountId}, section ${section}`);
    } else {
      console.log(`Updated ${updateResult.rowCount} website_settings row(s) for account ${accountId}, section ${section}`);
    }
    
    res.json({ success: true, message: 'Settings saved' });
  } catch (error) {
    console.error('Save website settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get all website builder settings for an account (admin use)
app.get('/api/admin/website-builder', async (req, res) => {
  try {
    const accountId = req.query.account_id || req.query.client_id;
    
    if (!accountId) {
      return res.json({ success: false, error: 'account_id required' });
    }
    
    const result = await pool.query(
      'SELECT section, settings FROM website_settings WHERE account_id = $1',
      [accountId]
    );
    
    const allSettings = {};
    result.rows.forEach(row => {
      allSettings[row.section] = row.settings;
    });
    
    res.json({ success: true, settings: allSettings });
  } catch (error) {
    console.error('Get all website settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================
// PER-WEBSITE BUILDER ENDPOINTS (New System)
// ============================================

// Get theme registry (all available themes)
app.get('/api/themes', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT code, name, description, version, sections, thumbnail_url, 
             preview_url, is_premium, min_tier, sort_order
      FROM theme_registry
      WHERE is_active = true
      ORDER BY sort_order, name
    `);
    res.json({ success: true, themes: result.rows });
  } catch (error) {
    console.error('Get themes error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get specific theme schema
app.get('/api/themes/:code', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM theme_registry WHERE code = $1
    `, [req.params.code]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Theme not found' });
    }
    
    res.json({ success: true, theme: result.rows[0] });
  } catch (error) {
    console.error('Get theme error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get all settings for a specific website
app.get('/api/websites/:websiteId/builder', async (req, res) => {
  try {
    const { websiteId } = req.params;
    
    // Get website details
    const websiteResult = await pool.query(`
      SELECT w.*, tr.schema as theme_schema, tr.sections as theme_sections
      FROM websites w
      LEFT JOIN theme_registry tr ON w.template_code = tr.code
      WHERE w.id = $1 OR w.public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = websiteResult.rows[0];
    
    // Get all settings for this website
    const settingsResult = await pool.query(`
      SELECT section, settings, variant, is_enabled, display_order, last_synced_at, sync_source
      FROM website_settings
      WHERE website_id = $1
      ORDER BY display_order
    `, [website.id]);
    
    const settings = {};
    settingsResult.rows.forEach(row => {
      settings[row.section] = {
        settings: row.settings,
        variant: row.variant,
        is_enabled: row.is_enabled,
        display_order: row.display_order,
        last_synced_at: row.last_synced_at,
        sync_source: row.sync_source
      };
    });
    
    res.json({ 
      success: true, 
      website: {
        id: website.id,
        public_id: website.public_id,
        name: website.name,
        template_code: website.template_code,
        theme_mode: website.theme_mode,
        status: website.status,
        setup_complete: website.setup_complete,
        setup_progress: website.setup_progress,
        site_url: website.site_url,
        last_synced_at: website.last_synced_at
      },
      theme_schema: website.theme_schema,
      theme_sections: website.theme_sections,
      settings 
    });
  } catch (error) {
    console.error('Get website builder error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get specific section settings for a website
app.get('/api/websites/:websiteId/builder/:section', async (req, res) => {
  try {
    const { websiteId, section } = req.params;
    
    // Get website id - check websites table first, then deployed_sites
    const isNumeric = /^\d+$/.test(websiteId);
    let dbWebsiteId = null;
    let accountId = null;
    let isDeployedSite = false;
    
    if (isNumeric) {
      // First try websites table
      const websiteResult = await pool.query(`
        SELECT id, owner_id FROM websites WHERE id = $1
      `, [parseInt(websiteId)]);
      
      if (websiteResult.rows.length > 0) {
        dbWebsiteId = websiteResult.rows[0].id;
        accountId = websiteResult.rows[0].owner_id;
      } else {
        // Try deployed_sites table
        const deployedResult = await pool.query(`
          SELECT id, account_id FROM deployed_sites WHERE id = $1
        `, [parseInt(websiteId)]);
        
        if (deployedResult.rows.length > 0) {
          isDeployedSite = true;
          dbWebsiteId = deployedResult.rows[0].id;
          accountId = deployedResult.rows[0].account_id;
        }
      }
    } else {
      const websiteResult = await pool.query(`
        SELECT id, owner_id FROM websites WHERE public_id = $1
      `, [websiteId]);
      
      if (websiteResult.rows.length > 0) {
        dbWebsiteId = websiteResult.rows[0].id;
        accountId = websiteResult.rows[0].owner_id;
      }
    }
    
    if (!dbWebsiteId) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    // For deployed sites, load from deployed_site_id settings
    if (isDeployedSite) {
      const result = await pool.query(`
        SELECT settings, variant, is_enabled, display_order
        FROM website_settings
        WHERE deployed_site_id = $1 AND section = $2
        ORDER BY updated_at DESC NULLS LAST
        LIMIT 1
      `, [dbWebsiteId, section]);
      
      if (result.rows.length > 0) {
        res.json({ success: true, ...result.rows[0] });
      } else {
        res.json({ success: true, settings: null, is_enabled: true });
      }
    } else {
      const result = await pool.query(`
        SELECT settings, variant, is_enabled, display_order
        FROM website_settings
        WHERE website_id = $1 AND section = $2
      `, [dbWebsiteId, section]);
      
      if (result.rows.length > 0) {
        res.json({ success: true, ...result.rows[0] });
      } else {
        res.json({ success: true, settings: null, is_enabled: true });
      }
    }
  } catch (error) {
    console.error('Get website section error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Save section settings for a specific website
app.post('/api/websites/:websiteId/builder/:section', async (req, res) => {
  try {
    const { websiteId, section } = req.params;
    const { settings, variant, is_enabled, display_order } = req.body;
    
    // Get website id - check if numeric ID or public_id
    const isNumeric = /^\d+$/.test(websiteId);
    let websiteResult;
    let accountId;
    let dbWebsiteId;
    let isDeployedSite = false;
    
    if (isNumeric) {
      // First try websites table
      websiteResult = await pool.query(`
        SELECT id, owner_id FROM websites WHERE id = $1
      `, [parseInt(websiteId)]);
      
      // If not found, try deployed_sites table
      if (websiteResult.rows.length === 0) {
        websiteResult = await pool.query(`
          SELECT id, account_id FROM deployed_sites WHERE id = $1
        `, [parseInt(websiteId)]);
        if (websiteResult.rows.length > 0) {
          isDeployedSite = true;
          dbWebsiteId = websiteResult.rows[0].id;
          accountId = websiteResult.rows[0].account_id;
        }
      } else {
        dbWebsiteId = websiteResult.rows[0].id;
        accountId = websiteResult.rows[0].owner_id;
      }
    } else {
      websiteResult = await pool.query(`
        SELECT id, owner_id FROM websites WHERE public_id = $1
      `, [websiteId]);
      if (websiteResult.rows.length > 0) {
        dbWebsiteId = websiteResult.rows[0].id;
        accountId = websiteResult.rows[0].owner_id;
      }
    }
    
    if (!dbWebsiteId) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    // For deployed sites, use deployed_site_id column; for websites, use website_id
    if (isDeployedSite) {
      // Use simple update-first approach for deployed sites (account-based storage)
      const updateResult = await pool.query(
        'UPDATE website_settings SET settings = $1, sync_source = $2, updated_at = CURRENT_TIMESTAMP WHERE account_id = $3 AND section = $4',
        [JSON.stringify(settings), 'gas', accountId, section]
      );
      
      if (updateResult.rowCount === 0) {
        // No existing row, insert new one
        await pool.query(
          'INSERT INTO website_settings (account_id, section, settings, sync_source, updated_at) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)',
          [accountId, section, JSON.stringify(settings), 'gas']
        );
        console.log(`Inserted website_settings for deployed site, account ${accountId}, section ${section}`);
      } else {
        console.log(`Updated website_settings for deployed site, account ${accountId}, section ${section}`);
      }
    } else {
      // Upsert the settings for websites table entries
      await pool.query(`
        INSERT INTO website_settings (website_id, account_id, section, settings, variant, is_enabled, display_order, sync_source, updated_at)
        VALUES ($1, $2, $3, $4, $5, COALESCE($6, true), COALESCE($7, 0), 'gas', CURRENT_TIMESTAMP)
        ON CONFLICT (website_id, section) WHERE website_id IS NOT NULL
        DO UPDATE SET 
          settings = $4, 
          variant = COALESCE($5, website_settings.variant),
          is_enabled = COALESCE($6, website_settings.is_enabled),
          display_order = COALESCE($7, website_settings.display_order),
          sync_source = 'gas',
          updated_at = CURRENT_TIMESTAMP
      `, [dbWebsiteId, accountId, section, JSON.stringify(settings), variant, is_enabled, display_order]);
      
      // Update setup progress for websites
      await pool.query(`
        UPDATE websites 
        SET setup_progress = COALESCE(setup_progress, '{}'::jsonb) || $2::jsonb,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      `, [dbWebsiteId, JSON.stringify({ [section]: true })]);
    }
    
    res.json({ success: true, message: 'Settings saved' });
  } catch (error) {
    console.error('Save website section error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Save all settings for a website at once (bulk save)
app.post('/api/websites/:websiteId/builder', async (req, res) => {
  try {
    const { websiteId } = req.params;
    const { settings } = req.body; // { header: {...}, hero: {...}, ... }
    
    // Get website id
    const websiteResult = await pool.query(`
      SELECT id, owner_id FROM websites WHERE id = $1 OR public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const dbWebsiteId = websiteResult.rows[0].id;
    const accountId = websiteResult.rows[0].owner_id;
    
    const setupProgress = {};
    
    for (const [section, sectionData] of Object.entries(settings)) {
      await pool.query(`
        INSERT INTO website_settings (website_id, account_id, section, settings, sync_source, updated_at)
        VALUES ($1, $2, $3, $4, 'gas', CURRENT_TIMESTAMP)
        ON CONFLICT (website_id, section) WHERE website_id IS NOT NULL
        DO UPDATE SET settings = $4, sync_source = 'gas', updated_at = CURRENT_TIMESTAMP
      `, [dbWebsiteId, accountId, section, JSON.stringify(sectionData)]);
      
      setupProgress[section] = true;
    }
    
    // Update setup progress
    await pool.query(`
      UPDATE websites 
      SET setup_progress = $2,
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $1
    `, [dbWebsiteId, JSON.stringify(setupProgress)]);
    
    res.json({ success: true, message: 'All settings saved', sections: Object.keys(settings) });
  } catch (error) {
    console.error('Bulk save website settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Mark website setup as complete
app.post('/api/websites/:websiteId/complete-setup', async (req, res) => {
  try {
    const { websiteId } = req.params;
    
    // Get website and check required sections
    const websiteResult = await pool.query(`
      SELECT w.id, w.template_code, w.setup_progress, tr.sections as theme_sections
      FROM websites w
      LEFT JOIN theme_registry tr ON w.template_code = tr.code
      WHERE w.id = $1 OR w.public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = websiteResult.rows[0];
    const themeSections = website.theme_sections || {};
    const setupProgress = website.setup_progress || {};
    
    // Check all required sections are complete
    const missingSections = [];
    for (const [sectionCode, sectionConfig] of Object.entries(themeSections)) {
      if (sectionConfig.required && !setupProgress[sectionCode]) {
        missingSections.push(sectionConfig.label || sectionCode);
      }
    }
    
    if (missingSections.length > 0) {
      return res.json({ 
        success: false, 
        error: 'Required sections incomplete',
        missing: missingSections
      });
    }
    
    // Mark as complete
    await pool.query(`
      UPDATE websites SET setup_complete = true, updated_at = CURRENT_TIMESTAMP
      WHERE id = $1
    `, [website.id]);
    
    res.json({ success: true, message: 'Setup marked as complete' });
  } catch (error) {
    console.error('Complete setup error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Sync website settings to WordPress
app.post('/api/websites/:websiteId/sync-to-wordpress', async (req, res) => {
  try {
    const { websiteId } = req.params;
    const { sections } = req.body; // Optional: specific sections to sync, or all if not provided
    
    // Get website details
    const websiteResult = await pool.query(`
      SELECT w.*, ws.section, ws.settings
      FROM websites w
      LEFT JOIN website_settings ws ON w.id = ws.website_id
      WHERE w.id = $1 OR w.public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = websiteResult.rows[0];
    
    if (!website.site_url) {
      return res.json({ success: false, error: 'Website has no site URL' });
    }
    
    // Collect all settings to sync
    const allSettings = {};
    
    // Key mapping from GAS short keys to WordPress theme_mod keys
    const keyMapping = {
      // Hero section
      'image-url': 'developer_hero_bg',
      'video-url': 'developer_hero_video_url',
      'headline': 'developer_hero_title',
      'subheadline': 'developer_hero_subtitle',
      'overlay-color': 'developer_hero_overlay_color',
      'overlay': 'developer_hero_opacity',
      'height': 'developer_hero_height',
      'badge-text': 'developer_hero_badge',
      'badge-link': 'developer_hero_badge_link',
      'badge-bg': 'developer_hero_badge_bg',
      'badge-text-color': 'developer_hero_badge_text',
      'badge-border': 'developer_hero_badge_border',
      // Header section
      'logo-image-url': 'developer_logo_image',
      'logo-text': 'developer_logo_text',
      // Trust badges
      'trust-1': 'developer_hero_trust_1',
      'trust-2': 'developer_hero_trust_2',
      'trust-3': 'developer_hero_trust_3',
      'trust-text-color': 'trust_text_color',
      // Search button
      'search-btn-bg': 'search_btn_bg',
      'search-btn-text': 'search_btn_text',
      'search-label-color': 'search_label_color'
    };
    
    websiteResult.rows.forEach(row => {
      if (row.section && row.settings) {
        if (!sections || sections.includes(row.section)) {
          // Flatten settings for WordPress theme_mods
          if (typeof row.settings === 'object') {
            // Transform keys if mapping exists
            const transformedSettings = {};
            for (const [key, value] of Object.entries(row.settings)) {
              const wpKey = keyMapping[key] || key;
              transformedSettings[wpKey] = value;
            }
            Object.assign(allSettings, transformedSettings);
          }
        }
      }
    });
    
    // Get WordPress API settings - use deploy key directly
    const deployKey = 'gas-deploy-2024-secure-key';
    
    // Push to WordPress
    const wpResponse = await fetch('https://sites.gas.travel/gas-api.php', {
      method: 'POST',
      headers: {
        'X-API-Key': deployKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: 'update_settings',
        site_url: website.site_url,
        section: sections ? sections[0] : 'hero',
        settings: allSettings
      })
    });
    
    const wpData = await wpResponse.json();
    
    // Log the sync
    await pool.query(`
      INSERT INTO website_sync_log (website_id, direction, sections_synced, status, error_message, source_data)
      VALUES ($1, 'push', $2, $3, $4, $5)
    `, [
      website.id, 
      JSON.stringify(sections || Object.keys(allSettings)),
      wpData.success ? 'success' : 'failed',
      wpData.error || null,
      JSON.stringify(allSettings)
    ]);
    
    // Update website sync timestamp
    if (wpData.success) {
      await pool.query(`
        UPDATE websites SET last_synced_at = CURRENT_TIMESTAMP, sync_source = 'gas'
        WHERE id = $1
      `, [website.id]);
    }
    
    res.json({ 
      success: wpData.success, 
      message: wpData.success ? 'Settings synced to WordPress' : 'Sync failed',
      error: wpData.error
    });
  } catch (error) {
    console.error('Sync to WordPress error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Pull settings from WordPress
app.post('/api/websites/:websiteId/sync-from-wordpress', async (req, res) => {
  try {
    const { websiteId } = req.params;
    
    // Get website details
    const websiteResult = await pool.query(`
      SELECT * FROM websites WHERE id = $1 OR public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = websiteResult.rows[0];
    
    if (!website.site_url) {
      return res.json({ success: false, error: 'Website has no site URL' });
    }
    
    // Get WordPress API settings
    const wpSettings = await pool.query('SELECT api_key FROM instawp_settings LIMIT 1');
    const apiKey = wpSettings.rows[0]?.api_key;
    
    if (!apiKey) {
      return res.json({ success: false, error: 'WordPress API not configured' });
    }
    
    // Pull from WordPress
    const wpResponse = await fetch('https://sites.gas.travel/gas-api.php', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: 'get_theme_mods',
        site_url: website.site_url
      })
    });
    
    const wpData = await wpResponse.json();
    
    if (!wpData.success) {
      return res.json({ success: false, error: wpData.error || 'Failed to get WordPress settings' });
    }
    
    // Get theme schema to know how to group settings by section
    const themeResult = await pool.query(`
      SELECT sections FROM theme_registry WHERE code = $1
    `, [website.template_code]);
    
    const themeSections = themeResult.rows[0]?.sections || {};
    
    // Group WordPress settings by section based on field prefixes
    const settingsBySection = {};
    for (const [key, value] of Object.entries(wpData.theme_mods || {})) {
      for (const [sectionCode, sectionConfig] of Object.entries(themeSections)) {
        const fields = sectionConfig.fields || {};
        if (fields[key]) {
          if (!settingsBySection[sectionCode]) {
            settingsBySection[sectionCode] = {};
          }
          settingsBySection[sectionCode][key] = value;
          break;
        }
      }
    }
    
    // Save each section's settings
    for (const [section, settings] of Object.entries(settingsBySection)) {
      await pool.query(`
        INSERT INTO website_settings (website_id, account_id, section, settings, sync_source, last_synced_at, updated_at)
        VALUES ($1, $2, $3, $4, 'wordpress', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        ON CONFLICT (website_id, section) WHERE website_id IS NOT NULL
        DO UPDATE SET settings = $4, sync_source = 'wordpress', last_synced_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
      `, [website.id, website.owner_id, section, JSON.stringify(settings)]);
    }
    
    // Log the sync
    await pool.query(`
      INSERT INTO website_sync_log (website_id, direction, sections_synced, status, source_data)
      VALUES ($1, 'pull', $2, 'success', $3)
    `, [website.id, JSON.stringify(Object.keys(settingsBySection)), JSON.stringify(wpData.theme_mods)]);
    
    // Update website sync timestamp
    await pool.query(`
      UPDATE websites SET last_synced_at = CURRENT_TIMESTAMP, sync_source = 'wordpress'
      WHERE id = $1
    `, [website.id]);
    
    res.json({ 
      success: true, 
      message: 'Settings pulled from WordPress',
      sections_updated: Object.keys(settingsBySection)
    });
  } catch (error) {
    console.error('Sync from WordPress error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get sync history for a website
app.get('/api/websites/:websiteId/sync-log', async (req, res) => {
  try {
    const { websiteId } = req.params;
    
    const websiteResult = await pool.query(`
      SELECT id FROM websites WHERE id = $1 OR public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const result = await pool.query(`
      SELECT id, direction, sections_synced, status, error_message, created_at
      FROM website_sync_log
      WHERE website_id = $1
      ORDER BY created_at DESC
      LIMIT 50
    `, [websiteResult.rows[0].id]);
    
    res.json({ success: true, logs: result.rows });
  } catch (error) {
    console.error('Get sync log error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Change website theme
app.post('/api/websites/:websiteId/change-theme', async (req, res) => {
  try {
    const { websiteId } = req.params;
    const { theme_code } = req.body;
    
    // Verify theme exists
    const themeResult = await pool.query(`
      SELECT code, name, sections FROM theme_registry WHERE code = $1 AND is_active = true
    `, [theme_code]);
    
    if (themeResult.rows.length === 0) {
      return res.json({ success: false, error: 'Theme not found' });
    }
    
    // Get website
    const websiteResult = await pool.query(`
      SELECT id, template_code FROM websites WHERE id = $1 OR public_id = $1
    `, [websiteId]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = websiteResult.rows[0];
    const oldTheme = website.template_code;
    
    // Update website theme
    await pool.query(`
      UPDATE websites 
      SET template_code = $1, 
          setup_complete = false, 
          setup_progress = '{}',
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
    `, [theme_code, website.id]);
    
    // Clear old theme-specific settings (keep units, etc.)
    await pool.query(`
      DELETE FROM website_settings WHERE website_id = $1
    `, [website.id]);
    
    res.json({ 
      success: true, 
      message: `Theme changed from ${oldTheme} to ${theme_code}`,
      requires_setup: true
    });
  } catch (error) {
    console.error('Change theme error:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================
// END PER-WEBSITE BUILDER ENDPOINTS
// ============================================

// Get all website settings for a client (for WordPress sync)
app.get('/api/v1/website-settings', validateApiKey, async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT section, settings FROM website_settings
      WHERE account_id = $1
    `, [req.client.id]);
    
    // Convert to object keyed by section
    const allSettings = {};
    result.rows.forEach(row => {
      allSettings[row.section] = row.settings;
    });
    
    res.json({ success: true, settings: allSettings });
  } catch (error) {
    console.error('Get all website settings error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Push website settings to WordPress site
app.post('/api/admin/push-to-wordpress', async (req, res) => {
  try {
    const { account_id, section, settings, site_url } = req.body;
    
    if (!account_id || !section || !site_url) {
      return res.json({ success: false, error: 'Missing required fields' });
    }
    
    // Get WordPress multisite API settings
    const wpSettings = await pool.query('SELECT api_key FROM instawp_settings LIMIT 1');
    const apiKey = wpSettings.rows[0]?.api_key;
    
    if (!apiKey) {
      return res.json({ success: false, error: 'WordPress API not configured' });
    }
    
    // Push settings to WordPress via gas-api.php
    const wpResponse = await fetch('https://sites.gas.travel/gas-api.php', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: 'update_settings',
        account_id,
        section,
        settings,
        site_url
      })
    });
    
    const wpData = await wpResponse.json();
    
    if (wpData.success) {
      res.json({ success: true, message: 'Settings pushed to WordPress' });
    } else {
      res.json({ success: false, error: wpData.error || 'WordPress update failed' });
    }
  } catch (error) {
    console.error('Push to WordPress error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Receive settings push from WordPress (WP ‚Üí GAS bidirectional sync)
app.post('/api/gas-api/push-from-wordpress', async (req, res) => {
  try {
    const { action, client_id, section, settings } = req.body;
    
    console.log('Push from WordPress:', { action, client_id, section, keys: Object.keys(settings || {}) });
    
    if (action !== 'update_settings') {
      return res.json({ success: false, error: 'Invalid action' });
    }
    
    if (!client_id || !section || !settings) {
      return res.json({ success: false, error: 'Missing required fields: client_id, section, and settings are required' });
    }
    
    // Find website by client_id (owner_id) - check both websites and account_websites tables
    let websiteId;
    
    // First try the new websites table
    const websiteResult = await pool.query(`
      SELECT id FROM websites WHERE owner_id = $1 AND owner_type = 'account' LIMIT 1
    `, [client_id]);
    
    if (websiteResult.rows.length > 0) {
      websiteId = websiteResult.rows[0].id;
    } else {
      // Check if there's a legacy account_websites entry to migrate
      const legacyResult = await pool.query(`
        SELECT id, site_url, template_used FROM account_websites WHERE account_id = $1 LIMIT 1
      `, [client_id]);
      
      if (legacyResult.rows.length > 0) {
        // Create a website entry from legacy data
        const legacy = legacyResult.rows[0];
        const newWebsite = await pool.query(`
          INSERT INTO websites (public_id, owner_type, owner_id, name, site_url, template_code, status)
          VALUES ($1, 'account', $2, 'WordPress Site', $3, $4, 'active')
          RETURNING id
        `, [`WP-${client_id}-${Date.now()}`, client_id, legacy.site_url, legacy.template_used]);
        websiteId = newWebsite.rows[0].id;
        
        // Update legacy record with migration reference
        await pool.query(`
          UPDATE account_websites SET migrated_to_website_id = $1 WHERE id = $2
        `, [websiteId, legacy.id]);
      } else {
        // Create a fresh website entry
        const newWebsite = await pool.query(`
          INSERT INTO websites (public_id, owner_type, owner_id, name, status)
          VALUES ($1, 'account', $2, 'WordPress Site', 'active')
          RETURNING id
        `, [`WP-${client_id}-${Date.now()}`, client_id]);
        websiteId = newWebsite.rows[0].id;
      }
    }
    
    // Upsert settings to website_settings table
    await pool.query(`
      INSERT INTO website_settings (website_id, account_id, section, settings, updated_at)
      VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
      ON CONFLICT (website_id, section)
      DO UPDATE SET settings = $4, updated_at = CURRENT_TIMESTAMP
    `, [websiteId, client_id, section, JSON.stringify(settings)]);
    
    // Update website sync timestamp
    await pool.query(`
      UPDATE websites SET last_synced_at = CURRENT_TIMESTAMP, sync_source = 'wordpress'
      WHERE id = $1
    `, [websiteId]);
    
    // Log the sync event
    await pool.query(`
      INSERT INTO website_sync_log (website_id, direction, sections_synced, status)
      VALUES ($1, 'pull', $2, 'success')
    `, [websiteId, JSON.stringify([section])]);
    
    console.log(`‚úÖ WordPress push received: ${section} for website ${websiteId} (client ${client_id})`);
    
    res.json({ 
      success: true, 
      message: `Received ${section} settings from WordPress`,
      website_id: websiteId,
      section: section
    });
    
  } catch (error) {
    console.error('Push from WordPress error:', error);
    
    // Log failed sync attempt if we have enough info
    if (req.body?.client_id) {
      try {
        const websiteResult = await pool.query(`
          SELECT id FROM websites WHERE owner_id = $1 LIMIT 1
        `, [req.body.client_id]);
        
        if (websiteResult.rows.length > 0) {
          await pool.query(`
            INSERT INTO website_sync_log (website_id, direction, sections_synced, status, error_message)
            VALUES ($1, 'pull', $2, 'failed', $3)
          `, [websiteResult.rows[0].id, JSON.stringify([req.body.section || 'unknown']), error.message]);
        }
      } catch (logError) {
        console.error('Failed to log sync error:', logError);
      }
    }
    
    res.json({ success: false, error: error.message });
  }
});

// Get account website details
app.get('/api/account/:accountId/website', async (req, res) => {
  try {
    const { accountId } = req.params;
    
    const result = await pool.query(`
      SELECT * FROM account_websites 
      WHERE account_id = $1 AND status = 'active'
      ORDER BY created_at DESC LIMIT 1
    `, [accountId]);
    
    if (result.rows.length > 0) {
      res.json({ success: true, data: result.rows[0] });
    } else {
      res.json({ success: true, data: null });
    }
  } catch (error) {
    console.error('Get account website error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =========================================================
// AI CHAT ASSISTANT (GAS Support Bot)
// =========================================================

// Rate limiting for chat - simple in-memory store
const chatRateLimits = new Map();
const CHAT_RATE_LIMIT = 20; // messages per minute
const CHAT_RATE_WINDOW = 60000; // 1 minute

function checkChatRateLimit(ip) {
  const now = Date.now();
  const userLimits = chatRateLimits.get(ip) || { count: 0, resetAt: now + CHAT_RATE_WINDOW };
  
  if (now > userLimits.resetAt) {
    userLimits.count = 0;
    userLimits.resetAt = now + CHAT_RATE_WINDOW;
  }
  
  userLimits.count++;
  chatRateLimits.set(ip, userLimits);
  
  return userLimits.count <= CHAT_RATE_LIMIT;
}

// GAS Documentation context for the AI
const GAS_SYSTEM_PROMPT = `You are the GAS Assistant - a helpful, knowledgeable guide for the Global Accommodation System.

üîí WHAT GAS IS (CRITICAL - ALWAYS GET THIS RIGHT):
- GAS is the Global Accommodation System - an independent inventory and website system
- GAS is NOT an OTA (Online Travel Agency) like Booking.com, Airbnb, or Expedia
- GAS NEVER connects to corporate OTAs - only to independent channel managers (Beds24, Hostaway, Smoobu)
- GAS does NOT collect payments for owners - payments happen on the owner's own website
- GAS connects property owners with independent travel agents, tour operators, and tourist groups

üéØ YOUR ROLE:
- Help users understand and use GAS features
- Guide them through setup and configuration
- Answer questions about how things work
- Be conversational and supportive - stay with the user through their journey
- If you have knowledge base articles, use them to provide accurate, detailed answers
- If you don't know something, say so and suggest contacting support

üìö HOW TO USE KNOWLEDGE BASE ARTICLES:
When knowledge base articles are provided in the context, use them to:
- Give accurate, detailed answers
- Reference specific steps and instructions
- Provide the correct terminology
- Link to relevant features

üîó CHANNEL MANAGER CREDENTIALS:

BEDS24 INVITE CODE:
1. Log into Beds24 ‚Üí Settings (top menu)
2. Click Marketplace ‚Üí API
3. Click "Generate invite code"
4. Copy and paste into GAS

HOSTAWAY API:
1. Log into Hostaway ‚Üí Settings ‚Üí Hostaway API
2. Click "Create" ‚Üí Select "Hostaway Public API"
3. Copy Account ID and API Key immediately (only shown once!)

SMOOBU API:
1. Log into Smoobu ‚Üí Settings ‚Üí API
2. Copy your API Key

üîó KEY LINKS:
- Home: /home.html
- Onboarding: /index.html
- Admin Dashboard: /gas-admin.html
- Support: support@gettingautomated.com

üí¨ CONVERSATION STYLE:
- Be warm and helpful
- Give complete answers using knowledge base when available
- For complex topics, break things down step by step
- Always offer to help with follow-up questions
- Format links as clickable: [Text](/path)
- Use bullet points for lists and steps`;

// Search knowledge base for relevant articles
async function searchKnowledgeBase(query) {
  try {
    const searchTerms = query.toLowerCase().split(/\s+/).filter(t => t.length > 2);
    
    if (searchTerms.length === 0) {
      return [];
    }
    
    const result = await pool.query(`
      SELECT a.id, a.title, a.summary, a.content, a.keywords, c.name as category_name
      FROM kb_articles a
      LEFT JOIN kb_categories c ON a.category_id = c.id
      WHERE a.status = 'published'
        AND (
          LOWER(a.title) LIKE $1
          OR LOWER(a.summary) LIKE $1
          OR LOWER(a.content) LIKE $1
          OR a.keywords && $2::text[]
        )
      ORDER BY 
        CASE WHEN LOWER(a.title) LIKE $1 THEN 1 ELSE 2 END,
        a.views DESC
      LIMIT 3
    `, [`%${query.toLowerCase()}%`, searchTerms]);
    
    return result.rows;
  } catch (error) {
    console.error('Knowledge base search error:', error);
    return [];
  }
}

// Track unanswered questions
async function trackUnansweredQuestion(question, sessionId, accountId) {
  try {
    // Check if similar question exists
    const existing = await pool.query(`
      SELECT id, times_asked FROM kb_unanswered 
      WHERE LOWER(question) LIKE $1 AND status = 'new'
      LIMIT 1
    `, [`%${question.toLowerCase().substring(0, 50)}%`]);
    
    if (existing.rows.length > 0) {
      // Increment counter
      await pool.query(
        'UPDATE kb_unanswered SET times_asked = times_asked + 1, updated_at = NOW() WHERE id = $1',
        [existing.rows[0].id]
      );
    } else {
      // Insert new
      await pool.query(`
        INSERT INTO kb_unanswered (question, session_id, account_id)
        VALUES ($1, $2, $3)
      `, [question, sessionId, accountId]);
    }
  } catch (error) {
    console.error('Track unanswered error:', error);
  }
}

// Chat endpoint
app.post('/api/chat', async (req, res) => {
  try {
    // Rate limiting
    const clientIp = req.ip || req.connection.remoteAddress;
    if (!checkChatRateLimit(clientIp)) {
      return res.status(429).json({ 
        success: false, 
        error: 'Too many messages. Please wait a moment before sending more.' 
      });
    }
    
    const { message, conversationHistory = [], sessionId, accountId } = req.body;
    
    if (!message || typeof message !== 'string') {
      return res.status(400).json({ success: false, error: 'Message is required' });
    }
    
    // Limit message length
    if (message.length > 1000) {
      return res.status(400).json({ success: false, error: 'Message too long (max 1000 characters)' });
    }
    
    // Search knowledge base for relevant articles
    const relevantArticles = await searchKnowledgeBase(message);
    
    // Build knowledge context if articles found
    let knowledgeContext = '';
    if (relevantArticles.length > 0) {
      knowledgeContext = '\n\nüìö RELEVANT KNOWLEDGE BASE ARTICLES:\n';
      for (const article of relevantArticles) {
        knowledgeContext += `\n--- ${article.title} (${article.category_name}) ---\n`;
        if (article.summary) knowledgeContext += `Summary: ${article.summary}\n`;
        // Include content but truncate if too long
        const content = article.content.length > 1500 
          ? article.content.substring(0, 1500) + '...'
          : article.content;
        knowledgeContext += `${content}\n`;
      }
      knowledgeContext += '\n---\nUse the above articles to provide accurate, helpful answers.\n';
    }
    
    // Limit conversation history to last 10 messages to control token usage
    const recentHistory = conversationHistory.slice(-10);
    
    // Build messages array for Claude
    const messages = [
      ...recentHistory.map(msg => ({
        role: msg.role,
        content: msg.content
      })),
      { role: 'user', content: message }
    ];
    
    // Build system prompt with knowledge context
    const systemPrompt = GAS_SYSTEM_PROMPT + knowledgeContext;
    
    // Call Claude API
    const response = await axios.post('https://api.anthropic.com/v1/messages', {
      model: 'claude-sonnet-4-20250514',
      max_tokens: 800,
      system: systemPrompt,
      messages: messages
    }, {
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      }
    });
    
    const assistantMessage = response.data.content[0].text;
    
    // Check if the response indicates uncertainty - track for review
    const uncertaintyIndicators = [
      "i don't have specific information",
      "i'm not sure about",
      "contact support",
      "i don't know",
      "i cannot find"
    ];
    
    const isUncertain = uncertaintyIndicators.some(indicator => 
      assistantMessage.toLowerCase().includes(indicator)
    );
    
    if (isUncertain && relevantArticles.length === 0) {
      // Track this as potentially unanswered
      await trackUnansweredQuestion(message, sessionId, accountId);
    }
    
    res.json({ 
      success: true, 
      message: assistantMessage,
      articlesUsed: relevantArticles.map(a => a.id)
    });
    
  } catch (error) {
    console.error('Chat error:', error.response?.data || error.message);
    res.status(500).json({ 
      success: false, 
      error: 'Sorry, I encountered an error. Please try again or contact support@gettingautomated.com' 
    });
  }
});

// ONE-TIME FIX: Recreate website_settings table (visit once then remove)
app.get('/api/admin/fix-website-settings-table', async (req, res) => {
  try {
    await pool.query('DROP TABLE IF EXISTS website_settings CASCADE');
    await pool.query(`
      CREATE TABLE website_settings (
        id SERIAL PRIMARY KEY,
        account_id INTEGER NOT NULL,
        section VARCHAR(50) NOT NULL,
        settings JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(account_id, section)
      )
    `);
    await pool.query('CREATE INDEX IF NOT EXISTS idx_website_settings_account ON website_settings(account_id)');
    res.json({ success: true, message: 'Table recreated successfully!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// ONE-TIME FIX: Create client_api_keys table
app.get('/api/admin/fix-api-keys-table', async (req, res) => {
  try {
    await pool.query('DROP TABLE IF EXISTS client_api_keys CASCADE');
    await pool.query(`
      CREATE TABLE client_api_keys (
        id SERIAL PRIMARY KEY,
        client_id INTEGER NOT NULL,
        key_name VARCHAR(100) DEFAULT 'Default',
        api_key VARCHAR(64) NOT NULL UNIQUE,
        permissions JSONB DEFAULT '{}',
        rate_limit_per_minute INTEGER DEFAULT 60,
        rate_limit_per_day INTEGER DEFAULT 10000,
        total_requests INTEGER DEFAULT 0,
        allowed_origins TEXT,
        expires_at TIMESTAMP,
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_used_at TIMESTAMP
      )
    `);
    await pool.query('CREATE INDEX IF NOT EXISTS idx_api_keys_client ON client_api_keys(client_id)');
    await pool.query('CREATE INDEX IF NOT EXISTS idx_api_keys_key ON client_api_keys(api_key)');
    res.json({ success: true, message: 'API keys table created successfully!' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// MULTI-WEBSITE API ENDPOINTS
// =====================================================

// Helper function to generate public ID
function generateWebsitePublicId() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let id = 'WEB-';
  for (let i = 0; i < 6; i++) {
    id += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return id;
}

// Get all websites (with optional all=true for master_admin)
app.get('/api/websites', async (req, res) => {
  try {
    const { owner_type, owner_id, all } = req.query;
    
    let result;
    
    if (all === 'true') {
      result = await pool.query(`
        SELECT w.*, 
               wt.name as template_name,
               a.name as account_name,
               (SELECT COUNT(*) FROM website_units wu WHERE wu.website_id = w.id AND wu.is_active = true) as unit_count
        FROM websites w
        LEFT JOIN website_templates wt ON w.template_code = wt.code
        LEFT JOIN accounts a ON w.owner_id = a.id AND w.owner_type = 'account'
        ORDER BY w.created_at DESC
      `);
    } else {
      if (!owner_id) {
        return res.json({ success: false, error: 'owner_id required' });
      }
      
      const ownerType = owner_type || 'account';
      
      result = await pool.query(`
        SELECT w.*, 
               wt.name as template_name,
               (SELECT COUNT(*) FROM website_units wu WHERE wu.website_id = w.id AND wu.is_active = true) as unit_count
        FROM websites w
        LEFT JOIN website_templates wt ON w.template_code = wt.code
        WHERE w.owner_type = $1 AND w.owner_id = $2
        ORDER BY w.created_at DESC
      `, [ownerType, owner_id]);
    }
    
    res.json({ success: true, websites: result.rows });
  } catch (error) {
    console.error('Get websites error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get single website with units
app.get('/api/websites/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const websiteResult = await pool.query(`
      SELECT w.*, wt.name as template_name
      FROM websites w
      LEFT JOIN website_templates wt ON w.template_code = wt.code
      WHERE w.id = $1
    `, [id]);
    
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const unitsResult = await pool.query(`
      SELECT wu.*, bu.name as unit_name, bu.display_name, p.name as property_name, p.city
      FROM website_units wu
      JOIN bookable_units bu ON wu.unit_id = bu.id
      JOIN properties p ON bu.property_id = p.id
      WHERE wu.website_id = $1
      ORDER BY wu.display_order, bu.name
    `, [id]);
    
    res.json({ 
      success: true, 
      website: websiteResult.rows[0],
      units: unitsResult.rows 
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Create new website
app.post('/api/websites', async (req, res) => {
  try {
    const { owner_type, owner_id, name, slug, template_code, website_type, site_url, admin_url, status } = req.body;
    
    if (!owner_id || !name) {
      return res.json({ success: false, error: 'owner_id and name required' });
    }
    
    const publicId = generateWebsitePublicId();
    
    const result = await pool.query(`
      INSERT INTO websites (public_id, owner_type, owner_id, name, slug, template_code, website_type, site_url, admin_url, status)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *
    `, [publicId, owner_type || 'account', owner_id, name, slug, template_code || 'starter', website_type || 'portfolio', site_url, admin_url, status || 'draft']);
    
    res.json({ success: true, website: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update website
app.put('/api/websites/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, slug, custom_domain, status, template_code, website_type, site_url, admin_url } = req.body;
    
    const result = await pool.query(`
      UPDATE websites SET
        name = COALESCE($2, name),
        slug = COALESCE($3, slug),
        custom_domain = COALESCE($4, custom_domain),
        status = COALESCE($5, status),
        template_code = COALESCE($6, template_code),
        website_type = COALESCE($7, website_type),
        site_url = COALESCE($8, site_url),
        admin_url = COALESCE($9, admin_url),
        updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `, [id, name, slug, custom_domain, status, template_code, website_type, site_url, admin_url]);
    
    res.json({ success: true, website: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete website
app.delete('/api/websites/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM websites WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update website status (with validation)
app.put('/api/websites/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    // Validate status
    const validStatuses = ['development', 'deployed', 'live', 'on-hold'];
    if (!validStatuses.includes(status)) {
      return res.json({ success: false, error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` });
    }
    
    // If setting to 'live', check if custom_domain is set (optional enforcement)
    if (status === 'live') {
      const website = await pool.query('SELECT custom_domain FROM websites WHERE id = $1', [id]);
      if (website.rows.length > 0 && !website.rows[0].custom_domain) {
        console.log('Note: Setting status to live without custom domain for website', id);
        // Allow it but log - master can override
      }
    }
    
    const result = await pool.query(`
      UPDATE websites SET status = $2, updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `, [id, status]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    console.log(`Website ${id} status updated to: ${status}`);
    res.json({ success: true, website: result.rows[0] });
  } catch (error) {
    console.error('Update website status error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get units on a website
app.get('/api/websites/:id/units', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT wu.*, bu.name as unit_name, bu.display_name, p.name as property_name, p.city
      FROM website_units wu
      JOIN bookable_units bu ON wu.unit_id = bu.id
      JOIN properties p ON bu.property_id = p.id
      WHERE wu.website_id = $1
      ORDER BY wu.display_order, bu.name
    `, [id]);
    
    res.json({ success: true, units: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get available units for a website (units owned by this account not already on website)
app.get('/api/websites/:id/available-units', async (req, res) => {
  try {
    const { id } = req.params;
    
    const websiteResult = await pool.query('SELECT * FROM websites WHERE id = $1', [id]);
    if (websiteResult.rows.length === 0) {
      return res.json({ success: false, error: 'Website not found' });
    }
    
    const website = websiteResult.rows[0];
    
    const result = await pool.query(`
      SELECT bu.*, p.name as property_name, p.city
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1
      AND bu.id NOT IN (SELECT unit_id FROM website_units WHERE website_id = $2)
      ORDER BY p.name, bu.name
    `, [website.owner_id, id]);
    
    res.json({ success: true, units: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add units to website
app.post('/api/websites/:id/units', async (req, res) => {
  try {
    const { id } = req.params;
    const { unit_ids } = req.body;
    
    if (!unit_ids || !Array.isArray(unit_ids) || unit_ids.length === 0) {
      return res.json({ success: false, error: 'unit_ids array required' });
    }
    
    for (const unitId of unit_ids) {
      await pool.query(`
        INSERT INTO website_units (website_id, unit_id)
        VALUES ($1, $2)
        ON CONFLICT (website_id, unit_id) DO NOTHING
      `, [id, unitId]);
    }
    
    res.json({ success: true, added: unit_ids.length });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Update unit on website (featured, order, etc)
app.put('/api/websites/:id/units/:unitId', async (req, res) => {
  try {
    const { id, unitId } = req.params;
    const { is_featured, display_order, custom_name } = req.body;
    
    await pool.query(`
      UPDATE website_units SET
        is_featured = COALESCE($3, is_featured),
        display_order = COALESCE($4, display_order),
        custom_name = COALESCE($5, custom_name)
      WHERE website_id = $1 AND unit_id = $2
    `, [id, unitId, is_featured, display_order, custom_name]);
    
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Remove unit from website
app.delete('/api/websites/:id/units/:unitId', async (req, res) => {
  try {
    const { id, unitId } = req.params;
    await pool.query('DELETE FROM website_units WHERE website_id = $1 AND unit_id = $2', [id, unitId]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Migrate deployed_sites to new websites table
app.post('/api/websites/migrate', async (req, res) => {
  try {
    await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS migrated_to_website_id INTEGER`);
    
    const oldSites = await pool.query(`
      SELECT ds.*, a.name as account_name 
      FROM deployed_sites ds
      LEFT JOIN accounts a ON ds.account_id = a.id
      WHERE ds.migrated_to_website_id IS NULL AND ds.status != 'deleted'
    `);
    
    const migrated = [];
    
    for (const old of oldSites.rows) {
      const publicId = generateWebsitePublicId();
      
      const newSite = await pool.query(`
        INSERT INTO websites (
          public_id, owner_type, owner_id, name, template_code,
          site_url, admin_url, status
        ) VALUES ($1, 'account', $2, $3, $4, $5, $6, $7)
        RETURNING *
      `, [
        publicId,
        old.account_id,
        old.site_name || old.account_name || 'My Website',
        'starter',
        old.site_url,
        old.admin_url,
        old.status === 'deployed' ? 'active' : (old.status || 'active')
      ]);
      
      const websiteId = newSite.rows[0].id;
      
      // Add all units from this account to the website
      await pool.query(`
        INSERT INTO website_units (website_id, unit_id, display_order)
        SELECT $1, bu.id, ROW_NUMBER() OVER (ORDER BY p.name, bu.name)
        FROM bookable_units bu
        JOIN properties p ON bu.property_id = p.id
        WHERE p.account_id = $2
        ON CONFLICT DO NOTHING
      `, [websiteId, old.account_id]);
      
      // Mark old site as migrated
      await pool.query(
        'UPDATE deployed_sites SET migrated_to_website_id = $1 WHERE id = $2',
        [websiteId, old.id]
      );
      
      migrated.push({ old_id: old.id, new_id: websiteId, public_id: publicId, name: old.site_name || old.account_name });
    }
    
    res.json({ 
      success: true, 
      message: `Migrated ${migrated.length} websites`,
      migrated 
    });
  } catch (error) {
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// SCHEDULED SYNC - All Channel Managers
// =====================================================
async function syncAllChannelManagers() {
  console.log('üîÑ Starting scheduled sync for all channel managers...');
  
  try {
    // Get all clients with CM connections
    const clientsResult = await pool.query(`
      SELECT DISTINCT c.id, c.name,
        (SELECT setting_value FROM client_settings WHERE client_id = c.id AND setting_key = 'smoobu_api_key') as smoobu_key,
        (SELECT setting_value FROM client_settings WHERE client_id = c.id AND setting_key = 'hostaway_api_key') as hostaway_key
      FROM clients c
      WHERE EXISTS (SELECT 1 FROM client_settings cs WHERE cs.client_id = c.id AND cs.setting_key LIKE '%_api_key')
    `);
    
    for (const client of clientsResult.rows) {
      // Sync Smoobu
      if (client.smoobu_key) {
        try {
          const smoobuProps = await pool.query(`
            SELECT bu.id as room_id, bu.smoobu_id
            FROM bookable_units bu
            JOIN properties p ON bu.property_id = p.id
            WHERE p.client_id = $1 AND bu.smoobu_id IS NOT NULL
          `, [client.id]);
          
          if (smoobuProps.rows.length > 0) {
            const apartmentIds = smoobuProps.rows.map(r => r.smoobu_id);
            const startDate = new Date().toISOString().split('T')[0];
            const endDate = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            
            const ratesResponse = await axios.get(
              `https://login.smoobu.com/api/rates?${apartmentIds.map(id => `apartments[]=${id}`).join('&')}&start_date=${startDate}&end_date=${endDate}`,
              { headers: { 'Api-Key': client.smoobu_key, 'Cache-Control': 'no-cache' } }
            );
            
            for (const room of smoobuProps.rows) {
              const apartmentRates = ratesResponse.data.data?.[room.smoobu_id];
              if (!apartmentRates) continue;
              
              for (const [date, info] of Object.entries(apartmentRates)) {
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, is_available, cm_price, standard_price, min_stay, source)
                  VALUES ($1, $2, $3, $4, $4, $5, 'smoobu')
                  ON CONFLICT (room_id, date) DO UPDATE SET
                    is_available = EXCLUDED.is_available, cm_price = EXCLUDED.cm_price,
                    standard_price = EXCLUDED.standard_price, min_stay = EXCLUDED.min_stay,
                    source = EXCLUDED.source, updated_at = NOW()
                `, [room.room_id, date, info.available > 0, info.price || null, info.min_length_of_stay || null]);
              }
            }
            console.log(`  ‚úÖ Synced Smoobu for ${client.name}`);
          }
        } catch (e) {
          console.log(`  ‚ùå Smoobu sync failed for ${client.name}: ${e.message}`);
        }
      }
      
      // Sync Hostaway
      if (client.hostaway_key) {
        try {
          // Similar logic for Hostaway...
          console.log(`  ‚úÖ Synced Hostaway for ${client.name}`);
        } catch (e) {
          console.log(`  ‚ùå Hostaway sync failed for ${client.name}: ${e.message}`);
        }
      }
    }
    
    // =====================================================
    // NEW: Sync Hostaway via gas_sync_connections
    // =====================================================
    try {
      const hostawayConnections = await pool.query(`
        SELECT * FROM gas_sync_connections 
        WHERE adapter_code = 'hostaway' AND sync_enabled = true AND status = 'connected'
      `);
      
      for (const conn of hostawayConnections.rows) {
        try {
          console.log(`  üîÑ Syncing Hostaway for account ${conn.account_id}...`);
          
          const credentials = typeof conn.credentials === 'string' 
            ? JSON.parse(conn.credentials) 
            : conn.credentials || {};
          
          // Get fresh token
          let token = conn.access_token;
          if (!token && credentials.accountId && credentials.apiKey) {
            const tokenResponse = await axios.post(
              'https://api.hostaway.com/v1/accessTokens',
              `grant_type=client_credentials&client_id=${credentials.accountId}&client_secret=${credentials.apiKey}`,
              { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
            );
            token = tokenResponse.data?.access_token;
            if (token) {
              await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [token, conn.id]);
            }
          }
          
          if (!token) {
            console.log(`    ‚ùå Could not get Hostaway token for account ${conn.account_id}`);
            continue;
          }
          
          // Get Hostaway rooms for this connection
          const roomsResult = await pool.query(`
            SELECT bu.id as room_id, bu.hostaway_listing_id, bu.name
            FROM bookable_units bu
            JOIN properties p ON bu.property_id = p.id
            WHERE p.account_id = $1 AND bu.hostaway_listing_id IS NOT NULL
          `, [conn.account_id]);
          
          if (roomsResult.rows.length === 0) {
            console.log(`    ‚ö†Ô∏è No Hostaway rooms for account ${conn.account_id}`);
            continue;
          }
          
          // Sync availability for next 90 days
          const today = new Date().toISOString().split('T')[0];
          const endDate = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
          let totalDays = 0;
          
          for (const room of roomsResult.rows) {
            try {
              const calResponse = await axios.get(
                `https://api.hostaway.com/v1/listings/${room.hostaway_listing_id}/calendar`,
                {
                  headers: { 'Authorization': `Bearer ${token}` },
                  params: { startDate: today, endDate: endDate }
                }
              );
              
              const calendar = calResponse.data?.result || [];
              
              for (const day of calendar) {
                const isAvailable = day.status === 'available';
                const isBlocked = day.status === 'blocked';
                
                await pool.query(`
                  INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, source)
                  VALUES ($1, $2, $3, $3, $4, $5, $6, 'hostaway')
                  ON CONFLICT (room_id, date) DO UPDATE SET
                    cm_price = COALESCE($3, room_availability.cm_price),
                    direct_price = COALESCE($3, room_availability.direct_price),
                    is_available = $4, is_blocked = $5, min_stay = $6,
                    source = 'hostaway', updated_at = NOW()
                `, [room.room_id, day.date, day.price || null, isAvailable, isBlocked, day.minimumStay || 1]);
                
                totalDays++;
              }
              
              // Rate limit
              await new Promise(r => setTimeout(r, 700));
            } catch (roomErr) {
              console.log(`    ‚ö†Ô∏è Failed to sync ${room.name}: ${roomErr.message}`);
            }
          }
          
          // Update last sync time
          await pool.query('UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1', [conn.id]);
          
          console.log(`  ‚úÖ Synced Hostaway account ${conn.account_id}: ${roomsResult.rows.length} rooms, ${totalDays} days`);
        } catch (connErr) {
          console.log(`  ‚ùå Hostaway sync failed for connection ${conn.id}: ${connErr.message}`);
        }
      }
    } catch (hostawayErr) {
      console.log(`  ‚ùå Hostaway scheduled sync error: ${hostawayErr.message}`);
    }
    
    console.log('üîÑ Scheduled sync complete');
  } catch (error) {
    console.error('Scheduled sync error:', error.message);
  }
}

// Run sync every 15 minutes
const SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutes
setInterval(syncAllChannelManagers, SYNC_INTERVAL);

// Also run once on startup (after 30 seconds to let DB connect)
setTimeout(syncAllChannelManagers, 30000);

// =========================================================
// BEDS24 SPECIFIC SCHEDULED SYNC
// =========================================================

// Helper function to run Beds24 bookings sync
async function runBeds24BookingsSync() {
  try {
    console.log('‚è∞ [Scheduled] Starting Beds24 bookings sync...');
    
    const accessToken = await getBeds24AccessToken(pool);
    const today = new Date();
    const fromDate = new Date(today);
    fromDate.setDate(fromDate.getDate() - 7);
    const toDate = new Date(today);
    toDate.setDate(toDate.getDate() + 365);
    
    const response = await axios.get('https://beds24.com/api/v2/bookings', {
      headers: { 'token': accessToken },
      params: {
        arrivalFrom: fromDate.toISOString().split('T')[0],
        arrivalTo: toDate.toISOString().split('T')[0]
      }
    });
    
    const bookings = Array.isArray(response.data) ? response.data : (response.data.data || []);
    let updatedDates = 0;
    let unblockedDates = 0;
    let gasBookingsCancelled = 0;
    
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      
      for (const booking of bookings) {
        const beds24RoomId = booking.roomId || booking.room_id || booking.unitId;
        if (!beds24RoomId) continue;
        
        const roomResult = await client.query(
          'SELECT id FROM bookable_units WHERE beds24_room_id = $1',
          [beds24RoomId]
        );
        if (roomResult.rows.length === 0) continue;
        
        const ourRoomId = roomResult.rows[0].id;
        const arrival = booking.arrival || booking.firstNight || booking.arrivalDate;
        const departure = booking.departure || booking.lastNight || booking.departureDate;
        if (!arrival || !departure) continue;
        
        const isCancelled = booking.status === 'cancelled' || booking.status === 'Cancelled';
        
        // If cancelled, check if we have a matching GAS booking to cancel
        if (isCancelled) {
          const gasBookingResult = await client.query(`
            UPDATE bookings 
            SET status = 'cancelled', updated_at = NOW()
            WHERE beds24_booking_id = $1 AND status != 'cancelled'
            RETURNING id
          `, [booking.id.toString()]);
          
          if (gasBookingResult.rowCount > 0) {
            gasBookingsCancelled++;
          }
        }
        
        const startDate = new Date(arrival);
        const endDate = new Date(departure);
        
        for (let d = new Date(startDate); d < endDate; d.setDate(d.getDate() + 1)) {
          const dateStr = d.toISOString().split('T')[0];
          
          if (isCancelled) {
            // Unblock cancelled booking dates (only if blocked by beds24)
            const result = await client.query(`
              UPDATE room_availability 
              SET is_available = true, is_blocked = false, source = 'beds24_cancelled', updated_at = NOW()
              WHERE room_id = $1 AND date = $2 AND source IN ('beds24_sync', 'beds24_webhook', 'beds24_inventory', 'booking')
            `, [ourRoomId, dateStr]);
            if (result.rowCount > 0) unblockedDates++;
          } else {
            // Block confirmed booking dates
            await client.query(`
              INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
              VALUES ($1, $2, false, false, 'beds24_sync')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET is_available = false, source = 'beds24_sync', updated_at = NOW()
            `, [ourRoomId, dateStr]);
            updatedDates++;
          }
        }
      }
      
      await client.query('COMMIT');
    } finally {
      client.release();
    }
    
    console.log(`‚è∞ [Scheduled] Beds24 bookings sync complete: ${bookings.length} bookings, ${updatedDates} blocked, ${unblockedDates} unblocked, ${gasBookingsCancelled} GAS cancelled`);
  } catch (error) {
    console.error('‚è∞ [Scheduled] Beds24 bookings sync error:', error.message);
  }
}
async function runBeds24InventorySync() {
  try {
    console.log('‚è∞ [Scheduled] Starting Beds24 full inventory sync...');
    
    const accessToken = await getBeds24AccessToken(pool);
    const today = new Date();
    
    const roomsResult = await pool.query(`
      SELECT bu.id, bu.beds24_room_id, bu.name 
      FROM bookable_units bu 
      WHERE bu.beds24_room_id IS NOT NULL
    `);
    
    const rooms = roomsResult.rows;
    const startDate = today.toISOString().split('T')[0];
    const endDate = new Date(today.getTime() + 365*24*60*60*1000).toISOString().split('T')[0];
    
    let inventoryBlocksFound = 0;
    let datesUnblocked = 0;
    
    for (const room of rooms) {
      try {
        const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
          headers: { 'token': accessToken },
          params: { roomId: room.beds24_room_id, startDate, endDate }
        });
        
        const data = availResponse.data?.data?.[0];
        if (data && data.availability) {
          for (const [dateStr, isAvailable] of Object.entries(data.availability)) {
            if (isAvailable === false) {
              inventoryBlocksFound++;
              await pool.query(`
                INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
                VALUES ($1, $2, false, true, 'beds24_inventory')
                ON CONFLICT (room_id, date) 
                DO UPDATE SET is_available = false, is_blocked = true, 
                  source = CASE WHEN room_availability.source IN ('beds24_sync', 'booking') THEN room_availability.source ELSE 'beds24_inventory' END,
                  updated_at = NOW()
              `, [room.id, dateStr]);
            } else {
              // Unblock if it was blocked by beds24
              const result = await pool.query(`
                UPDATE room_availability 
                SET is_available = true, is_blocked = false, source = 'beds24_unblocked', updated_at = NOW()
                WHERE room_id = $1 AND date = $2 AND source IN ('beds24_inventory', 'beds24_sync', 'beds24_webhook')
              `, [room.id, dateStr]);
              if (result.rowCount > 0) datesUnblocked++;
            }
          }
        }
      } catch (roomError) {
        // Silently skip errors for individual rooms
      }
    }
    
    console.log(`‚è∞ [Scheduled] Beds24 inventory sync complete: ${inventoryBlocksFound} blocked, ${datesUnblocked} unblocked from ${rooms.length} rooms`);
  } catch (error) {
    console.error('‚è∞ [Scheduled] Beds24 inventory sync error:', error.message);
  }
}

// Schedule Beds24 bookings sync every 15 minutes
setInterval(runBeds24BookingsSync, 15 * 60 * 1000);

// Schedule Beds24 full inventory sync every 6 hours
setInterval(runBeds24InventorySync, 6 * 60 * 60 * 1000);

// =========================================================
// HOSTAWAY SCHEDULED RESERVATIONS SYNC
// =========================================================

async function runHostawayReservationsSync() {
  try {
    console.log('‚è∞ [Scheduled] Starting Hostaway reservations sync...');
    
    const connections = await pool.query(`
      SELECT * FROM gas_sync_connections 
      WHERE adapter_code = 'hostaway' AND sync_enabled = true AND status = 'connected'
    `);
    
    if (connections.rows.length === 0) {
      console.log('‚è∞ [Scheduled] No active Hostaway connections');
      return;
    }
    
    let totalCreated = 0;
    let totalUpdated = 0;
    
    for (const conn of connections.rows) {
      try {
        const credentials = typeof conn.credentials === 'string' 
          ? JSON.parse(conn.credentials) 
          : conn.credentials || {};
        
        // Get fresh token
        let token = conn.access_token;
        if (!token && credentials.accountId && credentials.apiKey) {
          const tokenResponse = await axios.post(
            'https://api.hostaway.com/v1/accessTokens',
            `grant_type=client_credentials&client_id=${credentials.accountId}&client_secret=${credentials.apiKey}`,
            { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
          );
          token = tokenResponse.data?.access_token;
        }
        
        if (!token) continue;
        
        // Get room mapping
        const roomsResult = await pool.query(`
          SELECT bu.id as room_id, bu.hostaway_listing_id, p.id as property_id, p.account_id
          FROM bookable_units bu
          JOIN properties p ON bu.property_id = p.id
          WHERE p.account_id = $1 AND bu.hostaway_listing_id IS NOT NULL
        `, [conn.account_id]);
        
        const roomsByListingId = {};
        roomsResult.rows.forEach(r => { roomsByListingId[r.hostaway_listing_id] = r; });
        
        // Fetch reservations (last 30 days + future)
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - 30);
        
        const reservationsResponse = await axios.get('https://api.hostaway.com/v1/reservations', {
          headers: { 'Authorization': `Bearer ${token}` },
          params: {
            limit: 200,
            arrivalStartDate: startDate.toISOString().split('T')[0]
          }
        });
        
        const reservations = reservationsResponse.data?.result || [];
        
        for (const res of reservations) {
          const room = roomsByListingId[String(res.listingMapId)];
          if (!room) continue;
          
          // Check if exists
          const existing = await pool.query(
            'SELECT id FROM bookings WHERE hostaway_reservation_id = $1',
            [String(res.id)]
          );
          
          const statusMap = {
            'new': 'confirmed', 'confirmed': 'confirmed', 'modified': 'confirmed',
            'cancelled': 'cancelled', 'declined': 'cancelled', 'expired': 'cancelled'
          };
          const gasStatus = statusMap[res.status] || 'confirmed';
          
          if (existing.rows.length > 0) {
            await pool.query(`
              UPDATE bookings SET status = $1, updated_at = NOW() WHERE id = $2
            `, [gasStatus, existing.rows[0].id]);
            totalUpdated++;
          } else if (gasStatus !== 'cancelled') {
            await pool.query(`
              INSERT INTO bookings (
                property_id, room_id, account_id, check_in, check_out,
                guest_first_name, guest_last_name, guest_email, guest_phone,
                num_adults, total_price, currency, status,
                hostaway_reservation_id, channel_name, source, created_at, updated_at
              ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 'hostaway', NOW(), NOW())
            `, [
              room.property_id, room.room_id, room.account_id,
              res.arrivalDate, res.departureDate,
              res.guestFirstName || 'Guest', res.guestLastName || '',
              res.guestEmail || '', res.guestPhone || '',
              res.adults || res.numberOfGuests || 1,
              res.totalPrice || 0, res.currency || 'USD', gasStatus,
              String(res.id), res.channelName || 'Hostaway'
            ]);
            totalCreated++;
          }
        }
        
        await pool.query('UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1', [conn.id]);
        
      } catch (connErr) {
        console.log(`‚è∞ [Scheduled] Hostaway reservations error for connection ${conn.id}: ${connErr.message}`);
      }
    }
    
    console.log(`‚è∞ [Scheduled] Hostaway reservations sync complete: ${totalCreated} created, ${totalUpdated} updated`);
  } catch (error) {
    console.error('‚è∞ [Scheduled] Hostaway reservations sync error:', error.message);
  }
}

// Schedule Hostaway reservations sync every 15 minutes
setInterval(runHostawayReservationsSync, 15 * 60 * 1000);

// Run initial Hostaway sync 90 seconds after startup
setTimeout(runHostawayReservationsSync, 90 * 1000);

// OLD GasSync availability sync - DISABLED (replaced by tiered sync)
// This was causing "column name does not exist" error
// The tiered sync (startTieredSyncScheduler) now handles all availability syncing
/*
async function runGasSyncAvailabilitySync() {
  // ... disabled - using tiered sync instead
}
setInterval(runGasSyncAvailabilitySync, 15 * 60 * 1000);
*/

// Run initial Beds24 sync 60 seconds after startup
setTimeout(() => {
  runBeds24BookingsSync();
  runBeds24InventorySync();
}, 60 * 1000);

// OLD: Run initial GasSync availability sync - DISABLED (function is commented out)
// Using tiered sync instead which starts automatically
/*
setTimeout(() => {
  runGasSyncAvailabilitySync();
}, 120 * 1000);
*/

// =====================================================
// GASSYNC API ROUTES
// Channel Manager Integration Layer
// =====================================================

// Get all available adapters
app.get('/api/gas-sync/adapters', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, code, name, description, logo_url, auth_type, 
             capabilities, supports_webhooks, webhook_events, is_active
      FROM gas_sync_adapters
      WHERE is_active = true
      ORDER BY name
    `);
    
    // If no adapters in database, return hardcoded defaults
    if (result.rows.length === 0) {
      const defaultAdapters = [
        { id: 1, code: 'beds24', name: 'Beds24', description: 'PMS + Channel Manager', auth_type: 'oauth2', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations', 'images'], is_active: true },
        { id: 3, code: 'hostaway', name: 'Hostaway', description: 'Vacation Rental Software', auth_type: 'api_key', capabilities: ['properties', 'reservations', 'availability'], is_active: true },
        { id: 4, code: 'smoobu', name: 'Smoobu', description: 'Channel Manager', auth_type: 'api_key', capabilities: ['properties', 'reservations', 'availability'], is_active: true },
        { id: 10, code: 'calry_hostify', name: 'Hostify', description: 'Property Management Platform', auth_type: 'wizard', wizard_url: '/hostify-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 11, code: 'calry_lodgify', name: 'Lodgify', description: 'Vacation Rental Software', auth_type: 'wizard', wizard_url: '/lodgify-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 12, code: 'calry_hostfully', name: 'Hostfully', description: 'Property Management Platform', auth_type: 'wizard', wizard_url: '/hostfully-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 13, code: 'calry_guesty', name: 'Guesty', description: 'Property Management Platform', auth_type: 'wizard', wizard_url: '/guesty-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 14, code: 'calry_cloudbeds', name: 'Cloudbeds', description: 'Hospitality Management Suite', auth_type: 'wizard', wizard_url: '/cloudbeds-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 15, code: 'calry_ownerrez', name: 'OwnerRez', description: 'Vacation Rental Software', auth_type: 'wizard', wizard_url: '/ownerrez-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 16, code: 'calry_hospitable', name: 'Hospitable', description: 'Vacation Rental Automation', auth_type: 'wizard', wizard_url: '/hospitable-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 17, code: 'calry_uplisting', name: 'Uplisting', description: 'Channel Manager & PMS', auth_type: 'wizard', wizard_url: '/uplisting-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 18, code: 'calry_tokeet', name: 'Tokeet', description: 'Rental Management Software', auth_type: 'wizard', wizard_url: '/tokeet-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 19, code: 'calry_avantio', name: 'Avantio', description: 'Vacation Rental Software', auth_type: 'wizard', wizard_url: '/avantio-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
        { id: 7, code: 'other', name: 'Other / Not Listed', description: 'Request integration for unlisted PMS', auth_type: 'contact', capabilities: [], is_active: true }
      ];
      return res.json({ success: true, adapters: defaultAdapters });
    }
    
    res.json({ success: true, adapters: result.rows });
  } catch (error) {
    console.error('Error fetching adapters:', error);
    // Return hardcoded defaults on error
    const defaultAdapters = [
      { id: 1, code: 'beds24', name: 'Beds24', description: 'PMS + Channel Manager', auth_type: 'oauth2', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations', 'images'], is_active: true },
      { id: 3, code: 'hostaway', name: 'Hostaway', description: 'Vacation Rental Software', auth_type: 'api_key', capabilities: ['properties', 'reservations', 'availability'], is_active: true },
      { id: 4, code: 'smoobu', name: 'Smoobu', description: 'Channel Manager', auth_type: 'api_key', capabilities: ['properties', 'reservations', 'availability'], is_active: true },
      { id: 10, code: 'calry_hostify', name: 'Hostify', description: 'Property Management Platform', auth_type: 'wizard', wizard_url: '/hostify-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 11, code: 'calry_lodgify', name: 'Lodgify', description: 'Vacation Rental Software', auth_type: 'wizard', wizard_url: '/lodgify-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 12, code: 'calry_hostfully', name: 'Hostfully', description: 'Property Management Platform', auth_type: 'wizard', wizard_url: '/hostfully-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 13, code: 'calry_guesty', name: 'Guesty', description: 'Property Management Platform', auth_type: 'wizard', wizard_url: '/guesty-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 14, code: 'calry_cloudbeds', name: 'Cloudbeds', description: 'Hospitality Management Suite', auth_type: 'wizard', wizard_url: '/cloudbeds-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 15, code: 'calry_ownerrez', name: 'OwnerRez', description: 'Vacation Rental Software', auth_type: 'wizard', wizard_url: '/ownerrez-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 16, code: 'calry_hospitable', name: 'Hospitable', description: 'Vacation Rental Automation', auth_type: 'wizard', wizard_url: '/hospitable-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 17, code: 'calry_uplisting', name: 'Uplisting', description: 'Channel Manager & PMS', auth_type: 'wizard', wizard_url: '/uplisting-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 18, code: 'calry_tokeet', name: 'Tokeet', description: 'Rental Management Software', auth_type: 'wizard', wizard_url: '/tokeet-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 19, code: 'calry_avantio', name: 'Avantio', description: 'Vacation Rental Software', auth_type: 'wizard', wizard_url: '/avantio-wizard', capabilities: ['properties', 'room_types', 'availability', 'rates', 'reservations'], is_active: true },
      { id: 7, code: 'other', name: 'Other / Not Listed', description: 'Request integration for unlisted PMS', auth_type: 'contact', capabilities: [], is_active: true }
    ];
    res.json({ success: true, adapters: defaultAdapters });
  }
});

// Get all connections for an account
app.get('/api/gas-sync/connections', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    
    let result;
    if (accountId) {
      // Filter by specific account
      result = await pool.query(`
        SELECT c.id, c.account_id, c.adapter_code, c.status, c.credentials,
               c.external_account_id, c.external_account_name,
               COALESCE(c.external_account_name, acc.name, 'Unnamed') as connection_name,
               c.sync_enabled, c.sync_interval_minutes,
               c.last_sync_at, c.next_sync_at, c.last_error, c.last_error_at,
               c.webhook_registered, c.created_at, c.updated_at,
               a.name as adapter_name, a.logo_url as adapter_logo,
               a.capabilities as adapter_capabilities,
               acc.name as account_name,
               (SELECT COUNT(*) FROM gas_sync_properties WHERE connection_id = c.id) as property_count,
               (SELECT COUNT(*) FROM gas_sync_room_types WHERE connection_id = c.id) as room_type_count,
               (SELECT COUNT(*) FROM gas_sync_reservations WHERE connection_id = c.id AND status = 'confirmed') as reservation_count
        FROM gas_sync_connections c
        JOIN gas_sync_adapters a ON c.adapter_code = a.code
        LEFT JOIN accounts acc ON c.account_id = acc.id
        WHERE c.account_id = $1
        ORDER BY c.created_at DESC
      `, [accountId]);
    } else {
      // No filter - return all connections (for master admin)
      result = await pool.query(`
        SELECT c.id, c.account_id, c.adapter_code, c.status, c.credentials,
               c.external_account_id, c.external_account_name,
               COALESCE(c.external_account_name, acc.name, 'Unnamed') as connection_name,
               c.sync_enabled, c.sync_interval_minutes,
               c.last_sync_at, c.next_sync_at, c.last_error, c.last_error_at,
               c.webhook_registered, c.created_at, c.updated_at,
               a.name as adapter_name, a.logo_url as adapter_logo,
               a.capabilities as adapter_capabilities,
               acc.name as account_name,
               (SELECT COUNT(*) FROM gas_sync_properties WHERE connection_id = c.id) as property_count,
               (SELECT COUNT(*) FROM gas_sync_room_types WHERE connection_id = c.id) as room_type_count,
               (SELECT COUNT(*) FROM gas_sync_reservations WHERE connection_id = c.id AND status = 'confirmed') as reservation_count
        FROM gas_sync_connections c
        JOIN gas_sync_adapters a ON c.adapter_code = a.code
        LEFT JOIN accounts acc ON c.account_id = acc.id
        ORDER BY c.created_at DESC
      `);
    }
    
    // Mask sensitive credentials but show last 5 chars of V1 API key
    const connections = result.rows.map(conn => {
      let v1KeyMasked = null;
      if (conn.credentials) {
        const creds = typeof conn.credentials === 'string' ? JSON.parse(conn.credentials) : conn.credentials;
        const v1Key = creds.v1ApiKey || creds.apiKey;
        if (v1Key && v1Key.length > 5) {
          v1KeyMasked = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + v1Key.slice(-5);
        } else if (v1Key) {
          v1KeyMasked = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
        }
      }
      delete conn.credentials; // Don't send full credentials
      
      // Add webhook URL for Hostaway connections
      let webhook_url = null;
      let webhook_instructions = null;
      if (conn.adapter_code === 'hostaway') {
        webhook_url = 'https://admin.gas.travel/api/webhooks/hostaway';
        webhook_instructions = 'Add this URL in Hostaway Dashboard ‚Üí Settings ‚Üí Integrations ‚Üí Unified Webhooks';
      }
      
      return { ...conn, v1_key_masked: v1KeyMasked, webhook_url, webhook_instructions };
    });
    
    res.json({ success: true, connections });
  } catch (error) {
    console.error('Error fetching connections:', error);
    // Return empty array instead of error - table might not exist yet
    res.json({ success: true, connections: [] });
  }
});

// Admin: Get ALL connections across all accounts
app.get('/api/admin/gas-sync/connections', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT c.id, c.account_id, c.adapter_code, c.status, 
             c.external_account_id, c.external_account_name,
             COALESCE(c.external_account_name, acc.name, 'Unnamed') as connection_name,
             c.sync_enabled, c.sync_interval_minutes,
             c.last_sync_at, c.next_sync_at, c.last_error, c.last_error_at,
             c.webhook_registered, c.created_at, c.updated_at,
             a.name as adapter_name, a.logo_url as adapter_logo,
             acc.name as account_name, acc.email as account_email,
             (SELECT COUNT(*) FROM gas_sync_properties WHERE connection_id = c.id) as property_count,
             (SELECT COUNT(*) FROM gas_sync_room_types WHERE connection_id = c.id) as room_type_count
      FROM gas_sync_connections c
      JOIN gas_sync_adapters a ON c.adapter_code = a.code
      LEFT JOIN accounts acc ON c.account_id = acc.id
      ORDER BY c.created_at DESC
    `);
    
    // Add webhook URL for Hostaway connections
    const connections = result.rows.map(conn => {
      if (conn.adapter_code === 'hostaway') {
        conn.webhook_url = 'https://admin.gas.travel/api/webhooks/hostaway';
        conn.webhook_instructions = 'Add this URL in Hostaway Dashboard ‚Üí Settings ‚Üí Integrations ‚Üí Unified Webhooks';
      }
      return conn;
    });
    
    res.json({ success: true, connections });
  } catch (error) {
    console.error('Error fetching all connections:', error);
    res.json({ success: false, error: error.message });
  }
});

// GasSync stats endpoint for dashboard
app.get('/api/gas-sync/stats', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    
    let stats;
    
    if (accountId) {
      // Filtered by account
      stats = await pool.query(`
        SELECT 
          (SELECT COUNT(*) FROM gas_sync_connections WHERE account_id = $1) as connections,
          (SELECT COUNT(*) FROM gas_sync_properties p 
           JOIN gas_sync_connections c ON p.connection_id = c.id WHERE c.account_id = $1) as properties,
          (SELECT COUNT(*) FROM gas_sync_room_types rt 
           JOIN gas_sync_connections c ON rt.connection_id = c.id WHERE c.account_id = $1) as room_types,
          (SELECT COUNT(*) FROM gas_sync_reservations r 
           JOIN gas_sync_connections c ON r.connection_id = c.id 
           WHERE c.account_id = $1 AND r.status = 'confirmed') as reservations,
          (SELECT COUNT(*) FROM gas_sync_images i 
           JOIN gas_sync_connections c ON i.connection_id = c.id WHERE c.account_id = $1) as images,
          (SELECT COUNT(*) FROM gas_sync_connections 
           WHERE account_id = $1 AND last_error IS NOT NULL) as errors
      `, [accountId]);
    } else {
      // All accounts (for master admin)
      stats = await pool.query(`
        SELECT 
          (SELECT COUNT(*) FROM gas_sync_connections) as connections,
          (SELECT COUNT(*) FROM gas_sync_properties) as properties,
          (SELECT COUNT(*) FROM gas_sync_room_types) as room_types,
          (SELECT COUNT(*) FROM gas_sync_reservations WHERE status = 'confirmed') as reservations,
          (SELECT COUNT(*) FROM gas_sync_images) as images,
          (SELECT COUNT(*) FROM gas_sync_connections WHERE last_error IS NOT NULL) as errors
      `);
    }
    
    res.json({ 
      success: true, 
      stats: {
        connections: parseInt(stats.rows[0].connections) || 0,
        properties: parseInt(stats.rows[0].properties) || 0,
        room_types: parseInt(stats.rows[0].room_types) || 0,
        reservations: parseInt(stats.rows[0].reservations) || 0,
        images: parseInt(stats.rows[0].images) || 0,
        errors: parseInt(stats.rows[0].errors) || 0
      }
    });
  } catch (error) {
    console.error('Error fetching gas-sync stats:', error);
    res.json({ 
      success: true, 
      stats: { connections: 0, properties: 0, room_types: 0, reservations: 0, images: 0, errors: 0 }
    });
  }
});

// GasSync status endpoint for dashboard (matches frontend field names)
app.get('/api/gas-sync/status', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    
    let stats;
    
    if (accountId) {
      stats = await pool.query(`
        SELECT 
          (SELECT COUNT(*) FROM gas_sync_connections WHERE account_id = $1) as connections,
          (SELECT COUNT(*) FROM gas_sync_properties p 
           JOIN gas_sync_connections c ON p.connection_id = c.id WHERE c.account_id = $1) as properties,
          (SELECT COUNT(*) FROM gas_sync_room_types rt 
           JOIN gas_sync_connections c ON rt.connection_id = c.id WHERE c.account_id = $1) as room_types,
          (SELECT COUNT(*) FROM gas_sync_reservations r 
           JOIN gas_sync_connections c ON r.connection_id = c.id 
           WHERE c.account_id = $1 AND r.status = 'confirmed') as reservations,
          (SELECT COUNT(*) FROM gas_sync_images i 
           JOIN gas_sync_connections c ON i.connection_id = c.id WHERE c.account_id = $1) as images,
          (SELECT COUNT(*) FROM gas_sync_connections 
           WHERE account_id = $1 AND last_error IS NOT NULL) as errors
      `, [accountId]);
    } else {
      stats = await pool.query(`
        SELECT 
          (SELECT COUNT(*) FROM gas_sync_connections) as connections,
          (SELECT COUNT(*) FROM gas_sync_properties) as properties,
          (SELECT COUNT(*) FROM gas_sync_room_types) as room_types,
          (SELECT COUNT(*) FROM gas_sync_reservations WHERE status = 'confirmed') as reservations,
          (SELECT COUNT(*) FROM gas_sync_images) as images,
          (SELECT COUNT(*) FROM gas_sync_connections WHERE last_error IS NOT NULL) as errors
      `);
    }
    
    // Get recent sync activity
    const activity = await pool.query(`
      SELECT l.*, c.adapter_code 
      FROM gas_sync_logs l
      JOIN gas_sync_connections c ON l.connection_id = c.id
      ORDER BY l.started_at DESC
      LIMIT 10
    `);
    
    res.json({ 
      success: true, 
      stats: {
        active_connections: parseInt(stats.rows[0].connections) || 0,
        total_properties: parseInt(stats.rows[0].properties) || 0,
        total_room_types: parseInt(stats.rows[0].room_types) || 0,
        active_reservations: parseInt(stats.rows[0].reservations) || 0,
        total_images: parseInt(stats.rows[0].images) || 0,
        error_connections: parseInt(stats.rows[0].errors) || 0
      },
      recent_activity: activity.rows
    });
  } catch (error) {
    console.error('Error fetching gas-sync status:', error);
    res.json({ 
      success: true, 
      stats: { 
        active_connections: 0, total_properties: 0, total_room_types: 0, 
        active_reservations: 0, total_images: 0, error_connections: 0 
      },
      recent_activity: []
    });
  }
});

// Get single connection details
app.get('/api/gas-sync/connections/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT c.*, a.name as adapter_name, a.logo_url as adapter_logo,
             a.capabilities as adapter_capabilities, a.auth_type
      FROM gas_sync_connections c
      JOIN gas_sync_adapters a ON c.adapter_code = a.code
      WHERE c.id = $1
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const connection = result.rows[0];
    
    // Add masked V1 key for Beds24
    let v1KeyMasked = null;
    if (connection.credentials) {
      const creds = typeof connection.credentials === 'string' ? JSON.parse(connection.credentials) : connection.credentials;
      const v1Key = creds.v1ApiKey || creds.apiKey;
      if (v1Key && v1Key.length > 5) {
        v1KeyMasked = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + v1Key.slice(-5);
      } else if (v1Key) {
        v1KeyMasked = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
      }
    }
    connection.v1_key_masked = v1KeyMasked;
    
    // Add webhook URL for Hostaway connections
    if (connection.adapter_code === 'hostaway') {
      connection.webhook_url = 'https://admin.gas.travel/api/webhooks/hostaway';
      connection.webhook_instructions = 'Add this URL in Hostaway Dashboard ‚Üí Settings ‚Üí Integrations ‚Üí Unified Webhooks';
    }
    
    delete connection.credentials;
    delete connection.access_token;
    delete connection.refresh_token;
    
    res.json({ success: true, connection });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Create new connection
app.post('/api/gas-sync/connections', async (req, res) => {
  try {
    const { 
      account_id, 
      adapter_code, 
      credentials,
      sync_enabled = true,
      sync_interval_minutes = 15
    } = req.body;
    
    // Validate adapter exists
    const adapterCheck = await pool.query(
      'SELECT id FROM gas_sync_adapters WHERE code = $1 AND is_active = true',
      [adapter_code]
    );
    
    if (adapterCheck.rows.length === 0) {
      return res.status(400).json({ success: false, error: 'Invalid adapter code' });
    }
    
    // Check for existing connection
    const existingCheck = await pool.query(
      'SELECT id FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = $2',
      [account_id, adapter_code]
    );
    
    if (existingCheck.rows.length > 0) {
      return res.status(400).json({ 
        success: false, 
        error: 'Connection already exists for this adapter',
        existing_id: existingCheck.rows[0].id
      });
    }
    
    // Special handling for Beds24 - exchange invite code for token
    const beds24InviteCode = credentials.token || credentials.inviteCode;
    if (adapter_code === 'beds24' && beds24InviteCode) {
      try {
        console.log('Beds24: Exchanging invite code for token...');
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/setup', {
          headers: {
            'accept': 'application/json',
            'code': beds24InviteCode
          }
        });
        
        if (tokenResponse.data.token && tokenResponse.data.refreshToken) {
          credentials.token = tokenResponse.data.token;
          credentials.refreshToken = tokenResponse.data.refreshToken;
          credentials.expiresIn = tokenResponse.data.expiresIn;
          // Remove invite code from credentials since we now have the token
          delete credentials.inviteCode;
          console.log('Beds24: Got access token and refresh token');
        } else {
          return res.status(400).json({ 
            success: false, 
            error: 'Failed to exchange invite code. Please generate a new one.' 
          });
        }
      } catch (tokenError) {
        console.error('Beds24 token exchange error:', tokenError.response?.data || tokenError.message);
        return res.status(400).json({ 
          success: false, 
          error: `Invalid invite code: ${tokenError.response?.data?.error || tokenError.message}` 
        });
      }
    }
    
    // Test the connection before saving
    try {
      const adapter = getAdapter(adapter_code, credentials);
      const testResult = await adapter.testConnection();
      
      if (!testResult.success) {
        return res.status(400).json({ 
          success: false, 
          error: `Connection test failed: ${testResult.error}` 
        });
      }
    } catch (testError) {
      return res.status(400).json({ 
        success: false, 
        error: `Failed to initialize adapter: ${testError.message}` 
      });
    }
    
    // Create the connection
    const result = await pool.query(`
      INSERT INTO gas_sync_connections (
        account_id, adapter_code, credentials, 
        access_token, refresh_token, token_expires_at,
        status, sync_enabled, sync_interval_minutes,
        external_account_id, external_account_name,
        next_sync_at
      ) VALUES ($1, $2, $3, $4, $5, $6, 'connected', $7, $8, $9, $10, NOW())
      RETURNING id
    `, [
      account_id,
      adapter_code,
      JSON.stringify(credentials),
      credentials.token || credentials.access_token,
      credentials.refreshToken || credentials.refresh_token,
      credentials.expiresAt,
      sync_enabled,
      sync_interval_minutes,
      credentials.externalAccountId || credentials.workspaceId,
      credentials.externalAccountName || credentials.accountName
    ]);
    
    const connectionId = result.rows[0].id;
    
    // Trigger initial sync in background
    syncManager.syncConnection(connectionId, 'full').catch(err => {
      console.error(`Initial sync failed for connection ${connectionId}:`, err);
    });
    
    res.json({ 
      success: true, 
      connection_id: connectionId,
      message: 'Connection created. Initial sync started in background.'
    });
  } catch (error) {
    console.error('Error creating connection:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Update connection
app.put('/api/gas-sync/connections/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { 
      credentials, 
      sync_enabled, 
      sync_interval_minutes,
      external_account_name 
    } = req.body;
    
    const updates = [];
    const values = [id];
    let paramCount = 1;
    
    if (credentials !== undefined) {
      paramCount++;
      updates.push(`credentials = $${paramCount}`);
      values.push(JSON.stringify(credentials));
      
      if (credentials.token) {
        paramCount++;
        updates.push(`access_token = $${paramCount}`);
        values.push(credentials.token);
      }
    }
    
    if (sync_enabled !== undefined) {
      paramCount++;
      updates.push(`sync_enabled = $${paramCount}`);
      values.push(sync_enabled);
    }
    
    if (sync_interval_minutes !== undefined) {
      paramCount++;
      updates.push(`sync_interval_minutes = $${paramCount}`);
      values.push(sync_interval_minutes);
    }
    
    if (external_account_name !== undefined) {
      paramCount++;
      updates.push(`external_account_name = $${paramCount}`);
      values.push(external_account_name);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ success: false, error: 'No updates provided' });
    }
    
    updates.push('updated_at = NOW()');
    
    await pool.query(`
      UPDATE gas_sync_connections SET ${updates.join(', ')} WHERE id = $1
    `, values);
    
    res.json({ success: true, message: 'Connection updated' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Delete connection
app.delete('/api/gas-sync/connections/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Delete all related data first (foreign key order)
    await pool.query('DELETE FROM gas_sync_logs WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_images WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_reservations WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_room_types WHERE connection_id = $1', [id]);
    await pool.query('DELETE FROM gas_sync_properties WHERE connection_id = $1', [id]);
    
    // Now delete the connection
    await pool.query('DELETE FROM gas_sync_connections WHERE id = $1', [id]);
    
    res.json({ success: true, message: 'Connection and all synced data deleted' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Test connection
app.post('/api/gas-sync/connections/:id/test', async (req, res) => {
  try {
    const { id } = req.params;
    
    const adapter = await syncManager.getAdapterForConnection(id);
    const result = await adapter.testConnection();
    
    await pool.query(`
      UPDATE gas_sync_connections SET 
        status = $2,
        last_error = $3,
        last_error_at = $4,
        updated_at = NOW()
      WHERE id = $1
    `, [
      id,
      result.success ? 'connected' : 'error',
      result.success ? null : result.error,
      result.success ? null : new Date()
    ]);
    
    res.json({ success: result.success, message: result.message || result.error });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Trigger sync for a connection
app.post('/api/gas-sync/connections/:id/sync', async (req, res) => {
  try {
    const { id } = req.params;
    const { type = 'full', syncType } = req.body;  // Default to full, accept both type and syncType
    const actualType = syncType || type;
    
    console.log(`Starting ${actualType} sync for connection ${id}`);
    
    await pool.query(`
      UPDATE gas_sync_connections SET status = 'syncing', updated_at = NOW() WHERE id = $1
    `, [id]);
    
    syncManager.syncConnection(id, actualType)
      .then(async (result) => {
        await pool.query(`
          UPDATE gas_sync_connections SET status = 'connected', updated_at = NOW() WHERE id = $1
        `, [id]);
        console.log(`Sync completed for connection ${id}:`, result.stats);
      })
      .catch(async (error) => {
        await pool.query(`
          UPDATE gas_sync_connections SET 
            status = 'error', 
            last_error = $2, 
            last_error_at = NOW(),
            updated_at = NOW() 
          WHERE id = $1
        `, [id, error.message]);
        console.error(`Sync failed for connection ${id}:`, error);
      });
    
    res.json({ success: true, message: `${actualType} sync started` });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Immediate price sync for a connection (called after wizard import)
app.post('/api/gas-sync/connections/:id/sync-prices', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get connection with access token
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [id]);
    if (connResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    const accessToken = conn.access_token;
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token for connection' });
    }
    
    // Get all rooms for this connection that have beds24_room_id set
    const roomsResult = await pool.query(`
      SELECT bu.id, bu.name, bu.beds24_room_id, bu.property_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN gas_sync_properties sp ON sp.gas_property_id = p.id
      WHERE sp.connection_id = $1 AND bu.beds24_room_id IS NOT NULL
    `, [id]);
    
    console.log(`sync-prices: Found ${roomsResult.rows.length} rooms for connection ${id}`);
    
    if (roomsResult.rows.length === 0) {
      return res.json({ success: true, message: 'No rooms with beds24_room_id found', rooms: 0 });
    }
    
    let daysUpdated = 0;
    const today = new Date();
    const endDate = new Date(today);
    endDate.setDate(endDate.getDate() + 180); // Sync 6 months
    
    for (const room of roomsResult.rows) {
      try {
        console.log(`sync-prices: Syncing ${room.name} (beds24_room_id: ${room.beds24_room_id})`);
        
        // Use V2 calendar API directly
        const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
          headers: { 'token': accessToken },
          params: {
            roomId: parseInt(room.beds24_room_id),
            startDate: today.toISOString().split('T')[0],
            endDate: endDate.toISOString().split('T')[0],
            includeNumAvail: true,
            includePrices: true,
            includeMinStay: true
          }
        });
        
        const calendarData = calResponse.data.data?.[0]?.calendar || [];
        
        for (const entry of calendarData) {
          const fromDate = new Date(entry.from);
          const toDate = new Date(entry.to);
          
          for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            const numAvail = entry.numAvail || 0;
            const price = entry.price1 || null;
            const minStay = entry.minStay || 1;
            
            await pool.query(`
              INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
              VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24', NOW())
              ON CONFLICT (room_id, date) 
              DO UPDATE SET 
                cm_price = COALESCE($3, room_availability.cm_price),
                is_available = $4,
                is_blocked = $5,
                min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                cm_min_stay = $6,
                source = 'beds24',
                updated_at = NOW()
            `, [room.id, dateStr, price, numAvail > 0, numAvail === 0, minStay]);
            
            daysUpdated++;
          }
        }
        
        console.log(`sync-prices: Synced ${room.name} - calendar entries: ${calendarData.length}`);
        
      } catch (roomError) {
        console.log(`sync-prices: Error syncing ${room.name}:`, roomError.message);
      }
    }
    
    res.json({ 
      success: true, 
      message: `Synced prices for ${roomsResult.rows.length} rooms`,
      rooms: roomsResult.rows.length,
      daysUpdated
    });
    
  } catch (error) {
    console.error('sync-prices error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get sync logs for a connection
app.get('/api/gas-sync/connections/:id/logs', async (req, res) => {
  try {
    const { id } = req.params;
    const { limit = 50, offset = 0 } = req.query;
    
    const result = await pool.query(`
      SELECT id, sync_type, entity_type, direction, status,
             records_processed, records_created, records_updated, records_failed,
             started_at, completed_at, duration_ms, error_message
      FROM gas_sync_log
      WHERE connection_id = $1
      ORDER BY started_at DESC
      LIMIT $2 OFFSET $3
    `, [id, limit, offset]);
    
    res.json({ success: true, logs: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get synced properties for a connection
app.get('/api/gas-sync/connections/:id/properties', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Ensure display_order column exists
    await pool.query('ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS display_order INTEGER DEFAULT 0').catch(() => {});
    
    const result = await pool.query(`
      SELECT p.id, p.external_id, p.name, p.city, p.country, p.currency,
             p.is_active, p.synced_at, p.gas_property_id, p.prop_key,
             p.prop_key_tested, p.webhook_tested, p.raw_data, p.display_order,
             (SELECT COUNT(*) FROM gas_sync_room_types WHERE sync_property_id = p.id) as room_type_count,
             (SELECT COUNT(*) FROM gas_sync_images WHERE sync_property_id = p.id) as image_count
      FROM gas_sync_properties p
      WHERE p.connection_id = $1
      ORDER BY COALESCE(p.display_order, 999999), p.name
    `, [id]);
    
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Reorder synced properties
app.put('/api/gas-sync/connections/:id/reorder-properties', async (req, res) => {
  try {
    const { id } = req.params;
    const { order } = req.body; // Array of { id, display_order }
    
    if (!Array.isArray(order)) {
      return res.json({ success: false, error: 'order array required' });
    }
    
    for (const item of order) {
      await pool.query(
        'UPDATE gas_sync_properties SET display_order = $1 WHERE id = $2 AND connection_id = $3',
        [item.display_order, item.id, id]
      );
    }
    
    res.json({ success: true, message: `Updated order for ${order.length} properties` });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get synced room types for a property
app.get('/api/gas-sync/properties/:propertyId/room-types', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    const result = await pool.query(`
      SELECT rt.id, rt.external_id, rt.name, rt.max_guests, rt.bedrooms, rt.beds,
             rt.base_price, rt.currency, rt.unit_count, rt.synced_at, rt.gas_room_id,
             rt.price_linking
      FROM gas_sync_room_types rt
      WHERE rt.sync_property_id = $1
      ORDER BY rt.name
    `, [propertyId]);
    
    res.json({ success: true, room_types: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Refresh price linking for all rooms in a connection (fetches from Beds24 API)
app.post('/api/gas-sync/connections/:connectionId/refresh-price-linking', async (req, res) => {
  try {
    const { connectionId } = req.params;
    
    // Get connection
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [connectionId]);
    if (connResult.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const conn = connResult.rows[0];
    let accessToken = conn.access_token;
    
    // Refresh token if needed
    if (conn.refresh_token) {
      try {
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': conn.refresh_token }
        });
        accessToken = tokenResponse.data.token;
        await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [accessToken, connectionId]);
      } catch (e) {
        return res.json({ success: false, error: 'Token refresh failed' });
      }
    }
    
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token' });
    }
    
    // Get all properties for this connection
    const propsResult = await pool.query(`
      SELECT id, external_id, name FROM gas_sync_properties WHERE connection_id = $1
    `, [connectionId]);
    
    let updated = 0;
    let errors = [];
    
    for (const prop of propsResult.rows) {
      try {
        // Fetch property with priceRules
        const propResp = await axios.get('https://beds24.com/api/v2/properties', {
          headers: { 'token': accessToken },
          params: { 
            id: prop.external_id,
            includeAllRooms: true,
            includePriceRules: true
          }
        });
        
        const propData = propResp.data?.data?.[0];
        if (propData?.roomTypes) {
          for (const rt of propData.roomTypes) {
            const priceRule = rt.priceRules?.find(pr => pr.priceLinking?.roomId);
            if (priceRule?.priceLinking) {
              const priceLinking = {
                sourceRoomId: priceRule.priceLinking.roomId,
                priceId: priceRule.priceLinking.priceId || 1,
                offsetAmount: priceRule.priceLinking.offsetAmount || 0,
                offsetMultiplier: priceRule.priceLinking.offsetMultiplier || 1
              };
              
              await pool.query(`
                UPDATE gas_sync_room_types SET price_linking = $1 WHERE external_id = $2
              `, [JSON.stringify(priceLinking), String(rt.id)]);
              
              updated++;
              console.log(`  Updated price_linking for room ${rt.id} (${rt.name}): links to ${priceLinking.sourceRoomId} +${priceLinking.offsetAmount}`);
            }
          }
        }
        
        // Rate limit delay
        await new Promise(resolve => setTimeout(resolve, 3000));
        
      } catch (e) {
        if (e.response?.status === 429) {
          errors.push({ property: prop.name, error: 'Rate limited' });
          console.log(`Rate limited at ${prop.name}, waiting 60s...`);
          await new Promise(resolve => setTimeout(resolve, 60000));
        } else {
          errors.push({ property: prop.name, error: e.message });
        }
      }
    }
    
    res.json({ success: true, updated, errors: errors.length > 0 ? errors : undefined });
    
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Copy prices from BASE room to all linked rooms (no API calls needed)
app.post('/api/gas-sync/connections/:id/apply-linked-pricing', async (req, res) => {
  try {
    const { id } = req.params;
    const { days = 90 } = req.body;
    
    // Find all rooms with price_linking for this connection
    const roomsResult = await pool.query(`
      SELECT rt.id, rt.external_id, rt.name, rt.gas_room_id, rt.price_linking,
             sp.name as property_name
      FROM gas_sync_room_types rt
      JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
      WHERE sp.connection_id = $1 AND rt.price_linking IS NOT NULL AND rt.gas_room_id IS NOT NULL
    `, [id]);
    
    console.log(`apply-linked-pricing: Found ${roomsResult.rows.length} rooms with price_linking`);
    
    if (roomsResult.rows.length === 0) {
      return res.json({ success: true, message: 'No rooms with price_linking found', updated: 0 });
    }
    
    // Get unique source room IDs
    const sourceRoomIds = [...new Set(roomsResult.rows.map(r => {
      const linking = typeof r.price_linking === 'string' ? JSON.parse(r.price_linking) : r.price_linking;
      return linking.sourceRoomId;
    }))];
    
    console.log(`apply-linked-pricing: Source rooms: ${sourceRoomIds.join(', ')}`);
    
    // Find GAS room IDs for source rooms (need to map Beds24 room ID to GAS room ID)
    const sourceRoomsResult = await pool.query(`
      SELECT rt.external_id as beds24_room_id, rt.gas_room_id
      FROM gas_sync_room_types rt
      WHERE rt.external_id = ANY($1) AND rt.gas_room_id IS NOT NULL
    `, [sourceRoomIds.map(String)]);
    
    const sourceRoomMap = {};
    for (const row of sourceRoomsResult.rows) {
      sourceRoomMap[row.beds24_room_id] = row.gas_room_id;
    }
    
    console.log(`apply-linked-pricing: Source room map:`, sourceRoomMap);
    
    // Get prices for all source rooms
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    const sourcePrices = {};
    for (const [beds24Id, gasRoomId] of Object.entries(sourceRoomMap)) {
      const pricesResult = await pool.query(`
        SELECT date, price, available, min_stay
        FROM room_availability
        WHERE room_id = $1 AND date >= $2 AND date <= $3
        ORDER BY date
      `, [gasRoomId, startDate, endDate]);
      
      sourcePrices[beds24Id] = pricesResult.rows;
      console.log(`apply-linked-pricing: Got ${pricesResult.rows.length} price records for source room ${beds24Id} (GAS ${gasRoomId})`);
    }
    
    // Now copy prices to each linked room
    let updated = 0;
    let errors = [];
    
    for (const room of roomsResult.rows) {
      const linking = typeof room.price_linking === 'string' ? JSON.parse(room.price_linking) : room.price_linking;
      const sourceRoomId = String(linking.sourceRoomId);
      const prices = sourcePrices[sourceRoomId];
      
      if (!prices || prices.length === 0) {
        errors.push({ room: room.name, error: `No prices found for source room ${sourceRoomId}` });
        continue;
      }
      
      // Apply offset if any
      const offsetAmount = linking.offsetAmount || 0;
      const offsetMultiplier = linking.offsetMultiplier || 1;
      
      for (const priceRecord of prices) {
        const adjustedPrice = (priceRecord.price * offsetMultiplier) + offsetAmount;
        
        await pool.query(`
          INSERT INTO room_availability (room_id, date, price, available, min_stay, updated_at)
          VALUES ($1, $2, $3, $4, $5, NOW())
          ON CONFLICT (room_id, date) DO UPDATE SET
            price = EXCLUDED.price,
            available = EXCLUDED.available,
            min_stay = EXCLUDED.min_stay,
            updated_at = NOW()
        `, [room.gas_room_id, priceRecord.date, adjustedPrice, priceRecord.available, priceRecord.min_stay]);
      }
      
      updated++;
      console.log(`apply-linked-pricing: Copied ${prices.length} prices to ${room.name} (offset: +${offsetAmount})`);
    }
    
    res.json({
      success: true,
      updated,
      message: `Copied prices to ${updated} rooms from BASE`,
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('apply-linked-pricing error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Extract price_linking from raw_data (no API calls needed)
app.post('/api/gas-sync/connections/:id/extract-price-linking', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get all sync properties for this connection with their raw_data
    const propsResult = await pool.query(`
      SELECT id, name, external_id, raw_data 
      FROM gas_sync_properties 
      WHERE connection_id = $1
    `, [id]);
    
    console.log(`extract-price-linking: Processing ${propsResult.rows.length} properties for connection ${id}`);
    
    let updated = 0;
    let skipped = 0;
    const details = [];
    
    for (const prop of propsResult.rows) {
      const rawData = prop.raw_data;
      if (!rawData?.roomTypes) {
        skipped++;
        continue;
      }
      
      for (const rt of rawData.roomTypes) {
        // Find a priceRule with priceLinking
        const priceRule = rt.priceRules?.find(pr => pr.priceLinking?.roomId);
        
        if (priceRule?.priceLinking) {
          const priceLinking = {
            sourceRoomId: priceRule.priceLinking.roomId,
            priceId: priceRule.priceLinking.priceId || 1,
            offsetAmount: priceRule.priceLinking.offsetAmount || 0,
            offsetMultiplier: priceRule.priceLinking.offsetMultiplier || 1
          };
          
          // Update the gas_sync_room_types table
          const updateResult = await pool.query(`
            UPDATE gas_sync_room_types 
            SET price_linking = $1 
            WHERE external_id = $2
            RETURNING id, name
          `, [JSON.stringify(priceLinking), String(rt.id)]);
          
          if (updateResult.rows.length > 0) {
            updated++;
            details.push({
              property: prop.name,
              room: rt.name || updateResult.rows[0].name,
              roomId: rt.id,
              linksTo: priceLinking.sourceRoomId,
              offset: priceLinking.offsetAmount
            });
            console.log(`  Updated price_linking for room ${rt.id} (${rt.name}): links to ${priceLinking.sourceRoomId}`);
          }
        }
      }
    }
    
    console.log(`extract-price-linking: Updated ${updated} rooms, skipped ${skipped} properties without roomTypes`);
    
    res.json({ 
      success: true, 
      updated, 
      skipped,
      message: `Extracted price_linking for ${updated} rooms`,
      details: details.slice(0, 20) // Show first 20 for brevity
    });
    
  } catch (error) {
    console.error('extract-price-linking error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get synced reservations for a connection
app.get('/api/gas-sync/connections/:id/reservations', async (req, res) => {
  try {
    const { id } = req.params;
    const { status, start_date, end_date, limit = 50, offset = 0 } = req.query;
    
    let whereClause = 'WHERE r.connection_id = $1';
    const values = [id];
    let paramCount = 1;
    
    if (status) {
      paramCount++;
      whereClause += ` AND r.status = $${paramCount}`;
      values.push(status);
    }
    
    if (start_date) {
      paramCount++;
      whereClause += ` AND r.check_in >= $${paramCount}`;
      values.push(start_date);
    }
    
    if (end_date) {
      paramCount++;
      whereClause += ` AND r.check_out <= $${paramCount}`;
      values.push(end_date);
    }
    
    paramCount++;
    const limitParam = paramCount;
    paramCount++;
    const offsetParam = paramCount;
    values.push(limit, offset);
    
    const result = await pool.query(`
      SELECT r.id, r.external_id, r.channel, r.check_in, r.check_out,
             r.guest_first_name, r.guest_last_name, r.guest_email,
             r.adults, r.children, r.total, r.currency, r.status,
             r.synced_at, r.gas_booking_id,
             rt.name as room_type_name, p.name as property_name
      FROM gas_sync_reservations r
      LEFT JOIN gas_sync_room_types rt ON r.sync_room_type_id = rt.id
      LEFT JOIN gas_sync_properties p ON rt.sync_property_id = p.id
      ${whereClause}
      ORDER BY r.check_in DESC
      LIMIT $${limitParam} OFFSET $${offsetParam}
    `, values);
    
    res.json({ success: true, reservations: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get synced images for a property
app.get('/api/gas-sync/properties/:propertyId/images', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    const result = await pool.query(`
      SELECT id, external_id, original_url, thumbnail_url, caption,
             sort_order, image_type, width, height, is_downloaded, synced_at
      FROM gas_sync_images
      WHERE sync_property_id = $1
      ORDER BY sort_order, id
    `, [propertyId]);
    
    res.json({ success: true, images: result.rows });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Find sync property by GAS property ID (for resync)
app.get('/api/gas-sync/properties/by-gas-property/:gasPropertyId', async (req, res) => {
  try {
    const { gasPropertyId } = req.params;
    console.log('Resync lookup for GAS property:', gasPropertyId);
    
    // First try by gas_property_id link
    let result = await pool.query(`
      SELECT sp.*, c.adapter_code
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.gas_property_id = $1
    `, [gasPropertyId]);
    
    console.log('Direct link result:', result.rows.length, 'rows');
    
    // If not found, try matching by property name
    if (result.rows.length === 0) {
      const propResult = await pool.query('SELECT name, account_id FROM properties WHERE id = $1', [gasPropertyId]);
      console.log('Property lookup:', propResult.rows[0] || 'NOT FOUND');
      
      if (propResult.rows.length > 0) {
        const propName = propResult.rows[0].name;
        const accountId = propResult.rows[0].account_id;
        
        if (!accountId) {
          console.log('Property has no account_id');
          return res.json({ success: false, error: 'Property has no account assigned' });
        }
        
        // Try exact match first
        result = await pool.query(`
          SELECT sp.*, c.adapter_code
          FROM gas_sync_properties sp
          JOIN gas_sync_connections c ON sp.connection_id = c.id
          WHERE sp.name = $1 AND c.account_id = $2
        `, [propName, accountId]);
        
        console.log('Exact name match result:', result.rows.length, 'rows');
        
        // If not found, try partial match (property name contains sync name or vice versa)
        if (result.rows.length === 0) {
          result = await pool.query(`
            SELECT sp.*, c.adapter_code
            FROM gas_sync_properties sp
            JOIN gas_sync_connections c ON sp.connection_id = c.id
            WHERE c.account_id = $1 
            AND ($2 ILIKE '%' || sp.name || '%' OR sp.name ILIKE '%' || $2 || '%')
          `, [accountId, propName]);
          
          console.log('Partial name match result:', result.rows.length, 'rows');
        }
        
        // If found by name, update the link for future
        if (result.rows.length > 0) {
          await pool.query('UPDATE gas_sync_properties SET gas_property_id = $1 WHERE id = $2', [gasPropertyId, result.rows[0].id]);
          console.log('Updated link for future');
        }
      }
    }
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'No sync property found for this GAS property' });
    }
    
    res.json({ success: true, syncProperty: result.rows[0] });
  } catch (error) {
    console.error('Resync lookup error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Download images for a property (Beds24 V1)
app.post('/api/gas-sync/properties/:propertyId/download-images', async (req, res) => {
  try {
    const { propertyId } = req.params;
    
    const propResult = await pool.query(`
      SELECT p.connection_id, p.external_id, p.prop_key, c.adapter_code
      FROM gas_sync_properties p
      JOIN gas_sync_connections c ON p.connection_id = c.id
      WHERE p.id = $1
    `, [propertyId]);
    
    if (propResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Property not found' });
    }
    
    const { connection_id, external_id, prop_key, adapter_code } = propResult.rows[0];
    
    if (adapter_code !== 'beds24') {
      return res.status(400).json({ 
        success: false, 
        error: 'Image download only supported for Beds24' 
      });
    }
    
    if (!prop_key) {
      return res.status(400).json({
        success: false,
        error: 'Property has no prop_key set. Use /set-prop-key first.'
      });
    }
    
    const adapter = await syncManager.getAdapterForConnection(connection_id);
    
    // Set the property-specific propKey on the adapter
    adapter.propKey = prop_key;
    
    const imagesResult = await adapter.getImages(external_id);
    
    if (!imagesResult.success) {
      return res.status(400).json({ success: false, error: imagesResult.error });
    }
    
    let downloadedCount = 0;
    for (const image of imagesResult.data) {
      // Use adapter's method to properly save room_type_external_id
      await adapter.syncImageToDatabase(image, external_id);
      downloadedCount++;
    }
    
    res.json({ 
      success: true, 
      message: `Downloaded ${downloadedCount} images`,
      images: imagesResult.data
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Link synced property to GAS property
app.post('/api/gas-sync/properties/:syncPropertyId/link', async (req, res) => {
  try {
    const { syncPropertyId } = req.params;
    const { gas_property_id } = req.body;
    
    await pool.query(`
      UPDATE gas_sync_properties SET gas_property_id = $2, updated_at = NOW()
      WHERE id = $1
    `, [syncPropertyId, gas_property_id]);
    
    res.json({ success: true, message: 'Property linked' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Auto-import synced property into GAS
app.post('/api/gas-sync/properties/:syncPropertyId/import', async (req, res) => {
  try {
    const { syncPropertyId } = req.params;
    let { account_id } = req.body;
    
    const syncProp = await pool.query(`
      SELECT sp.*, c.account_id as connection_account_id
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [syncPropertyId]);
    
    if (syncProp.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Synced property not found' });
    }
    
    const sp = syncProp.rows[0];
    
    // Use connection's account_id, not the passed one
    account_id = sp.connection_account_id;
    
    // Simple insert without JSON columns
    const newProp = await pool.query(`
      INSERT INTO properties (
        account_id, name, property_type,
        address, city, state, country, postcode,
        latitude, longitude, timezone, currency,
        check_in_time, check_out_time, status, beds24_property_id
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, 'active', $15)
      RETURNING id
    `, [
      account_id,
      sp.name,
      sp.property_type || 'hotel',
      sp.street || '',
      sp.city || '',
      sp.state || '',
      sp.country || '',
      sp.postal_code || '',
      sp.latitude,
      sp.longitude,
      sp.timezone || 'UTC',
      sp.currency || 'GBP',
      sp.check_in_time || '15:00',
      sp.check_out_time || '11:00',
      sp.external_id
    ]);
    
    const gasPropertyId = newProp.rows[0].id;
    
    await pool.query(`
      UPDATE gas_sync_properties SET gas_property_id = $2, updated_at = NOW() WHERE id = $1
    `, [syncPropertyId, gasPropertyId]);
    
    const roomTypes = await pool.query(`
      SELECT * FROM gas_sync_room_types WHERE sync_property_id = $1
    `, [syncPropertyId]);
    
    for (const rt of roomTypes.rows) {
      const newRoom = await pool.query(`
        INSERT INTO bookable_units (
          property_id, name, max_guests, base_price, status
        ) VALUES ($1, $2, $3, $4, 'available')
        RETURNING id
      `, [
        gasPropertyId,
        rt.name || 'Room',
        rt.max_guests || 2,
        rt.base_price || 100
      ]);
      
      await pool.query(`
        UPDATE gas_sync_room_types SET gas_room_id = $2, updated_at = NOW() WHERE id = $1
      `, [rt.id, newRoom.rows[0].id]);
    }
    
    res.json({ 
      success: true, 
      gas_property_id: gasPropertyId,
      message: `Property imported with ${roomTypes.rows.length} room types`
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get overall sync status
app.get('/api/gas-sync/status', async (req, res) => {
  try {
    const accountId = req.query.account_id || req.user?.account_id || 1;
    
    const stats = await pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM gas_sync_connections WHERE account_id = $1) as total_connections,
        (SELECT COUNT(*) FROM gas_sync_connections WHERE account_id = $1 AND status = 'connected') as active_connections,
        (SELECT COUNT(*) FROM gas_sync_connections WHERE account_id = $1 AND status = 'error') as error_connections,
        (SELECT COUNT(*) FROM gas_sync_properties p 
         JOIN gas_sync_connections c ON p.connection_id = c.id 
         WHERE c.account_id = $1) as total_properties,
        (SELECT COUNT(*) FROM gas_sync_room_types rt
         JOIN gas_sync_connections c ON rt.connection_id = c.id
         WHERE c.account_id = $1) as total_room_types,
        (SELECT COUNT(*) FROM gas_sync_reservations r
         JOIN gas_sync_connections c ON r.connection_id = c.id
         WHERE c.account_id = $1 AND r.status = 'confirmed') as active_reservations,
        (SELECT COUNT(*) FROM gas_sync_images i
         JOIN gas_sync_connections c ON i.connection_id = c.id
         WHERE c.account_id = $1) as total_images
    `, [accountId]);
    
    const recentActivity = await pool.query(`
      SELECT l.sync_type, l.status, l.records_processed, l.started_at, l.duration_ms,
             c.adapter_code
      FROM gas_sync_log l
      JOIN gas_sync_connections c ON l.connection_id = c.id
      WHERE c.account_id = $1
      ORDER BY l.started_at DESC
      LIMIT 10
    `, [accountId]);
    
    res.json({
      success: true,
      stats: stats.rows[0],
      recent_activity: recentActivity.rows
    });
  } catch (error) {
    console.error('Error fetching gas-sync status:', error);
    // Return empty stats on error - tables might not exist yet
    res.json({
      success: true,
      stats: {
        total_connections: 0,
        active_connections: 0,
        error_connections: 0,
        total_properties: 0,
        total_room_types: 0,
        active_reservations: 0,
        total_images: 0
      },
      recent_activity: []
    });
  }
});

// Webhook endpoint (no auth - CMs will call this)
app.post('/api/gas-sync/webhooks/:connectionId', async (req, res) => {
  try {
    const { connectionId } = req.params;
    console.log(`Webhook received for connection ${connectionId}:`, req.body);
    
    syncManager.processWebhook(connectionId, req.body, req.headers)
      .then(event => console.log(`Webhook processed: ${event.event}`))
      .catch(err => console.error(`Webhook processing failed:`, err));
    
    res.json({ received: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Cron endpoint for scheduled syncs
app.post('/api/gas-sync/cron/sync', async (req, res) => {
  const cronSecret = req.headers['x-cron-secret'];
  if (cronSecret !== process.env.CRON_SECRET) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  try {
    const dueConnections = await pool.query(`
      SELECT id FROM gas_sync_connections
      WHERE sync_enabled = true
        AND status != 'syncing'
        AND (next_sync_at IS NULL OR next_sync_at <= NOW())
      LIMIT 10
    `);
    
    const results = [];
    
    for (const conn of dueConnections.rows) {
      try {
        await syncManager.syncConnection(conn.id, 'incremental');
        results.push({ id: conn.id, status: 'success' });
      } catch (error) {
        results.push({ id: conn.id, status: 'error', error: error.message });
      }
    }
    
    res.json({ success: true, synced: results.length, results });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// =====================================================
// SYNC COMPARISON & RECONCILIATION
// =====================================================

// Compare GAS rooms with Beds24 rooms for a property
app.get('/api/gas-sync/properties/:id/compare', async (req, res) => {
  const { id } = req.params; // This is gas_sync_properties.id
  
  try {
    // Get the sync property info
    const propResult = await pool.query(`
      SELECT sp.*, c.credentials, c.adapter_code
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [id]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const syncProp = propResult.rows[0];
    const credentials = syncProp.credentials;
    
    // Get rooms currently in GAS for this property
    const gasRoomsResult = await pool.query(`
      SELECT rt.id as sync_id, rt.external_id as beds24_id, rt.name as sync_name,
             bu.id as gas_id, bu.name as gas_name, bu.beds24_room_id, bu.cm_room_id
      FROM gas_sync_room_types rt
      LEFT JOIN bookable_units bu ON rt.gas_room_id = bu.id
      WHERE rt.sync_property_id = $1
    `, [id]);
    
    const gasRooms = gasRoomsResult.rows;
    
    // Also get any GAS rooms that might exist but aren't linked to sync
    const unlinkedGasRooms = await pool.query(`
      SELECT bu.id as gas_id, bu.name as gas_name, bu.beds24_room_id, bu.cm_room_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      JOIN gas_sync_properties sp ON sp.gas_property_id = p.id
      WHERE sp.id = $1
        AND bu.id NOT IN (SELECT gas_room_id FROM gas_sync_room_types WHERE sync_property_id = $1 AND gas_room_id IS NOT NULL)
    `, [id]);
    
    // Fetch current rooms from Beds24
    let beds24Rooms = [];
    
    if (syncProp.adapter_code === 'beds24') {
      try {
        // Get access token
        const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
          headers: { 'refreshToken': credentials.v2_token }
        });
        const accessToken = tokenResponse.data.token;
        
        // Fetch rooms from Beds24
        const roomsResponse = await axios.get('https://beds24.com/api/v2/properties/rooms', {
          headers: { 'token': accessToken },
          params: { propertyId: syncProp.external_id }
        });
        
        beds24Rooms = roomsResponse.data?.data || roomsResponse.data || [];
      } catch (apiError) {
        console.error('Error fetching from Beds24:', apiError.message);
        return res.json({ success: false, error: 'Could not fetch rooms from Beds24: ' + apiError.message });
      }
    }
    
    // Build comparison
    const rooms = [];
    const beds24RoomIds = new Set(beds24Rooms.map(r => String(r.id)));
    const gasRoomBeds24Ids = new Set();
    
    // Process GAS rooms
    gasRooms.forEach(gasRoom => {
      const beds24Id = gasRoom.beds24_id || gasRoom.beds24_room_id || gasRoom.cm_room_id;
      if (beds24Id) gasRoomBeds24Ids.add(String(beds24Id));
      
      const existsInBeds24 = beds24Id && beds24RoomIds.has(String(beds24Id));
      const beds24Room = beds24Rooms.find(r => String(r.id) === String(beds24Id));
      
      // Check if name changed
      const nameChanged = beds24Room && beds24Room.name !== gasRoom.gas_name && beds24Room.name !== gasRoom.sync_name;
      
      rooms.push({
        name: gasRoom.gas_name || gasRoom.sync_name,
        beds24_name: beds24Room?.name,
        beds24_id: beds24Id,
        gas_id: gasRoom.gas_id,
        sync_id: gasRoom.sync_id,
        status: existsInBeds24 ? (nameChanged ? 'updated' : 'matched') : 'missing',
        is_active: true
      });
    });
    
    // Add unlinked GAS rooms
    unlinkedGasRooms.rows.forEach(room => {
      const beds24Id = room.beds24_room_id || room.cm_room_id;
      if (beds24Id && !gasRoomBeds24Ids.has(String(beds24Id))) {
        gasRoomBeds24Ids.add(String(beds24Id));
        const existsInBeds24 = beds24RoomIds.has(String(beds24Id));
        
        rooms.push({
          name: room.gas_name,
          beds24_id: beds24Id,
          gas_id: room.gas_id,
          sync_id: null,
          status: existsInBeds24 ? 'matched' : 'missing',
          is_active: true
        });
      }
    });
    
    // Find NEW rooms (in Beds24 but not in GAS)
    beds24Rooms.forEach(b24Room => {
      if (!gasRoomBeds24Ids.has(String(b24Room.id))) {
        rooms.push({
          name: b24Room.name,
          beds24_id: String(b24Room.id),
          gas_id: null,
          sync_id: null,
          status: 'new',
          is_active: null
        });
      }
    });
    
    // Calculate summary
    const summary = {
      new: rooms.filter(r => r.status === 'new').length,
      matched: rooms.filter(r => r.status === 'matched').length,
      updated: rooms.filter(r => r.status === 'updated').length,
      missing: rooms.filter(r => r.status === 'missing').length,
      total_gas: gasRooms.length + unlinkedGasRooms.rows.length,
      total_beds24: beds24Rooms.length
    };
    
    res.json({
      success: true,
      property: {
        id: syncProp.id,
        name: syncProp.name,
        external_id: syncProp.external_id
      },
      summary,
      rooms
    });
    
  } catch (error) {
    console.error('Compare error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Apply sync changes
app.post('/api/gas-sync/properties/:id/apply-sync', async (req, res) => {
  const { id } = req.params;
  const { actions } = req.body; // Array of { roomId, status, action }
  
  try {
    // Get property info
    const propResult = await pool.query(`
      SELECT sp.*, c.credentials, c.adapter_code, sp.gas_property_id
      FROM gas_sync_properties sp
      JOIN gas_sync_connections c ON sp.connection_id = c.id
      WHERE sp.id = $1
    `, [id]);
    
    if (propResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const syncProp = propResult.rows[0];
    const credentials = syncProp.credentials;
    
    let added = 0;
    let deactivated = 0;
    let deleted = 0;
    let updated = 0;
    
    // Process actions for missing rooms
    const missingActions = (actions || []).filter(a => a.status === 'missing');
    for (const action of missingActions) {
      if (action.action === 'deactivate') {
        await pool.query("UPDATE bookable_units SET status = 'inactive' WHERE id = $1", [action.roomId]);
        deactivated++;
      } else if (action.action === 'delete') {
        // Delete related data first
        await pool.query('DELETE FROM room_availability WHERE room_id = $1', [action.roomId]);
        await pool.query('DELETE FROM room_images WHERE room_id = $1', [action.roomId]);
        await pool.query('UPDATE gas_sync_room_types SET gas_room_id = NULL WHERE gas_room_id = $1', [action.roomId]);
        await pool.query('DELETE FROM bookable_units WHERE id = $1', [action.roomId]);
        deleted++;
      }
      // 'keep' action does nothing
    }
    
    // Process new rooms - fetch from Beds24 and add
    const newActions = (actions || []).filter(a => a.status === 'new' && a.action === 'add');
    
    if (newActions.length > 0 && syncProp.adapter_code === 'beds24') {
      // Get access token
      const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
        headers: { 'refreshToken': credentials.v2_token }
      });
      const accessToken = tokenResponse.data.token;
      
      // Fetch rooms from Beds24
      const roomsResponse = await axios.get('https://beds24.com/api/v2/properties/rooms', {
        headers: { 'token': accessToken },
        params: { propertyId: syncProp.external_id }
      });
      
      const beds24Rooms = roomsResponse.data?.data || roomsResponse.data || [];
      
      for (const action of newActions) {
        const b24Room = beds24Rooms.find(r => String(r.id) === String(action.roomId));
        if (!b24Room) continue;
        
        // Insert into gas_sync_room_types
        const syncRoomResult = await pool.query(`
          INSERT INTO gas_sync_room_types (sync_property_id, external_id, name, max_guests, created_at, updated_at)
          VALUES ($1, $2, $3, $4, NOW(), NOW())
          RETURNING id
        `, [id, b24Room.id, b24Room.name, b24Room.maxGuests || 2]);
        
        const syncRoomId = syncRoomResult.rows[0].id;
        
        // Insert into bookable_units if gas_property_id exists
        if (syncProp.gas_property_id) {
          const gasRoomResult = await pool.query(`
            INSERT INTO bookable_units (property_id, name, beds24_room_id, cm_room_id, max_guests, status, created_at, updated_at)
            VALUES ($1, $2, $3, $4, $5, 'active', NOW(), NOW())
            RETURNING id
          `, [syncProp.gas_property_id, b24Room.name, parseInt(b24Room.id), String(b24Room.id), b24Room.maxGuests || 2]);
          
          // Link sync room to GAS room
          await pool.query('UPDATE gas_sync_room_types SET gas_room_id = $1 WHERE id = $2', 
            [gasRoomResult.rows[0].id, syncRoomId]);
        }
        
        added++;
      }
    }
    
    res.json({
      success: true,
      added,
      deactivated,
      deleted,
      updated
    });
    
  } catch (error) {
    console.error('Apply sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Search properties by name (admin)
app.get('/api/admin/properties/search', async (req, res) => {
  const { q } = req.query;
  
  try {
    const result = await pool.query(`
      SELECT p.id, p.name, p.account_id, a.name as account_name,
             (SELECT COUNT(*) FROM bookable_units WHERE property_id = p.id) as room_count
      FROM properties p
      LEFT JOIN accounts a ON p.account_id = a.id
      WHERE p.name ILIKE $1
      ORDER BY p.name
    `, [`%${q || ''}%`]);
    
    res.json({ success: true, properties: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Fix property account assignment
app.post('/api/admin/properties/:id/set-account', async (req, res) => {
  const { id } = req.params;
  const { account_id } = req.body;
  
  try {
    await pool.query('UPDATE properties SET account_id = $1 WHERE id = $2', [account_id, id]);
    res.json({ success: true, message: `Property ${id} moved to account ${account_id}` });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check connection credentials (shows keys only, not values)
app.get('/api/admin/debug/connection-creds/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query('SELECT id, credentials, access_token, refresh_token FROM gas_sync_connections WHERE id = $1', [id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const conn = result.rows[0];
    const creds = typeof conn.credentials === 'string' ? JSON.parse(conn.credentials) : conn.credentials;
    
    res.json({
      success: true,
      connection_id: id,
      has_credentials: !!creds,
      credential_keys: creds ? Object.keys(creds) : [],
      has_access_token: !!conn.access_token,
      has_refresh_token: !!conn.refresh_token,
      v2_token_present: !!(creds?.refreshToken || creds?.v2_token),
      api_key_present: !!(creds?.apiKey || creds?.api_key)
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Force token refresh by clearing expired access token
app.post('/api/admin/debug/refresh-token/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get connection
    const result = await pool.query('SELECT refresh_token, credentials FROM gas_sync_connections WHERE id = $1', [id]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const conn = result.rows[0];
    const creds = typeof conn.credentials === 'string' ? JSON.parse(conn.credentials) : conn.credentials;
    const refreshToken = conn.refresh_token || creds?.refreshToken;
    
    if (!refreshToken) {
      return res.json({ success: false, error: 'No refresh token found' });
    }
    
    // Get new access token
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
      headers: { 'refreshToken': refreshToken }
    });
    
    const newAccessToken = tokenResponse.data.token;
    
    // Save new access token
    await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [newAccessToken, id]);
    
    res.json({ success: true, message: 'Token refreshed successfully' });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check Beds24 PROPERTY-level pricing (fixedPrices by propertyId)
app.get('/api/admin/debug/beds24-property-pricing/:connectionId/:propertyId', async (req, res) => {
  try {
    const { connectionId, propertyId } = req.params;
    
    const result = await pool.query('SELECT access_token FROM gas_sync_connections WHERE id = $1', [connectionId]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const accessToken = result.rows[0].access_token;
    if (!accessToken) {
      return res.json({ success: false, error: 'No access token' });
    }
    
    const pricesResponse = await axios.get('https://beds24.com/api/v2/inventory/fixedPrices', {
      headers: { 'token': accessToken },
      params: { propertyId: propertyId }
    });
    
    // Filter to just offer 1 and current/future dates
    const today = new Date().toISOString().split('T')[0];
    const relevantPrices = (pricesResponse.data.data || []).filter(p => 
      p.offerId === 1 && p.lastNight >= today
    );
    
    res.json({
      success: true,
      propertyId,
      totalCount: pricesResponse.data.count,
      relevantCount: relevantPrices.length,
      prices: relevantPrices.map(p => ({
        id: p.id,
        name: p.name,
        roomId: p.roomId,
        firstNight: p.firstNight,
        lastNight: p.lastNight,
        roomPrice: p.roomPrice,
        minNights: p.minNights
      }))
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Check what Beds24 returns for a room's pricing
app.get('/api/admin/debug/beds24-room-pricing/:connectionId/:roomId', async (req, res) => {
  try {
    const { connectionId, roomId } = req.params;
    
    // Get connection with token
    const result = await pool.query('SELECT access_token, refresh_token, credentials FROM gas_sync_connections WHERE id = $1', [connectionId]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const conn = result.rows[0];
    let accessToken = conn.access_token;
    
    // Get fixed prices
    const pricesResponse = await axios.get('https://beds24.com/api/v2/inventory/fixedPrices', {
      params: { roomId: parseInt(roomId) },
      headers: { 'token': accessToken }
    });
    
    // Get availability
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    const availResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/availability', {
      params: { roomId: parseInt(roomId), from: startDate, to: endDate },
      headers: { 'token': accessToken }
    });
    
    res.json({
      success: true,
      roomId,
      fixedPrices: pricesResponse.data,
      availability: availResponse.data
    });
  } catch (error) {
    res.json({ success: false, error: error.message, details: error.response?.data });
  }
});

// Debug: List room IDs for a property
app.get('/api/admin/debug/property-rooms/:propertyId', async (req, res) => {
  try {
    const { propertyId } = req.params;
    const result = await pool.query(
      'SELECT id, name, beds24_room_id, cm_room_id FROM bookable_units WHERE property_id = $1',
      [propertyId]
    );
    res.json({ success: true, rooms: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Debug: Test calendar API with connection token
app.get('/api/admin/debug/beds24-calendar/:connectionId/:roomId', async (req, res) => {
  try {
    const { connectionId, roomId } = req.params;
    
    // Get connection with token
    const result = await pool.query('SELECT access_token FROM gas_sync_connections WHERE id = $1', [connectionId]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const accessToken = result.rows[0].access_token;
    const startDate = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    // Use EXACT same params as the real sync
    const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
      headers: { 'token': accessToken },
      params: { 
        roomId: parseInt(roomId), 
        startDate, 
        endDate,
        includeNumAvail: true,
        includePrices: true,
        includeMinStay: true
      }
    });
    
    const calendarData = calResponse.data.data?.[0]?.calendar || [];
    
    // Extract ALL unique field names across all entries
    const allFields = new Set();
    calendarData.forEach(entry => {
      Object.keys(entry).forEach(key => allFields.add(key));
    });
    
    // Flag which entries have price2 or other price fields
    const priceFieldSummary = {};
    allFields.forEach(field => {
      if (field.toLowerCase().includes('price')) {
        const nonNullCount = calendarData.filter(e => e[field] !== null && e[field] !== undefined && e[field] !== 0).length;
        priceFieldSummary[field] = { total: calendarData.length, nonNull: nonNullCount };
      }
    });
    
    res.json({
      success: true,
      connectionId,
      roomId,
      startDate,
      endDate,
      totalEntries: calendarData.length,
      allFieldsFound: [...allFields].sort(),
      priceFieldSummary,
      rawEntries: calendarData,
      rawApiResponse: calResponse.data
    });
  } catch (error) {
    res.json({ success: false, error: error.message, details: error.response?.data });
  }
});

// Debug: Test offers API with connection token
app.get('/api/admin/debug/beds24-offers/:connectionId/:roomId', async (req, res) => {
  try {
    const { connectionId, roomId } = req.params;
    
    const result = await pool.query('SELECT access_token FROM gas_sync_connections WHERE id = $1', [connectionId]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    const accessToken = result.rows[0].access_token;
    const arrival = new Date().toISOString().split('T')[0];
    const departure = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    const offerResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/offers', {
      headers: { 'token': accessToken },
      params: { roomId: parseInt(roomId), arrival, departure, numAdults: 2 }
    });
    
    res.json({
      success: true,
      roomId,
      arrival,
      departure,
      offers: offerResponse.data
    });
  } catch (error) {
    res.json({ success: false, error: error.message, details: error.response?.data });
  }
});

// =====================================================
// END GASSYNC ROUTES
// =====================================================

// =====================================================
// BEDS24 WIZARD - Clean import process
// =====================================================

// Delete a property and ALL related data (for testing/cleanup)
app.delete('/api/admin/properties/:id/full-delete', async (req, res) => {
  try {
    const { id } = req.params;
    
    console.log(`Full delete of property ${id} starting...`);
    
    // Get room IDs first
    const rooms = await pool.query('SELECT id FROM bookable_units WHERE property_id = $1', [id]);
    const roomIds = rooms.rows.map(r => r.id);
    
    if (roomIds.length > 0) {
      // Delete room-related data
      await pool.query('DELETE FROM room_images WHERE room_id = ANY($1)', [roomIds]);
      await pool.query('DELETE FROM bookable_unit_amenities WHERE bookable_unit_id = ANY($1)', [roomIds]);
      await pool.query('DELETE FROM room_availability WHERE room_id = ANY($1)', [roomIds]).catch(() => {});
      
      // Delete rooms
      await pool.query('DELETE FROM bookable_units WHERE property_id = $1', [id]);
      console.log(`  Deleted ${roomIds.length} rooms`);
    }
    
    // Delete property-related data
    await pool.query('DELETE FROM property_images WHERE property_id = $1', [id]).catch(() => {});
    await pool.query('DELETE FROM property_amenity_selections WHERE property_id = $1', [id]).catch(() => {});
    await pool.query('DELETE FROM property_policies WHERE property_id = $1', [id]).catch(() => {});
    await pool.query('DELETE FROM reservations WHERE property_id = $1', [id]).catch(() => {});
    
    // Unlink from gas_sync
    await pool.query('UPDATE gas_sync_properties SET gas_property_id = NULL WHERE gas_property_id = $1', [id]).catch(() => {});
    
    // Delete the property
    await pool.query('DELETE FROM properties WHERE id = $1', [id]);
    
    console.log(`  Property ${id} fully deleted`);
    
    res.json({ success: true, message: `Property ${id} and all related data deleted`, roomsDeleted: roomIds.length });
  } catch (error) {
    console.error('Full delete error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Serve the wizard HTML page
app.get('/beds24-wizard', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'beds24-wizard.html'));
});

// Serve the sync review page
app.get('/sync-review', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'sync-review.html'));
});

// Serve the developers/partner signup page
app.get('/developers', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'developers.html'));
});

// Step 1: Test V2 API key and fetch properties
app.post('/api/beds24-wizard/properties', async (req, res) => {
  try {
    const { inviteCode, v1ApiKey } = req.body;
    
    if (!inviteCode) {
      return res.json({ success: false, error: 'V2 Invite Code required' });
    }
    
    // Get token from Beds24 V2 API - use GET with code in header (working method)
    const axios = require('axios');
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/setup', {
      headers: {
        'accept': 'application/json',
        'code': inviteCode
      }
    });
    
    const tokenData = tokenResponse.data;
    console.log('Beds24 auth response:', tokenData);
    
    if (!tokenData.token) {
      return res.json({ success: false, error: 'Invalid V2 Invite Code - could not authenticate with Beds24', response: tokenData });
    }
    
    const token = tokenData.token;
    
    // Fetch properties
    const propsResponse = await fetch('https://beds24.com/api/v2/properties', {
      headers: { 
        'Content-Type': 'application/json',
        'token': token
      }
    });
    
    const propsData = await propsResponse.json();
    
    if (!propsData.success && propsData.error) {
      return res.json({ success: false, error: propsData.error });
    }
    
    // Format properties
    const properties = (Array.isArray(propsData) ? propsData : propsData.data || []).map(p => ({
      id: p.id,
      name: p.name,
      city: p.city,
      country: p.country,
      address: p.address,
      roomTypeCount: p.roomTypes?.length || 0
    }));
    
    res.json({ success: true, properties, token });
    
  } catch (error) {
    console.error('Beds24 wizard properties error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Step 2: Fetch room types for a property (with property code)
app.post('/api/beds24-wizard/room-types', async (req, res) => {
  try {
    const { inviteCode, propId, propCode } = req.body;
    
    if (!inviteCode || !propId) {
      return res.json({ success: false, error: 'V2 Invite Code and property ID required' });
    }
    
    // Get token - use GET with code in header (working method)
    const axios = require('axios');
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/setup', {
      headers: {
        'accept': 'application/json',
        'code': inviteCode
      }
    });
    
    const tokenData = tokenResponse.data;
    if (!tokenData.token) {
      return res.json({ success: false, error: 'Invalid V2 Invite Code' });
    }
    
    const token = tokenData.token;
    
    // Fetch property with room types
    const propResponse = await fetch(`https://beds24.com/api/v2/properties/${propId}`, {
      headers: { 
        'Content-Type': 'application/json',
        'token': token
      }
    });
    
    const propData = await propResponse.json();
    
    // Extract room types with their descriptions
    const rawRoomTypes = propData.roomTypes || [];
    
    // Helper to extract text from Beds24 format {EN: "...", DE: "..."}
    function getText(val) {
      if (!val) return '';
      if (typeof val === 'string') return val;
      if (typeof val === 'object') {
        return val.EN || val.en || val.DE || val.de || val.FR || val.fr || Object.values(val).find(v => typeof v === 'string' && v.trim()) || '';
      }
      return '';
    }
    
    const roomTypes = rawRoomTypes.map(rt => {
      const texts = rt.texts || {};
      return {
        id: rt.id,
        name: rt.name,
        displayName: getText(texts.displayName) || rt.name,
        shortDescription: getText(texts.roomDescription1) || '',
        fullDescription: getText(texts.auxiliaryText) || '',
        maxGuests: rt.maxPeople || rt.maxGuests || 2,
        basePrice: rt.rackRate || null,
        featureCodes: rt.featureCodes || '',
        imageCount: rt.images?.length || 0,
        raw: rt  // Keep raw data for import
      };
    });
    
    res.json({ success: true, roomTypes, property: propData });
    
  } catch (error) {
    console.error('Beds24 wizard room-types error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Step 3: Import property to GAS (with all credentials)
app.post('/api/beds24-wizard/import', async (req, res) => {
  try {
    const { inviteCode, v1ApiKey, propCode, propId, accountId, importImages, propertyData } = req.body;
    
    if (!inviteCode || !propId || !accountId) {
      return res.json({ success: false, error: 'Missing required fields' });
    }
    
    // Get token - use GET with code in header (working method)
    const axios = require('axios');
    const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/setup', {
      headers: {
        'accept': 'application/json',
        'code': inviteCode
      }
    });
    
    const tokenData = tokenResponse.data;
    if (!tokenData.token) {
      return res.json({ success: false, error: 'Invalid V2 Invite Code' });
    }
    
    const token = tokenData.token;
    
    // Fetch full property data
    const propResponse = await fetch(`https://beds24.com/api/v2/properties/${propId}`, {
      headers: { 
        'Content-Type': 'application/json',
        'token': token
      }
    });
    
    const prop = await propResponse.json();
    
    // Helper function
    function getText(val) {
      if (!val) return '';
      if (typeof val === 'string') return val;
      if (typeof val === 'object') {
        return val.EN || val.en || val.DE || val.de || Object.values(val).find(v => typeof v === 'string' && v.trim()) || '';
      }
      return '';
    }
    
    // Extract property texts
    const propTexts = prop.texts || {};
    
    // Create property in GAS
    const propertyResult = await pool.query(`
      INSERT INTO properties (
        account_id, name, property_type, 
        address, city, state, country, postcode,
        latitude, longitude,
        check_in_time, check_out_time,
        currency, phone, email,
        short_description, full_description,
        house_rules, cancellation_policy, terms_conditions,
        directions, check_in_instructions, check_out_instructions,
        beds24_property_id, cm_source,
        created_at, updated_at
      ) VALUES (
        $1, $2, $3,
        $4, $5, $6, $7, $8,
        $9, $10,
        $11, $12,
        $13, $14, $15,
        $16, $17,
        $18, $19, $20,
        $21, $22, $23,
        $24, 'beds24',
        NOW(), NOW()
      )
      RETURNING id
    `, [
      accountId,
      prop.name || 'Unnamed Property',
      prop.propertyType || 'hotel',
      prop.address || '',
      prop.city || '',
      prop.state || prop.region || '',
      prop.country || '',
      prop.postcode || prop.zip || '',
      prop.latitude || null,
      prop.longitude || null,
      prop.checkInStart || '15:00',
      prop.checkOutEnd || '11:00',
      prop.currency || 'GBP',
      prop.phone || '',
      prop.email || '',
      getText(propTexts.propertyShortDescription) || '',
      getText(propTexts.propertyDescription) || '',
      getText(propTexts.houseRules) || '',
      getText(propTexts.cancellationPolicy) || '',
      getText(propTexts.termsConditions) || '',
      getText(propTexts.directions) || '',
      getText(propTexts.checkInInstructions) || '',
      getText(propTexts.checkOutInstructions) || '',
      propId
    ]);
    
    const gasPropertyId = propertyResult.rows[0].id;
    
    // Create room types
    let roomsCreated = 0;
    let imagesCreated = 0;
    const rawRoomTypes = prop.roomTypes || [];
    
    for (const rt of rawRoomTypes) {
      const texts = rt.texts || {};
      const displayName = getText(texts.displayName) || '';
      const shortDesc = getText(texts.roomDescription1) || '';
      const fullDesc = getText(texts.auxiliaryText) || '';
      
      // Insert room type as bookable unit
      const roomResult = await pool.query(`
        INSERT INTO bookable_units (
          property_id, name, display_name,
          short_description, full_description,
          max_guests, base_price,
          room_type, feature_codes,
          cm_room_id,
          created_at, updated_at
        ) VALUES (
          $1, $2, $3,
          $4, $5,
          $6, $7,
          $8, $9,
          $10,
          NOW(), NOW()
        )
        RETURNING id
      `, [
        gasPropertyId,
        rt.name,
        displayName || null,
        shortDesc || null,
        fullDesc || null,
        rt.maxPeople || rt.maxGuests || 2,
        rt.rackRate || null,
        getText(texts.accommodationType) || 'room',
        rt.featureCodes || null,
        String(rt.id)
      ]);
      
      roomsCreated++;
      const gasRoomId = roomResult.rows[0].id;
      
      // Import images using V1 API if requested and we have V1 key
      if (importImages && v1ApiKey && propCode) {
        try {
          // Use V1 API to get images for this room type
          const v1ImageResponse = await fetch('https://beds24.com/api/json/getPropertyImages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              apiKey: v1ApiKey,
              propKey: propCode,
              propId: propId
            })
          });
          
          const v1Images = await v1ImageResponse.json();
          
          // Filter images for this room type
          const roomImages = Array.isArray(v1Images) 
            ? v1Images.filter(img => img.roomId == rt.id || img.room_id == rt.id)
            : [];
          
          for (let i = 0; i < roomImages.length; i++) {
            const img = roomImages[i];
            const imageUrl = img.url || img.image || img.imageUrl;
            
            if (imageUrl && typeof imageUrl === 'string') {
              try {
                await pool.query(`
                  INSERT INTO room_images (room_id, image_url, display_order, is_active, created_at)
                  VALUES ($1, $2, $3, true, NOW())
                  ON CONFLICT DO NOTHING
                `, [gasRoomId, imageUrl, i]);
                imagesCreated++;
              } catch (imgErr) {
                console.log('Image insert error:', imgErr.message);
              }
            }
          }
        } catch (imgFetchErr) {
          console.log('V1 image fetch error:', imgFetchErr.message);
        }
      }
    }
    
    // Store connection info with ALL credentials for future syncs
    // Store as JSON to keep all three keys together
    const credentials = JSON.stringify({
      inviteCode: inviteCode,
      v1ApiKey: v1ApiKey || '',
      propCode: propCode || ''
    });
    
    await pool.query(`
      INSERT INTO gas_sync_connections (
        account_id, channel_manager, name, api_key, status, created_at
      ) VALUES ($1, 'beds24', $2, $3, 'active', NOW())
      ON CONFLICT (account_id, channel_manager) 
      DO UPDATE SET api_key = $3, status = 'active', updated_at = NOW()
    `, [accountId, prop.name + ' Connection', credentials]).catch(e => console.log('Connection save:', e.message));
    
    // Also store property-specific codes in gas_sync_properties if table exists
    await pool.query(`
      INSERT INTO gas_sync_properties (
        connection_id, external_property_id, gas_property_id, name, api_key, status, created_at
      )
      SELECT 
        c.id, $1, $2, $3, $4, 'active', NOW()
      FROM gas_sync_connections c 
      WHERE c.account_id = $5 AND c.adapter_code = 'beds24'
      ON CONFLICT (connection_id, external_property_id) 
      DO UPDATE SET gas_property_id = $2, api_key = $4, status = 'active', updated_at = NOW()
    `, [String(propId), gasPropertyId, prop.name, propCode || '', accountId]).catch(e => console.log('Property connection save:', e.message));
    
    console.log(`Beds24 wizard: Imported property ${prop.name} (ID ${propId}) -> GAS property ${gasPropertyId}`);
    console.log(`  - Room types: ${roomsCreated}, Images: ${imagesCreated}`);
    console.log(`  - Credentials stored: V2 ‚úì, V1 ${v1ApiKey ? '‚úì' : '‚úó'}, PropCode ${propCode ? '‚úì' : '‚úó'}`);
    
    res.json({
      success: true,
      message: 'Property imported successfully',
      gasPropertyId,
      stats: {
        roomsCreated,
        imagesCreated
      }
    });
    
  } catch (error) {
    console.error('Beds24 wizard import error:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================
// HOSTAWAY WIZARD ENDPOINTS
// ============================================

// Serve Hostaway wizard HTML
app.get('/hostaway-wizard', (req, res) => {
  const wizardPath = path.join(__dirname, 'public', 'hostaway-wizard.html');
  if (fs.existsSync(wizardPath)) {
    res.sendFile(wizardPath);
  } else {
    res.status(404).send('Hostaway wizard file not found');
  }
});

// Serve universal Calry CM wizard ‚Äî one page handles ALL Calry-based PMS
// Branding/instructions driven by ?cm= query parameter
app.get('/cm-wizard.html', (req, res) => {
  const wizardPath = path.join(__dirname, 'public', 'cm-wizard.html');
  if (fs.existsSync(wizardPath)) {
    res.sendFile(wizardPath);
  } else {
    res.status(404).send('CM wizard file not found');
  }
});

// Test Hostaway connection with credentials
app.post('/api/hostaway-wizard/test-connection', async (req, res) => {
  try {
    const { accountId, apiKey } = req.body;
    
    if (!accountId || !apiKey) {
      return res.json({ success: false, error: 'Account ID and API Key are required' });
    }
    
    const axios = require('axios');
    
    // Get access token using OAuth client credentials flow
    const tokenResponse = await axios.post(
      'https://api.hostaway.com/v1/accessTokens',
      `grant_type=client_credentials&client_id=${accountId}&client_secret=${apiKey}`,
      {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Cache-control': 'no-cache'
        },
        timeout: 30000
      }
    );
    
    if (!tokenResponse.data?.access_token) {
      return res.json({ success: false, error: 'Failed to get access token' });
    }
    
    const token = tokenResponse.data.access_token;
    
    // Test by fetching listings count
    const listingsResponse = await axios.get('https://api.hostaway.com/v1/listings?limit=1', {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    res.json({
      success: true,
      message: 'Connection successful',
      token: token,
      expiresIn: tokenResponse.data.expires_in
    });
    
  } catch (error) {
    console.error('Hostaway connection test error:', error.response?.data || error.message);
    res.json({
      success: false,
      error: error.response?.data?.message || error.message
    });
  }
});

// Get Hostaway properties (listings)
app.post('/api/hostaway-wizard/properties', async (req, res) => {
  try {
    const { token } = req.body;
    
    if (!token) {
      return res.json({ success: false, error: 'Access token required' });
    }
    
    const axios = require('axios');
    
    // Fetch all listings (paginated)
    let allListings = [];
    let offset = 0;
    const limit = 100;
    let hasMore = true;
    
    while (hasMore) {
      const response = await axios.get(`https://api.hostaway.com/v1/listings?limit=${limit}&offset=${offset}`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        timeout: 60000
      });
      
      const listings = response.data?.result || [];
      allListings = allListings.concat(listings);
      
      hasMore = listings.length >= limit;
      offset += limit;
      
      // Safety limit
      if (allListings.length >= 1000) break;
    }
    
    // Map to simplified format for wizard
    const properties = allListings.map(listing => ({
      id: listing.id,
      name: listing.name || listing.internalListingName || `Listing ${listing.id}`,
      internalName: listing.internalListingName || '',
      externalName: listing.externalListingName || '',
      address: listing.address || listing.street || '',
      city: listing.city || '',
      state: listing.state || '',
      country: listing.countryCode || listing.country || '',
      isActive: listing.isActive,
      propertyType: listing.propertyTypeId,
      thumbnailUrl: listing.thumbnailUrl || '',
      bedrooms: listing.bedroomsNumber || 0,
      bathrooms: listing.bathroomsNumber || 0,
      maxGuests: listing.personCapacity || listing.guestsIncluded || 2
    }));
    
    res.json({
      success: true,
      properties: properties,
      total: properties.length
    });
    
  } catch (error) {
    console.error('Hostaway properties error:', error.response?.data || error.message);
    res.json({
      success: false,
      error: error.response?.data?.message || error.message
    });
  }
});

// Get single Hostaway property with full details
app.post('/api/hostaway-wizard/property-details', async (req, res) => {
  try {
    const { token, listingId } = req.body;
    
    if (!token || !listingId) {
      return res.json({ success: false, error: 'Token and listing ID required' });
    }
    
    const axios = require('axios');
    
    const response = await axios.get(`https://api.hostaway.com/v1/listings/${listingId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    const listing = response.data?.result || response.data;
    
    // Extract images
    const images = (listing.listingImages || []).map((img, idx) => ({
      id: img.id,
      url: img.url,
      caption: img.airbnbCaption || img.caption || img.vrboCaption || '',
      sortOrder: img.sortOrder || idx + 1
    }));
    
    // If no listingImages but has thumbnailUrl, use that
    if (images.length === 0 && listing.thumbnailUrl) {
      images.push({
        id: null,
        url: listing.thumbnailUrl,
        caption: 'Thumbnail',
        sortOrder: 1
      });
    }
    
    res.json({
      success: true,
      property: {
        id: listing.id,
        name: listing.name,
        internalListingName: listing.internalListingName,
        externalListingName: listing.externalListingName,
        description: listing.description,
        houseRules: listing.houseRules,
        address: listing.address || listing.street,
        city: listing.city,
        state: listing.state,
        country: listing.countryCode || listing.country,
        postalCode: listing.zipcode,
        latitude: listing.lat,
        longitude: listing.lng,
        checkInTimeStart: listing.checkInTimeStart,
        checkInTimeEnd: listing.checkInTimeEnd,
        checkOutTime: listing.checkOutTime,
        currencyCode: listing.currencyCode,
        contactEmail: listing.contactEmail,
        contactPhone: listing.contactPhone,
        personCapacity: listing.personCapacity,
        bedroomsNumber: listing.bedroomsNumber,
        bathroomsNumber: listing.bathroomsNumber,
        bedsNumber: listing.bedsNumber,
        price: listing.price,
        cleaningFee: listing.cleaningFee,
        minNights: listing.minNights,
        maxNights: listing.maxNights,
        propertyTypeId: listing.propertyTypeId,
        isActive: listing.isActive,
        images: images,
        amenities: listing.amenities || [],
        raw: listing
      }
    });
    
  } catch (error) {
    console.error('Hostaway property details error:', error.response?.data || error.message);
    res.json({
      success: false,
      error: error.response?.data?.message || error.message
    });
  }
});

// Delete all Hostaway properties (for reimport)
app.post('/api/hostaway-wizard/delete-all', async (req, res) => {
  try {
    // Delete in correct order for foreign keys
    const imgResult = await pool.query(`
      DELETE FROM room_images WHERE room_id IN (SELECT id FROM bookable_units WHERE hostaway_listing_id IS NOT NULL)
    `);
    
    const roomResult = await pool.query(`
      DELETE FROM bookable_units WHERE hostaway_listing_id IS NOT NULL
    `);
    
    const propResult = await pool.query(`
      DELETE FROM properties WHERE hostaway_listing_id IS NOT NULL
    `);
    
    const connResult = await pool.query(`
      DELETE FROM gas_sync_connections WHERE adapter_code = 'hostaway'
    `);
    
    console.log('Hostaway delete-all:', {
      images: imgResult.rowCount,
      rooms: roomResult.rowCount,
      properties: propResult.rowCount,
      connections: connResult.rowCount
    });
    
    res.json({
      success: true,
      deleted: {
        images: imgResult.rowCount,
        rooms: roomResult.rowCount,
        properties: propResult.rowCount,
        connections: connResult.rowCount
      }
    });
  } catch (error) {
    console.error('Hostaway delete-all error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Sync Hostaway pricing and availability
app.post('/api/hostaway/sync-availability', async (req, res) => {
  try {
    const { connectionId, accountId } = req.body;
    
    // Get connection
    let connection;
    if (connectionId) {
      const connResult = await pool.query(
        'SELECT * FROM gas_sync_connections WHERE id = $1',
        [connectionId]
      );
      connection = connResult.rows[0];
    } else if (accountId) {
      const connResult = await pool.query(
        `SELECT * FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'hostaway'`,
        [accountId]
      );
      connection = connResult.rows[0];
    }
    
    if (!connection) {
      return res.json({ success: false, error: 'Hostaway connection not found' });
    }
    
    const credentials = typeof connection.credentials === 'string' 
      ? JSON.parse(connection.credentials) 
      : connection.credentials || {};
    
    const axios = require('axios');
    
    // Get fresh token
    let token = connection.access_token;
    if (!token && credentials.accountId && credentials.apiKey) {
      const tokenResponse = await axios.post(
        'https://api.hostaway.com/v1/accessTokens',
        `grant_type=client_credentials&client_id=${credentials.accountId}&client_secret=${credentials.apiKey}`,
        { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
      );
      token = tokenResponse.data?.access_token;
    }
    
    if (!token) {
      return res.json({ success: false, error: 'Could not get Hostaway access token' });
    }
    
    // Get all Hostaway rooms for this account
    const roomsResult = await pool.query(`
      SELECT bu.id as room_id, bu.hostaway_listing_id, bu.name, p.id as property_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1 AND bu.hostaway_listing_id IS NOT NULL
    `, [connection.account_id]);
    
    if (roomsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No Hostaway rooms found for this account' });
    }
    
    // Ensure room_availability table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS room_availability (
        id SERIAL PRIMARY KEY,
        room_id INTEGER NOT NULL,
        date DATE NOT NULL,
        cm_price DECIMAL(10,2),
        direct_price DECIMAL(10,2),
        is_available BOOLEAN DEFAULT true,
        is_blocked BOOLEAN DEFAULT false,
        min_stay INTEGER DEFAULT 1,
        max_stay INTEGER,
        source VARCHAR(50),
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        UNIQUE(room_id, date)
      )
    `);
    
    const today = new Date().toISOString().split('T')[0];
    const endDate = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    
    let totalDaysUpdated = 0;
    let roomsSynced = 0;
    const errors = [];
    
    for (const room of roomsResult.rows) {
      try {
        console.log(`Syncing Hostaway availability for ${room.name} (Listing ID: ${room.hostaway_listing_id})`);
        
        // Fetch calendar from Hostaway
        const calendarResponse = await axios.get(
          `https://api.hostaway.com/v1/listings/${room.hostaway_listing_id}/calendar`,
          {
            headers: { 'Authorization': `Bearer ${token}` },
            params: { startDate: today, endDate: endDate }
          }
        );
        
        const calendar = calendarResponse.data?.result || [];
        
        if (Array.isArray(calendar) && calendar.length > 0) {
          for (const day of calendar) {
            const isAvailable = day.status === 'available';
            const isBlocked = day.status === 'blocked';
            const price = day.price || null;
            const minStay = day.minimumStay || 1;
            
            await pool.query(`
              INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source)
              VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'hostaway')
              ON CONFLICT (room_id, date) DO UPDATE SET
                cm_price = COALESCE($3, room_availability.cm_price),
                direct_price = COALESCE($3, room_availability.direct_price),
                is_available = $4,
                is_blocked = $5,
                min_stay = $6,
                cm_min_stay = $6,
                source = 'hostaway',
                updated_at = NOW()
            `, [room.room_id, day.date, price, isAvailable, isBlocked, minStay]);
            
            totalDaysUpdated++;
          }
          roomsSynced++;
          console.log(`  ‚úì ${room.name}: ${calendar.length} days synced`);
        } else {
          console.log(`  - ${room.name}: No calendar data`);
        }
      } catch (roomErr) {
        console.error(`  ‚úó ${room.name}: ${roomErr.message}`);
        errors.push({ room: room.name, error: roomErr.message });
      }
    }
    
    // Update connection last sync time
    await pool.query(
      'UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1',
      [connection.id]
    );
    
    console.log(`Hostaway sync complete: ${roomsSynced} rooms, ${totalDaysUpdated} days updated`);
    
    res.json({
      success: true,
      message: `Synced ${roomsSynced} rooms, ${totalDaysUpdated} days updated`,
      stats: {
        roomsSynced,
        totalDaysUpdated,
        errors: errors.length
      },
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('Hostaway sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Sync Hostaway reservations (pull bookings from Hostaway into GAS)
app.post('/api/hostaway/sync-reservations', async (req, res) => {
  const client = await pool.connect();
  try {
    const { connectionId, accountId } = req.body;
    
    // Get connection
    let connection;
    if (connectionId) {
      const connResult = await pool.query(
        'SELECT * FROM gas_sync_connections WHERE id = $1',
        [connectionId]
      );
      connection = connResult.rows[0];
    } else if (accountId) {
      const connResult = await pool.query(
        `SELECT * FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'hostaway'`,
        [accountId]
      );
      connection = connResult.rows[0];
    }
    
    if (!connection) {
      return res.json({ success: false, error: 'Hostaway connection not found' });
    }
    
    const credentials = typeof connection.credentials === 'string' 
      ? JSON.parse(connection.credentials) 
      : connection.credentials || {};
    
    const axios = require('axios');
    
    // Get fresh token
    let token = connection.access_token;
    if (!token && credentials.accountId && credentials.apiKey) {
      const tokenResponse = await axios.post(
        'https://api.hostaway.com/v1/accessTokens',
        `grant_type=client_credentials&client_id=${credentials.accountId}&client_secret=${credentials.apiKey}`,
        { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
      );
      token = tokenResponse.data?.access_token;
    }
    
    if (!token) {
      return res.json({ success: false, error: 'Could not get Hostaway access token' });
    }
    
    // Get all Hostaway rooms for this account (for mapping)
    const roomsResult = await pool.query(`
      SELECT bu.id as room_id, bu.hostaway_listing_id, bu.name, p.id as property_id, p.account_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1 AND bu.hostaway_listing_id IS NOT NULL
    `, [connection.account_id]);
    
    // Create lookup by hostaway listing ID
    const roomsByListingId = {};
    roomsResult.rows.forEach(r => {
      roomsByListingId[r.hostaway_listing_id] = r;
    });
    
    if (Object.keys(roomsByListingId).length === 0) {
      return res.json({ success: false, error: 'No Hostaway rooms found for this account' });
    }
    
    // Fetch reservations from Hostaway (last 90 days and future)
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 90);
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + 365);
    
    console.log(`Fetching Hostaway reservations from ${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}`);
    
    const reservationsResponse = await axios.get('https://api.hostaway.com/v1/reservations', {
      headers: { 'Authorization': `Bearer ${token}` },
      params: {
        limit: 500,
        arrivalStartDate: startDate.toISOString().split('T')[0],
        arrivalEndDate: endDate.toISOString().split('T')[0]
      }
    });
    
    const reservations = reservationsResponse.data?.result || [];
    console.log(`Found ${reservations.length} Hostaway reservations`);
    
    let created = 0;
    let updated = 0;
    let skipped = 0;
    const errors = [];
    
    await client.query('BEGIN');
    
    for (const res of reservations) {
      try {
        const listingId = String(res.listingMapId);
        const room = roomsByListingId[listingId];
        
        if (!room) {
          skipped++;
          continue; // Skip reservations for listings we haven't imported
        }
        
        // Check if reservation already exists
        const existingBooking = await client.query(
          'SELECT id, status FROM bookings WHERE hostaway_reservation_id = $1',
          [String(res.id)]
        );
        
        // Map Hostaway status to GAS status
        const statusMap = {
          'new': 'confirmed',
          'confirmed': 'confirmed',
          'modified': 'confirmed',
          'cancelled': 'cancelled',
          'declined': 'cancelled',
          'expired': 'cancelled',
          'completed': 'checked_out'
        };
        const gasStatus = statusMap[res.status] || 'confirmed';
        
        if (existingBooking.rows.length > 0) {
          // Update existing booking
          await client.query(`
            UPDATE bookings SET
              check_in = $1,
              check_out = $2,
              guest_first_name = $3,
              guest_last_name = $4,
              guest_email = $5,
              guest_phone = $6,
              num_adults = $7,
              num_children = $8,
              total_price = $9,
              status = $10,
              channel_name = $11,
              updated_at = NOW()
            WHERE id = $12
          `, [
            res.arrivalDate,
            res.departureDate,
            res.guestFirstName || 'Guest',
            res.guestLastName || '',
            res.guestEmail || '',
            res.guestPhone || '',
            res.adults || res.numberOfGuests || 1,
            res.children || 0,
            res.totalPrice || 0,
            gasStatus,
            res.channelName || 'Hostaway',
            existingBooking.rows[0].id
          ]);
          updated++;
        } else {
          // Create new booking
          await client.query(`
            INSERT INTO bookings (
              property_id, room_id, account_id,
              check_in, check_out,
              guest_first_name, guest_last_name, guest_email, guest_phone,
              num_adults, num_children,
              total_price, currency, status,
              hostaway_reservation_id, channel_name, source,
              created_at, updated_at
            ) VALUES (
              $1, $2, $3,
              $4, $5,
              $6, $7, $8, $9,
              $10, $11,
              $12, $13, $14,
              $15, $16, 'hostaway',
              NOW(), NOW()
            )
          `, [
            room.property_id,
            room.room_id,
            room.account_id,
            res.arrivalDate,
            res.departureDate,
            res.guestFirstName || 'Guest',
            res.guestLastName || '',
            res.guestEmail || '',
            res.guestPhone || '',
            res.adults || res.numberOfGuests || 1,
            res.children || 0,
            res.totalPrice || 0,
            res.currency || 'USD',
            gasStatus,
            String(res.id),
            res.channelName || 'Hostaway'
          ]);
          created++;
        }
        
        // Update availability for booked dates
        if (gasStatus !== 'cancelled') {
          const checkIn = new Date(res.arrivalDate);
          const checkOut = new Date(res.departureDate);
          
          for (let d = new Date(checkIn); d < checkOut; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toISOString().split('T')[0];
            await client.query(`
              INSERT INTO room_availability (room_id, date, is_available, is_blocked, source)
              VALUES ($1, $2, false, false, 'hostaway_reservation')
              ON CONFLICT (room_id, date) 
              DO UPDATE SET is_available = false, source = 'hostaway_reservation', updated_at = NOW()
            `, [room.room_id, dateStr]);
          }
        }
        
      } catch (resErr) {
        console.error(`Error processing reservation ${res.id}:`, resErr.message);
        errors.push({ reservationId: res.id, error: resErr.message });
      }
    }
    
    await client.query('COMMIT');
    
    // Update connection last sync time
    await pool.query(
      'UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1',
      [connection.id]
    );
    
    console.log(`Hostaway reservations sync complete: ${created} created, ${updated} updated, ${skipped} skipped`);
    
    res.json({
      success: true,
      message: `Synced reservations: ${created} created, ${updated} updated, ${skipped} skipped`,
      stats: { created, updated, skipped, total: reservations.length, errors: errors.length },
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Hostaway reservations sync error:', error);
    res.json({ success: false, error: error.message });
  } finally {
    client.release();
  }
});

// Sync Hostaway reviews (pull reviews from Hostaway into GAS)
app.post('/api/hostaway/sync-reviews', async (req, res) => {
  try {
    const { connectionId, accountId } = req.body;
    
    // Get connection
    let connection;
    if (connectionId) {
      const connResult = await pool.query(
        'SELECT * FROM gas_sync_connections WHERE id = $1',
        [connectionId]
      );
      connection = connResult.rows[0];
    } else if (accountId) {
      const connResult = await pool.query(
        `SELECT * FROM gas_sync_connections WHERE account_id = $1 AND adapter_code = 'hostaway'`,
        [accountId]
      );
      connection = connResult.rows[0];
    }
    
    if (!connection) {
      return res.json({ success: false, error: 'Hostaway connection not found' });
    }
    
    const credentials = typeof connection.credentials === 'string' 
      ? JSON.parse(connection.credentials) 
      : connection.credentials || {};
    
    // Get fresh token
    let token = connection.access_token;
    if (!token && credentials.accountId && credentials.apiKey) {
      const tokenResponse = await axios.post(
        'https://api.hostaway.com/v1/accessTokens',
        `grant_type=client_credentials&client_id=${credentials.accountId}&client_secret=${credentials.apiKey}`,
        { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
      );
      token = tokenResponse.data?.access_token;
    }
    
    if (!token) {
      return res.json({ success: false, error: 'Could not get Hostaway access token' });
    }
    
    // Get all Hostaway rooms for this account (for property mapping)
    const roomsResult = await pool.query(`
      SELECT bu.id as room_id, bu.hostaway_listing_id, bu.name, p.id as property_id, p.account_id
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1 AND bu.hostaway_listing_id IS NOT NULL
    `, [connection.account_id]);
    
    // Create lookup by hostaway listing ID
    const roomsByListingId = {};
    roomsResult.rows.forEach(r => {
      roomsByListingId[r.hostaway_listing_id] = r;
    });
    
    if (Object.keys(roomsByListingId).length === 0) {
      return res.json({ success: false, error: 'No Hostaway rooms found for this account' });
    }
    
    // Fetch reviews from Hostaway API
    console.log(`Fetching Hostaway reviews for account ${connection.account_id}...`);
    
    let allReviews = [];
    let offset = 0;
    const limit = 100;
    let hasMore = true;
    
    while (hasMore) {
      const reviewsResponse = await axios.get('https://api.hostaway.com/v1/reviews', {
        headers: { 'Authorization': `Bearer ${token}` },
        params: { limit, offset }
      });
      
      const reviews = reviewsResponse.data?.result || [];
      allReviews = allReviews.concat(reviews);
      
      if (reviews.length < limit) {
        hasMore = false;
      } else {
        offset += limit;
        if (offset > 10000) hasMore = false;
      }
    }
    
    console.log(`Found ${allReviews.length} Hostaway reviews`);
    
    let created = 0;
    let updated = 0;
    let skipped = 0;
    const errors = [];
    
    for (const review of allReviews) {
      try {
        // Skip host-to-guest reviews (we only want guest reviews of property)
        if (review.type === 'host-to-guest') {
          skipped++;
          continue;
        }
        
        // Skip reviews that are awaiting or have no content
        if (review.status === 'awaiting' || (!review.publicReview && !review.rating)) {
          skipped++;
          continue;
        }
        
        const listingId = String(review.listingMapId || review.listingId);
        const room = roomsByListingId[listingId];
        
        if (!room) {
          skipped++;
          continue;
        }
        
        const existingReview = await pool.query(
          `SELECT id FROM reviews WHERE source = 'hostaway' AND external_id = $1`,
          [String(review.id)]
        );
        
        // Map Hostaway channelId to channel name
        const channelIdMap = {
          2000: 'Airbnb',
          2001: 'HomeAway',
          2002: 'VRBO',
          2003: 'Booking.com',
          2004: 'Expedia',
          2005: 'TripAdvisor',
          2006: 'Google',
          2007: 'Agoda',
          2008: 'Hotels.com',
          2009: 'Direct',
          2010: 'Other'
        };
        const channelName = channelIdMap[review.channelId] || review.channelName || review.source || 'Unknown';
        
        const subRatings = {};
        if (review.accuracyRating) subRatings.accuracy = review.accuracyRating;
        if (review.cleanlinessRating) subRatings.cleanliness = review.cleanlinessRating;
        if (review.communicationRating) subRatings.communication = review.communicationRating;
        if (review.locationRating) subRatings.location = review.locationRating;
        if (review.checkinRating) subRatings.checkin = review.checkinRating;
        if (review.valueRating) subRatings.value = review.valueRating;
        
        const reviewData = {
          account_id: room.account_id,
          property_id: room.property_id,
          room_id: room.room_id,
          external_id: String(review.id),
          source: 'hostaway',
          channel_name: channelName,
          review_type: review.type || 'guest-to-host',
          reservation_id: review.reservationId ? String(review.reservationId) : null,
          guest_name: review.guestName || review.reviewerName || 'Guest',
          guest_avatar: review.guestPicture || review.reviewerPhoto || null,
          guest_country: review.guestCountry || null,
          rating: review.overallRating || review.rating || null,
          title: review.headline || review.title || null,
          comment: review.publicReview || review.comment || review.reviewText || null,
          private_feedback: review.privateReview || review.privateFeedback || null,
          host_reply: review.revieweeResponse || review.hostReply || review.response || null,
          host_reply_at: review.hostReplyDate ? new Date(review.hostReplyDate) : null,
          review_date: review.submittedAt || review.reviewDate || review.insertedOn || null,
          stay_date_start: review.arrivalDate || review.checkIn || null,
          stay_date_end: review.departureDate || review.checkOut || null,
          is_public: review.isHidden !== 1,
          language: review.language || null,
          sub_ratings: Object.keys(subRatings).length > 0 ? JSON.stringify(subRatings) : null,
          raw_data: JSON.stringify(review)
        };
        
        if (existingReview.rows.length > 0) {
          await pool.query(`
            UPDATE reviews SET
              property_id = $1, room_id = $2, channel_name = $3, reservation_id = $4,
              guest_name = $5, guest_avatar = $6, guest_country = $7, rating = $8,
              title = $9, comment = $10, private_feedback = $11, host_reply = $12,
              host_reply_at = $13, review_date = $14, stay_date_start = $15, stay_date_end = $16,
              is_public = $17, language = $18, sub_ratings = $19, raw_data = $20,
              synced_at = NOW(), updated_at = NOW()
            WHERE id = $21
          `, [
            reviewData.property_id, reviewData.room_id, reviewData.channel_name, reviewData.reservation_id,
            reviewData.guest_name, reviewData.guest_avatar, reviewData.guest_country, reviewData.rating,
            reviewData.title, reviewData.comment, reviewData.private_feedback, reviewData.host_reply,
            reviewData.host_reply_at, reviewData.review_date, reviewData.stay_date_start, reviewData.stay_date_end,
            reviewData.is_public, reviewData.language, reviewData.sub_ratings, reviewData.raw_data,
            existingReview.rows[0].id
          ]);
          updated++;
        } else {
          await pool.query(`
            INSERT INTO reviews (
              account_id, property_id, room_id, external_id, source, channel_name, reservation_id,
              guest_name, guest_avatar, guest_country, rating, title, comment, private_feedback,
              host_reply, host_reply_at, review_date, stay_date_start, stay_date_end, is_public,
              language, sub_ratings, raw_data, synced_at, created_at, updated_at
            ) VALUES ($1, $2, $3, $4, 'hostaway', $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, NOW(), NOW(), NOW())
          `, [
            reviewData.account_id, reviewData.property_id, reviewData.room_id, reviewData.external_id,
            reviewData.channel_name, reviewData.reservation_id, reviewData.guest_name, reviewData.guest_avatar,
            reviewData.guest_country, reviewData.rating, reviewData.title, reviewData.comment,
            reviewData.private_feedback, reviewData.host_reply, reviewData.host_reply_at, reviewData.review_date,
            reviewData.stay_date_start, reviewData.stay_date_end, reviewData.is_public, reviewData.language,
            reviewData.sub_ratings, reviewData.raw_data
          ]);
          created++;
        }
        
      } catch (reviewErr) {
        console.error(`Error processing review ${review.id}:`, reviewErr.message);
        errors.push({ reviewId: review.id, error: reviewErr.message });
      }
    }
    
    await pool.query(
      'UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1',
      [connection.id]
    );
    
    console.log(`Hostaway reviews sync complete: ${created} created, ${updated} updated, ${skipped} skipped`);
    
    res.json({
      success: true,
      message: `Synced reviews: ${created} created, ${updated} updated, ${skipped} skipped`,
      stats: { created, updated, skipped, total: allReviews.length, errors: errors.length },
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('Hostaway reviews sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// =====================================================
// BEDS24 REVIEWS SYNC
// =====================================================

// Sync reviews from Beds24 (Airbnb + Booking.com channels)
app.post('/api/beds24/sync-reviews', async (req, res) => {
  try {
    const { connectionId } = req.body;
    
    if (!connectionId) {
      return res.json({ success: false, error: 'connectionId required' });
    }
    
    // Get connection
    const connResult = await pool.query(
      'SELECT * FROM gas_sync_connections WHERE id = $1',
      [connectionId]
    );
    const connection = connResult.rows[0];
    
    if (!connection) {
      return res.json({ success: false, error: 'Connection not found' });
    }
    
    if (connection.adapter_code !== 'beds24') {
      return res.json({ success: false, error: 'Not a Beds24 connection' });
    }
    
    const token = connection.access_token;
    if (!token) {
      return res.json({ success: false, error: 'No Beds24 V2 token available' });
    }
    
    // Get all Beds24 rooms for this connection (for property mapping)
    const roomsResult = await pool.query(`
      SELECT gsp.id as sync_property_id, gsp.external_id as beds24_property_id, gsp.gas_property_id,
             bu.id as room_id, p.account_id
      FROM gas_sync_properties gsp
      LEFT JOIN properties p ON gsp.gas_property_id = p.id
      LEFT JOIN bookable_units bu ON bu.property_id = p.id
      WHERE gsp.connection_id = $1 AND gsp.gas_property_id IS NOT NULL
    `, [connectionId]);
    
    // Create lookup by Beds24 property ID
    const roomsByBeds24Id = {};
    roomsResult.rows.forEach(r => {
      roomsByBeds24Id[String(r.beds24_property_id)] = r;
    });
    
    if (Object.keys(roomsByBeds24Id).length === 0) {
      return res.json({ success: false, error: 'No imported properties found for this connection' });
    }
    
    console.log(`Beds24 reviews sync: Found ${Object.keys(roomsByBeds24Id).length} imported properties`);
    
    let allReviews = [];
    const errors = [];
    const propertyIds = Object.keys(roomsByBeds24Id);
    
    // Fetch reviews for each property
    for (const propertyId of propertyIds) {
      // Fetch Airbnb reviews for this property
      try {
        const airbnbResponse = await axios.get('https://beds24.com/api/v2/channels/airbnb/reviews', {
          headers: { 'token': token },
          params: { propertyId: propertyId }
        });
        
        if (airbnbResponse.data?.success && airbnbResponse.data?.data) {
          const airbnbReviews = airbnbResponse.data.data.map(r => ({ ...r, _channel: 'Airbnb', _propertyId: propertyId }));
          allReviews = allReviews.concat(airbnbReviews);
        }
      } catch (airbnbErr) {
        // Only log if it's not a "no reviews" type error
        const errDetail = airbnbErr.response?.data || airbnbErr.message;
        if (errDetail?.code !== 3000) {
          console.log(`Beds24 reviews: Airbnb error for property ${propertyId}:`, errDetail);
        }
      }
      
      // Fetch Booking.com reviews for this property
      try {
        const bookingResponse = await axios.get('https://beds24.com/api/v2/channels/booking/reviews', {
          headers: { 'token': token },
          params: { propertyId: propertyId }
        });
        
        if (bookingResponse.data?.success && bookingResponse.data?.data) {
          const bookingReviews = bookingResponse.data.data.map(r => ({ ...r, _channel: 'Booking.com', _propertyId: propertyId }));
          allReviews = allReviews.concat(bookingReviews);
        }
      } catch (bookingErr) {
        const errDetail = bookingErr.response?.data || bookingErr.message;
        if (errDetail?.code !== 3000) {
          console.log(`Beds24 reviews: Booking.com error for property ${propertyId}:`, errDetail);
        }
      }
    }
    
    console.log(`Beds24 reviews: Found ${allReviews.length} total reviews across ${propertyIds.length} properties`);
    
    let created = 0;
    let updated = 0;
    let skipped = 0;
    
    for (const review of allReviews) {
      try {
        // Use the propertyId we attached when fetching, or fall back to review data
        const propertyId = String(review._propertyId || review.propertyId || review.roomId || review.listingId || '');
        const room = roomsByBeds24Id[propertyId];
        
        if (!room) {
          skipped++;
          continue;
        }
        
        // Generate external ID based on channel
        const externalId = review._channel === 'Airbnb' 
          ? `airbnb-${review.id || review.reviewer_id}-${review.submitted_at || ''}`
          : `booking-${review.review_id || review.reservation_id || ''}`;
        
        const existingReview = await pool.query(
          `SELECT id FROM reviews WHERE source = 'beds24' AND external_id = $1`,
          [externalId]
        );
        
        // Extract review data based on channel
        let rating, comment, guestName, guestCountry, reviewDate, title, subRatings = {};
        
        if (review._channel === 'Airbnb') {
          // Airbnb structure
          rating = review.overall_rating;
          comment = review.public_review;
          guestName = review.reviewer_name || 'Guest';
          reviewDate = review.submitted_at || review.first_completed_at;
          
          // Category ratings
          if (review.category_ratings && Array.isArray(review.category_ratings)) {
            review.category_ratings.forEach(cr => {
              if (cr.category && cr.rating) {
                subRatings[cr.category.toLowerCase()] = cr.rating;
              }
            });
          }
        } else {
          // Booking.com structure
          rating = review.scoring?.review_score;
          comment = [review.content?.positive, review.content?.negative].filter(Boolean).join('\n\n');
          title = review.content?.headline;
          guestName = review.reviewer?.name || 'Guest';
          guestCountry = review.reviewer?.country_code;
          reviewDate = review.created_timestamp;
          
          // Sub-ratings from scoring
          if (review.scoring) {
            if (review.scoring.clean) subRatings.cleanliness = review.scoring.clean;
            if (review.scoring.facilities) subRatings.facilities = review.scoring.facilities;
            if (review.scoring.location) subRatings.location = review.scoring.location;
            if (review.scoring.services) subRatings.services = review.scoring.services;
            if (review.scoring.staff) subRatings.staff = review.scoring.staff;
            if (review.scoring.value) subRatings.value = review.scoring.value;
          }
        }
        
        // Normalize rating to 5-point scale if needed (Booking.com uses 10-point)
        if (review._channel === 'Booking.com' && rating && rating > 5) {
          rating = rating / 2;
        }
        
        const reviewData = {
          account_id: room.account_id,
          property_id: room.gas_property_id,
          room_id: room.room_id,
          external_id: externalId,
          source: 'beds24',
          channel_name: review._channel,
          reservation_id: review.reservation_id ? String(review.reservation_id) : null,
          guest_name: guestName,
          guest_country: guestCountry || null,
          rating: rating || null,
          title: title || null,
          comment: comment || null,
          private_feedback: review.private_feedback || review.privateReview || null,
          host_reply: review.reviewee_response || review.reply?.text || null,
          host_reply_at: review.responded_at || review.reply?.last_change_timestamp || null,
          review_date: reviewDate || null,
          is_public: review.hidden !== true,
          language: review.content?.language_code || null,
          sub_ratings: Object.keys(subRatings).length > 0 ? JSON.stringify(subRatings) : null,
          raw_data: JSON.stringify(review)
        };
        
        if (existingReview.rows.length > 0) {
          await pool.query(`
            UPDATE reviews SET
              property_id = $1, room_id = $2, channel_name = $3, reservation_id = $4,
              guest_name = $5, guest_country = $6, rating = $7,
              title = $8, comment = $9, private_feedback = $10, host_reply = $11,
              host_reply_at = $12, review_date = $13, is_public = $14, language = $15,
              sub_ratings = $16, raw_data = $17, synced_at = NOW(), updated_at = NOW()
            WHERE id = $18
          `, [
            reviewData.property_id, reviewData.room_id, reviewData.channel_name, reviewData.reservation_id,
            reviewData.guest_name, reviewData.guest_country, reviewData.rating,
            reviewData.title, reviewData.comment, reviewData.private_feedback, reviewData.host_reply,
            reviewData.host_reply_at, reviewData.review_date, reviewData.is_public, reviewData.language,
            reviewData.sub_ratings, reviewData.raw_data,
            existingReview.rows[0].id
          ]);
          updated++;
        } else {
          await pool.query(`
            INSERT INTO reviews (
              account_id, property_id, room_id, external_id, source, channel_name, reservation_id,
              guest_name, guest_country, rating, title, comment, private_feedback,
              host_reply, host_reply_at, review_date, is_public, language, sub_ratings, raw_data,
              synced_at, created_at, updated_at
            ) VALUES ($1, $2, $3, $4, 'beds24', $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, NOW(), NOW(), NOW())
          `, [
            reviewData.account_id, reviewData.property_id, reviewData.room_id, reviewData.external_id,
            reviewData.channel_name, reviewData.reservation_id, reviewData.guest_name, reviewData.guest_country,
            reviewData.rating, reviewData.title, reviewData.comment, reviewData.private_feedback,
            reviewData.host_reply, reviewData.host_reply_at, reviewData.review_date, reviewData.is_public,
            reviewData.language, reviewData.sub_ratings, reviewData.raw_data
          ]);
          created++;
        }
        
      } catch (reviewErr) {
        console.error(`Beds24 reviews: Error processing review:`, reviewErr.message);
        errors.push({ review: review.id, error: reviewErr.message });
        skipped++;
      }
    }
    
    await pool.query(
      'UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1',
      [connectionId]
    );
    
    console.log(`Beds24 reviews sync complete: ${created} created, ${updated} updated, ${skipped} skipped`);
    
    res.json({
      success: true,
      message: `Synced reviews: ${created} created, ${updated} updated, ${skipped} skipped`,
      stats: { created, updated, skipped, total: allReviews.length, errors: errors.length },
      errors: errors.length > 0 ? errors : undefined
    });
    
  } catch (error) {
    console.error('Beds24 reviews sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Debug endpoint to test Beds24 reviews API for a single property
app.post('/api/beds24/test-reviews-api', async (req, res) => {
  try {
    const { connectionId, propertyId, showToken, testProperty } = req.body;
    
    const connResult = await pool.query('SELECT * FROM gas_sync_connections WHERE id = $1', [connectionId]);
    const connection = connResult.rows[0];
    
    if (!connection || !connection.access_token) {
      return res.json({ success: false, error: 'No token' });
    }
    
    const token = connection.access_token;
    
    // If just requesting token for Swagger testing
    if (showToken) {
      return res.json({ success: true, token: token });
    }
    
    // If testing property details
    if (testProperty) {
      try {
        // Get full property with all rooms and details from V2
        const propResp = await axios.get('https://beds24.com/api/v2/properties', {
          headers: { 'token': token },
          params: { 
            id: propertyId,
            includeAllRooms: true,
            includePriceRules: true
          }
        });
        
        // Also try V1 getDailyPriceSetup if we have V1 credentials
        let v1DailyPriceSetup = null;
        if (connection.api_key) {
          try {
            const v1Resp = await axios.post('https://api.beds24.com/json/getDailyPriceSetup', {
              authentication: {
                apiKey: connection.api_key,
                propKey: propertyId  // Try with propertyId as propKey
              }
            });
            v1DailyPriceSetup = v1Resp.data;
          } catch (v1Err) {
            v1DailyPriceSetup = { error: v1Err.message };
          }
        }
        
        return res.json({ 
          success: true, 
          property: propResp.data?.data?.[0] || propResp.data,
          allKeys: Object.keys(propResp.data?.data?.[0] || {}),
          v1DailyPriceSetup,
          hasV1Key: !!connection.api_key
        });
      } catch (e) {
        return res.json({ success: false, error: e.response?.data || e.message });
      }
    }
    
    // Test calendar to see if prices are already calculated with linking
    if (req.body.testCalendar) {
      try {
        const roomId = req.body.roomId || 418862; // Barnsley's room ID
        const today = new Date().toISOString().split('T')[0];
        const endDate = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
        
        const calResp = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
          headers: { 'token': token },
          params: { 
            roomId: roomId,
            startDate: today,
            endDate: endDate,
            includeNumAvail: true,
            includePrices: true,
            includeMinStay: true
          }
        });
        
        return res.json({
          success: true,
          roomId,
          calendar: calResp.data?.data?.[0]?.calendar || calResp.data
        });
      } catch (e) {
        return res.json({ success: false, error: e.response?.data || e.message });
      }
    }
    
    const results = {};
    
    // First verify token works with a known endpoint
    try {
      const propResp = await axios.get('https://beds24.com/api/v2/properties', {
        headers: { 'token': token },
        params: { id: propertyId }
      });
      results.token_test_properties = { success: true, count: propResp.data?.data?.length || 0 };
    } catch (e) {
      results.token_test_properties = { error: e.response?.data || e.message };
    }
    
    // Try GET /channels/booking/reviews with propertyId AND from date (required!)
    try {
      const resp = await axios.get('https://beds24.com/api/v2/channels/booking/reviews', {
        headers: { 'token': token },
        params: { 
          propertyId: parseInt(propertyId),
          from: '2024-01-01'  // Get reviews from last year+
        }
      });
      results.booking_with_from = resp.data;
    } catch (e) { 
      results.booking_with_from = e.response?.data || e.message;
    }
    
    res.json({ success: true, results, tokenLength: token?.length });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Global sync reviews for ALL Hostaway-connected accounts
app.post('/api/hostaway/sync-all-reviews', async (req, res) => {
  try {
    const connectionsResult = await pool.query(`
      SELECT * FROM gas_sync_connections 
      WHERE adapter_code = 'hostaway' AND status = 'active'
    `);
    
    if (connectionsResult.rows.length === 0) {
      return res.json({ success: false, error: 'No active Hostaway connections found' });
    }
    
    console.log(`Starting global Hostaway reviews sync for ${connectionsResult.rows.length} connections...`);
    
    const results = [];
    
    for (const connection of connectionsResult.rows) {
      try {
        const credentials = typeof connection.credentials === 'string' 
          ? JSON.parse(connection.credentials) 
          : connection.credentials || {};
        
        let token = connection.access_token;
        if (!token && credentials.accountId && credentials.apiKey) {
          const tokenResponse = await axios.post(
            'https://api.hostaway.com/v1/accessTokens',
            `grant_type=client_credentials&client_id=${credentials.accountId}&client_secret=${credentials.apiKey}`,
            { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }
          );
          token = tokenResponse.data?.access_token;
        }
        
        if (!token) {
          results.push({ accountId: connection.account_id, success: false, error: 'No token' });
          continue;
        }
        
        const roomsResult = await pool.query(`
          SELECT bu.id as room_id, bu.hostaway_listing_id, bu.name, p.id as property_id, p.account_id
          FROM bookable_units bu
          JOIN properties p ON bu.property_id = p.id
          WHERE p.account_id = $1 AND bu.hostaway_listing_id IS NOT NULL
        `, [connection.account_id]);
        
        const roomsByListingId = {};
        roomsResult.rows.forEach(r => {
          roomsByListingId[r.hostaway_listing_id] = r;
        });
        
        if (Object.keys(roomsByListingId).length === 0) {
          results.push({ accountId: connection.account_id, success: true, skipped: true, message: 'No rooms' });
          continue;
        }
        
        const reviewsResponse = await axios.get('https://api.hostaway.com/v1/reviews', {
          headers: { 'Authorization': `Bearer ${token}` },
          params: { limit: 500 }
        });
        
        const reviews = reviewsResponse.data?.result || [];
        let created = 0, updated = 0, skipped = 0;
        
        for (const review of reviews) {
          const listingId = String(review.listingMapId || review.listingId);
          const room = roomsByListingId[listingId];
          
          if (!room) { skipped++; continue; }
          
          const subRatings = {};
          if (review.accuracyRating) subRatings.accuracy = review.accuracyRating;
          if (review.cleanlinessRating) subRatings.cleanliness = review.cleanlinessRating;
          if (review.communicationRating) subRatings.communication = review.communicationRating;
          if (review.locationRating) subRatings.location = review.locationRating;
          if (review.checkinRating) subRatings.checkin = review.checkinRating;
          if (review.valueRating) subRatings.value = review.valueRating;
          
          const existing = await pool.query(
            `SELECT id FROM reviews WHERE source = 'hostaway' AND external_id = $1`,
            [String(review.id)]
          );
          
          if (existing.rows.length > 0) {
            await pool.query(`
              UPDATE reviews SET rating = $1, comment = $2, host_reply = $3, 
              sub_ratings = $4, raw_data = $5, synced_at = NOW(), updated_at = NOW()
              WHERE id = $6
            `, [
              review.overallRating || review.rating,
              review.publicReview || review.comment || review.reviewText,
              review.hostReply || review.response,
              Object.keys(subRatings).length > 0 ? JSON.stringify(subRatings) : null,
              JSON.stringify(review),
              existing.rows[0].id
            ]);
            updated++;
          } else {
            await pool.query(`
              INSERT INTO reviews (
                account_id, property_id, room_id, external_id, source, channel_name, reservation_id,
                guest_name, guest_avatar, guest_country, rating, title, comment, private_feedback,
                host_reply, host_reply_at, review_date, stay_date_start, stay_date_end, is_public,
                language, sub_ratings, raw_data
              ) VALUES ($1, $2, $3, $4, 'hostaway', $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
            `, [
              room.account_id, room.property_id, room.room_id, String(review.id),
              review.channelName || review.source || 'Unknown',
              review.reservationId ? String(review.reservationId) : null,
              review.guestName || review.reviewerName || 'Guest',
              review.guestPicture || review.reviewerPhoto,
              review.guestCountry,
              review.overallRating || review.rating,
              review.headline || review.title,
              review.publicReview || review.comment || review.reviewText,
              review.privateReview || review.privateFeedback,
              review.hostReply || review.response,
              review.hostReplyDate ? new Date(review.hostReplyDate) : null,
              review.reviewDate || review.submittedAt || review.createdAt,
              review.arrivalDate || review.checkIn,
              review.departureDate || review.checkOut,
              review.isPublic !== false,
              review.language,
              Object.keys(subRatings).length > 0 ? JSON.stringify(subRatings) : null,
              JSON.stringify(review)
            ]);
            created++;
          }
        }
        
        results.push({ 
          accountId: connection.account_id, 
          connectionName: connection.name,
          success: true, 
          stats: { created, updated, skipped, total: reviews.length } 
        });
        
      } catch (connError) {
        console.error(`Error syncing reviews for connection ${connection.id}:`, connError.message);
        results.push({ accountId: connection.account_id, success: false, error: connError.message });
      }
    }
    
    const totalCreated = results.reduce((sum, r) => sum + (r.stats?.created || 0), 0);
    const totalUpdated = results.reduce((sum, r) => sum + (r.stats?.updated || 0), 0);
    
    console.log(`Global Hostaway reviews sync complete: ${totalCreated} created, ${totalUpdated} updated`);
    
    res.json({
      success: true,
      message: `Synced reviews across ${results.length} connections`,
      totalCreated,
      totalUpdated,
      results
    });
    
  } catch (error) {
    console.error('Global Hostaway reviews sync error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get reviews for an account
app.get('/api/reviews', async (req, res) => {
  try {
    const { account_id, property_id, room_id, source, min_rating, limit = 50, offset = 0 } = req.query;
    
    let query = `
      SELECT r.*, p.name as property_name, bu.name as room_name
      FROM reviews r
      LEFT JOIN properties p ON r.property_id = p.id
      LEFT JOIN bookable_units bu ON r.room_id = bu.id
      WHERE 1=1
    `;
    const params = [];
    let paramIndex = 1;
    
    if (account_id) {
      query += ` AND r.account_id = $${paramIndex}`;
      params.push(account_id);
      paramIndex++;
    }
    if (property_id) {
      query += ` AND r.property_id = $${paramIndex}`;
      params.push(property_id);
      paramIndex++;
    }
    if (room_id) {
      query += ` AND r.room_id = $${paramIndex}`;
      params.push(room_id);
      paramIndex++;
    }
    if (source) {
      query += ` AND r.source = $${paramIndex}`;
      params.push(source);
      paramIndex++;
    }
    if (min_rating) {
      query += ` AND r.rating >= $${paramIndex}`;
      params.push(min_rating);
      paramIndex++;
    }
    
    query += ` ORDER BY r.review_date DESC NULLS LAST, r.created_at DESC`;
    
    // Add LIMIT and OFFSET
    const limitVal = Math.max(1, parseInt(limit) || 50);
    const offsetVal = Math.max(0, parseInt(offset) || 0);
    query += ` LIMIT ${limitVal} OFFSET ${offsetVal}`;
    
    const reviewsResult = await pool.query(query, params);
    
    // Stats query - with or without account filter
    let avgQuery, avgParams;
    if (account_id) {
      avgQuery = `SELECT AVG(rating) as avg_rating, COUNT(*) as total FROM reviews WHERE account_id = $1 AND rating IS NOT NULL`;
      avgParams = [account_id];
    } else {
      avgQuery = `SELECT AVG(rating) as avg_rating, COUNT(*) as total FROM reviews WHERE rating IS NOT NULL`;
      avgParams = [];
    }
    const avgResult = await pool.query(avgQuery, avgParams);
    
    res.json({
      success: true,
      reviews: reviewsResult.rows,
      total: reviewsResult.rows.length,
      average_rating: parseFloat(avgResult.rows[0].avg_rating || 0).toFixed(1),
      total_reviews: parseInt(avgResult.rows[0].total)
    });
    
  } catch (error) {
    console.error('Get reviews error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Debug endpoint to see raw review data
app.get('/api/reviews/debug/:id', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM reviews WHERE id = $1', [req.params.id]);
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'Review not found' });
    }
    const review = result.rows[0];
    let rawData = null;
    try {
      rawData = typeof review.raw_data === 'string' ? JSON.parse(review.raw_data) : review.raw_data;
    } catch (e) {
      rawData = review.raw_data;
    }
    res.json({
      success: true,
      review: {
        id: review.id,
        channel_name: review.channel_name,
        source: review.source,
        rating: review.rating,
        guest_name: review.guest_name
      },
      raw_data_keys: rawData ? Object.keys(rawData) : [],
      raw_data: rawData
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Get review statistics for an account
app.get('/api/reviews/stats', async (req, res) => {
  try {
    const { account_id, property_id } = req.query;
    
    if (!account_id) {
      return res.json({ success: false, error: 'account_id required' });
    }
    
    let whereClause = 'account_id = $1';
    const params = [account_id];
    
    if (property_id) {
      whereClause += ' AND property_id = $2';
      params.push(property_id);
    }
    
    const overallStats = await pool.query(`
      SELECT 
        COUNT(*) as total_reviews,
        AVG(rating) as average_rating,
        COUNT(CASE WHEN rating >= 4.5 THEN 1 END) as excellent_count,
        COUNT(CASE WHEN rating >= 4.0 AND rating < 4.5 THEN 1 END) as good_count,
        COUNT(CASE WHEN rating >= 3.0 AND rating < 4.0 THEN 1 END) as average_count,
        COUNT(CASE WHEN rating < 3.0 THEN 1 END) as poor_count,
        COUNT(CASE WHEN host_reply IS NOT NULL THEN 1 END) as replied_count
      FROM reviews
      WHERE ${whereClause} AND rating IS NOT NULL
    `, params);
    
    const bySource = await pool.query(`
      SELECT source, channel_name, COUNT(*) as count, AVG(rating) as average_rating
      FROM reviews WHERE ${whereClause}
      GROUP BY source, channel_name ORDER BY count DESC
    `, params);
    
    const trend = await pool.query(`
      SELECT DATE_TRUNC('month', COALESCE(review_date, created_at)) as month,
        COUNT(*) as count, AVG(rating) as average_rating
      FROM reviews
      WHERE ${whereClause} AND COALESCE(review_date, created_at) > NOW() - INTERVAL '6 months'
      GROUP BY DATE_TRUNC('month', COALESCE(review_date, created_at))
      ORDER BY month DESC
    `, params);
    
    const stats = overallStats.rows[0];
    
    res.json({
      success: true,
      stats: {
        total_reviews: parseInt(stats.total_reviews),
        average_rating: parseFloat(stats.average_rating || 0).toFixed(2),
        rating_distribution: {
          excellent: parseInt(stats.excellent_count),
          good: parseInt(stats.good_count),
          average: parseInt(stats.average_count),
          poor: parseInt(stats.poor_count)
        },
        response_rate: stats.total_reviews > 0 
          ? Math.round((parseInt(stats.replied_count) / parseInt(stats.total_reviews)) * 100) 
          : 0
      },
      by_source: bySource.rows,
      trend: trend.rows
    });
    
  } catch (error) {
    console.error('Get review stats error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Import Hostaway property into GAS
app.post('/api/hostaway-wizard/import', async (req, res) => {
  try {
    const { accountId, apiKey, token, listingId, importImages, gasAccountId } = req.body;
    
    if (!token || !listingId || !gasAccountId) {
      return res.json({ success: false, error: 'Token, listing ID, and GAS account ID required' });
    }
    
    const axios = require('axios');
    
    // Fetch full listing details WITH images (includeResources=1 is required for listingImages)
    const response = await axios.get(`https://api.hostaway.com/v1/listings/${listingId}?includeResources=1`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });
    
    const listing = response.data?.result || response.data;
    
    if (!listing || !listing.id) {
      return res.json({ success: false, error: 'Listing not found' });
    }
    
    // Debug: log what we got for images
    console.log('Hostaway listing images:', {
      listingId: listing.id,
      hasListingImages: !!listing.listingImages,
      listingImagesCount: listing.listingImages?.length || 0,
      hasThumbnail: !!listing.thumbnailUrl,
      thumbnailUrl: listing.thumbnailUrl
    });
    
    // Check if property already exists
    const existingProp = await pool.query(
      `SELECT p.id as property_id, bu.id as room_id 
       FROM properties p 
       LEFT JOIN bookable_units bu ON bu.property_id = p.id 
       WHERE p.hostaway_listing_id = $1`,
      [String(listing.id)]
    ).catch(() => ({ rows: [] }));
    
    // If exists and not updating, return error
    const updateExisting = req.body.updateExisting;
    if (existingProp.rows.length > 0 && !updateExisting) {
      return res.json({
        success: false,
        error: 'This property has already been imported',
        existingPropertyId: existingProp.rows[0].property_id
      });
    }
    
    // If updating existing, just import images
    if (existingProp.rows.length > 0 && updateExisting) {
      const gasPropertyId = existingProp.rows[0].property_id;
      const gasRoomId = existingProp.rows[0].room_id;
      let imagesCreated = 0;
      
      if (importImages && gasRoomId) {
        const images = listing.listingImages || [];
        
        // If no listingImages but has thumbnailUrl, use that (larger version)
        if (images.length === 0 && listing.thumbnailUrl) {
          let fullSizeUrl = listing.thumbnailUrl;
          if (fullSizeUrl.includes('aki_policy=')) {
            fullSizeUrl = fullSizeUrl.replace(/\?aki_policy=\w+/, '');
          }
          images.push({ id: 'thumb', url: fullSizeUrl, sortOrder: 1 });
        }
        
        for (let i = 0; i < images.length; i++) {
          const img = images[i];
          if (img.url) {
            try {
              const imageKey = `hostaway_${listing.id}_${img.id || i}`;
              // Check if already exists
              const existing = await pool.query(
                'SELECT id FROM room_images WHERE image_key = $1', [imageKey]
              ).catch(() => ({ rows: [] }));
              
              if (existing.rows.length === 0) {
                await pool.query(`
                  INSERT INTO room_images (room_id, image_key, image_url, thumbnail_url, display_order, upload_source, is_active, created_at)
                  VALUES ($1, $2, $3, $4, $5, 'hostaway', true, NOW())
                `, [gasRoomId, imageKey, img.url, img.url, img.sortOrder || i + 1]);
                imagesCreated++;
              }
            } catch (imgErr) {
              console.log('Image insert error:', imgErr.message);
            }
          }
        }
      }
      
      console.log(`Hostaway wizard: Updated existing property ${listing.name} with ${imagesCreated} images`);
      
      return res.json({
        success: true,
        message: 'Property updated with images',
        gasPropertyId,
        gasRoomId,
        stats: { roomsCreated: 0, imagesCreated }
      });
    }
    
    // Ensure hostaway_listing_id column exists
    await pool.query('ALTER TABLE properties ADD COLUMN IF NOT EXISTS hostaway_listing_id VARCHAR(50)').catch(() => {});
    
    // Helper to safely convert to string
    const safeString = (val) => {
      if (val === null || val === undefined) return '';
      if (typeof val === 'string') return val;
      if (typeof val === 'object') return JSON.stringify(val);
      return String(val);
    };
    
    // Helper for JSONB text columns (short_description, full_description, house_rules, etc)
    const toJsonText = (val) => {
      if (val === null || val === undefined || val === '') return null;
      const text = safeString(val);
      if (!text) return null;
      return JSON.stringify({ en: text });
    };
    
    // Create property in GAS - only location/contact info
    const propertyResult = await pool.query(`
      INSERT INTO properties (
        user_id, account_id, name,
        address, city, state, country, postcode,
        latitude, longitude,
        currency, phone, email,
        hostaway_listing_id, cm_source,
        created_at, updated_at
      ) VALUES (
        1, $1, $2,
        $3, $4, $5, $6, $7,
        $8, $9,
        $10, $11, $12,
        $13, 'hostaway',
        NOW(), NOW()
      )
      RETURNING id
    `, [
      gasAccountId,
      safeString(listing.name || listing.internalListingName || `Listing ${listing.id}`),
      safeString(listing.address || listing.street || ''),
      safeString(listing.city || ''),
      safeString(listing.state || ''),
      safeString(listing.countryCode || listing.country || ''),
      safeString(listing.zipcode || ''),
      listing.lat || null,
      listing.lng || null,
      safeString(listing.currencyCode || 'USD'),
      safeString(listing.contactPhone || ''),
      safeString(listing.contactEmail || ''),
      String(listing.id)
    ]);
    
    const gasPropertyId = propertyResult.rows[0].id;
    
    // For Hostaway, the listing IS the bookable unit (no separate room types)
    // Create one bookable unit with all the bookable data
    const roomResult = await pool.query(`
      INSERT INTO bookable_units (
        property_id, name, display_name,
        short_description, full_description,
        max_guests, base_price,
        room_type, check_in_time, check_out_time,
        cm_room_id, hostaway_listing_id,
        created_at, updated_at
      ) VALUES (
        $1, $2, $3,
        $4, $5,
        $6, $7,
        $8, $9, $10,
        $11, $12,
        NOW(), NOW()
      )
      RETURNING id
    `, [
      gasPropertyId,
      safeString(listing.internalListingName || listing.name || `Listing ${listing.id}`),
      toJsonText(listing.name),
      toJsonText(listing.externalListingName),
      toJsonText(listing.description),
      listing.personCapacity || listing.guestsIncluded || 2,
      listing.price || null,
      'entire_place',
      listing.checkInTimeStart ? `${listing.checkInTimeStart}:00` : '15:00',
      listing.checkOutTime ? `${listing.checkOutTime}:00` : '11:00',
      String(listing.id),
      String(listing.id)
    ]).catch(async (e) => {
      // If hostaway_listing_id or check_in_time columns don't exist, add them and retry
      if (e.message.includes('hostaway_listing_id') || e.message.includes('check_in_time')) {
        await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS hostaway_listing_id VARCHAR(50)').catch(() => {});
        await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS check_in_time VARCHAR(10)').catch(() => {});
        await pool.query('ALTER TABLE bookable_units ADD COLUMN IF NOT EXISTS check_out_time VARCHAR(10)').catch(() => {});
        return pool.query(`
          INSERT INTO bookable_units (
            property_id, name, display_name,
            short_description, full_description,
            max_guests, base_price,
            room_type, check_in_time, check_out_time,
            cm_room_id, hostaway_listing_id,
            created_at, updated_at
          ) VALUES (
            $1, $2, $3,
            $4, $5,
            $6, $7,
            $8, $9, $10,
            $11, $12,
            NOW(), NOW()
          )
          RETURNING id
        `, [
          gasPropertyId,
          safeString(listing.internalListingName || listing.name || `Listing ${listing.id}`),
          toJsonText(listing.name),
          toJsonText(listing.externalListingName),
          toJsonText(listing.description),
          listing.personCapacity || listing.guestsIncluded || 2,
          listing.price || null,
          'entire_place',
          listing.checkInTimeStart ? `${listing.checkInTimeStart}:00` : '15:00',
          listing.checkOutTime ? `${listing.checkOutTime}:00` : '11:00',
          String(listing.id),
          String(listing.id)
        ]);
      }
      throw e;
    });
    
    const gasRoomId = roomResult.rows[0].id;
    let imagesCreated = 0;
    
    // Import images if requested
    if (importImages) {
      const images = listing.listingImages || [];
      
      // If no listingImages but has thumbnailUrl, use that (but try to get larger version)
      if (images.length === 0 && listing.thumbnailUrl) {
        // Remove size restriction from Airbnb CDN URLs to get full size
        let fullSizeUrl = listing.thumbnailUrl;
        if (fullSizeUrl.includes('aki_policy=')) {
          fullSizeUrl = fullSizeUrl.replace(/\?aki_policy=\w+/, '');
        }
        images.push({
          id: 'thumb',
          url: fullSizeUrl,
          sortOrder: 1
        });
        console.log('Using thumbnail as full image:', fullSizeUrl);
      }
      
      for (let i = 0; i < images.length; i++) {
        const img = images[i];
        if (img.url) {
          try {
            const imageKey = `hostaway_${listing.id}_${img.id || i}`;
            // Check if already exists
            const existing = await pool.query(
              'SELECT id FROM room_images WHERE image_key = $1', [imageKey]
            ).catch(() => ({ rows: [] }));
            
            if (existing.rows.length === 0) {
              await pool.query(`
                INSERT INTO room_images (room_id, image_key, image_url, thumbnail_url, display_order, upload_source, is_active, created_at)
                VALUES ($1, $2, $3, $4, $5, 'hostaway', true, NOW())
              `, [gasRoomId, imageKey, img.url, img.url, img.sortOrder || i + 1]);
              imagesCreated++;
            }
          } catch (imgErr) {
            console.log('Image insert error:', imgErr.message);
          }
        }
      }
    }
    
    // Create or update GasSync connection
    // First check if connection exists
    let connectionId = null;
    const existingConn = await pool.query(`
      SELECT id FROM gas_sync_connections 
      WHERE account_id = $1 AND adapter_code = 'hostaway'
    `, [gasAccountId]).catch(() => ({ rows: [] }));
    
    if (existingConn.rows.length > 0) {
      // Update existing
      connectionId = existingConn.rows[0].id;
      await pool.query(`
        UPDATE gas_sync_connections SET
          access_token = $1,
          credentials = $2,
          status = 'connected',
          updated_at = NOW()
        WHERE id = $3
      `, [token, JSON.stringify({ accountId: accountId || '', apiKey: apiKey || '' }), connectionId])
        .catch(e => console.log('Connection update warning:', e.message));
    } else {
      // Insert new
      const connectionResult = await pool.query(`
        INSERT INTO gas_sync_connections (
          account_id, adapter_code,
          credentials, access_token,
          status, sync_enabled,
          created_at, updated_at
        ) VALUES (
          $1, 'hostaway',
          $2, $3,
          'connected', true,
          NOW(), NOW()
        )
        RETURNING id
      `, [
        gasAccountId,
        JSON.stringify({ accountId: accountId || '', apiKey: apiKey || '' }),
        token
      ]).catch(e => {
        console.log('Connection save warning:', e.message);
        return { rows: [] };
      });
      connectionId = connectionResult.rows[0]?.id;
    }
    
    // Store property mapping in gas_sync_properties
    if (connectionId) {
      // First check if exists
      const existingSyncProp = await pool.query(`
        SELECT id FROM gas_sync_properties WHERE connection_id = $1 AND external_id = $2
      `, [connectionId, String(listing.id)]).catch(() => ({ rows: [] }));
      
      let syncPropertyId;
      
      if (existingSyncProp.rows.length > 0) {
        // Update existing
        syncPropertyId = existingSyncProp.rows[0].id;
        await pool.query(`
          UPDATE gas_sync_properties SET gas_property_id = $1, name = $2, updated_at = NOW()
          WHERE id = $3
        `, [gasPropertyId, listing.name || listing.internalListingName, syncPropertyId])
          .catch(e => console.log('Property mapping update error:', e.message));
      } else {
        // Insert new
        const syncPropResult = await pool.query(`
          INSERT INTO gas_sync_properties (connection_id, external_id, gas_property_id, name, created_at)
          VALUES ($1, $2, $3, $4, NOW())
          RETURNING id
        `, [connectionId, String(listing.id), gasPropertyId, listing.name || listing.internalListingName])
          .catch(e => {
            console.log('Property mapping insert error:', e.message);
            return { rows: [] };
          });
        syncPropertyId = syncPropResult.rows[0]?.id;
      }
      
      console.log('Property mapping result:', { connectionId, syncPropertyId, gasPropertyId });
      
      // Store room type mapping
      if (syncPropertyId) {
        const existingRoomType = await pool.query(`
          SELECT id FROM gas_sync_room_types WHERE sync_property_id = $1 AND external_id = $2
        `, [syncPropertyId, String(listing.id)]).catch(() => ({ rows: [] }));
        
        if (existingRoomType.rows.length > 0) {
          await pool.query(`
            UPDATE gas_sync_room_types SET gas_room_id = $1, name = $2, synced_at = NOW()
            WHERE id = $3
          `, [gasRoomId, listing.internalListingName || listing.name, existingRoomType.rows[0].id])
            .catch(e => console.log('Room type mapping update error:', e.message));
        } else {
          await pool.query(`
            INSERT INTO gas_sync_room_types (sync_property_id, external_id, gas_room_id, name, max_guests, unit_count, synced_at)
            VALUES ($1, $2, $3, $4, $5, 1, NOW())
          `, [syncPropertyId, String(listing.id), gasRoomId, listing.internalListingName || listing.name, listing.personCapacity || 2])
            .catch(e => console.log('Room type mapping insert error:', e.message));
        }
      }
    }
    
    console.log(`Hostaway wizard: Imported listing ${listing.name} (ID ${listing.id}) -> GAS property ${gasPropertyId}`);
    console.log(`  - Bookable unit created: ${gasRoomId}`);
    console.log(`  - Images: ${imagesCreated}`);
    
    res.json({
      success: true,
      message: 'Property imported successfully',
      gasPropertyId,
      gasRoomId,
      stats: {
        roomsCreated: 1,
        imagesCreated
      }
    });
    
  } catch (error) {
    console.error('Hostaway wizard import error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Serve frontend - MUST BE LAST (after all API routes)

// Plugin license GET routes (moved before catch-all)
app.get('/api/plugin-licenses', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    
    let query = `
      SELECT pl.*, a.name as account_name
      FROM plugin_licenses pl
      LEFT JOIN accounts a ON pl.account_id = a.id
      ORDER BY pl.created_at DESC
    `;
    let params = [];
    
    if (accountId) {
      query = `
        SELECT pl.*, a.name as account_name
        FROM plugin_licenses pl
        LEFT JOIN accounts a ON pl.account_id = a.id
        WHERE pl.account_id = $1
        ORDER BY pl.created_at DESC
      `;
      params = [accountId];
    }
    
    const result = await pool.query(query, params);
    res.json({ success: true, licenses: result.rows });
  } catch (error) {
    console.error('Error fetching licenses:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get single license details
app.get('/api/plugin-licenses/:id', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT pl.*, a.name as account_name
      FROM plugin_licenses pl
      LEFT JOIN accounts a ON pl.account_id = a.id
      WHERE pl.id = $1
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'License not found' });
    }
    
    res.json({ success: true, license: result.rows[0] });
  } catch (error) {
    console.error('Error fetching license:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================
// BEDS24 WIZARD ENDPOINTS
// ============================================

// Serve wizard HTML - try multiple locations
app.get('/beds24-wizard', (req, res) => {
  const path = require('path');
  const fs = require('fs');
  
  // Try root first, then public
  const rootPath = path.join(__dirname, 'beds24-wizard-v2.html');
  const publicPath = path.join(__dirname, 'public', 'beds24-wizard.html');
  const publicV2Path = path.join(__dirname, 'public', 'beds24-wizard-v2.html');
  
  if (fs.existsSync(rootPath)) {
    res.sendFile(rootPath);
  } else if (fs.existsSync(publicV2Path)) {
    res.sendFile(publicV2Path);
  } else if (fs.existsSync(publicPath)) {
    res.sendFile(publicPath);
  } else {
    res.status(404).send('Wizard file not found. Please ensure beds24-wizard-v2.html exists.');
  }
});

// =====================================================
// Blog Feed Management (iCal & RSS)
// =====================================================

// Ensure blog_feeds table exists
(async () => {
  try {
    await pool.query(`
      CREATE TABLE IF NOT EXISTS blog_feeds (
        id SERIAL PRIMARY KEY,
        account_id INTEGER REFERENCES accounts(id),
        property_id INTEGER REFERENCES properties(id),
        type VARCHAR(10) NOT NULL CHECK (type IN ('ical', 'rss')),
        name VARCHAR(255) NOT NULL,
        url TEXT NOT NULL,
        last_fetched TIMESTAMP,
        last_error TEXT,
        is_active BOOLEAN DEFAULT true,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);
    // Add property_id column if table already exists
    await pool.query(`ALTER TABLE blog_feeds ADD COLUMN IF NOT EXISTS property_id INTEGER REFERENCES properties(id)`);
    console.log('‚úÖ blog_feeds table ensured');
  } catch (e) {
    console.log('‚ÑπÔ∏è  blog_feeds table:', e.message);
  }
})();

// Get feeds for account
app.get('/api/blog/feeds', async (req, res) => {
  try {
    const { type, account_id, property_id } = req.query;
    let query = `
      SELECT bf.*, p.name as property_name 
      FROM blog_feeds bf
      LEFT JOIN properties p ON bf.property_id = p.id
      WHERE 1=1
    `;
    const params = [];
    
    if (type) {
      params.push(type);
      query += ` AND bf.type = $${params.length}`;
    }
    if (account_id) {
      params.push(account_id);
      query += ` AND bf.account_id = $${params.length}`;
    }
    if (property_id) {
      params.push(property_id);
      query += ` AND bf.property_id = $${params.length}`;
    }
    
    query += ' ORDER BY bf.created_at DESC';
    
    const result = await pool.query(query, params);
    res.json({ success: true, feeds: result.rows });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Add new feed
app.post('/api/blog/feeds', async (req, res) => {
  try {
    const { type, name, url, account_id, property_id } = req.body;
    
    if (!type || !url) {
      return res.json({ success: false, error: 'Type and URL are required' });
    }
    
    const result = await pool.query(`
      INSERT INTO blog_feeds (account_id, property_id, type, name, url)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING *
    `, [account_id || null, property_id || null, type, name || `${type.toUpperCase()} Feed`, url]);
    
    res.json({ success: true, feed: result.rows[0] });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Delete feed
app.delete('/api/blog/feeds/:id', async (req, res) => {
  try {
    await pool.query('DELETE FROM blog_feeds WHERE id = $1', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Fetch iCal events and create blog ideas
app.post('/api/blog/feeds/fetch-ical', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    // Ensure content_ideas table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS content_ideas (
        id SERIAL PRIMARY KEY,
        client_id INTEGER,
        property_id INTEGER,
        title VARCHAR(500) NOT NULL,
        description TEXT,
        content_type VARCHAR(50) DEFAULT 'blog',
        category VARCHAR(100),
        subcategory VARCHAR(100),
        status VARCHAR(50) DEFAULT 'idea',
        source_type VARCHAR(50),
        source_url TEXT,
        event_date TIMESTAMP,
        event_location TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    // Add missing columns if table exists
    await pool.query(`ALTER TABLE content_ideas ADD COLUMN IF NOT EXISTS subcategory VARCHAR(100)`).catch(() => {});
    await pool.query(`ALTER TABLE content_ideas ADD COLUMN IF NOT EXISTS source_type VARCHAR(50)`).catch(() => {});
    await pool.query(`ALTER TABLE content_ideas ADD COLUMN IF NOT EXISTS source_url TEXT`).catch(() => {});
    await pool.query(`ALTER TABLE content_ideas ADD COLUMN IF NOT EXISTS event_date TIMESTAMP`).catch(() => {});
    await pool.query(`ALTER TABLE content_ideas ADD COLUMN IF NOT EXISTS event_location TEXT`).catch(() => {});
    
    // Get feeds - if account_id provided filter by it, otherwise get all
    let query = 'SELECT * FROM blog_feeds WHERE type = $1 AND is_active = true';
    const params = ['ical'];
    
    if (account_id) {
      params.push(account_id);
      query += ` AND (account_id = $${params.length} OR account_id IS NULL)`;
    }
    
    const feeds = await pool.query(query, params);
    console.log(`Fetching ${feeds.rows.length} iCal feeds...`);
    
    let totalEvents = 0;
    let ideasCreated = 0;
    let ideasSkipped = 0;
    let feedsProcessed = 0;
    
    for (const feed of feeds.rows) {
      try {
        // Convert webcal:// to https://
        let fetchUrl = feed.url;
        if (fetchUrl.startsWith('webcal://')) {
          fetchUrl = fetchUrl.replace('webcal://', 'https://');
        }
        
        console.log(`Fetching iCal: ${fetchUrl}`);
        const response = await axios.get(fetchUrl, { 
          timeout: 30000,
          headers: {
            'User-Agent': 'GAS-Calendar-Sync/1.0'
          }
        });
        const icsData = response.data;
        
        // Parse iCal events
        const events = parseIcalEvents(icsData);
        totalEvents += events.length;
        feedsProcessed++;
        
        console.log(`iCal feed ${feed.name}: ${events.length} events found`);
        
        // Create blog ideas from events (only future events)
        const now = new Date();
        for (const event of events) {
          // Skip past events (more than 1 day ago)
          if (event.startDate && new Date(event.startDate) < new Date(now - 86400000)) {
            continue;
          }
          
          // Check if idea already exists (by title + property) - any status
          const existingIdea = await pool.query(
            'SELECT id FROM content_ideas WHERE title = $1 AND property_id = $2',
            [event.summary, feed.property_id]
          );
          
          // Also check if a blog post already exists with similar title
          const existingBlog = await pool.query(
            `SELECT id FROM blog_posts WHERE title ILIKE $1 AND property_id = $2`,
            [`%${event.summary}%`, feed.property_id]
          );
          
          if (existingIdea.rows.length > 0 || existingBlog.rows.length > 0) {
            ideasSkipped++;
            continue;
          }
          
          // Create new idea
          await pool.query(`
            INSERT INTO content_ideas (
              client_id, property_id, title, description, content_type, 
              category, subcategory, status, source_type, source_url, 
              event_date, event_location
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
          `, [
            feed.account_id,
              feed.property_id,
              event.summary || 'Untitled Event',
              event.description || '',
              'blog',
              'Events & Concerts',
              'Local Events',
              'idea',
              'ical',
              feed.url,
              event.startDate,
              event.location || ''
            ]);
            ideasCreated++;
        }
        
        // Update last_fetched
        await pool.query(
          'UPDATE blog_feeds SET last_fetched = NOW(), last_error = NULL WHERE id = $1',
          [feed.id]
        );
        
      } catch (feedError) {
        await pool.query(
          'UPDATE blog_feeds SET last_error = $1 WHERE id = $2',
          [feedError.message, feed.id]
        );
        console.log(`iCal feed ${feed.name} error:`, feedError.message);
      }
    }
    
    console.log(`iCal fetch complete: ${ideasCreated} new ideas, ${ideasSkipped} skipped (duplicates/already have blog)`);
    
    res.json({
      success: true,
      feeds_processed: feedsProcessed,
      events_count: totalEvents,
      ideas_created: ideasCreated,
      ideas_skipped: ideasSkipped
    });
  } catch (error) {
    console.error('Fetch iCal error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Helper function to parse iCal data
function parseIcalEvents(icsData) {
  const events = [];
  const eventBlocks = icsData.split('BEGIN:VEVENT');
  
  for (let i = 1; i < eventBlocks.length; i++) {
    const block = eventBlocks[i].split('END:VEVENT')[0];
    const event = {};
    
    // Extract SUMMARY (title)
    const summaryMatch = block.match(/SUMMARY[^:]*:(.+?)(?:\r?\n(?! )|\r?\n(?=\w+:))/s);
    if (summaryMatch) {
      event.summary = summaryMatch[1].replace(/\\n/g, ' ').replace(/\\,/g, ',').replace(/\r?\n /g, '').trim();
    }
    
    // Extract DESCRIPTION
    const descMatch = block.match(/DESCRIPTION[^:]*:(.+?)(?:\r?\n(?! )|\r?\n(?=\w+:))/s);
    if (descMatch) {
      event.description = descMatch[1].replace(/\\n/g, '\n').replace(/\\,/g, ',').replace(/\r?\n /g, '').trim();
    }
    
    // Extract LOCATION
    const locMatch = block.match(/LOCATION[^:]*:(.+?)(?:\r?\n(?! )|\r?\n(?=\w+:))/s);
    if (locMatch) {
      event.location = locMatch[1].replace(/\\n/g, ' ').replace(/\\,/g, ',').replace(/\r?\n /g, '').trim();
    }
    
    // Extract DTSTART (start date)
    const startMatch = block.match(/DTSTART[^:]*:(\d{8}(?:T\d{6})?Z?)/);
    if (startMatch) {
      const dateStr = startMatch[1];
      // Parse YYYYMMDD or YYYYMMDDTHHmmss format
      const year = dateStr.substring(0, 4);
      const month = dateStr.substring(4, 6);
      const day = dateStr.substring(6, 8);
      let hour = '00', min = '00', sec = '00';
      if (dateStr.length >= 15) {
        hour = dateStr.substring(9, 11);
        min = dateStr.substring(11, 13);
        sec = dateStr.substring(13, 15);
      }
      event.startDate = `${year}-${month}-${day}T${hour}:${min}:${sec}`;
    }
    
    // Extract DTEND (end date)
    const endMatch = block.match(/DTEND[^:]*:(\d{8}(?:T\d{6})?Z?)/);
    if (endMatch) {
      const dateStr = endMatch[1];
      const year = dateStr.substring(0, 4);
      const month = dateStr.substring(4, 6);
      const day = dateStr.substring(6, 8);
      let hour = '00', min = '00', sec = '00';
      if (dateStr.length >= 15) {
        hour = dateStr.substring(9, 11);
        min = dateStr.substring(11, 13);
        sec = dateStr.substring(13, 15);
      }
      event.endDate = `${year}-${month}-${day}T${hour}:${min}:${sec}`;
    }
    
    // Extract URL if present
    const urlMatch = block.match(/URL[^:]*:(.+?)(?:\r?\n|$)/);
    if (urlMatch) {
      event.url = urlMatch[1].trim();
    }
    
    if (event.summary) {
      events.push(event);
    }
  }
  
  return events;
}

// Fetch RSS articles and create blog ideas
app.post('/api/blog/feeds/fetch-rss', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    // Get feeds - if account_id provided filter by it, otherwise get all
    let query = 'SELECT * FROM blog_feeds WHERE type = $1 AND is_active = true';
    const params = ['rss'];
    
    if (account_id) {
      params.push(account_id);
      query += ` AND (account_id = $${params.length} OR account_id IS NULL)`;
    }
    
    const feeds = await pool.query(query, params);
    console.log(`Fetching ${feeds.rows.length} RSS feeds...`);
    
    let totalArticles = 0;
    let ideasCreated = 0;
    let ideasSkipped = 0;
    let feedsProcessed = 0;
    
    for (const feed of feeds.rows) {
      try {
        console.log(`Fetching RSS: ${feed.url}`);
        const response = await axios.get(feed.url, { 
          timeout: 30000,
          headers: {
            'User-Agent': 'GAS-RSS-Reader/1.0'
          }
        });
        const rssData = response.data;
        
        // Parse RSS/Atom feed
        const articles = parseRssFeed(rssData);
        totalArticles += articles.length;
        feedsProcessed++;
        
        console.log(`RSS feed ${feed.name}: ${articles.length} articles found`);
        
        // Create blog ideas from articles (limit to recent ones)
        for (const article of articles.slice(0, 20)) { // Max 20 per feed
          if (!article.title) continue;
          
          // Check if idea already exists (by title + property) - any status
          const existingIdea = await pool.query(
            'SELECT id FROM content_ideas WHERE title = $1 AND property_id = $2',
            [article.title, feed.property_id]
          );
          
          // Also check if a blog post already exists with similar title
          const existingBlog = await pool.query(
            `SELECT id FROM blog_posts WHERE title ILIKE $1 AND property_id = $2`,
            [`%${article.title.substring(0, 100)}%`, feed.property_id]
          );
          
          if (existingIdea.rows.length > 0 || existingBlog.rows.length > 0) {
            ideasSkipped++;
            continue;
          }
          
          // Create new idea
          await pool.query(`
            INSERT INTO content_ideas (
              client_id, property_id, title, description, content_type, 
              category, subcategory, status, source_type, source_url
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
          `, [
            feed.account_id,
            feed.property_id,
            article.title.substring(0, 500),
            article.description || '',
            'blog',
            'News & Updates',
            'Local News',
            'idea',
            'rss',
            article.link || feed.url
          ]);
          ideasCreated++;
        }
        
        // Update last_fetched
        await pool.query(
          'UPDATE blog_feeds SET last_fetched = NOW(), last_error = NULL WHERE id = $1',
          [feed.id]
        );
        
      } catch (feedError) {
        await pool.query(
          'UPDATE blog_feeds SET last_error = $1 WHERE id = $2',
          [feedError.message, feed.id]
        );
        console.log(`RSS feed ${feed.name} error:`, feedError.message);
      }
    }
    
    console.log(`RSS fetch complete: ${ideasCreated} new ideas, ${ideasSkipped} skipped (duplicates/already have blog)`);
    
    res.json({
      success: true,
      feeds_processed: feedsProcessed,
      articles_count: totalArticles,
      ideas_created: ideasCreated,
      ideas_skipped: ideasSkipped
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Helper function to parse RSS/Atom feeds
function parseRssFeed(rssData) {
  const articles = [];
  
  // Try RSS 2.0 format first
  const itemMatches = rssData.match(/<item>([\s\S]*?)<\/item>/gi);
  if (itemMatches) {
    for (const item of itemMatches) {
      const article = {};
      
      const titleMatch = item.match(/<title[^>]*>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/title>/i);
      if (titleMatch) article.title = titleMatch[1].trim();
      
      const descMatch = item.match(/<description[^>]*>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/description>/i);
      if (descMatch) article.description = descMatch[1].replace(/<[^>]+>/g, '').trim().substring(0, 500);
      
      const linkMatch = item.match(/<link[^>]*>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/link>/i);
      if (linkMatch) article.link = linkMatch[1].trim();
      
      const pubDateMatch = item.match(/<pubDate[^>]*>([\s\S]*?)<\/pubDate>/i);
      if (pubDateMatch) article.pubDate = pubDateMatch[1].trim();
      
      if (article.title) articles.push(article);
    }
    return articles;
  }
  
  // Try Atom format
  const entryMatches = rssData.match(/<entry>([\s\S]*?)<\/entry>/gi);
  if (entryMatches) {
    for (const entry of entryMatches) {
      const article = {};
      
      const titleMatch = entry.match(/<title[^>]*>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/title>/i);
      if (titleMatch) article.title = titleMatch[1].trim();
      
      const summaryMatch = entry.match(/<summary[^>]*>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/summary>/i);
      if (summaryMatch) article.description = summaryMatch[1].replace(/<[^>]+>/g, '').trim().substring(0, 500);
      
      const linkMatch = entry.match(/<link[^>]*href=["']([^"']+)["'][^>]*\/?>/i);
      if (linkMatch) article.link = linkMatch[1].trim();
      
      if (article.title) articles.push(article);
    }
  }
  
  return articles;
}

// Run database migrations
app.post('/api/admin/run-migrations', async (req, res) => {
  try {
    const results = [];
    
    // Add webhook columns to accounts table
    try {
      await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS booking_webhook_url TEXT`);
      results.push('Added booking_webhook_url to accounts');
    } catch (e) {
      results.push('booking_webhook_url: ' + e.message);
    }
    
    try {
      await pool.query(`ALTER TABLE accounts ADD COLUMN IF NOT EXISTS webhook_secret TEXT`);
      results.push('Added webhook_secret to accounts');
    } catch (e) {
      results.push('webhook_secret: ' + e.message);
    }
    
    // Add custom_domain to deployed_sites
    try {
      await pool.query(`ALTER TABLE deployed_sites ADD COLUMN IF NOT EXISTS custom_domain VARCHAR(255)`);
      results.push('Added custom_domain to deployed_sites');
    } catch (e) {
      results.push('custom_domain: ' + e.message);
    }
    
    // Add account_id to custom_sites
    try {
      await pool.query(`ALTER TABLE custom_sites ADD COLUMN IF NOT EXISTS account_id INTEGER`);
      results.push('Added account_id to custom_sites');
    } catch (e) {
      results.push('account_id: ' + e.message);
    }
    
    res.json({ success: true, results });
  } catch (error) {
    console.error('Migration error:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================
// GAS NETWORK API - Contacts, Tags, Segments
// ============================================

// GET /api/network/tags - Get all tags (system + account-specific)
app.get('/api/network/tags', async (req, res) => {
  try {
    const accountId = req.query.account_id;
    
    const result = await pool.query(`
      SELECT * FROM network_tags 
      WHERE account_id IS NULL OR account_id = $1
      ORDER BY is_system DESC, category, name
    `, [accountId || null]);
    
    res.json({ success: true, tags: result.rows });
  } catch (error) {
    console.error('Get tags error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/network/tags - Create custom tag
app.post('/api/network/tags', async (req, res) => {
  try {
    const { account_id, name, category, icon, color } = req.body;
    
    if (!account_id || !name) {
      return res.status(400).json({ success: false, error: 'account_id and name required' });
    }
    
    const result = await pool.query(`
      INSERT INTO network_tags (account_id, name, category, icon, color, is_system)
      VALUES ($1, $2, $3, $4, $5, false)
      RETURNING *
    `, [account_id, name, category || 'custom', icon || 'üè∑Ô∏è', color || '#3b82f6']);
    
    res.json({ success: true, tag: result.rows[0] });
  } catch (error) {
    console.error('Create tag error:', error);
    res.json({ success: false, error: error.message });
  }
});

// DELETE /api/network/tags/:id - Delete custom tag
app.delete('/api/network/tags/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Don't allow deleting system tags
    const check = await pool.query('SELECT is_system FROM network_tags WHERE id = $1', [id]);
    if (check.rows[0]?.is_system) {
      return res.status(400).json({ success: false, error: 'Cannot delete system tags' });
    }
    
    await pool.query('DELETE FROM network_tags WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    console.error('Delete tag error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET /api/network/contacts - Get contacts with optional filters (from travellers)
app.get('/api/network/contacts', async (req, res) => {
  try {
    const { account_id, tag_id, search, limit = 100, offset = 0 } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    let query = `
      SELECT t.id, t.email, t.phone, t.first_name, t.last_name, 
             t.city, t.country, t.status,
             tpl.total_bookings, tpl.total_spent, tpl.last_stay_date, tpl.source,
             tpl.tags, tpl.notes
      FROM travellers t
      JOIN traveller_property_links tpl ON tpl.traveller_id = t.id
      WHERE tpl.account_id = $1
    `;
    const params = [account_id];
    let paramIndex = 2;
    
    if (search) {
      query += ` AND (t.email ILIKE $${paramIndex} OR t.first_name ILIKE $${paramIndex} OR t.last_name ILIKE $${paramIndex})`;
      params.push(`%${search}%`);
      paramIndex++;
    }
    
    query += ` ORDER BY t.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
    params.push(parseInt(limit), parseInt(offset));
    
    const result = await pool.query(query, params);
    
    // Get total count
    const countResult = await pool.query(
      'SELECT COUNT(*) FROM traveller_property_links WHERE account_id = $1',
      [account_id]
    );
    
    res.json({ 
      success: true, 
      contacts: result.rows,
      total: parseInt(countResult.rows[0].count),
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Get contacts error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET /api/network/stats - Get contact stats for account
app.get('/api/network/stats', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    const stats = await pool.query(`
      SELECT 
        COUNT(*) as total_contacts,
        COUNT(CASE WHEN source = 'booking' OR source = 'gas-lite' THEN 1 END) as from_bookings,
        COUNT(CASE WHEN source = 'import' OR source = 'manual' THEN 1 END) as from_import,
        COUNT(CASE WHEN total_bookings > 1 THEN 1 END) as repeat_guests
      FROM traveller_property_links
      WHERE account_id = $1
    `, [account_id]);
    
    res.json({ 
      success: true, 
      stats: stats.rows[0] || { total_contacts: 0, from_bookings: 0, from_import: 0, repeat_guests: 0 }
    });
  } catch (error) {
    console.error('Get stats error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/network/contacts - Create single contact (adds to travellers)
app.post('/api/network/contacts', async (req, res) => {
  try {
    const { account_id, email, first_name, last_name, phone, city, country, source, notes, tags } = req.body;
    
    if (!account_id || !email) {
      return res.status(400).json({ success: false, error: 'account_id and email required' });
    }
    
    // Create or update traveller
    const travResult = await pool.query(`
      INSERT INTO travellers (email, first_name, last_name, phone, city, country, status)
      VALUES ($1, $2, $3, $4, $5, $6, 'lead')
      ON CONFLICT (email) DO UPDATE SET
        first_name = COALESCE(NULLIF($2, ''), travellers.first_name),
        last_name = COALESCE(NULLIF($3, ''), travellers.last_name),
        phone = COALESCE(NULLIF($4, ''), travellers.phone),
        city = COALESCE(NULLIF($5, ''), travellers.city),
        country = COALESCE(NULLIF($6, ''), travellers.country),
        updated_at = NOW()
      RETURNING *
    `, [email.toLowerCase().trim(), first_name, last_name, phone, city, country]);
    
    const traveller = travResult.rows[0];
    
    // Look up full tag details if tags provided
    let tagObjects = [];
    if (tags && tags.length > 0) {
      const tagResult = await pool.query(
        'SELECT id, name, icon FROM network_tags WHERE id = ANY($1)',
        [tags]
      );
      tagObjects = tagResult.rows;
    }
    
    // Create link to account
    const linkResult = await pool.query(`
      INSERT INTO traveller_property_links (traveller_id, account_id, source, notes, tags)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (traveller_id, account_id) DO UPDATE SET
        notes = COALESCE($4, traveller_property_links.notes),
        tags = COALESCE($5, traveller_property_links.tags),
        updated_at = NOW()
      RETURNING *
    `, [traveller.id, account_id, source || 'manual', notes, JSON.stringify(tagObjects)]);
    
    res.json({ 
      success: true, 
      contact: {
        ...traveller,
        ...linkResult.rows[0]
      }
    });
  } catch (error) {
    console.error('Create contact error:', error);
    res.json({ success: false, error: error.message });
  }
});

// PUT /api/network/contacts/:id - Update contact
app.put('/api/network/contacts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { first_name, last_name, phone, notes, tags } = req.body;
    
    const result = await pool.query(`
      UPDATE network_contacts 
      SET first_name = COALESCE($1, first_name),
          last_name = COALESCE($2, last_name),
          phone = COALESCE($3, phone),
          notes = COALESCE($4, notes),
          updated_at = NOW()
      WHERE id = $5
      RETURNING *
    `, [first_name, last_name, phone, notes, id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Contact not found' });
    }
    
    // Update tags if provided
    if (tags !== undefined) {
      await pool.query('DELETE FROM network_contact_tags WHERE contact_id = $1', [id]);
      for (const tagId of tags) {
        await pool.query(`
          INSERT INTO network_contact_tags (contact_id, tag_id)
          VALUES ($1, $2)
          ON CONFLICT DO NOTHING
        `, [id, tagId]);
      }
    }
    
    res.json({ success: true, contact: result.rows[0] });
  } catch (error) {
    console.error('Update contact error:', error);
    res.json({ success: false, error: error.message });
  }
});

// DELETE /api/network/contacts/:id - Delete contact link (removes from this account only)
app.delete('/api/network/contacts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { account_id } = req.query;
    
    // Delete the link between traveller and account, not the traveller itself
    if (account_id) {
      await pool.query('DELETE FROM traveller_property_links WHERE traveller_id = $1 AND account_id = $2', [id, account_id]);
    } else {
      // Fallback - delete by traveller id (but this removes from all accounts)
      await pool.query('DELETE FROM traveller_property_links WHERE traveller_id = $1', [id]);
    }
    res.json({ success: true });
  } catch (error) {
    console.error('Delete contact error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/network/contacts/:id/tags - Add tags to contact
app.post('/api/network/contacts/:id/tags', async (req, res) => {
  try {
    const { id } = req.params;
    const { tag_ids } = req.body;
    
    if (!tag_ids || !Array.isArray(tag_ids)) {
      return res.status(400).json({ success: false, error: 'tag_ids array required' });
    }
    
    for (const tagId of tag_ids) {
      await pool.query(`
        INSERT INTO network_contact_tags (contact_id, tag_id)
        VALUES ($1, $2)
        ON CONFLICT DO NOTHING
      `, [id, tagId]);
    }
    
    res.json({ success: true, added: tag_ids.length });
  } catch (error) {
    console.error('Add tags error:', error);
    res.json({ success: false, error: error.message });
  }
});

// DELETE /api/network/contacts/:id/tags/:tagId - Remove tag from contact
app.delete('/api/network/contacts/:id/tags/:tagId', async (req, res) => {
  try {
    const { id, tagId } = req.params;
    await pool.query('DELETE FROM network_contact_tags WHERE contact_id = $1 AND tag_id = $2', [id, tagId]);
    res.json({ success: true });
  } catch (error) {
    console.error('Remove tag error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/network/contacts/import - Bulk import contacts from CSV
app.post('/api/network/contacts/import', async (req, res) => {
  try {
    const { account_id, contacts, default_tags } = req.body;
    
    if (!account_id || !contacts || !Array.isArray(contacts)) {
      return res.status(400).json({ success: false, error: 'account_id and contacts array required' });
    }
    
    // Look up full tag details if default_tags provided
    let tagObjects = [];
    if (default_tags && default_tags.length > 0) {
      const tagResult = await pool.query(
        'SELECT id, name, icon FROM network_tags WHERE id = ANY($1)',
        [default_tags]
      );
      tagObjects = tagResult.rows;
    }
    
    let imported = 0;
    let updated = 0;
    let errors = [];
    
    for (const contact of contacts) {
      if (!contact.email) {
        errors.push({ row: contact, error: 'Missing email' });
        continue;
      }
      
      try {
        // Create or update traveller
        const travResult = await pool.query(`
          INSERT INTO travellers (email, first_name, last_name, phone, status)
          VALUES ($1, $2, $3, $4, 'lead')
          ON CONFLICT (email) DO UPDATE SET
            first_name = COALESCE(NULLIF($2, ''), travellers.first_name),
            last_name = COALESCE(NULLIF($3, ''), travellers.last_name),
            phone = COALESCE(NULLIF($4, ''), travellers.phone),
            updated_at = NOW()
          RETURNING *, (xmax = 0) as is_new
        `, [contact.email.toLowerCase().trim(), contact.first_name, contact.last_name, contact.phone]);
        
        const traveller = travResult.rows[0];
        const isNew = traveller.is_new;
        
        // Create link to account
        await pool.query(`
          INSERT INTO traveller_property_links (traveller_id, account_id, source, tags)
          VALUES ($1, $2, 'import', $3)
          ON CONFLICT (traveller_id, account_id) DO UPDATE SET
            tags = COALESCE($3, traveller_property_links.tags),
            updated_at = NOW()
        `, [traveller.id, account_id, JSON.stringify(tagObjects)]);
        
        if (isNew) {
          imported++;
        } else {
          updated++;
        }
      } catch (err) {
        errors.push({ row: contact, error: err.message });
      }
    }
    
    res.json({ 
      success: true, 
      imported,
      updated,
      errors: errors.length,
      error_details: errors.slice(0, 10)
    });
  } catch (error) {
    console.error('Import contacts error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET /api/network/segments - Get saved segments
app.get('/api/network/segments', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    const result = await pool.query(`
      SELECT * FROM network_segments
      WHERE account_id = $1
      ORDER BY name
    `, [account_id]);
    
    res.json({ success: true, segments: result.rows });
  } catch (error) {
    console.error('Get segments error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/network/segments - Create segment
app.post('/api/network/segments', async (req, res) => {
  try {
    const { account_id, name, description, filter_tags, filter_source, filter_min_bookings, filter_last_stayed_after, filter_last_stayed_before } = req.body;
    
    if (!account_id || !name) {
      return res.status(400).json({ success: false, error: 'account_id and name required' });
    }
    
    const result = await pool.query(`
      INSERT INTO network_segments (account_id, name, description, filter_tags, filter_source, filter_min_bookings, filter_last_stayed_after, filter_last_stayed_before)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *
    `, [account_id, name, description, filter_tags, filter_source, filter_min_bookings, filter_last_stayed_after, filter_last_stayed_before]);
    
    res.json({ success: true, segment: result.rows[0] });
  } catch (error) {
    console.error('Create segment error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET /api/network/stats - Get network statistics
app.get('/api/network/stats', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    const stats = await pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM network_contacts WHERE account_id = $1) as total_contacts,
        (SELECT COUNT(*) FROM network_contacts WHERE account_id = $1 AND source = 'booking') as from_bookings,
        (SELECT COUNT(*) FROM network_contacts WHERE account_id = $1 AND source = 'import') as from_import,
        (SELECT COUNT(*) FROM network_contacts WHERE account_id = $1 AND total_bookings > 1) as repeat_guests,
        (SELECT COUNT(*) FROM network_contacts WHERE account_id = $1 AND unsubscribed = true) as unsubscribed
    `, [account_id]);
    
    res.json({ success: true, stats: stats.rows[0] });
  } catch (error) {
    console.error('Get stats error:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================
// TURBINES API - Campaigns
// ============================================

// GET /api/turbines/campaigns - Get all campaigns
app.get('/api/turbines/campaigns', async (req, res) => {
  try {
    const { account_id, status } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    let query = `
      SELECT c.*, 
             p.name as property_name,
             bu.name as room_name
      FROM turbine_campaigns c
      LEFT JOIN properties p ON p.id = c.property_id
      LEFT JOIN bookable_units bu ON bu.id = c.room_id
      WHERE c.account_id = $1
    `;
    const params = [account_id];
    
    if (status) {
      query += ' AND c.status = $2';
      params.push(status);
    }
    
    query += ' ORDER BY c.created_at DESC';
    
    const result = await pool.query(query, params);
    
    res.json({ success: true, campaigns: result.rows });
  } catch (error) {
    console.error('Get campaigns error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/turbines/campaigns - Create campaign
app.post('/api/turbines/campaigns', async (req, res) => {
  try {
    const { 
      account_id, name, property_id, room_id,
      discount_type, discount_value, custom_price,
      start_date, end_date, min_nights,
      gas_lite_slug, target_type, target_tags, target_segment_id,
      channels, email_subject, email_body, social_caption, social_image_url, hero_image_url
    } = req.body;
    
    if (!account_id || !name) {
      return res.status(400).json({ success: false, error: 'account_id and name required' });
    }
    
    // Generate unique offer code (e.g., CAM-X7K9)
    const generateOfferCode = () => {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // No I, O, 0, 1 to avoid confusion
      let code = 'CAM-';
      for (let i = 0; i < 4; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    };
    
    let offerCode = generateOfferCode();
    // Ensure uniqueness (try up to 5 times)
    for (let attempt = 0; attempt < 5; attempt++) {
      const existing = await pool.query('SELECT 1 FROM turbine_campaigns WHERE offer_code = $1', [offerCode]);
      if (existing.rows.length === 0) break;
      offerCode = generateOfferCode();
    }
    
    // Get the GAS Lite slug for the room if not provided
    let liteSlug = gas_lite_slug;
    if (!liteSlug && room_id) {
      // Try gas_lites table first
      let liteRes = await pool.query('SELECT slug FROM gas_lites WHERE room_id = $1 AND active = true LIMIT 1', [room_id]);
      if (liteRes.rows.length > 0) {
        liteSlug = liteRes.rows[0].slug;
      } else {
        // Try deployed_sites table - check if room is in room_ids array
        liteRes = await pool.query(`
          SELECT slug FROM deployed_sites 
          WHERE $1 = ANY(room_ids) 
          LIMIT 1
        `, [room_id]);
        if (liteRes.rows.length > 0) {
          liteSlug = liteRes.rows[0].slug;
        }
      }
    }
    
    const result = await pool.query(`
      INSERT INTO turbine_campaigns (
        account_id, name, property_id, room_id,
        discount_type, discount_value, custom_price,
        start_date, end_date, min_nights,
        offer_code, gas_lite_slug, target_type, target_tags, target_segment_id,
        channels, email_subject, email_body, social_caption, social_image_url, hero_image_url
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)
      RETURNING *
    `, [
      account_id, name, property_id, room_id,
      discount_type, discount_value, custom_price,
      start_date, end_date, min_nights,
      offerCode, liteSlug, target_type || 'all', target_tags, target_segment_id,
      JSON.stringify(channels || {}), email_subject, email_body, social_caption, social_image_url, hero_image_url
    ]);
    
    const campaign = result.rows[0];
    
    // Build the campaign URL
    if (liteSlug) {
      campaign.campaign_url = `https://lite.gas.travel/${liteSlug}?offer=${offerCode}`;
    }
    
    res.json({ success: true, campaign });
  } catch (error) {
    console.error('Create campaign error:', error);
    res.json({ success: false, error: error.message });
  }
});

// PUT /api/turbines/campaigns/:id - Update campaign
app.put('/api/turbines/campaigns/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    const fields = [];
    const values = [];
    let paramIndex = 1;
    
    const allowedFields = [
      'name', 'property_id', 'room_id', 'discount_type', 'discount_value', 'custom_price',
      'start_date', 'end_date', 'min_nights', 'gas_lite_slug', 'target_type', 'target_tags',
      'target_segment_id', 'channels', 'email_subject', 'email_body', 'social_caption',
      'social_image_url', 'status', 'scheduled_at'
    ];
    
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        fields.push(`${field} = $${paramIndex}`);
        values.push(field === 'channels' ? JSON.stringify(updates[field]) : updates[field]);
        paramIndex++;
      }
    }
    
    if (fields.length === 0) {
      return res.status(400).json({ success: false, error: 'No fields to update' });
    }
    
    fields.push('updated_at = NOW()');
    values.push(id);
    
    const result = await pool.query(`
      UPDATE turbine_campaigns SET ${fields.join(', ')} WHERE id = $${paramIndex} RETURNING *
    `, values);
    
    res.json({ success: true, campaign: result.rows[0] });
  } catch (error) {
    console.error('Update campaign error:', error);
    res.json({ success: false, error: error.message });
  }
});

// DELETE /api/turbines/campaigns/:id - Delete campaign
app.delete('/api/turbines/campaigns/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await pool.query('DELETE FROM turbine_campaigns WHERE id = $1', [id]);
    res.json({ success: true });
  } catch (error) {
    console.error('Delete campaign error:', error);
    res.json({ success: false, error: error.message });
  }
});

// POST /api/turbines/campaigns/:id/send - Send campaign emails to contacts
app.post('/api/turbines/campaigns/:id/send', async (req, res) => {
  try {
    const { id } = req.params;
    const { test_email } = req.body; // Optional - send test to single email
    
    // Get campaign details
    const campaignResult = await pool.query(`
      SELECT c.*, p.name as property_name, p.address as property_address,
             bu.name as room_name, a.name as account_name
      FROM turbine_campaigns c
      LEFT JOIN properties p ON p.id = c.property_id
      LEFT JOIN bookable_units bu ON bu.id = c.room_id
      LEFT JOIN accounts a ON a.id = c.account_id
      WHERE c.id = $1
    `, [id]);
    
    if (campaignResult.rows.length === 0) {
      return res.json({ success: false, error: 'Campaign not found' });
    }
    
    const campaign = campaignResult.rows[0];
    
    // Check if email channel is enabled (handle both formats: true or {enabled: true})
    const channels = typeof campaign.channels === 'string' ? JSON.parse(campaign.channels) : campaign.channels;
    const emailEnabled = channels?.email === true || channels?.email?.enabled === true;
    if (!emailEnabled && !test_email) {
      return res.json({ success: false, error: 'Email channel not enabled for this campaign' });
    }
    
    // Get recipients
    let recipients = [];
    if (test_email) {
      recipients = [{ email: test_email, first_name: 'Test', last_name: 'User' }];
    } else {
      // Get contacts linked to this account
      const contactsResult = await pool.query(`
        SELECT t.email, t.first_name, t.last_name
        FROM travellers t
        JOIN traveller_property_links tpl ON tpl.traveller_id = t.id
        WHERE tpl.account_id = $1
        AND t.email IS NOT NULL
      `, [campaign.account_id]);
      recipients = contactsResult.rows;
    }
    
    if (recipients.length === 0) {
      return res.json({ success: false, error: 'No recipients found' });
    }
    
    // Build campaign URL
    const campaignUrl = campaign.gas_lite_slug 
      ? `https://lite.gas.travel/${campaign.gas_lite_slug}?offer=${campaign.offer_code}`
      : null;
    
    // Format dates
    const formatDate = (d) => d ? new Date(d).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' }) : '';
    
    // Calculate discount display (handle both 'percent' and 'percentage')
    let discountText = '';
    if (campaign.discount_type === 'percent' || campaign.discount_type === 'percentage') {
      discountText = `${parseFloat(campaign.discount_value).toFixed(0)}% OFF`;
    } else if (campaign.discount_type === 'fixed') {
      discountText = `$${campaign.discount_value} OFF`;
    } else if (campaign.discount_type === 'custom' || campaign.discount_type === 'custom_price') {
      discountText = `Special Price: $${campaign.custom_price}`;
    }
    
    // Get room image for Lite card
    let roomImageUrl = campaign.hero_image_url;
    if (!roomImageUrl && campaign.room_id) {
      const imgRes = await pool.query(
        'SELECT image_url FROM room_images WHERE room_id = $1 ORDER BY display_order, id LIMIT 1',
        [campaign.room_id]
      );
      if (imgRes.rows[0]) {
        roomImageUrl = imgRes.rows[0].image_url;
      }
    }
    
    // Get room price for Lite card
    let roomPrice = null;
    if (campaign.room_id) {
      const priceRes = await pool.query(`
        SELECT COALESCE(direct_price, standard_price, cm_price) as price 
        FROM room_availability WHERE room_id = $1 AND date >= CURRENT_DATE 
        ORDER BY date LIMIT 1
      `, [campaign.room_id]);
      if (priceRes.rows[0]?.price) {
        roomPrice = parseFloat(priceRes.rows[0].price);
      }
    }
    
    // Build email HTML
    const buildEmailHtml = (recipient) => {
      const firstName = recipient.first_name || 'Guest';
      
      // Replace placeholders in email body
      let body = campaign.email_body || '';
      body = body.replace(/\{\{first_name\}\}/g, firstName);
      body = body.replace(/\{\{property_name\}\}/g, campaign.property_name || '');
      body = body.replace(/\{\{room_name\}\}/g, campaign.room_name || '');
      body = body.replace(/\{\{discount\}\}/g, discountText);
      
      // Calculate discounted price
      let discountedPrice = roomPrice;
      let originalPrice = roomPrice;
      if (roomPrice && campaign.discount_value) {
        if (campaign.discount_type === 'percent' || campaign.discount_type === 'percentage') {
          discountedPrice = roomPrice * (1 - parseFloat(campaign.discount_value) / 100);
        } else if (campaign.discount_type === 'fixed') {
          discountedPrice = roomPrice - parseFloat(campaign.discount_value);
        }
      }
      if (campaign.custom_price) {
        discountedPrice = parseFloat(campaign.custom_price);
      }
      
      return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${campaign.email_subject || campaign.name}</title>
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5;">
  <div style="max-width: 600px; margin: 0 auto; background: #ffffff;">
    
    ${roomImageUrl ? `
    <div style="width: 100%; position: relative;">
      <img src="${roomImageUrl}" alt="${campaign.property_name || 'Property'}" style="width: 100%; height: 250px; object-fit: cover; display: block;">
      <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.7)); padding: 1rem;">
        <div style="color: white; font-size: 1.25rem; font-weight: bold;">${campaign.property_name || ''}</div>
        <div style="color: rgba(255,255,255,0.9); font-size: 0.9rem;">${campaign.room_name || ''}</div>
      </div>
    </div>
    ` : ''}
    
    <!-- Offer Banner -->
    <div style="background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; padding: 1rem; text-align: center;">
      <div style="font-size: 1.5rem; font-weight: bold;">üî• ${discountText || 'SPECIAL OFFER'}</div>
      <div style="font-size: 0.9rem; opacity: 0.9; margin-top: 0.25rem;">
        ${campaign.name} ‚Ä¢ Valid until ${formatDate(campaign.end_date)}
      </div>
    </div>
    
    <!-- Two Column Layout -->
    <div style="padding: 1.5rem;">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td valign="top" style="width: 55%; padding-right: 1rem;">
            <!-- Custom Message -->
            <div style="font-size: 1rem; line-height: 1.6; color: #333;">
              ${body}
            </div>
          </td>
          <td valign="top" style="width: 45%;">
            <!-- Lite Card -->
            <div style="background: #f8fafc; border-radius: 12px; overflow: hidden; border: 1px solid #e2e8f0;">
              ${roomImageUrl ? `
              <img src="${roomImageUrl}" alt="${campaign.room_name || 'Room'}" style="width: 100%; height: 120px; object-fit: cover;">
              ` : ''}
              <div style="padding: 1rem;">
                <div style="font-weight: 600; color: #1e293b; margin-bottom: 0.5rem;">${campaign.room_name || campaign.property_name || 'Special Offer'}</div>
                ${originalPrice ? `
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                  <span style="text-decoration: line-through; color: #94a3b8; font-size: 0.9rem;">$${originalPrice.toFixed(0)}</span>
                  <span style="color: #16a34a; font-weight: bold; font-size: 1.1rem;">$${discountedPrice.toFixed(0)}</span>
                  <span style="background: #dc2626; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold;">${discountText}</span>
                </div>
                ` : ''}
                ${campaignUrl ? `
                <a href="${campaignUrl}" style="display: block; background: #2563eb; color: white; padding: 0.75rem; text-decoration: none; border-radius: 6px; font-weight: 600; text-align: center; font-size: 0.9rem;">
                  Book Now ‚Üí
                </a>
                ` : ''}
              </div>
            </div>
          </td>
        </tr>
      </table>
    </div>
    
    <!-- Footer -->
    <div style="background: #f8f8f8; padding: 1rem; text-align: center; font-size: 0.75rem; color: #999; border-top: 1px solid #e2e8f0;">
      <p style="margin: 0;">${campaign.property_name || ''}</p>
      <p style="margin: 0.25rem 0 0 0;">${campaign.property_address || ''}</p>
      <p style="margin: 1rem 0 0 0;">You're receiving this because you stayed with us or subscribed to offers.</p>
      <p style="margin: 0.5rem 0 0 0;">
        <a href="#" style="color: #666;">Unsubscribe</a>
      </p>
    </div>
  </div>
</body>
</html>`;
    };
    
    // Send emails
    let sent = 0;
    let failed = 0;
    const errors = [];
    
    for (const recipient of recipients) {
      try {
        const html = buildEmailHtml(recipient);
        const result = await sendEmail({
          to: recipient.email,
          subject: campaign.email_subject || `${discountText} - ${campaign.name}`,
          html: html,
          from: `${campaign.account_name || 'GAS'} <bookings@mg.gas.travel>`
        });
        
        if (result.success) {
          sent++;
        } else {
          failed++;
          errors.push({ email: recipient.email, error: result.error });
        }
        
        // Small delay between emails to avoid rate limits
        if (!test_email) {
          await new Promise(r => setTimeout(r, 100));
        }
      } catch (err) {
        failed++;
        errors.push({ email: recipient.email, error: err.message });
      }
    }
    
    // Update campaign stats
    if (!test_email) {
      await pool.query(`
        UPDATE turbine_campaigns 
        SET status = 'sent', 
            sent_at = NOW(),
            updated_at = NOW()
        WHERE id = $1
      `, [id]);
      
      // Record in stats
      await pool.query(`
        INSERT INTO turbine_campaign_stats (campaign_id, channel, sent_count, updated_at)
        VALUES ($1, 'email', $2, NOW())
      `, [id, sent]);
    }
    
    res.json({ 
      success: true, 
      sent,
      failed,
      total: recipients.length,
      test: !!test_email,
      errors: errors.slice(0, 10)
    });
  } catch (error) {
    console.error('Send campaign error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET /api/turbines/connections - Get connected social accounts
app.get('/api/turbines/connections', async (req, res) => {
  try {
    const { account_id } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    const result = await pool.query(`
      SELECT id, platform, platform_username, page_name, status, created_at
      FROM turbine_connections
      WHERE account_id = $1 AND status = 'active'
      ORDER BY platform
    `, [account_id]);
    
    res.json({ success: true, connections: result.rows });
  } catch (error) {
    console.error('Get connections error:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET /api/turbines/availability-gaps - Find gaps in availability for campaign targeting
app.get('/api/turbines/availability-gaps', async (req, res) => {
  try {
    const { account_id, property_id, min_gap_nights = 3, days_ahead = 90 } = req.query;
    
    if (!account_id) {
      return res.status(400).json({ success: false, error: 'account_id required' });
    }
    
    // Get all rooms for the account/property
    let roomQuery = `
      SELECT bu.id, bu.name, bu.property_id, p.name as property_name
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      WHERE p.account_id = $1
    `;
    const roomParams = [account_id];
    
    if (property_id) {
      roomQuery += ' AND bu.property_id = $2';
      roomParams.push(property_id);
    }
    
    const rooms = await pool.query(roomQuery, roomParams);
    
    const gaps = [];
    const startDate = new Date();
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + parseInt(days_ahead));
    
    for (const room of rooms.rows) {
      // Get bookings for this room in the date range
      const bookings = await pool.query(`
        SELECT check_in, check_out FROM bookings
        WHERE room_id = $1 AND status != 'cancelled'
        AND check_in <= $2 AND check_out >= $3
        ORDER BY check_in
      `, [room.id, endDate, startDate]);
      
      // Find gaps between bookings
      let currentDate = new Date(startDate);
      
      for (const booking of bookings.rows) {
        const bookingStart = new Date(booking.check_in);
        const gapNights = Math.floor((bookingStart - currentDate) / (1000 * 60 * 60 * 24));
        
        if (gapNights >= parseInt(min_gap_nights)) {
          gaps.push({
            room_id: room.id,
            room_name: room.name,
            property_id: room.property_id,
            property_name: room.property_name,
            gap_start: currentDate.toISOString().split('T')[0],
            gap_end: bookingStart.toISOString().split('T')[0],
            nights: gapNights
          });
        }
        
        currentDate = new Date(booking.check_out);
      }
      
      // Check gap after last booking
      const gapNights = Math.floor((endDate - currentDate) / (1000 * 60 * 60 * 24));
      if (gapNights >= parseInt(min_gap_nights)) {
        gaps.push({
          room_id: room.id,
          room_name: room.name,
          property_id: room.property_id,
          property_name: room.property_name,
          gap_start: currentDate.toISOString().split('T')[0],
          gap_end: endDate.toISOString().split('T')[0],
          nights: gapNights
        });
      }
    }
    
    res.json({ success: true, gaps: gaps.sort((a, b) => new Date(a.gap_start) - new Date(b.gap_start)) });
  } catch (error) {
    console.error('Get availability gaps error:', error);
    res.json({ success: false, error: error.message });
  }
});

// ============================================


app.listen(PORT, '0.0.0.0', async () => {
  console.log('üöÄ Server running on port ' + PORT);
  console.log('üîÑ Auto-sync scheduled: Prices every 15min, Beds24 bookings every 15min, Inventory every 6hrs');
  
  // Run database migrations on startup
  try {
    console.log('üì¶ Running database migrations...');
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS last_price_sync TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS last_image_sync TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_properties ADD COLUMN IF NOT EXISTS last_content_sync TIMESTAMP`);
    await pool.query(`ALTER TABLE gas_sync_room_types ADD COLUMN IF NOT EXISTS tier5_synced_at TIMESTAMP`);
    
    // Portfolio display columns
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS show_on_portfolio BOOLEAN DEFAULT true`);
    await pool.query(`ALTER TABLE properties ADD COLUMN IF NOT EXISTS portfolio_display JSONB DEFAULT '{}'::jsonb`);
    
    // Ensure faq_schema column exists on client_pages
    await pool.query(`ALTER TABLE client_pages ADD COLUMN IF NOT EXISTS faq_schema JSONB`);
    
    console.log('‚úÖ Database migrations complete');
  } catch (migrationError) {
    console.log('‚ö†Ô∏è Migration error (may already exist):', migrationError.message);
  }
  
  // Start internal tiered availability sync scheduler
  startTieredSyncScheduler();
  
  // Start translation worker (auto-translate missing languages)
  startTranslationWorker();
});

// =====================================================
// INTERNAL TIERED SYNC SCHEDULER
// Runs automatically - no external cron needed
// =====================================================

async function runTieredSync() {
  console.log('‚è∞ [Tiered Sync] Starting automatic sync...');
  
  try {
    await ensureTierTrackingColumns();
    
    const now = new Date();
    let totalRoomsSynced = 0;
    let totalDaysUpdated = 0;
    const errors = [];
    
    // Get all active Beds24 connections
    const connections = await pool.query(`
      SELECT * FROM gas_sync_connections 
      WHERE adapter_code = 'beds24' AND sync_enabled = true AND status != 'syncing'
    `);
    
    if (connections.rows.length === 0) {
      console.log('‚è∞ [Tiered Sync] No active Beds24 connections found');
      return;
    }
    
    for (const conn of connections.rows) {
      let accessToken = conn.access_token;
      
      // Always try to refresh token - access tokens expire quickly
      if (conn.refresh_token) {
        try {
          const tokenResponse = await axios.get('https://beds24.com/api/v2/authentication/token', {
            headers: { 'refreshToken': conn.refresh_token }
          });
          accessToken = tokenResponse.data.token;
          await pool.query('UPDATE gas_sync_connections SET access_token = $1 WHERE id = $2', [accessToken, conn.id]);
          console.log(`‚è∞ [Tiered Sync] Refreshed token for connection ${conn.id} (${conn.name || 'unnamed'})`);
        } catch (e) {
          console.error(`‚è∞ [Tiered Sync] Token refresh failed for connection ${conn.id}: ${e.message}`);
          errors.push({ connection: conn.id, error: 'Token refresh failed: ' + e.message });
          continue;
        }
      }
      
      if (!accessToken) {
        console.log(`‚è∞ [Tiered Sync] No token for connection ${conn.id}, skipping`);
        continue;
      }
      
      // Load price linking map for this connection
      const priceLinkingMap = {};
      const linkingResult = await pool.query(`
        SELECT rt.external_id, rt.price_linking
        FROM gas_sync_room_types rt
        JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
        WHERE sp.connection_id = $1 AND rt.price_linking IS NOT NULL
      `, [conn.id]);
      for (const row of linkingResult.rows) {
        if (row.price_linking) {
          priceLinkingMap[row.external_id] = typeof row.price_linking === 'string' 
            ? JSON.parse(row.price_linking) 
            : row.price_linking;
        }
      }
      
      // Get rooms that need syncing for each tier
      for (const tier of SYNC_TIERS) {
        const tierColumn = `tier${tier.tier}_synced_at`;
        const cutoffTime = new Date(now.getTime() - tier.intervalMinutes * 60 * 1000);
        
        // Find rooms due for this tier sync (use roomsPerRun from tier config)
        const roomsResult = await pool.query(`
          SELECT rt.id, rt.external_id as beds24_room_id, rt.gas_room_id, bu.name
          FROM gas_sync_room_types rt
          JOIN gas_sync_properties sp ON rt.sync_property_id = sp.id
          JOIN bookable_units bu ON bu.id = rt.gas_room_id
          WHERE sp.connection_id = $1 
            AND rt.gas_room_id IS NOT NULL
            AND (rt.${tierColumn} IS NULL OR rt.${tierColumn} < $2)
          ORDER BY rt.${tierColumn} ASC NULLS FIRST
          LIMIT $3
        `, [conn.id, cutoffTime, tier.roomsPerRun || 5]);
        
        if (roomsResult.rows.length === 0) continue;
        
        console.log(`‚è∞ [Tiered Sync] Tier ${tier.tier} (${tier.name}): ${roomsResult.rows.length} rooms due`);
        
        for (const room of roomsResult.rows) {
          try {
            // Calculate date range for this tier
            const startDate = new Date(now.getTime() + tier.startDay * 24 * 60 * 60 * 1000);
            const endDate = new Date(now.getTime() + tier.endDay * 24 * 60 * 60 * 1000);
            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];
            
            // Get prop_key for this room's property
            const propKeyResult = await pool.query(`
              SELECT sp.prop_key FROM gas_sync_properties sp
              JOIN gas_sync_room_types rt ON rt.sync_property_id = sp.id
              WHERE rt.id = $1
            `, [room.id]);
            const propKey = propKeyResult.rows[0]?.prop_key;
            
            // Fetch calendar from Beds24 V2
            const calResponse = await axios.get('https://beds24.com/api/v2/inventory/rooms/calendar', {
              headers: { 'token': accessToken },
              params: {
                roomId: parseInt(room.beds24_room_id),
                startDate: startDate.toISOString().split('T')[0],
                endDate: endDate.toISOString().split('T')[0],
                includeNumAvail: true,
                includePrices: true,
                includeMinStay: true
              }
            });
            
            const calendarData = calResponse.data.data?.[0]?.calendar || [];
            let daysUpdated = 0;
            
            // Check if V2 returned any prices
            const hasAnyPrices = calendarData.some(entry => entry.price1 || entry.price);
            
            // Check if this room has price linking
            const linking = priceLinkingMap[room.beds24_room_id];
            
            // If no prices but has price linking, get prices from BASE in database
            if (!hasAnyPrices && linking) {
              // Find the GAS room ID for the source room (BASE)
              const sourceRoomResult = await pool.query(`
                SELECT rt.gas_room_id 
                FROM gas_sync_room_types rt
                JOIN gas_sync_properties sp ON sp.id = rt.sync_property_id
                WHERE sp.connection_id = $1 AND rt.external_id = $2
              `, [conn.id, String(linking.sourceRoomId)]);
              
              const sourceGasRoomId = sourceRoomResult.rows[0]?.gas_room_id;
              
              if (sourceGasRoomId) {
                // Get BASE prices from database
                const sourcePricesResult = await pool.query(`
                  SELECT date, cm_price, min_stay
                  FROM room_availability
                  WHERE room_id = $1 AND date >= $2 AND date <= $3 AND cm_price IS NOT NULL
                  ORDER BY date
                `, [sourceGasRoomId, startDateStr, endDateStr]);
                
                if (sourcePricesResult.rows.length > 0) {
                  const multiplier = linking.offsetMultiplier || 1;
                  const offset = linking.offsetAmount || 0;
                  
                  console.log(`  üìä Applying ${sourcePricesResult.rows.length} BASE prices to ${room.name} (x${multiplier})`);
                  
                  // Save prices to this linked room
                  for (const row of sourcePricesResult.rows) {
                    const dateStr = row.date.toISOString().split('T')[0];
                    const basePrice = parseFloat(row.cm_price);
                    const linkedPrice = (basePrice * multiplier) + offset;
                    const minStay = row.min_stay || 1;
                    
                    await pool.query(`
                      INSERT INTO room_availability (room_id, date, cm_price, direct_price, min_stay, cm_min_stay, source, updated_at)
                      VALUES ($1, $2, $3, $3, $4, $4, 'beds24-linked', NOW())
                      ON CONFLICT (room_id, date) 
                      DO UPDATE SET 
                        cm_price = $3,
                        direct_price = $3,
                        min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $4 END,
                        cm_min_stay = $4,
                        source = 'beds24-linked',
                        updated_at = NOW()
                    `, [room.gas_room_id, dateStr, linkedPrice, minStay]);
                    
                    daysUpdated++;
                  }
                } else {
                  console.log(`  ‚ö†Ô∏è ${room.name}: No BASE prices found in DB for date range`);
                }
              }
            } else if (hasAnyPrices) {
              // Process V2 calendar data normally
              for (const entry of calendarData) {
                const fromDate = new Date(entry.from);
                const toDate = new Date(entry.to);
                
                for (let d = new Date(fromDate); d <= toDate; d.setDate(d.getDate() + 1)) {
                  const dateStr = d.toISOString().split('T')[0];
                  const numAvail = entry.numAvail || 0;
                  const price = entry.price1 || null;
                  const minStay = entry.minStay || 1;
                  
                  await pool.query(`
                    INSERT INTO room_availability (room_id, date, cm_price, direct_price, is_available, is_blocked, min_stay, cm_min_stay, source, updated_at)
                    VALUES ($1, $2, $3, $3, $4, $5, $6, $6, 'beds24', NOW())
                    ON CONFLICT (room_id, date) 
                    DO UPDATE SET 
                      cm_price = COALESCE($3, room_availability.cm_price),
                      is_available = $4,
                      is_blocked = $5,
                      min_stay = CASE WHEN room_availability.min_stay_override IS NOT NULL THEN room_availability.min_stay ELSE $6 END,
                      cm_min_stay = $6,
                      source = 'beds24',
                      updated_at = NOW()
                  `, [room.gas_room_id, dateStr, price, numAvail > 0, numAvail === 0, minStay]);
                  
                  daysUpdated++;
                }
              }
            } else {
              console.log(`  ‚è≠Ô∏è ${room.name}: No prices and no linking configured`);
            }
            
            // Update tier sync timestamp
            await pool.query(`UPDATE gas_sync_room_types SET ${tierColumn} = NOW() WHERE id = $1`, [room.id]);
            
            totalRoomsSynced++;
            totalDaysUpdated += daysUpdated;
            
            console.log(`  ‚úì ${room.name}: ${daysUpdated} days (Tier ${tier.tier})`);
            
            // Rate limit protection: wait 2 seconds between API calls
            await new Promise(resolve => setTimeout(resolve, 2000));
            
          } catch (roomError) {
            console.error(`  ‚úó ${room.name}: ${roomError.message}`);
            errors.push({ room: room.id, name: room.name, tier: tier.tier, error: roomError.message });
            
            // If rate limited, stop and wait longer
            if (roomError.response?.status === 429) {
              console.log(`‚è∞ [Tiered Sync] Rate limited! Stopping this run.`);
              return;
            }
          }
        }
      }
    }
    
    if (totalRoomsSynced > 0) {
      console.log(`‚è∞ [Tiered Sync] Complete: ${totalRoomsSynced} rooms, ${totalDaysUpdated} days updated`);
    }
    
  } catch (error) {
    console.error('‚è∞ [Tiered Sync] Error:', error.message);
  }
}

// ============================================
// PLUGIN API ENDPOINTS
// ============================================

// Cache for GitHub release info (refresh every 5 minutes)
let gitHubReleaseCache = null;
let gitHubReleaseCacheTime = 0;
const GITHUB_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

async function getLatestGitHubRelease() {
  const now = Date.now();
  
  // Return cached if still valid
  if (gitHubReleaseCache && (now - gitHubReleaseCacheTime) < GITHUB_CACHE_TTL) {
    return gitHubReleaseCache;
  }
  
  try {
    const response = await axios.get('https://api.github.com/repos/rezintelhelp-hub/gas-booking-plugin/releases/latest', {
      headers: { 'Accept': 'application/vnd.github.v3+json' },
      timeout: 5000
    });
    
    const release = response.data;
    const version = release.tag_name.replace('v', ''); // v1.0.165 -> 1.0.165
    
    // Find the zip asset
    const zipAsset = release.assets.find(a => a.name.endsWith('.zip'));
    const downloadUrl = zipAsset ? zipAsset.browser_download_url : null;
    
    gitHubReleaseCache = {
      version: version,
      download_url: downloadUrl,
      published_at: release.published_at,
      body: release.body || ''
    };
    gitHubReleaseCacheTime = now;
    
    console.log(`[GitHub] Fetched latest release: v${version}`);
    return gitHubReleaseCache;
    
  } catch (error) {
    console.error('[GitHub] Error fetching release:', error.message);
    // Return fallback if API fails
    return {
      version: '1.0.165',
      download_url: 'https://github.com/rezintelhelp-hub/gas-booking-plugin/releases/latest',
      published_at: new Date().toISOString(),
      body: ''
    };
  }
}

// Plugin update check - returns latest version info (fetches from GitHub)
app.get('/api/plugin/check-update', async (req, res) => {
  try {
    const latest = await getLatestGitHubRelease();
    
    const latestVersion = {
      version: latest.version,
      download_url: latest.download_url,
      requires: '5.8',
      tested: '6.4',
      requires_php: '7.4',
      last_updated: latest.published_at ? latest.published_at.split('T')[0] : new Date().toISOString().split('T')[0],
      description: 'Complete booking system for Guest Accommodation System. Display rooms, handle bookings, and integrate with channel managers.',
      changelog: latest.body || '<p>See GitHub releases for changelog</p>'
    };
    res.json(latestVersion);
  } catch (error) {
    console.error('Plugin update check error:', error);
    res.status(500).json({ error: 'Failed to check for updates' });
  }
});

// Validate plugin license key
app.post('/api/plugin/validate-license', async (req, res) => {
  try {
    const { license_key } = req.body;
    
    if (!license_key) {
      return res.json({ success: false, error: 'License key required' });
    }
    
    // Look up license in plugin_licenses table (LEFT JOIN in case account_id is null)
    const licenseResult = await pool.query(`
      SELECT pl.*, a.name as account_name, a.email as account_email
      FROM plugin_licenses pl
      LEFT JOIN accounts a ON pl.account_id = a.id
      WHERE pl.license_key = $1 AND pl.status = 'active'
    `, [license_key]);
    
    if (licenseResult.rows.length === 0) {
      // Also check if license_key matches an account's api_key (legacy support)
      const accountResult = await pool.query(`
        SELECT id, name, email FROM accounts WHERE api_key = $1 AND status = 'active'
      `, [license_key]);
      
      if (accountResult.rows.length === 0) {
        return res.json({ success: false, error: 'Invalid or expired license key' });
      }
      
      const account = accountResult.rows[0];
      return res.json({
        success: true,
        account_id: account.id,
        account_name: account.name,
        account_email: account.email,
        room_ids: [], // All rooms for legacy
        display_settings: {} // Default settings for legacy
      });
    }
    
    const license = licenseResult.rows[0];
    
    // Update last_used timestamp (ignore if column doesn't exist)
    await pool.query(`UPDATE plugin_licenses SET last_used_at = NOW() WHERE id = $1`, [license.id]).catch(() => {});
    
    res.json({
      success: true,
      account_id: license.account_id,
      account_name: license.account_name || license.email,
      account_email: license.account_email || license.email,
      plan: license.plan || 'plugin',
      room_ids: license.room_ids || [],
      display_settings: license.display_settings || {}
    });
    
  } catch (error) {
    console.error('Plugin license validation error:', error);
    res.json({ success: false, error: 'Validation failed: ' + error.message });
  }
});

// List all plugin licenses for an account
// Update license display settings
app.put('/api/plugin-licenses/:id', async (req, res) => {
  try {
    const { display_settings, room_ids, status } = req.body;
    
    const updates = [];
    const values = [];
    let paramIndex = 1;
    
    if (display_settings !== undefined) {
      updates.push(`display_settings = $${paramIndex++}`);
      values.push(JSON.stringify(display_settings));
    }
    
    if (room_ids !== undefined) {
      updates.push(`room_ids = $${paramIndex++}`);
      values.push(JSON.stringify(room_ids));
    }
    
    if (status !== undefined) {
      updates.push(`status = $${paramIndex++}`);
      values.push(status);
    }
    
    if (updates.length === 0) {
      return res.json({ success: false, error: 'No updates provided' });
    }
    
    values.push(req.params.id);
    
    const result = await pool.query(`
      UPDATE plugin_licenses 
      SET ${updates.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `, values);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'License not found' });
    }
    
    res.json({ success: true, license: result.rows[0] });
  } catch (error) {
    console.error('Error updating license:', error);
    res.json({ success: false, error: error.message });
  }
});

// GET rooms for a plugin license (same pattern as deployed-sites rooms)
app.get('/api/plugin-licenses/:id/rooms', async (req, res) => {
  try {
    const { id } = req.params;
    
    const licenseResult = await pool.query('SELECT account_id, room_ids FROM plugin_licenses WHERE id = $1', [id]);
    if (licenseResult.rows.length === 0) {
      return res.json({ success: false, error: 'License not found' });
    }
    
    const accountId = licenseResult.rows[0].account_id;
    const roomIdsJson = licenseResult.rows[0].room_ids;
    
    let linkedRoomIds = [];
    if (roomIdsJson) {
      linkedRoomIds = typeof roomIdsJson === 'string' ? JSON.parse(roomIdsJson) : roomIdsJson;
    }
    
    if (!accountId) {
      return res.json({ success: true, propertyGroups: [], linkedRoomIds: [], message: 'No account linked to license' });
    }
    
    const propertiesResult = await pool.query(`
      SELECT id, name FROM properties WHERE account_id = $1 ORDER BY name
    `, [accountId]);
    
    const roomsResult = await pool.query(`
      SELECT bu.*, p.name as property_name 
      FROM bookable_units bu
      JOIN properties p ON bu.property_id = p.id
      WHERE p.account_id = $1
      ORDER BY p.name, bu.name
    `, [accountId]);
    
    const propertyGroups = propertiesResult.rows.map(prop => ({
      property: prop,
      rooms: roomsResult.rows.filter(r => r.property_id === prop.id)
    }));
    
    res.json({ success: true, propertyGroups, linkedRoomIds });
  } catch (error) {
    console.error('Get plugin license rooms error:', error);
    res.json({ success: false, error: error.message });
  }
});

// PUT rooms for a plugin license
app.put('/api/plugin-licenses/:id/rooms', async (req, res) => {
  try {
    const { id } = req.params;
    const { roomIds } = req.body;
    
    if (!Array.isArray(roomIds)) {
      return res.json({ success: false, error: 'roomIds array required' });
    }
    
    const result = await pool.query(`
      UPDATE plugin_licenses SET room_ids = $1 WHERE id = $2 RETURNING id, room_ids, account_id
    `, [JSON.stringify(roomIds), id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'License not found' });
    }
    
    // Find associated WordPress site URLs for this account
    const accountId = result.rows[0].account_id;
    let siteUrls = [];
    
    if (accountId) {
      // Check deployed_sites (multisite)
      const deployedResult = await pool.query(
        `SELECT site_url FROM deployed_sites WHERE account_id = $1 AND status = 'active' AND site_url IS NOT NULL`,
        [accountId]
      );
      siteUrls.push(...deployedResult.rows.map(r => r.site_url));
      
      // Check custom_sites
      const customResult = await pool.query(
        `SELECT domain FROM custom_sites WHERE account_id = $1 AND domain IS NOT NULL`,
        [accountId]
      );
      siteUrls.push(...customResult.rows.map(r => `https://${r.domain}`));
    }
    
    res.json({ success: true, message: `Updated: ${roomIds.length} rooms selected`, room_ids: roomIds, site_urls: siteUrls });
  } catch (error) {
    console.error('Update plugin license rooms error:', error);
    res.json({ success: false, error: error.message });
  }
});

// Delete/deactivate license
app.delete('/api/plugin-licenses/:id', async (req, res) => {
  try {
    const result = await pool.query(`
      UPDATE plugin_licenses SET status = 'inactive' WHERE id = $1 RETURNING *
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'License not found' });
    }
    
    res.json({ success: true, message: 'License deactivated' });
  } catch (error) {
    console.error('Error deactivating license:', error);
    res.json({ success: false, error: error.message });
  }
});

// Permanently delete license
app.delete('/api/plugin-licenses/:id/delete', async (req, res) => {
  try {
    const result = await pool.query(`
      DELETE FROM plugin_licenses WHERE id = $1 RETURNING *
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.json({ success: false, error: 'License not found' });
    }
    
    res.json({ success: true, message: 'License permanently deleted' });
  } catch (error) {
    console.error('Error deleting license:', error);
    res.json({ success: false, error: error.message });
  }
});

// Get properties for plugin (requires license key in Authorization header)
app.get('/api/plugin/properties', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'Authorization required' });
    }
    
    const licenseKey = authHeader.replace('Bearer ', '');
    
    // Get account from license key
    const accountResult = await pool.query(`
      SELECT a.id FROM accounts a
      LEFT JOIN plugin_licenses pl ON pl.account_id = a.id
      WHERE pl.license_key = $1 OR a.api_key = $1
      LIMIT 1
    `, [licenseKey]);
    
    if (accountResult.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid license key' });
    }
    
    const accountId = accountResult.rows[0].id;
    
    // Get properties for this account
    const propertiesResult = await pool.query(`
      SELECT 
        p.id,
        p.name,
        p.description,
        p.bedrooms,
        p.bathrooms,
        p.max_guests,
        p.address,
        p.city,
        p.state,
        p.country,
        p.latitude,
        p.longitude,
        p.base_price as price,
        p.currency,
        p.property_type,
        p.amenities,
        p.images,
        p.status,
        COALESCE(
          (SELECT AVG(rating) FROM reviews WHERE property_id = p.id),
          0
        ) as rating,
        COALESCE(
          (SELECT COUNT(*) FROM reviews WHERE property_id = p.id),
          0
        ) as review_count
      FROM properties p
      WHERE p.account_id = $1 AND p.status = 'active'
      ORDER BY p.name
    `, [accountId]);
    
    // Format properties for plugin
    const properties = propertiesResult.rows.map(p => ({
      id: p.id,
      name: p.name,
      description: p.description,
      bedrooms: p.bedrooms,
      bathrooms: p.bathrooms,
      max_guests: p.max_guests,
      location: [p.city, p.state].filter(Boolean).join(', '),
      address: p.address,
      latitude: p.latitude,
      longitude: p.longitude,
      price: parseFloat(p.price) || 0,
      currency: p.currency || 'USD',
      property_type: p.property_type,
      amenities: p.amenities || [],
      images: p.images || [],
      rating: parseFloat(p.rating) || 0,
      review_count: parseInt(p.review_count) || 0,
      status: p.status
    }));
    
    res.json({ success: true, properties });
    
  } catch (error) {
    console.error('Plugin properties error:', error);
    res.json({ success: false, error: 'Failed to fetch properties' });
  }
});

// Sync properties from channel manager
app.post('/api/plugin/sync', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.json({ success: false, error: 'Authorization required' });
    }
    
    const licenseKey = authHeader.replace('Bearer ', '');
    
    // Get account from license key
    const accountResult = await pool.query(`
      SELECT a.id FROM accounts a
      LEFT JOIN plugin_licenses pl ON pl.account_id = a.id
      WHERE pl.license_key = $1 OR a.api_key = $1
      LIMIT 1
    `, [licenseKey]);
    
    if (accountResult.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid license key' });
    }
    
    const accountId = accountResult.rows[0].id;
    
    // Check for channel manager connection
    const connectionResult = await pool.query(`
      SELECT * FROM gas_sync_connections WHERE account_id = $1 AND status = 'active' LIMIT 1
    `, [accountId]);
    
    if (connectionResult.rows.length === 0) {
      return res.json({ success: false, error: 'No channel manager connected. Please connect Hostaway or Beds24 first.' });
    }
    
    const connection = connectionResult.rows[0];
    
    // Trigger sync based on adapter type
    try {
      const adapter = getAdapter(connection.adapter_code);
      const credentials = connection.credentials;
      
      // Fetch properties from channel manager
      const cmProperties = await adapter.getProperties(credentials);
      
      let synced = 0;
      for (const cmProp of cmProperties) {
        // Upsert property
        await pool.query(`
          INSERT INTO properties (
            account_id, external_id, name, description, bedrooms, bathrooms, 
            max_guests, address, city, state, country, latitude, longitude,
            base_price, currency, property_type, amenities, images, status, updated_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, 'active', NOW())
          ON CONFLICT (account_id, external_id) DO UPDATE SET
            name = EXCLUDED.name,
            description = EXCLUDED.description,
            bedrooms = EXCLUDED.bedrooms,
            bathrooms = EXCLUDED.bathrooms,
            max_guests = EXCLUDED.max_guests,
            address = EXCLUDED.address,
            city = EXCLUDED.city,
            state = EXCLUDED.state,
            country = EXCLUDED.country,
            latitude = EXCLUDED.latitude,
            longitude = EXCLUDED.longitude,
            base_price = EXCLUDED.base_price,
            currency = EXCLUDED.currency,
            amenities = EXCLUDED.amenities,
            images = EXCLUDED.images,
            updated_at = NOW()
        `, [
          accountId,
          cmProp.id,
          cmProp.name,
          cmProp.description,
          cmProp.bedrooms,
          cmProp.bathrooms,
          cmProp.maxGuests,
          cmProp.address,
          cmProp.city,
          cmProp.state,
          cmProp.country,
          cmProp.latitude,
          cmProp.longitude,
          cmProp.price,
          cmProp.currency || 'USD',
          cmProp.propertyType,
          JSON.stringify(cmProp.amenities || []),
          JSON.stringify(cmProp.images || [])
        ]);
        synced++;
      }
      
      // Update connection last sync time
      await pool.query(`UPDATE gas_sync_connections SET last_sync_at = NOW() WHERE id = $1`, [connection.id]);
      
      // Return updated properties list
      const propertiesResult = await pool.query(`
        SELECT * FROM properties WHERE account_id = $1 AND status = 'active' ORDER BY name
      `, [accountId]);
      
      res.json({ 
        success: true, 
        message: `Synced ${synced} properties from ${connection.adapter_code}`,
        properties: propertiesResult.rows 
      });
      
    } catch (syncError) {
      console.error('Sync error:', syncError);
      res.json({ success: false, error: 'Sync failed: ' + syncError.message });
    }
    
  } catch (error) {
    console.error('Plugin sync error:', error);
    res.json({ success: false, error: 'Sync failed' });
  }
});

// Get availability for a property
app.get('/api/plugin/availability', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    const licenseKey = authHeader?.replace('Bearer ', '');
    
    const { property_id, start_date, end_date } = req.query;
    
    if (!property_id || !start_date || !end_date) {
      return res.json({ success: false, error: 'property_id, start_date, and end_date required' });
    }
    
    // Get property with pricing
    const propertyResult = await pool.query(`
      SELECT p.*, c.adapter_code, c.credentials
      FROM properties p
      LEFT JOIN gas_sync_connections c ON c.account_id = p.account_id AND c.status = 'active'
      WHERE p.id = $1
    `, [property_id]);
    
    if (propertyResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const property = propertyResult.rows[0];
    
    // Try to get real-time availability from channel manager
    let availability = { available: true, nightly_rate: property.base_price || 100 };
    
    if (property.adapter_code && property.credentials) {
      try {
        const adapter = getAdapter(property.adapter_code);
        const realAvailability = await adapter.getAvailability(
          property.credentials,
          property.external_id,
          start_date,
          end_date
        );
        availability = realAvailability;
      } catch (e) {
        console.log('Could not fetch real-time availability:', e.message);
      }
    }
    
    // Calculate total
    const nights = Math.ceil((new Date(end_date) - new Date(start_date)) / (1000 * 60 * 60 * 24));
    const total = availability.nightly_rate * nights;
    
    res.json({
      success: true,
      available: availability.available,
      nightly_rate: availability.nightly_rate,
      nights: nights,
      total: total,
      currency: property.currency || 'USD'
    });
    
  } catch (error) {
    console.error('Plugin availability error:', error);
    res.json({ success: false, error: 'Failed to check availability' });
  }
});

// Create booking from plugin
app.post('/api/plugin/booking', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    const licenseKey = authHeader?.replace('Bearer ', '');
    
    const { property_id, start_date, end_date, guests, guest_name, guest_email, guest_phone, notes } = req.body;
    
    if (!property_id || !start_date || !end_date || !guest_name || !guest_email) {
      return res.json({ success: false, error: 'Missing required fields' });
    }
    
    // Get property
    const propertyResult = await pool.query(`SELECT * FROM properties WHERE id = $1`, [property_id]);
    if (propertyResult.rows.length === 0) {
      return res.json({ success: false, error: 'Property not found' });
    }
    
    const property = propertyResult.rows[0];
    
    // Calculate pricing
    const nights = Math.ceil((new Date(end_date) - new Date(start_date)) / (1000 * 60 * 60 * 24));
    const total = (property.base_price || 100) * nights;
    
    // Generate confirmation number
    const confirmationNumber = 'GAS-' + Date.now().toString(36).toUpperCase();
    
    // Create booking record
    const bookingResult = await pool.query(`
      INSERT INTO bookings (
        account_id, property_id, confirmation_number,
        check_in_date, check_out_date, nights,
        guest_name, guest_email, guest_phone,
        num_guests, total_amount, currency,
        notes, status, source, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'pending', 'plugin', NOW())
      RETURNING *
    `, [
      property.account_id,
      property_id,
      confirmationNumber,
      start_date,
      end_date,
      nights,
      guest_name,
      guest_email,
      guest_phone,
      guests || 1,
      total,
      property.currency || 'USD',
      notes
    ]);
    
    const booking = bookingResult.rows[0];
    
    // TODO: Push booking to channel manager
    // TODO: Send confirmation email
    
    res.json({
      success: true,
      booking_id: booking.id,
      confirmation_number: confirmationNumber,
      total: total,
      currency: property.currency || 'USD'
    });
    
  } catch (error) {
    console.error('Plugin booking error:', error);
    res.json({ success: false, error: 'Booking failed' });
  }
});

// Get reviews for plugin
app.get('/api/plugin/reviews', async (req, res) => {
  try {
    // Accept license key from multiple sources
    const authHeader = req.headers.authorization;
    const xLicenseKey = req.headers['x-license-key'];
    const xApiKey = req.headers['x-api-key'];
    const licenseKey = xLicenseKey || xApiKey || authHeader?.replace('Bearer ', '') || req.query.license_key;
    
    const { property_id, room_id, room_ids, min_rating, limit } = req.query;
    
    // Get account from license
    const accountResult = await pool.query(`
      SELECT a.id FROM accounts a
      LEFT JOIN plugin_licenses pl ON pl.account_id = a.id
      WHERE pl.license_key = $1 OR a.api_key = $1
      LIMIT 1
    `, [licenseKey]);
    
    if (accountResult.rows.length === 0) {
      return res.json({ success: false, error: 'Invalid license key' });
    }
    
    const accountId = accountResult.rows[0].id;
    
    let query = `
      SELECT r.*, p.name as property_name, rm.name as room_name
      FROM reviews r
      JOIN properties p ON r.property_id = p.id
      LEFT JOIN rooms rm ON r.room_id = rm.id
      WHERE p.account_id = $1 AND r.is_public = true
    `;
    const params = [accountId];
    let paramIndex = 2;
    
    if (property_id) {
      query += ` AND r.property_id = $${paramIndex}`;
      params.push(property_id);
      paramIndex++;
    }
    
    // Support both room_id (single) and room_ids (comma-separated)
    if (room_ids) {
      const roomIdArray = room_ids.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
      if (roomIdArray.length > 0) {
        query += ` AND r.room_id = ANY($${paramIndex}::int[])`;
        params.push(roomIdArray);
        paramIndex++;
      }
    } else if (room_id) {
      query += ` AND r.room_id = $${paramIndex}`;
      params.push(room_id);
      paramIndex++;
    }
    
    if (min_rating) {
      query += ` AND r.rating >= $${paramIndex}`;
      params.push(parseFloat(min_rating));
      paramIndex++;
    }
    
    const reviewLimit = Math.min(parseInt(limit) || 50, 100);
    query += ` ORDER BY r.review_date DESC NULLS LAST, r.created_at DESC LIMIT ${reviewLimit}`;
    
    const reviewsResult = await pool.query(query, params);
    
    res.json({
      success: true,
      reviews: reviewsResult.rows.map(r => ({
        id: r.id,
        property_id: r.property_id,
        property_name: r.property_name,
        room_id: r.room_id,
        room_name: r.room_name,
        guest_name: r.guest_name,
        guest_avatar: r.guest_avatar,
        guest_country: r.guest_country,
        rating: r.rating,
        comment: r.comment,
        channel_name: r.channel_name,
        review_date: r.review_date,
        source: r.source
      })),
      total: reviewsResult.rows.length
    });
    
  } catch (error) {
    console.error('Plugin reviews error:', error);
    res.json({ success: false, error: 'Failed to fetch reviews' });
  }
});

// ============================================
// APP SETTINGS API ENDPOINTS
// ============================================

// PUBLIC endpoint for WordPress plugins to fetch reviews
app.get('/api/public/client/:clientId/reviews', async (req, res) => {
    try {
        const { clientId } = req.params;
        const { property_id, min_rating, limit } = req.query;
        
        // Get account - try by id first (numeric), then by account_code
        let accountId;
        const numericId = parseInt(clientId);
        
        if (!isNaN(numericId)) {
            const accountResult = await pool.query('SELECT id FROM accounts WHERE id = $1', [numericId]);
            if (accountResult.rows.length > 0) {
                accountId = accountResult.rows[0].id;
            }
        }
        
        if (!accountId) {
            const accountResult = await pool.query('SELECT id FROM accounts WHERE account_code = $1', [clientId]);
            if (accountResult.rows.length > 0) {
                accountId = accountResult.rows[0].id;
            }
        }
        
        if (!accountId) {
            return res.json({ success: true, reviews: [] });
        }
        
        let query = `
            SELECT r.*, p.name as property_name
            FROM reviews r
            JOIN properties p ON r.property_id = p.id
            WHERE p.account_id = $1 AND r.is_public = true
        `;
        const params = [accountId];
        let paramIndex = 2;
        
        if (property_id) {
            query += ` AND r.property_id = $${paramIndex}`;
            params.push(property_id);
            paramIndex++;
        }
        
        if (min_rating) {
            query += ` AND r.rating >= $${paramIndex}`;
            params.push(parseFloat(min_rating));
            paramIndex++;
        }
        
        const reviewLimit = Math.min(parseInt(limit) || 50, 100);
        query += ` ORDER BY r.review_date DESC NULLS LAST, r.created_at DESC LIMIT ${reviewLimit}`;
        
        const reviewsResult = await pool.query(query, params);
        
        res.json({
            success: true,
            reviews: reviewsResult.rows.map(r => ({
                id: r.id,
                property_id: r.property_id,
                property_name: r.property_name,
                guest_name: r.guest_name,
                guest_country: r.guest_country,
                rating: r.rating,
                comment: r.comment,
                review_date: r.review_date,
                source: r.source || r.channel_name
            })),
            total: reviewsResult.rows.length
        });
        
    } catch (error) {
        console.error('Public reviews error:', error);
        res.json({ success: true, reviews: [] });
    }
});

// GET /api/app-settings/:app - Get app display settings (blog, attractions, reviews, properties)
app.get('/api/app-settings/:app', async (req, res) => {
    try {
        const { app } = req.params;
        const validApps = ['blog', 'attractions', 'reviews', 'properties'];
        
        if (!validApps.includes(app)) {
            return res.status(400).json({ success: false, error: 'Invalid app name' });
        }
        
        // Ensure table exists
        await pool.query(`
            CREATE TABLE IF NOT EXISTS app_settings (
                id SERIAL PRIMARY KEY,
                account_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
                app_name VARCHAR(50) NOT NULL,
                settings JSONB DEFAULT '{}',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(account_id, app_name)
            )
        `);
        
        const accountId = req.query.account_id || req.user?.account_id || 1;
        
        const result = await pool.query(
            `SELECT settings FROM app_settings WHERE account_id = $1 AND app_name = $2`,
            [accountId, app]
        );
        
        if (result.rows.length > 0) {
            res.json({ success: true, colors: result.rows[0].settings?.colors || {} });
        } else {
            // Return defaults
            const defaults = {
                blog: { accent: '#667eea', bg: '#ffffff', card_bg: '#ffffff', text: '#1a1a1a', text_secondary: '#666666', category_bg: '#e0e7ff', category_text: '#4338ca' },
                attractions: { accent: '#f59e0b', bg: '#ffffff', card_bg: '#ffffff', text: '#1a1a1a', text_secondary: '#666666', category_bg: '#fef3c7', category_text: '#92400e' },
                reviews: { accent: '#667eea', bg: '#ffffff', card_bg: '#ffffff', text: '#1e293b', text_secondary: '#64748b', star: '#fbbf24' }
            };
            res.json({ success: true, colors: defaults[app] });
        }
    } catch (error) {
        console.error('Error getting app settings:', error);
        res.status(500).json({ success: false, error: 'Failed to get settings' });
    }
});

// PUT /api/app-settings/:app - Save app display settings
app.put('/api/app-settings/:app', async (req, res) => {
    try {
        const { app } = req.params;
        const { colors } = req.body;
        const validApps = ['blog', 'attractions', 'reviews', 'properties'];
        
        if (!validApps.includes(app)) {
            return res.status(400).json({ success: false, error: 'Invalid app name' });
        }
        
        // Ensure table exists
        await pool.query(`
            CREATE TABLE IF NOT EXISTS app_settings (
                id SERIAL PRIMARY KEY,
                account_id INTEGER NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
                app_name VARCHAR(50) NOT NULL,
                settings JSONB DEFAULT '{}',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(account_id, app_name)
            )
        `);
        
        const accountId = req.body.account_id || req.query.account_id || req.user?.account_id || 1;
        
        const result = await pool.query(
            `INSERT INTO app_settings (account_id, app_name, settings, updated_at)
             VALUES ($1, $2, $3, NOW())
             ON CONFLICT (account_id, app_name) 
             DO UPDATE SET settings = $3, updated_at = NOW()
             RETURNING *`,
            [accountId, app, { colors }]
        );
        
        res.json({ success: true, message: 'Settings saved', settings: result.rows[0] });
    } catch (error) {
        console.error('Error saving app settings:', error);
        res.status(500).json({ success: false, error: 'Failed to save settings' });
    }
});

// PUBLIC endpoint for WordPress plugins to fetch colors
app.get('/api/public/client/:clientId/app-settings/:app', async (req, res) => {
    try {
        const { clientId, app } = req.params;
        const validApps = ['blog', 'attractions', 'reviews', 'properties'];
        
        if (!validApps.includes(app)) {
            return res.status(400).json({ success: false, error: 'Invalid app name' });
        }
        
        // Default colors to return
        const defaults = {
            blog: { accent: '#667eea', bg: '#ffffff', card_bg: '#ffffff', text: '#1a1a1a', text_secondary: '#666666', category_bg: '#e0e7ff', category_text: '#4338ca' },
            attractions: { accent: '#f59e0b', bg: '#ffffff', card_bg: '#ffffff', text: '#1a1a1a', text_secondary: '#666666', category_bg: '#fef3c7', category_text: '#92400e' },
            reviews: { accent: '#667eea', bg: '#ffffff', card_bg: '#ffffff', text: '#1e293b', text_secondary: '#64748b', star: '#fbbf24' },
            properties: { accent: '#10b981', bg: '#ffffff', card_bg: '#ffffff', text: '#1a1a1a', text_secondary: '#666666', badge_bg: '#d1fae5', badge_text: '#065f46', button_bg: '#10b981', button_text: '#ffffff' }
        };
        
        // Get account - try by id first (numeric), then by account_code
        let accountId;
        const numericId = parseInt(clientId);
        
        if (!isNaN(numericId)) {
            // Client ID is numeric, query by id
            const accountResult = await pool.query(
                'SELECT id FROM accounts WHERE id = $1',
                [numericId]
            );
            if (accountResult.rows.length > 0) {
                accountId = accountResult.rows[0].id;
            }
        }
        
        if (!accountId) {
            // Try by account_code
            const accountResult = await pool.query(
                'SELECT id FROM accounts WHERE account_code = $1',
                [clientId]
            );
            if (accountResult.rows.length > 0) {
                accountId = accountResult.rows[0].id;
            }
        }
        
        if (!accountId) {
            // Return defaults if account not found
            return res.json({ success: true, colors: defaults[app] });
        }
        
        // Check if table exists and query it
        try {
            const result = await pool.query(
                `SELECT settings FROM app_settings WHERE account_id = $1 AND app_name = $2`,
                [accountId, app]
            );
            
            if (result.rows.length > 0 && result.rows[0].settings?.colors) {
                res.json({ success: true, colors: result.rows[0].settings.colors });
            } else {
                res.json({ success: true, colors: defaults[app] });
            }
        } catch (tableError) {
            // Table doesn't exist yet, return defaults
            console.log('app_settings table not found, returning defaults');
            res.json({ success: true, colors: defaults[app] });
        }
    } catch (error) {
        console.error('Error getting public app settings:', error);
        res.status(500).json({ success: false, error: 'Failed to get settings' });
    }
});

// ============================================
// END PLUGIN API ENDPOINTS
// ============================================

// ============================================
// LANGUAGE / i18n API ENDPOINTS
// ============================================

// GAS_TRANSLATIONS is already defined above at line ~44185

// Available languages configuration
const AVAILABLE_LANGUAGES = [
  { code: 'en', name: 'English', native_name: 'English', flag: 'üá¨üáß', rtl: false },
  { code: 'fr', name: 'French', native_name: 'Fran√ßais', flag: 'üá´üá∑', rtl: false },
  { code: 'es', name: 'Spanish', native_name: 'Espa√±ol', flag: 'üá™üá∏', rtl: false },
  { code: 'de', name: 'German', native_name: 'Deutsch', flag: 'üá©üá™', rtl: false },
  { code: 'nl', name: 'Dutch', native_name: 'Nederlands', flag: 'üá≥üá±', rtl: false },
  { code: 'it', name: 'Italian', native_name: 'Italiano', flag: 'üáÆüáπ', rtl: false },
  { code: 'pt', name: 'Portuguese', native_name: 'Portugu√™s', flag: 'üáµüáπ', rtl: false },
  { code: 'ru', name: 'Russian', native_name: '–†—É—Å—Å–∫–∏–π', flag: 'üá∑üá∫', rtl: false },
  { code: 'pl', name: 'Polish', native_name: 'Polski', flag: 'üáµüá±', rtl: false },
  { code: 'cs', name: 'Czech', native_name: 'ƒåe≈°tina', flag: 'üá®üáø', rtl: false },
  { code: 'el', name: 'Greek', native_name: 'ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨', flag: 'üá¨üá∑', rtl: false },
  { code: 'tr', name: 'Turkish', native_name: 'T√ºrk√ße', flag: 'üáπüá∑', rtl: false },
  { code: 'sv', name: 'Swedish', native_name: 'Svenska', flag: 'üá∏üá™', rtl: false },
  { code: 'da', name: 'Danish', native_name: 'Dansk', flag: 'üá©üá∞', rtl: false },
  { code: 'no', name: 'Norwegian', native_name: 'Norsk', flag: 'üá≥üá¥', rtl: false },
  { code: 'fi', name: 'Finnish', native_name: 'Suomi', flag: 'üá´üáÆ', rtl: false },
  { code: 'hu', name: 'Hungarian', native_name: 'Magyar', flag: 'üá≠üá∫', rtl: false },
  { code: 'ro', name: 'Romanian', native_name: 'Rom√¢nƒÉ', flag: 'üá∑üá¥', rtl: false },
  { code: 'hr', name: 'Croatian', native_name: 'Hrvatski', flag: 'üá≠üá∑', rtl: false },
  { code: 'zh', name: 'Chinese', native_name: '‰∏≠Êñá', flag: 'üá®üá≥', rtl: false },
  { code: 'ja', name: 'Japanese', native_name: 'Êó•Êú¨Ë™û', flag: 'üáØüáµ', rtl: false },
  { code: 'ko', name: 'Korean', native_name: 'ÌïúÍµ≠Ïñ¥', flag: 'üá∞üá∑', rtl: false },
  { code: 'th', name: 'Thai', native_name: '‡πÑ‡∏ó‡∏¢', flag: 'üáπüá≠', rtl: false },
  { code: 'vi', name: 'Vietnamese', native_name: 'Ti·∫øng Vi·ªát', flag: 'üáªüá≥', rtl: false },
  { code: 'ar', name: 'Arabic', native_name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', flag: 'üá∏üá¶', rtl: true },
  { code: 'he', name: 'Hebrew', native_name: '◊¢◊ë◊®◊ô◊™', flag: 'üáÆüá±', rtl: true }
];

// Cache for translation files (from database overrides)
const translationCache = {};

// GET /api/languages - List all available languages
app.get('/api/languages', async (req, res) => {
  try {
    // Check if account has specific language restrictions
    const { accountId } = req.query;
    
    if (accountId) {
      // Check for account-specific enabled languages
      const result = await pool.query(
        'SELECT enabled_languages FROM accounts WHERE id = $1',
        [accountId]
      ).catch(() => ({ rows: [] }));
      
      if (result.rows.length > 0 && result.rows[0].enabled_languages) {
        const enabled = result.rows[0].enabled_languages;
        const filtered = AVAILABLE_LANGUAGES.filter(l => enabled.includes(l.code));
        return res.json({ success: true, languages: filtered.length > 0 ? filtered : AVAILABLE_LANGUAGES });
      }
    }
    
    res.json({ success: true, languages: AVAILABLE_LANGUAGES });
  } catch (error) {
    console.error('Error getting languages:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/languages/:code - Get translation file for a language
app.get('/api/languages/:code', async (req, res) => {
  try {
    const { code } = req.params;
    const langCode = code.toLowerCase();
    
    // Check if language is valid
    const langInfo = AVAILABLE_LANGUAGES.find(l => l.code === langCode);
    if (!langInfo) {
      return res.status(404).json({ success: false, error: 'Language not found' });
    }
    
    // Check cache first (for database overrides)
    if (translationCache[langCode]) {
      return res.json({ 
        success: true, 
        ...langInfo,
        strings: translationCache[langCode]
      });
    }
    
    // Try to load from database first (for custom translations)
    const dbResult = await pool.query(
      'SELECT strings FROM gas_translations WHERE lang_code = $1',
      [langCode]
    ).catch(() => ({ rows: [] }));
    
    if (dbResult.rows.length > 0) {
      const strings = dbResult.rows[0].strings;
      translationCache[langCode] = strings;
      return res.json({ 
        success: true, 
        ...langInfo,
        strings 
      });
    }
    
    // Use combined translations file
    if (GAS_TRANSLATIONS[langCode]) {
      return res.json({ 
        success: true, 
        ...langInfo,
        strings: GAS_TRANSLATIONS[langCode].strings
      });
    }
    
    // Fall back to English if language not found
    if (langCode !== 'en' && GAS_TRANSLATIONS['en']) {
      return res.json({ 
        success: true, 
        ...langInfo,
        strings: GAS_TRANSLATIONS['en'].strings,
        fallback: true
      });
    }
    
    res.status(404).json({ success: false, error: 'Translation file not found' });
  } catch (error) {
    console.error('Error getting translation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /api/languages/:code - Update/create translations (admin only)
app.post('/api/languages/:code', async (req, res) => {
  try {
    const { code } = req.params;
    const { strings } = req.body;
    const langCode = code.toLowerCase();
    
    // Check if language is valid
    if (!AVAILABLE_LANGUAGES.find(l => l.code === langCode)) {
      return res.status(400).json({ success: false, error: 'Invalid language code' });
    }
    
    // Ensure table exists
    await pool.query(`
      CREATE TABLE IF NOT EXISTS gas_translations (
        id SERIAL PRIMARY KEY,
        lang_code VARCHAR(10) UNIQUE NOT NULL,
        strings JSONB NOT NULL,
        updated_at TIMESTAMP DEFAULT NOW(),
        updated_by INTEGER
      )
    `);
    
    // Upsert translation
    await pool.query(`
      INSERT INTO gas_translations (lang_code, strings, updated_at)
      VALUES ($1, $2, NOW())
      ON CONFLICT (lang_code) DO UPDATE SET
        strings = EXCLUDED.strings,
        updated_at = NOW()
    `, [langCode, JSON.stringify(strings)]);
    
    // Clear cache
    delete translationCache[langCode];
    
    res.json({ success: true, message: `Translations for ${langCode} updated` });
  } catch (error) {
    console.error('Error updating translation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /api/public/languages - Public endpoint for websites/widgets
app.get('/api/public/languages', (req, res) => {
  // Return languages that have translations in the combined file
  const availableWithTranslations = AVAILABLE_LANGUAGES.filter(l => 
    GAS_TRANSLATIONS[l.code] || translationCache[l.code]
  );
  
  // Always include at least English
  if (availableWithTranslations.length === 0) {
    availableWithTranslations.push(AVAILABLE_LANGUAGES.find(l => l.code === 'en'));
  }
  
  res.json({ success: true, languages: availableWithTranslations });
});

// GET /api/public/languages/:code - Public endpoint to get translation
app.get('/api/public/languages/:code', async (req, res) => {
  try {
    const { code } = req.params;
    const langCode = code.toLowerCase();
    
    const langInfo = AVAILABLE_LANGUAGES.find(l => l.code === langCode);
    if (!langInfo) {
      return res.status(404).json({ success: false, error: 'Language not found' });
    }
    
    // Check cache (database overrides)
    if (translationCache[langCode]) {
      return res.json({ 
        success: true, 
        lang: langCode,
        name: langInfo.name,
        native_name: langInfo.native_name,
        flag: langInfo.flag,
        rtl: langInfo.rtl,
        strings: translationCache[langCode]
      });
    }
    
    // Try database
    const dbResult = await pool.query(
      'SELECT strings FROM gas_translations WHERE lang_code = $1',
      [langCode]
    ).catch(() => ({ rows: [] }));
    
    if (dbResult.rows.length > 0) {
      translationCache[langCode] = dbResult.rows[0].strings;
      return res.json({ 
        success: true, 
        lang: langCode,
        name: langInfo.name,
        native_name: langInfo.native_name,
        flag: langInfo.flag,
        rtl: langInfo.rtl,
        strings: dbResult.rows[0].strings
      });
    }
    
    // Use combined translations file
    if (GAS_TRANSLATIONS[langCode]) {
      return res.json({ 
        success: true, 
        lang: langCode,
        name: langInfo.name,
        native_name: langInfo.native_name,
        flag: langInfo.flag,
        rtl: langInfo.rtl,
        strings: GAS_TRANSLATIONS[langCode].strings
      });
    }
    
    // Fallback to English
    if (GAS_TRANSLATIONS['en']) {
      return res.json({ 
        success: true, 
        lang: langCode,
        name: langInfo.name,
        native_name: langInfo.native_name,
        flag: langInfo.flag,
        rtl: langInfo.rtl,
        strings: GAS_TRANSLATIONS['en'].strings,
        fallback: true
      });
    }
    
    res.status(404).json({ success: false, error: 'Translation not found' });
  } catch (error) {
    console.error('Error getting public translation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================
// END LANGUAGE API ENDPOINTS
// ============================================

// ============================================
// ============================================
// TRANSLATION WORKER (Gemini + DeepL fallback)
// ============================================

const DEEPL_API_KEY = process.env.DEEPL_API_KEY;
const DEEPL_API_URL = DEEPL_API_KEY && DEEPL_API_KEY.endsWith(':fx') 
  ? 'https://api-free.deepl.com/v2/translate'
  : 'https://api.deepl.com/v2/translate';

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent';

// Languages we auto-translate to
const AUTO_TRANSLATE_LANGUAGES = ['en', 'fr', 'es', 'de', 'nl'];

// Language names for Gemini prompts
const LANGUAGE_NAMES = {
  'en': 'English',
  'fr': 'French', 
  'es': 'Spanish',
  'de': 'German',
  'nl': 'Dutch',
  'it': 'Italian',
  'pt': 'Portuguese',
  'pl': 'Polish',
  'ru': 'Russian',
  'ja': 'Japanese',
  'zh': 'Chinese'
};

// DeepL language codes (some differ from our codes)
const DEEPL_LANG_MAP = {
  'en': 'EN',
  'fr': 'FR', 
  'es': 'ES',
  'de': 'DE',
  'nl': 'NL',
  'it': 'IT',
  'pt': 'PT-PT',
  'pl': 'PL',
  'ru': 'RU',
  'ja': 'JA',
  'zh': 'ZH'
};

/**
 * Translate text using Gemini API (primary - much cheaper)
 */
async function translateWithGemini(text, sourceLang, targetLang) {
  if (!GEMINI_API_KEY) {
    console.log('[Gemini] No API key configured');
    return null;
  }
  
  if (!text || text.trim().length === 0) {
    return '';
  }
  
  if (sourceLang === targetLang) {
    return text;
  }
  
  const sourceName = LANGUAGE_NAMES[sourceLang] || sourceLang;
  const targetName = LANGUAGE_NAMES[targetLang] || targetLang;
  
  try {
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `Translate the following text from ${sourceName} to ${targetName}. Return ONLY the translated text, no explanations or notes:\n\n${text}`
          }]
        }],
        generationConfig: {
          temperature: 0.1,
          maxOutputTokens: 2048
        }
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[Gemini] API error ${response.status}:`, errorText);
      return null;
    }
    
    const data = await response.json();
    if (data.candidates && data.candidates[0]?.content?.parts?.[0]?.text) {
      const translated = data.candidates[0].content.parts[0].text.trim();
      console.log(`[Gemini] Translated ${sourceLang}->${targetLang}: "${text.substring(0, 50)}..." -> "${translated.substring(0, 50)}..."`);
      return translated;
    }
    
    console.error('[Gemini] Unexpected response format:', JSON.stringify(data).substring(0, 200));
    return null;
  } catch (error) {
    console.error('[Gemini] Translation error:', error.message);
    return null;
  }
}

/**
 * Translate text using DeepL API (fallback)
 */
async function translateWithDeepL(text, sourceLang, targetLang) {
  if (!DEEPL_API_KEY) {
    console.log('[DeepL] No API key configured');
    return null;
  }
  
  if (!text || text.trim().length === 0) {
    return '';
  }
  
  // Don't translate if source and target are the same
  if (sourceLang === targetLang) {
    return text;
  }
  
  try {
    const response = await fetch(DEEPL_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `DeepL-Auth-Key ${DEEPL_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: [text],
        source_lang: DEEPL_LANG_MAP[sourceLang] || sourceLang.toUpperCase(),
        target_lang: DEEPL_LANG_MAP[targetLang] || targetLang.toUpperCase()
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[DeepL] API error ${response.status}:`, errorText);
      return null;
    }
    
    const data = await response.json();
    if (data.translations && data.translations[0]) {
      console.log(`[DeepL] Translated ${sourceLang}->${targetLang}: "${text.substring(0, 50)}..."`);
      return data.translations[0].text;
    }
    
    return null;
  } catch (error) {
    console.error('[DeepL] Translation error:', error.message);
    return null;
  }
}

/**
 * Translate text - tries Gemini first (cheaper), falls back to DeepL
 */
async function translateText(text, sourceLang, targetLang) {
  // Try Gemini first (much cheaper: $0.10/1M tokens vs DeepL $25/1M chars)
  let result = await translateWithGemini(text, sourceLang, targetLang);
  
  // Fall back to DeepL if Gemini fails
  if (result === null && DEEPL_API_KEY) {
    console.log('[Translation] Gemini failed, falling back to DeepL');
    result = await translateWithDeepL(text, sourceLang, targetLang);
  }
  
  return result;
}

/**
 * Translate a multilingual field object to missing languages
 * @param {Object|string} fieldValue - Current field value (could be string or {en: "...", fr: "..."})
 * @param {string} sourceLang - Source language code
 * @param {string[]} targetLangs - Target language codes to translate to
 * @returns {Object} - Multilingual object with translations
 */
async function translateFieldToLanguages(fieldValue, sourceLang = 'en', targetLangs = AUTO_TRANSLATE_LANGUAGES) {
  // Parse existing value
  let existing = {};
  let sourceText = '';
  
  if (typeof fieldValue === 'string') {
    // Plain string - assume it's the source language
    try {
      if (fieldValue.trim().startsWith('{')) {
        existing = JSON.parse(fieldValue);
        sourceText = existing[sourceLang] || existing.en || Object.values(existing)[0] || '';
      } else {
        sourceText = fieldValue;
        existing[sourceLang] = fieldValue;
      }
    } catch (e) {
      sourceText = fieldValue;
      existing[sourceLang] = fieldValue;
    }
  } else if (typeof fieldValue === 'object' && fieldValue !== null) {
    existing = { ...fieldValue };
    sourceText = existing[sourceLang] || existing.en || Object.values(existing).find(v => typeof v === 'string' && v) || '';
  }
  
  if (!sourceText || sourceText.trim().length === 0) {
    return existing;
  }
  
  // Track metadata
  if (!existing._source) {
    existing._source = sourceLang;
  }
  if (!existing._auto) {
    existing._auto = [];
  }
  
  // Translate to each missing target language
  for (const targetLang of targetLangs) {
    // Skip if already has this language (and not auto-translated or manual override exists)
    if (existing[targetLang] && !existing._auto?.includes(targetLang)) {
      continue;
    }
    
    // Skip source language
    if (targetLang === sourceLang) {
      continue;
    }
    
    const translated = await translateText(sourceText, sourceLang, targetLang);
    if (translated) {
      existing[targetLang] = translated;
      if (!existing._auto.includes(targetLang)) {
        existing._auto.push(targetLang);
      }
    }
    
    // Small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  return existing;
}

/**
 * Process translation queue - find and translate untranslated content
 */
async function processTranslationQueue() {
  if (!GEMINI_API_KEY && !DEEPL_API_KEY) {
    console.log('[Translation Worker] No translation API key configured - skipping');
    return;
  }
  
  console.log('[Translation Worker] Starting translation batch (using ' + (GEMINI_API_KEY ? 'Gemini' : 'DeepL') + ')...');
  
  try {
    // Find bookable_units with missing translations
    // Look for units where short_description exists but is missing languages
    // Use jsonb_typeof to check if it's valid JSON first
    const unitsToTranslate = await pool.query(`
      SELECT bu.id, bu.name, bu.display_name, bu.short_description, bu.full_description,
             p.account_id
      FROM bookable_units bu
      JOIN properties p ON p.id = bu.property_id
      WHERE bu.short_description IS NOT NULL 
        AND bu.short_description::text != ''
        AND bu.short_description::text != '{}'
        AND bu.short_description::text != 'null'
        AND (
          -- Either it's not JSON (plain string that needs translating)
          jsonb_typeof(bu.short_description) != 'object'
          OR (
            -- Or it's JSON but missing translations
            jsonb_typeof(bu.short_description) = 'object'
            AND (
              bu.short_description->>'fr' IS NULL
              OR bu.short_description->>'es' IS NULL
              OR bu.short_description->>'de' IS NULL
              OR bu.short_description->>'nl' IS NULL
            )
          )
        )
      LIMIT 10
    `);
    
    console.log(`[Translation Worker] Found ${unitsToTranslate.rows.length} units needing translation`);
    
    let translatedCount = 0;
    
    for (const unit of unitsToTranslate.rows) {
      try {
        console.log(`[Translation Worker] Translating unit ${unit.id}: ${unit.name}`);
        
        // Determine source language (check what we have)
        let sourceLang = 'en';
        const shortDesc = unit.short_description;
        if (typeof shortDesc === 'object') {
          if (shortDesc._source) {
            sourceLang = shortDesc._source;
          } else if (shortDesc.en) {
            sourceLang = 'en';
          } else if (shortDesc.fr) {
            sourceLang = 'fr';
          } else {
            // Use first available language
            const firstLang = Object.keys(shortDesc).find(k => !k.startsWith('_') && shortDesc[k]);
            if (firstLang) sourceLang = firstLang;
          }
        }
        
        // Translate short_description
        const translatedShort = await translateFieldToLanguages(
          unit.short_description, 
          sourceLang, 
          AUTO_TRANSLATE_LANGUAGES
        );
        
        // Translate full_description - handle string, object, or null
        let translatedFull = null;
        if (unit.full_description) {
          // Parse if it's a JSON string
          let fullDescObj = unit.full_description;
          if (typeof fullDescObj === 'string') {
            try {
              fullDescObj = JSON.parse(fullDescObj);
            } catch (e) {
              // Plain string - wrap in object
              fullDescObj = { [sourceLang]: fullDescObj };
            }
          }
          if (fullDescObj && (typeof fullDescObj === 'object' || typeof fullDescObj === 'string')) {
            translatedFull = await translateFieldToLanguages(
              fullDescObj,
              sourceLang,
              AUTO_TRANSLATE_LANGUAGES
            );
          }
        }
        
        // Translate display_name - handle string, object, or null
        let translatedDisplayName = null;
        if (unit.display_name) {
          // Parse if it's a JSON string
          let displayNameObj = unit.display_name;
          if (typeof displayNameObj === 'string') {
            try {
              displayNameObj = JSON.parse(displayNameObj);
            } catch (e) {
              // Plain string - wrap in object
              displayNameObj = { [sourceLang]: displayNameObj };
            }
          }
          if (displayNameObj && (typeof displayNameObj === 'object' || typeof displayNameObj === 'string')) {
            translatedDisplayName = await translateFieldToLanguages(
              displayNameObj,
              sourceLang,
              AUTO_TRANSLATE_LANGUAGES
            );
          }
        }
        
        // Update the unit - only update fields that were translated
        const updates = [];
        const params = [];
        let paramIndex = 1;
        
        if (translatedShort && Object.keys(translatedShort).length > 0) {
          updates.push(`short_description = $${paramIndex}::jsonb`);
          params.push(JSON.stringify(translatedShort));
          paramIndex++;
        }
        
        if (translatedFull && Object.keys(translatedFull).length > 0) {
          updates.push(`full_description = $${paramIndex}::jsonb`);
          params.push(JSON.stringify(translatedFull));
          paramIndex++;
        }
        
        if (translatedDisplayName && Object.keys(translatedDisplayName).length > 0) {
          updates.push(`display_name = $${paramIndex}::jsonb`);
          params.push(JSON.stringify(translatedDisplayName));
          paramIndex++;
        }
        
        if (updates.length > 0) {
          updates.push('updated_at = NOW()');
          params.push(unit.id);
          
          await pool.query(`
            UPDATE bookable_units 
            SET ${updates.join(', ')}
            WHERE id = $${paramIndex}
          `, params);
          
          console.log(`[Translation Worker] ‚úì Translated unit ${unit.id} - updated: ${updates.filter(u => !u.includes('updated_at')).map(u => u.split(' ')[0]).join(', ')}`);
        } else {
          console.log(`[Translation Worker] ‚è≠Ô∏è Unit ${unit.id} - nothing to translate`);
        }
        
        translatedCount++;
        
        // Delay between units to respect rate limits
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (unitError) {
        console.error(`[Translation Worker] Error translating unit ${unit.id}:`, unitError.message);
      }
    }
    
    console.log(`[Translation Worker] Completed - translated ${translatedCount} units`);
    
  } catch (error) {
    console.error('[Translation Worker] Error:', error.message);
  }
}

/**
 * Check DeepL API status and usage
 */
async function checkDeepLStatus() {
  if (!DEEPL_API_KEY) {
    console.log('[DeepL] No API key configured');
    return null;
  }
  
  try {
    const usageUrl = DEEPL_API_KEY.endsWith(':fx')
      ? 'https://api-free.deepl.com/v2/usage'
      : 'https://api.deepl.com/v2/usage';
      
    const response = await fetch(usageUrl, {
      headers: {
        'Authorization': `DeepL-Auth-Key ${DEEPL_API_KEY}`
      }
    });
    
    if (!response.ok) {
      console.error('[DeepL] Failed to get usage:', response.status);
      return null;
    }
    
    const data = await response.json();
    console.log(`[DeepL] Usage: ${data.character_count?.toLocaleString() || 0} / ${data.character_limit?.toLocaleString() || 'unlimited'} characters`);
    return data;
  } catch (error) {
    console.error('[DeepL] Error checking status:', error.message);
    return null;
  }
}

// Start translation worker - DISABLED automatic scheduling
// On-demand translation via /api/translate endpoint still works
function startTranslationWorker() {
  if (!DEEPL_API_KEY) {
    console.log('[Translation Worker] Disabled - no DEEPL_API_KEY configured');
    return;
  }
  
  console.log('[Translation Worker] Auto-scheduling DISABLED - use üåê button for on-demand translation');
  console.log('[Translation Worker] DeepL API available for manual translation requests');
  
  // Check DeepL status on startup
  checkDeepLStatus();
  
  // NO automatic scheduling - translation only happens when user clicks translate button
  // The /api/translate endpoint remains available for on-demand use
}

// API endpoint to manually trigger translation
app.post('/api/admin/translate-unit/:unitId', async (req, res) => {
  try {
    const { unitId } = req.params;
    const { targetLangs } = req.body;
    
    const unit = await pool.query(
      'SELECT * FROM bookable_units WHERE id = $1',
      [unitId]
    );
    
    if (unit.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Unit not found' });
    }
    
    const u = unit.rows[0];
    const langs = targetLangs || AUTO_TRANSLATE_LANGUAGES;
    
    // Translate short_description
    const translatedShort = await translateFieldToLanguages(u.short_description, 'en', langs);
    
    // Translate full_description
    const translatedFull = u.full_description 
      ? await translateFieldToLanguages(u.full_description, 'en', langs)
      : null;
    
    // Update
    await pool.query(`
      UPDATE bookable_units 
      SET short_description = $1, full_description = $2, updated_at = NOW()
      WHERE id = $3
    `, [JSON.stringify(translatedShort), translatedFull ? JSON.stringify(translatedFull) : null, unitId]);
    
    res.json({ 
      success: true, 
      short_description: translatedShort,
      full_description: translatedFull
    });
    
  } catch (error) {
    console.error('Manual translate error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// API endpoint to check DeepL usage
app.get('/api/admin/deepl-usage', async (req, res) => {
  const usage = await checkDeepLStatus();
  if (usage) {
    res.json({ success: true, ...usage });
  } else {
    res.status(500).json({ success: false, error: 'Could not get DeepL usage' });
  }
});

// Simple translate API for admin UI
app.post('/api/translate', async (req, res) => {
  try {
    const { text, targetLangs = ['en', 'es', 'fr', 'de', 'nl'], sourceLang } = req.body;
    
    if (!text || text.trim().length === 0) {
      return res.json({ success: false, error: 'No text to translate' });
    }
    
    // Check if we have any translation service configured
    if (!GEMINI_API_KEY && !DEEPL_API_KEY) {
      return res.json({ success: false, error: 'No translation service configured (need Gemini or DeepL API key)' });
    }
    
    // Detect source language if not provided
    const detectedSource = sourceLang || 'en';
    
    const translations = {};
    translations[detectedSource] = text; // Keep original
    
    // Translate to each target language (except source)
    for (const lang of targetLangs) {
      if (lang === detectedSource) continue;
      
      try {
        const translated = await translateText(text, detectedSource, lang);
        if (translated) {
          translations[lang] = translated;
        }
      } catch (e) {
        console.error(`Translation to ${lang} failed:`, e.message);
      }
    }
    
    res.json({ success: true, translations });
    
  } catch (error) {
    console.error('Translate API error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Admin translate-text endpoint for website builder
app.post('/api/admin/translate-text', async (req, res) => {
  try {
    const { text, source_lang = 'en', target_langs = ['fr', 'es', 'nl'] } = req.body;
    
    if (!text || text.trim().length === 0) {
      return res.json({ success: false, error: 'No text to translate' });
    }
    
    // Check if we have any translation service configured
    if (!GEMINI_API_KEY && !DEEPL_API_KEY) {
      return res.json({ success: false, error: 'No translation service configured (need Gemini or DeepL API key)' });
    }
    
    const translations = {};
    
    // Translate to each target language
    for (const lang of target_langs) {
      if (lang === source_lang) continue;
      
      try {
        const translated = await translateText(text, source_lang, lang);
        if (translated) {
          translations[lang] = translated;
        }
      } catch (e) {
        console.error(`Translation to ${lang} failed:`, e.message);
        // Continue with other languages even if one fails
      }
    }
    
    res.json({ success: true, translations });
    
  } catch (error) {
    console.error('Admin translate-text API error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================
// END TRANSLATION WORKER
// ============================================

// ============================================
// CATCH-ALL HANDLER (must be last route)
// ============================================
app.get('*', (req, res) => {
  // Don't serve index.html for API routes - return 404 instead
  if (req.path.startsWith('/api')) {
    return res.status(404).json({ error: 'API endpoint not found', path: req.path });
  }
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Catch-all for non-GET API routes (POST, PUT, DELETE to unknown endpoints)
app.all('/api/*', (req, res) => {
  res.status(404).json({ error: 'API endpoint not found', method: req.method, path: req.path });
});

// Global error handler - ALWAYS return JSON, never HTML
app.use((err, req, res, next) => {
  console.error('Global error handler:', err.message);
  console.error('Request:', req.method, req.url);
  if (err.stack) console.error(err.stack);
  res.status(err.status || 500).json({
    success: false,
    error: err.message || 'Internal server error',
    path: req.url
  });
});
// SYNC SCHEDULER
// ============================================
function startTieredSyncScheduler() {
  // Run every 15 minutes (900000ms)
  const SYNC_INTERVAL = 15 * 60 * 1000;
  
  console.log('‚è∞ [Tiered Sync] Scheduler started - runs every 15 minutes');
  
  // Run first sync after 30 seconds (let server fully start)
  setTimeout(() => {
    runTieredSync();
  }, 30000);
  
  // Then run every 15 minutes
  setInterval(() => {
    runTieredSync();
  }, SYNC_INTERVAL);
}
